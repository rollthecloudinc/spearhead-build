{
  "version": 3,
  "sources": ["../../@softarc/native-federation-runtime/fesm2022/softarc-native-federation-runtime.mjs"],
  "sourcesContent": ["const defaultShareOptions = {\n  singleton: false,\n  requiredVersionPrefix: ''\n};\nfunction getShared(options = defaultShareOptions) {\n  const nfc = window;\n  const externals = nfc.__NATIVE_FEDERATION__.externals;\n  const shared = {};\n  const allKeys = [...externals.keys()];\n  const keys = allKeys.filter(k => !k.startsWith('/@id/') && !k.startsWith('@angular-architects/module-federation') && !k.endsWith('@')).sort();\n  for (const key of keys) {\n    const idx = key.lastIndexOf('@');\n    const pkgName = key.substring(0, idx);\n    const version = key.substring(idx + 1);\n    const path = externals.get(key) ?? '';\n    const shareObj = {\n      version,\n      get: async () => {\n        const lib = await window.importShim(path);\n        return () => lib;\n      },\n      shareConfig: {\n        singleton: options.singleton,\n        requiredVersion: options.requiredVersionPrefix + version\n      }\n    };\n    if (!shared[pkgName]) {\n      shared[pkgName] = [];\n    }\n    shared[pkgName].push(shareObj);\n  }\n  return shared;\n}\nconst nfNamespace = '__NATIVE_FEDERATION__';\nconst global = globalThis;\nglobal[nfNamespace] ??= {\n  externals: new Map(),\n  remoteNamesToRemote: new Map(),\n  baseUrlToRemoteNames: new Map()\n};\nconst globalCache = global[nfNamespace];\nconst externals = globalCache.externals;\nfunction getExternalKey(shared) {\n  return `${shared.packageName}@${shared.version}`;\n}\nfunction getExternalUrl(shared) {\n  const packageKey = getExternalKey(shared);\n  return externals.get(packageKey);\n}\nfunction setExternalUrl(shared, url) {\n  const packageKey = getExternalKey(shared);\n  externals.set(packageKey, url);\n}\nfunction mergeImportMaps(map1, map2) {\n  return {\n    imports: {\n      ...map1.imports,\n      ...map2.imports\n    },\n    scopes: {\n      ...map1.scopes,\n      ...map2.scopes\n    }\n  };\n}\nconst remoteNamesToRemote = globalCache.remoteNamesToRemote;\nconst baseUrlToRemoteNames = globalCache.baseUrlToRemoteNames;\nfunction addRemote(remoteName, remote) {\n  remoteNamesToRemote.set(remoteName, remote);\n  baseUrlToRemoteNames.set(remote.baseUrl, remoteName);\n}\nfunction getRemoteNameByBaseUrl(baseUrl) {\n  return baseUrlToRemoteNames.get(baseUrl);\n}\nfunction isRemoteInitialized(baseUrl) {\n  return baseUrlToRemoteNames.has(baseUrl);\n}\nfunction getRemote(remoteName) {\n  return remoteNamesToRemote.get(remoteName);\n}\nfunction hasRemote(remoteName) {\n  return remoteNamesToRemote.has(remoteName);\n}\nfunction appendImportMap(importMap) {\n  document.head.appendChild(Object.assign(document.createElement('script'), {\n    type: 'importmap-shim',\n    innerHTML: JSON.stringify(importMap)\n  }));\n}\nfunction getDirectory(url) {\n  const parts = url.split('/');\n  parts.pop();\n  return parts.join('/');\n}\nfunction joinPaths(path1, path2) {\n  while (path1.endsWith('/')) {\n    path1 = path1.substring(0, path1.length - 1);\n  }\n  if (path2.startsWith('./')) {\n    path2 = path2.substring(2, path2.length);\n  }\n  return `${path1}/${path2}`;\n}\nconst BUILD_NOTIFICATIONS_ENDPOINT = '/@angular-architects/native-federation:build-notifications';\nvar BuildNotificationType = /*#__PURE__*/function (BuildNotificationType) {\n  BuildNotificationType[\"COMPLETED\"] = \"federation-rebuild-complete\";\n  BuildNotificationType[\"ERROR\"] = \"federation-rebuild-error\";\n  return BuildNotificationType;\n}(BuildNotificationType || {});\n/**\n * Watches for federation build completion events and automatically reloads the page.\n *\n * This function establishes a Server-Sent Events (SSE) connection to listen for\n * 'federation-rebuild-complete' notifications. When a build completes successfully,\n * it triggers a page reload to reflect the latest changes.\n * @param endpoint - The SSE endpoint URL to watch for build notifications.\n */\nfunction watchFederationBuildCompletion(endpoint) {\n  const eventSource = new EventSource(endpoint);\n  eventSource.onmessage = function (event) {\n    const data = JSON.parse(event.data);\n    if (data.type === BuildNotificationType.COMPLETED) {\n      console.log('[Federation] Rebuild completed, reloading...');\n      window.location.reload();\n    }\n  };\n  eventSource.onerror = function (event) {\n    console.warn('[Federation] SSE connection error:', event);\n  };\n}\n\n/**\n * Initialize the federation runtime\n * @param remotesOrManifestUrl\n * @param options The cacheTag allows you to invalidate the cache of the remoteEntry.json files, pass a new value with every release (f.ex. the version number)\n */\nasync function initFederation(remotesOrManifestUrl = {}, options) {\n  const cacheOption = options?.cacheTag ? `?t=${options.cacheTag}` : '';\n  const remotes = typeof remotesOrManifestUrl === 'string' ? await loadManifest(remotesOrManifestUrl + cacheOption) : remotesOrManifestUrl;\n  const url = './remoteEntry.json' + cacheOption;\n  const hostInfo = await loadFederationInfo(url);\n  const hostImportMap = await processHostInfo(hostInfo);\n  const remotesImportMap = await processRemoteInfos(remotes, {\n    throwIfRemoteNotFound: false,\n    ...options\n  });\n  const importMap = mergeImportMaps(hostImportMap, remotesImportMap);\n  appendImportMap(importMap);\n  return importMap;\n}\nasync function loadManifest(remotes) {\n  return await fetch(remotes).then(r => r.json());\n}\nasync function processRemoteInfos(remotes, options = {\n  throwIfRemoteNotFound: false\n}) {\n  const processRemoteInfoPromises = Object.keys(remotes).map(async remoteName => {\n    try {\n      let url = remotes[remoteName];\n      if (options.cacheTag) {\n        const addAppend = remotes[remoteName].includes('?') ? '&' : '?';\n        url += `${addAppend}t=${options.cacheTag}`;\n      }\n      return await processRemoteInfo(url, remoteName);\n    } catch (e) {\n      const error = `Error loading remote entry for ${remoteName} from file ${remotes[remoteName]}`;\n      if (options.throwIfRemoteNotFound) {\n        throw new Error(error);\n      }\n      console.error(error);\n      return null;\n    }\n  });\n  const remoteImportMaps = await Promise.all(processRemoteInfoPromises);\n  const importMap = remoteImportMaps.reduce((acc, remoteImportMap) => remoteImportMap ? mergeImportMaps(acc, remoteImportMap) : acc, {\n    imports: {},\n    scopes: {}\n  });\n  return importMap;\n}\nasync function processRemoteInfo(federationInfoUrl, remoteName) {\n  const baseUrl = getDirectory(federationInfoUrl);\n  const remoteInfo = await loadFederationInfo(federationInfoUrl);\n  if (!remoteName) {\n    remoteName = remoteInfo.name;\n  }\n  if (remoteInfo.buildNotificationsEndpoint) {\n    watchFederationBuildCompletion(baseUrl + remoteInfo.buildNotificationsEndpoint);\n  }\n  const importMap = createRemoteImportMap(remoteInfo, remoteName, baseUrl);\n  addRemote(remoteName, {\n    ...remoteInfo,\n    baseUrl\n  });\n  return importMap;\n}\nfunction createRemoteImportMap(remoteInfo, remoteName, baseUrl) {\n  const imports = processExposed(remoteInfo, remoteName, baseUrl);\n  const scopes = processRemoteImports(remoteInfo, baseUrl);\n  return {\n    imports,\n    scopes\n  };\n}\nasync function loadFederationInfo(url) {\n  const info = await fetch(url).then(r => r.json());\n  return info;\n}\nfunction processRemoteImports(remoteInfo, baseUrl) {\n  const scopes = {};\n  const scopedImports = {};\n  for (const shared of remoteInfo.shared) {\n    const outFileName = getExternalUrl(shared) ?? joinPaths(baseUrl, shared.outFileName);\n    setExternalUrl(shared, outFileName);\n    scopedImports[shared.packageName] = outFileName;\n  }\n  scopes[baseUrl + '/'] = scopedImports;\n  return scopes;\n}\nfunction processExposed(remoteInfo, remoteName, baseUrl) {\n  const imports = {};\n  for (const exposed of remoteInfo.exposes) {\n    const key = joinPaths(remoteName, exposed.key);\n    const value = joinPaths(baseUrl, exposed.outFileName);\n    imports[key] = value;\n  }\n  return imports;\n}\nasync function processHostInfo(hostInfo, relBundlesPath = './') {\n  const imports = hostInfo.shared.reduce((acc, cur) => ({\n    ...acc,\n    [cur.packageName]: relBundlesPath + cur.outFileName\n  }), {});\n  for (const shared of hostInfo.shared) {\n    setExternalUrl(shared, relBundlesPath + shared.outFileName);\n  }\n  return {\n    imports,\n    scopes: {}\n  };\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nasync function loadRemoteModule(optionsOrRemoteName, exposedModule) {\n  const options = normalizeOptions(optionsOrRemoteName, exposedModule);\n  await ensureRemoteInitialized(options);\n  const remoteName = getRemoteNameByOptions(options);\n  const remote = getRemote(remoteName);\n  const fallback = options.fallback;\n  const remoteError = !remote ? 'unknown remote ' + remoteName : '';\n  if (!remote && !fallback) {\n    throw new Error(remoteError);\n  } else if (!remote) {\n    logClientError(remoteError);\n    return Promise.resolve(fallback);\n  }\n  const exposed = remote.exposes.find(e => e.key === options.exposedModule);\n  const exposedError = !exposed ? `Unknown exposed module ${options.exposedModule} in remote ${remoteName}` : '';\n  if (!exposed && !fallback) {\n    throw new Error(exposedError);\n  } else if (!exposed) {\n    logClientError(exposedError);\n    return Promise.resolve(fallback);\n  }\n  const url = joinPaths(remote.baseUrl, exposed.outFileName);\n  try {\n    const module = _import(url);\n    return module;\n  } catch (e) {\n    if (fallback) {\n      console.error('error loading remote module', e);\n      return fallback;\n    }\n    throw e;\n  }\n}\nfunction _import(url) {\n  return typeof importShim !== 'undefined' ? importShim(url) : import(/* @vite-ignore */url);\n}\nfunction getRemoteNameByOptions(options) {\n  let remoteName;\n  if (options.remoteName) {\n    remoteName = options.remoteName;\n  } else if (options.remoteEntry) {\n    const baseUrl = getDirectory(options.remoteEntry);\n    remoteName = getRemoteNameByBaseUrl(baseUrl);\n  } else {\n    throw new Error('unexpcted arguments: Please pass remoteName or remoteEntry');\n  }\n  if (!remoteName) {\n    throw new Error('unknown remoteName ' + remoteName);\n  }\n  return remoteName;\n}\nasync function ensureRemoteInitialized(options) {\n  if (options.remoteEntry && !isRemoteInitialized(getDirectory(options.remoteEntry))) {\n    const importMap = await processRemoteInfo(options.remoteEntry);\n    appendImportMap(importMap);\n  }\n}\nfunction normalizeOptions(optionsOrRemoteName, exposedModule) {\n  let options;\n  if (typeof optionsOrRemoteName === 'string' && exposedModule) {\n    options = {\n      remoteName: optionsOrRemoteName,\n      exposedModule\n    };\n  } else if (typeof optionsOrRemoteName === 'object' && !exposedModule) {\n    options = optionsOrRemoteName;\n  } else {\n    throw new Error('unexpected arguments: please pass options or a remoteName/exposedModule-pair');\n  }\n  return options;\n}\nfunction logClientError(error) {\n  if (typeof window !== 'undefined') {\n    console.error(error);\n  }\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { BUILD_NOTIFICATIONS_ENDPOINT, BuildNotificationType, getShared, initFederation, loadRemoteModule, mergeImportMaps, processHostInfo, processRemoteInfo, processRemoteInfos };\n"],
  "mappings": "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",
  "names": ["nfNamespace", "global", "globalCache", "externals", "getExternalKey", "shared", "getExternalUrl", "packageKey", "setExternalUrl", "url", "remoteNamesToRemote", "globalCache", "baseUrlToRemoteNames", "addRemote", "remoteName", "remote", "getRemoteNameByBaseUrl", "baseUrl", "isRemoteInitialized", "getRemote", "appendImportMap", "importMap", "getDirectory", "url", "parts", "joinPaths", "path1", "path2", "BuildNotificationType", "watchFederationBuildCompletion", "endpoint", "eventSource", "event", "processRemoteInfo", "federationInfoUrl", "remoteName", "__async", "baseUrl", "getDirectory", "remoteInfo", "loadFederationInfo", "watchFederationBuildCompletion", "importMap", "createRemoteImportMap", "addRemote", "__spreadProps", "__spreadValues", "imports", "processExposed", "scopes", "processRemoteImports", "url", "r", "scopedImports", "shared", "outFileName", "getExternalUrl", "joinPaths", "setExternalUrl", "exposed", "key", "value", "loadRemoteModule", "optionsOrRemoteName", "exposedModule", "__async", "options", "normalizeOptions", "ensureRemoteInitialized", "remoteName", "getRemoteNameByOptions", "remote", "getRemote", "fallback", "remoteError", "logClientError", "exposed", "e", "exposedError", "url", "joinPaths", "_import", "baseUrl", "getDirectory", "getRemoteNameByBaseUrl", "isRemoteInitialized", "importMap", "processRemoteInfo", "appendImportMap", "error"]
}
