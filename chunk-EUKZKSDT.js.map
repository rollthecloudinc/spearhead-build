{
  "version": 3,
  "sources": ["../../@angular/material/fesm2022/select-module.mjs"],
  "sourcesContent": ["import { createRepositionScrollStrategy, CdkConnectedOverlay, CdkOverlayOrigin, OverlayModule } from '@angular/cdk/overlay';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, inject, Injector, ChangeDetectorRef, ElementRef, Renderer2, signal, EventEmitter, HostAttributeToken, booleanAttribute, numberAttribute, Component, ViewEncapsulation, ChangeDetectionStrategy, ContentChildren, ContentChild, Input, ViewChild, Output, Directive, NgModule } from '@angular/core';\nimport { ViewportRuler, CdkScrollableModule } from '@angular/cdk/scrolling';\nimport { _IdGenerator, LiveAnnouncer, removeAriaReferencedId, addAriaReferencedId, ActiveDescendantKeyManager } from '@angular/cdk/a11y';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { SelectionModel } from '@angular/cdk/collections';\nimport { hasModifierKey, ENTER, SPACE, A, ESCAPE, DOWN_ARROW, UP_ARROW, LEFT_ARROW, RIGHT_ARROW } from '@angular/cdk/keycodes';\nimport { NgControl, Validators, NgForm, FormGroupDirective } from '@angular/forms';\nimport { Subject, defer, merge } from 'rxjs';\nimport { startWith, switchMap, filter, map, takeUntil, take } from 'rxjs/operators';\nimport { NgClass } from '@angular/common';\nimport { MAT_FORM_FIELD, MatFormFieldControl } from './form-field2.mjs';\nimport { _animationsDisabled } from './animation.mjs';\nimport { _countGroupLabelsBeforeOption, _getOptionScrollPosition, MAT_OPTION_PARENT_COMPONENT, MatOption, MAT_OPTGROUP } from './option.mjs';\nimport { ErrorStateMatcher } from './error-options.mjs';\nimport { _ErrorStateTracker } from './error-state.mjs';\nimport { MatOptionModule } from './option-module.mjs';\nimport { MatCommonModule } from './common-module.mjs';\nimport { MatFormFieldModule } from './form-field-module.mjs';\n\n// Note that these have been copied over verbatim from\n// `material/select` so that we don't have to expose them publicly.\n/**\n * Returns an exception to be thrown when attempting to change a select's `multiple` option\n * after initialization.\n * @docs-private\n */\nconst _c0 = [\"trigger\"];\nconst _c1 = [\"panel\"];\nconst _c2 = [[[\"mat-select-trigger\"]], \"*\"];\nconst _c3 = [\"mat-select-trigger\", \"*\"];\nfunction MatSelect_Conditional_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.\u0275\u0275elementStart(0, \"span\", 4);\n    i0.\u0275\u0275text(1);\n    i0.\u0275\u0275elementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.\u0275\u0275nextContext();\n    i0.\u0275\u0275advance();\n    i0.\u0275\u0275textInterpolate(ctx_r1.placeholder);\n  }\n}\nfunction MatSelect_Conditional_5_Conditional_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.\u0275\u0275projection(0);\n  }\n}\nfunction MatSelect_Conditional_5_Conditional_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.\u0275\u0275elementStart(0, \"span\", 11);\n    i0.\u0275\u0275text(1);\n    i0.\u0275\u0275elementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.\u0275\u0275nextContext(2);\n    i0.\u0275\u0275advance();\n    i0.\u0275\u0275textInterpolate(ctx_r1.triggerValue);\n  }\n}\nfunction MatSelect_Conditional_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.\u0275\u0275elementStart(0, \"span\", 5);\n    i0.\u0275\u0275conditionalCreate(1, MatSelect_Conditional_5_Conditional_1_Template, 1, 0)(2, MatSelect_Conditional_5_Conditional_2_Template, 2, 1, \"span\", 11);\n    i0.\u0275\u0275elementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.\u0275\u0275nextContext();\n    i0.\u0275\u0275advance();\n    i0.\u0275\u0275conditional(ctx_r1.customTrigger ? 1 : 2);\n  }\n}\nfunction MatSelect_ng_template_10_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r3 = i0.\u0275\u0275getCurrentView();\n    i0.\u0275\u0275elementStart(0, \"div\", 12, 1);\n    i0.\u0275\u0275listener(\"keydown\", function MatSelect_ng_template_10_Template_div_keydown_0_listener($event) {\n      i0.\u0275\u0275restoreView(_r3);\n      const ctx_r1 = i0.\u0275\u0275nextContext();\n      return i0.\u0275\u0275resetView(ctx_r1._handleKeydown($event));\n    });\n    i0.\u0275\u0275projection(2, 1);\n    i0.\u0275\u0275elementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.\u0275\u0275nextContext();\n    i0.\u0275\u0275classMap(i0.\u0275\u0275interpolate1(\"mat-mdc-select-panel mdc-menu-surface mdc-menu-surface--open \", ctx_r1._getPanelTheme()));\n    i0.\u0275\u0275classProp(\"mat-select-panel-animations-enabled\", !ctx_r1._animationsDisabled);\n    i0.\u0275\u0275property(\"ngClass\", ctx_r1.panelClass);\n    i0.\u0275\u0275attribute(\"id\", ctx_r1.id + \"-panel\")(\"aria-multiselectable\", ctx_r1.multiple)(\"aria-label\", ctx_r1.ariaLabel || null)(\"aria-labelledby\", ctx_r1._getPanelAriaLabelledby());\n  }\n}\nfunction getMatSelectDynamicMultipleError() {\n  return Error('Cannot change `multiple` mode of select after initialization.');\n}\n/**\n * Returns an exception to be thrown when attempting to assign a non-array value to a select\n * in `multiple` mode. Note that `undefined` and `null` are still valid values to allow for\n * resetting the value.\n * @docs-private\n */\nfunction getMatSelectNonArrayValueError() {\n  return Error('Value must be an array in multiple-selection mode.');\n}\n/**\n * Returns an exception to be thrown when assigning a non-function value to the comparator\n * used to determine if a value corresponds to an option. Note that whether the function\n * actually takes two values and returns a boolean is not checked.\n */\nfunction getMatSelectNonFunctionValueError() {\n  return Error('`compareWith` must be a function.');\n}\n\n/** Injection token that determines the scroll handling while a select is open. */\nconst MAT_SELECT_SCROLL_STRATEGY = /*#__PURE__*/new InjectionToken('mat-select-scroll-strategy', {\n  providedIn: 'root',\n  factory: () => {\n    const injector = inject(Injector);\n    return () => createRepositionScrollStrategy(injector);\n  }\n});\n/**\n * @docs-private\n * @deprecated No longer used, will be removed.\n * @breaking-change 21.0.0\n */\nfunction MAT_SELECT_SCROLL_STRATEGY_PROVIDER_FACTORY(_overlay) {\n  const injector = inject(Injector);\n  return () => createRepositionScrollStrategy(injector);\n}\n/** Injection token that can be used to provide the default options the select module. */\nconst MAT_SELECT_CONFIG = /*#__PURE__*/new InjectionToken('MAT_SELECT_CONFIG');\n/**\n * @docs-private\n * @deprecated No longer used, will be removed.\n * @breaking-change 21.0.0\n */\nconst MAT_SELECT_SCROLL_STRATEGY_PROVIDER = {\n  provide: MAT_SELECT_SCROLL_STRATEGY,\n  deps: [],\n  useFactory: MAT_SELECT_SCROLL_STRATEGY_PROVIDER_FACTORY\n};\n/**\n * Injection token that can be used to reference instances of `MatSelectTrigger`. It serves as\n * alternative token to the actual `MatSelectTrigger` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nconst MAT_SELECT_TRIGGER = /*#__PURE__*/new InjectionToken('MatSelectTrigger');\n/** Change event object that is emitted when the select value has changed. */\nclass MatSelectChange {\n  source;\n  value;\n  constructor(/** Reference to the select that emitted the change event. */\n  source, /** Current value of the select that emitted the event. */\n  value) {\n    this.source = source;\n    this.value = value;\n  }\n}\nlet MatSelect = /*#__PURE__*/(() => {\n  class MatSelect {\n    _viewportRuler = inject(ViewportRuler);\n    _changeDetectorRef = inject(ChangeDetectorRef);\n    _elementRef = inject(ElementRef);\n    _dir = inject(Directionality, {\n      optional: true\n    });\n    _idGenerator = inject(_IdGenerator);\n    _renderer = inject(Renderer2);\n    _parentFormField = inject(MAT_FORM_FIELD, {\n      optional: true\n    });\n    ngControl = inject(NgControl, {\n      self: true,\n      optional: true\n    });\n    _liveAnnouncer = inject(LiveAnnouncer);\n    _defaultOptions = inject(MAT_SELECT_CONFIG, {\n      optional: true\n    });\n    _animationsDisabled = _animationsDisabled();\n    _initialized = new Subject();\n    _cleanupDetach;\n    /** All of the defined select options. */\n    options;\n    // TODO(crisbeto): this is only necessary for the non-MDC select, but it's technically a\n    // public API so we have to keep it. It should be deprecated and removed eventually.\n    /** All of the defined groups of options. */\n    optionGroups;\n    /** User-supplied override of the trigger element. */\n    customTrigger;\n    /**\n     * This position config ensures that the top \"start\" corner of the overlay\n     * is aligned with with the top \"start\" of the origin by default (overlapping\n     * the trigger completely). If the panel cannot fit below the trigger, it\n     * will fall back to a position above the trigger.\n     */\n    _positions = [{\n      originX: 'start',\n      originY: 'bottom',\n      overlayX: 'start',\n      overlayY: 'top'\n    }, {\n      originX: 'end',\n      originY: 'bottom',\n      overlayX: 'end',\n      overlayY: 'top'\n    }, {\n      originX: 'start',\n      originY: 'top',\n      overlayX: 'start',\n      overlayY: 'bottom',\n      panelClass: 'mat-mdc-select-panel-above'\n    }, {\n      originX: 'end',\n      originY: 'top',\n      overlayX: 'end',\n      overlayY: 'bottom',\n      panelClass: 'mat-mdc-select-panel-above'\n    }];\n    /** Scrolls a particular option into the view. */\n    _scrollOptionIntoView(index) {\n      const option = this.options.toArray()[index];\n      if (option) {\n        const panel = this.panel.nativeElement;\n        const labelCount = _countGroupLabelsBeforeOption(index, this.options, this.optionGroups);\n        const element = option._getHostElement();\n        if (index === 0 && labelCount === 1) {\n          // If we've got one group label before the option and we're at the top option,\n          // scroll the list to the top. This is better UX than scrolling the list to the\n          // top of the option, because it allows the user to read the top group's label.\n          panel.scrollTop = 0;\n        } else {\n          panel.scrollTop = _getOptionScrollPosition(element.offsetTop, element.offsetHeight, panel.scrollTop, panel.offsetHeight);\n        }\n      }\n    }\n    /** Called when the panel has been opened and the overlay has settled on its final position. */\n    _positioningSettled() {\n      this._scrollOptionIntoView(this._keyManager.activeItemIndex || 0);\n    }\n    /** Creates a change event object that should be emitted by the select. */\n    _getChangeEvent(value) {\n      return new MatSelectChange(this, value);\n    }\n    /** Factory function used to create a scroll strategy for this select. */\n    _scrollStrategyFactory = inject(MAT_SELECT_SCROLL_STRATEGY);\n    /** Whether or not the overlay panel is open. */\n    _panelOpen = false;\n    /** Comparison function to specify which option is displayed. Defaults to object equality. */\n    _compareWith = (o1, o2) => o1 === o2;\n    /** Unique id for this input. */\n    _uid = this._idGenerator.getId('mat-select-');\n    /** Current `aria-labelledby` value for the select trigger. */\n    _triggerAriaLabelledBy = null;\n    /**\n     * Keeps track of the previous form control assigned to the select.\n     * Used to detect if it has changed.\n     */\n    _previousControl;\n    /** Emits whenever the component is destroyed. */\n    _destroy = new Subject();\n    /** Tracks the error state of the select. */\n    _errorStateTracker;\n    /**\n     * Emits whenever the component state changes and should cause the parent\n     * form-field to update. Implemented as part of `MatFormFieldControl`.\n     * @docs-private\n     */\n    stateChanges = new Subject();\n    /**\n     * Disable the automatic labeling to avoid issues like #27241.\n     * @docs-private\n     */\n    disableAutomaticLabeling = true;\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    userAriaDescribedBy;\n    /** Deals with the selection logic. */\n    _selectionModel;\n    /** Manages keyboard events for options in the panel. */\n    _keyManager;\n    /** Ideal origin for the overlay panel. */\n    _preferredOverlayOrigin;\n    /** Width of the overlay panel. */\n    _overlayWidth;\n    /** `View -> model callback called when value changes` */\n    _onChange = () => {};\n    /** `View -> model callback called when select has been touched` */\n    _onTouched = () => {};\n    /** ID for the DOM node containing the select's value. */\n    _valueId = this._idGenerator.getId('mat-select-value-');\n    /** Strategy that will be used to handle scrolling while the select panel is open. */\n    _scrollStrategy;\n    _overlayPanelClass = this._defaultOptions?.overlayPanelClass || '';\n    /** Whether the select is focused. */\n    get focused() {\n      return this._focused || this._panelOpen;\n    }\n    _focused = false;\n    /** A name for this control that can be used by `mat-form-field`. */\n    controlType = 'mat-select';\n    /** Trigger that opens the select. */\n    trigger;\n    /** Panel containing the select options. */\n    panel;\n    /** Overlay pane containing the options. */\n    _overlayDir;\n    /** Classes to be passed to the select panel. Supports the same syntax as `ngClass`. */\n    panelClass;\n    /** Whether the select is disabled. */\n    disabled = false;\n    /** Whether ripples in the select are disabled. */\n    get disableRipple() {\n      return this._disableRipple();\n    }\n    set disableRipple(value) {\n      this._disableRipple.set(value);\n    }\n    _disableRipple = signal(false, ...(ngDevMode ? [{\n      debugName: \"_disableRipple\"\n    }] : []));\n    /** Tab index of the select. */\n    tabIndex = 0;\n    /** Whether checkmark indicator for single-selection options is hidden. */\n    get hideSingleSelectionIndicator() {\n      return this._hideSingleSelectionIndicator;\n    }\n    set hideSingleSelectionIndicator(value) {\n      this._hideSingleSelectionIndicator = value;\n      this._syncParentProperties();\n    }\n    _hideSingleSelectionIndicator = this._defaultOptions?.hideSingleSelectionIndicator ?? false;\n    /** Placeholder to be shown if no value has been selected. */\n    get placeholder() {\n      return this._placeholder;\n    }\n    set placeholder(value) {\n      this._placeholder = value;\n      this.stateChanges.next();\n    }\n    _placeholder;\n    /** Whether the component is required. */\n    get required() {\n      return this._required ?? this.ngControl?.control?.hasValidator(Validators.required) ?? false;\n    }\n    set required(value) {\n      this._required = value;\n      this.stateChanges.next();\n    }\n    _required;\n    /** Whether the user should be allowed to select multiple options. */\n    get multiple() {\n      return this._multiple;\n    }\n    set multiple(value) {\n      if (this._selectionModel && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throw getMatSelectDynamicMultipleError();\n      }\n      this._multiple = value;\n    }\n    _multiple = false;\n    /** Whether to center the active option over the trigger. */\n    disableOptionCentering = this._defaultOptions?.disableOptionCentering ?? false;\n    /**\n     * Function to compare the option values with the selected values. The first argument\n     * is a value from an option. The second is a value from the selection. A boolean\n     * should be returned.\n     */\n    get compareWith() {\n      return this._compareWith;\n    }\n    set compareWith(fn) {\n      if (typeof fn !== 'function' && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throw getMatSelectNonFunctionValueError();\n      }\n      this._compareWith = fn;\n      if (this._selectionModel) {\n        // A different comparator means the selection could change.\n        this._initializeSelection();\n      }\n    }\n    /** Value of the select control. */\n    get value() {\n      return this._value;\n    }\n    set value(newValue) {\n      const hasAssigned = this._assignValue(newValue);\n      if (hasAssigned) {\n        this._onChange(newValue);\n      }\n    }\n    _value;\n    /** Aria label of the select. */\n    ariaLabel = '';\n    /** Input that can be used to specify the `aria-labelledby` attribute. */\n    ariaLabelledby;\n    /** Object used to control when error messages are shown. */\n    get errorStateMatcher() {\n      return this._errorStateTracker.matcher;\n    }\n    set errorStateMatcher(value) {\n      this._errorStateTracker.matcher = value;\n    }\n    /** Time to wait in milliseconds after the last keystroke before moving focus to an item. */\n    typeaheadDebounceInterval;\n    /**\n     * Function used to sort the values in a select in multiple mode.\n     * Follows the same logic as `Array.prototype.sort`.\n     */\n    sortComparator;\n    /** Unique id of the element. */\n    get id() {\n      return this._id;\n    }\n    set id(value) {\n      this._id = value || this._uid;\n      this.stateChanges.next();\n    }\n    _id;\n    /** Whether the select is in an error state. */\n    get errorState() {\n      return this._errorStateTracker.errorState;\n    }\n    set errorState(value) {\n      this._errorStateTracker.errorState = value;\n    }\n    /**\n     * Width of the panel. If set to `auto`, the panel will match the trigger width.\n     * If set to null or an empty string, the panel will grow to match the longest option's text.\n     */\n    panelWidth = this._defaultOptions && typeof this._defaultOptions.panelWidth !== 'undefined' ? this._defaultOptions.panelWidth : 'auto';\n    /**\n     * By default selecting an option with a `null` or `undefined` value will reset the select's\n     * value. Enable this option if the reset behavior doesn't match your requirements and instead\n     * the nullable options should become selected. The value of this input can be controlled app-wide\n     * using the `MAT_SELECT_CONFIG` injection token.\n     */\n    canSelectNullableOptions = this._defaultOptions?.canSelectNullableOptions ?? false;\n    /** Combined stream of all of the child options' change events. */\n    optionSelectionChanges = defer(() => {\n      const options = this.options;\n      if (options) {\n        return options.changes.pipe(startWith(options), switchMap(() => merge(...options.map(option => option.onSelectionChange))));\n      }\n      return this._initialized.pipe(switchMap(() => this.optionSelectionChanges));\n    });\n    /** Event emitted when the select panel has been toggled. */\n    openedChange = new EventEmitter();\n    /** Event emitted when the select has been opened. */\n    _openedStream = this.openedChange.pipe(filter(o => o), map(() => {}));\n    /** Event emitted when the select has been closed. */\n    _closedStream = this.openedChange.pipe(filter(o => !o), map(() => {}));\n    /** Event emitted when the selected value has been changed by the user. */\n    selectionChange = new EventEmitter();\n    /**\n     * Event that emits whenever the raw value of the select changes. This is here primarily\n     * to facilitate the two-way binding for the `value` input.\n     * @docs-private\n     */\n    valueChange = new EventEmitter();\n    constructor() {\n      const defaultErrorStateMatcher = inject(ErrorStateMatcher);\n      const parentForm = inject(NgForm, {\n        optional: true\n      });\n      const parentFormGroup = inject(FormGroupDirective, {\n        optional: true\n      });\n      const tabIndex = inject(new HostAttributeToken('tabindex'), {\n        optional: true\n      });\n      if (this.ngControl) {\n        // Note: we provide the value accessor through here, instead of\n        // the `providers` to avoid running into a circular import.\n        this.ngControl.valueAccessor = this;\n      }\n      // Note that we only want to set this when the defaults pass it in, otherwise it should\n      // stay as `undefined` so that it falls back to the default in the key manager.\n      if (this._defaultOptions?.typeaheadDebounceInterval != null) {\n        this.typeaheadDebounceInterval = this._defaultOptions.typeaheadDebounceInterval;\n      }\n      this._errorStateTracker = new _ErrorStateTracker(defaultErrorStateMatcher, this.ngControl, parentFormGroup, parentForm, this.stateChanges);\n      this._scrollStrategy = this._scrollStrategyFactory();\n      this.tabIndex = tabIndex == null ? 0 : parseInt(tabIndex) || 0;\n      // Force setter to be called in case id was not specified.\n      this.id = this.id;\n    }\n    ngOnInit() {\n      this._selectionModel = new SelectionModel(this.multiple);\n      this.stateChanges.next();\n      this._viewportRuler.change().pipe(takeUntil(this._destroy)).subscribe(() => {\n        if (this.panelOpen) {\n          this._overlayWidth = this._getOverlayWidth(this._preferredOverlayOrigin);\n          this._changeDetectorRef.detectChanges();\n        }\n      });\n    }\n    ngAfterContentInit() {\n      this._initialized.next();\n      this._initialized.complete();\n      this._initKeyManager();\n      this._selectionModel.changed.pipe(takeUntil(this._destroy)).subscribe(event => {\n        event.added.forEach(option => option.select());\n        event.removed.forEach(option => option.deselect());\n      });\n      this.options.changes.pipe(startWith(null), takeUntil(this._destroy)).subscribe(() => {\n        this._resetOptions();\n        this._initializeSelection();\n      });\n    }\n    ngDoCheck() {\n      const newAriaLabelledby = this._getTriggerAriaLabelledby();\n      const ngControl = this.ngControl;\n      // We have to manage setting the `aria-labelledby` ourselves, because part of its value\n      // is computed as a result of a content query which can cause this binding to trigger a\n      // \"changed after checked\" error.\n      if (newAriaLabelledby !== this._triggerAriaLabelledBy) {\n        const element = this._elementRef.nativeElement;\n        this._triggerAriaLabelledBy = newAriaLabelledby;\n        if (newAriaLabelledby) {\n          element.setAttribute('aria-labelledby', newAriaLabelledby);\n        } else {\n          element.removeAttribute('aria-labelledby');\n        }\n      }\n      if (ngControl) {\n        // The disabled state might go out of sync if the form group is swapped out. See #17860.\n        if (this._previousControl !== ngControl.control) {\n          if (this._previousControl !== undefined && ngControl.disabled !== null && ngControl.disabled !== this.disabled) {\n            this.disabled = ngControl.disabled;\n          }\n          this._previousControl = ngControl.control;\n        }\n        this.updateErrorState();\n      }\n    }\n    ngOnChanges(changes) {\n      // Updating the disabled state is handled by the input, but we need to additionally let\n      // the parent form field know to run change detection when the disabled state changes.\n      if (changes['disabled'] || changes['userAriaDescribedBy']) {\n        this.stateChanges.next();\n      }\n      if (changes['typeaheadDebounceInterval'] && this._keyManager) {\n        this._keyManager.withTypeAhead(this.typeaheadDebounceInterval);\n      }\n    }\n    ngOnDestroy() {\n      this._cleanupDetach?.();\n      this._keyManager?.destroy();\n      this._destroy.next();\n      this._destroy.complete();\n      this.stateChanges.complete();\n      this._clearFromModal();\n    }\n    /** Toggles the overlay panel open or closed. */\n    toggle() {\n      this.panelOpen ? this.close() : this.open();\n    }\n    /** Opens the overlay panel. */\n    open() {\n      if (!this._canOpen()) {\n        return;\n      }\n      // It's important that we read this as late as possible, because doing so earlier will\n      // return a different element since it's based on queries in the form field which may\n      // not have run yet. Also this needs to be assigned before we measure the overlay width.\n      if (this._parentFormField) {\n        this._preferredOverlayOrigin = this._parentFormField.getConnectedOverlayOrigin();\n      }\n      this._cleanupDetach?.();\n      this._overlayWidth = this._getOverlayWidth(this._preferredOverlayOrigin);\n      this._applyModalPanelOwnership();\n      this._panelOpen = true;\n      this._overlayDir.positionChange.pipe(take(1)).subscribe(() => {\n        this._changeDetectorRef.detectChanges();\n        this._positioningSettled();\n      });\n      this._overlayDir.attachOverlay();\n      this._keyManager.withHorizontalOrientation(null);\n      this._highlightCorrectOption();\n      this._changeDetectorRef.markForCheck();\n      // Required for the MDC form field to pick up when the overlay has been opened.\n      this.stateChanges.next();\n      // Simulate the animation event before we moved away from `@angular/animations`.\n      Promise.resolve().then(() => this.openedChange.emit(true));\n    }\n    /**\n     * Track which modal we have modified the `aria-owns` attribute of. When the combobox trigger is\n     * inside an aria-modal, we apply aria-owns to the parent modal with the `id` of the options\n     * panel. Track the modal we have changed so we can undo the changes on destroy.\n     */\n    _trackedModal = null;\n    /**\n     * If the autocomplete trigger is inside of an `aria-modal` element, connect\n     * that modal to the options panel with `aria-owns`.\n     *\n     * For some browser + screen reader combinations, when navigation is inside\n     * of an `aria-modal` element, the screen reader treats everything outside\n     * of that modal as hidden or invisible.\n     *\n     * This causes a problem when the combobox trigger is _inside_ of a modal, because the\n     * options panel is rendered _outside_ of that modal, preventing screen reader navigation\n     * from reaching the panel.\n     *\n     * We can work around this issue by applying `aria-owns` to the modal with the `id` of\n     * the options panel. This effectively communicates to assistive technology that the\n     * options panel is part of the same interaction as the modal.\n     *\n     * At time of this writing, this issue is present in VoiceOver.\n     * See https://github.com/angular/components/issues/20694\n     */\n    _applyModalPanelOwnership() {\n      // TODO(http://github.com/angular/components/issues/26853): consider de-duplicating this with\n      // the `LiveAnnouncer` and any other usages.\n      //\n      // Note that the selector here is limited to CDK overlays at the moment in order to reduce the\n      // section of the DOM we need to look through. This should cover all the cases we support, but\n      // the selector can be expanded if it turns out to be too narrow.\n      const modal = this._elementRef.nativeElement.closest('body > .cdk-overlay-container [aria-modal=\"true\"]');\n      if (!modal) {\n        // Most commonly, the autocomplete trigger is not inside a modal.\n        return;\n      }\n      const panelId = `${this.id}-panel`;\n      if (this._trackedModal) {\n        removeAriaReferencedId(this._trackedModal, 'aria-owns', panelId);\n      }\n      addAriaReferencedId(modal, 'aria-owns', panelId);\n      this._trackedModal = modal;\n    }\n    /** Clears the reference to the listbox overlay element from the modal it was added to. */\n    _clearFromModal() {\n      if (!this._trackedModal) {\n        // Most commonly, the autocomplete trigger is not used inside a modal.\n        return;\n      }\n      const panelId = `${this.id}-panel`;\n      removeAriaReferencedId(this._trackedModal, 'aria-owns', panelId);\n      this._trackedModal = null;\n    }\n    /** Closes the overlay panel and focuses the host element. */\n    close() {\n      if (this._panelOpen) {\n        this._panelOpen = false;\n        this._exitAndDetach();\n        this._keyManager.withHorizontalOrientation(this._isRtl() ? 'rtl' : 'ltr');\n        this._changeDetectorRef.markForCheck();\n        this._onTouched();\n        // Required for the MDC form field to pick up when the overlay has been closed.\n        this.stateChanges.next();\n        // Simulate the animation event before we moved away from `@angular/animations`.\n        Promise.resolve().then(() => this.openedChange.emit(false));\n      }\n    }\n    /** Triggers the exit animation and detaches the overlay at the end. */\n    _exitAndDetach() {\n      if (this._animationsDisabled || !this.panel) {\n        this._detachOverlay();\n        return;\n      }\n      this._cleanupDetach?.();\n      this._cleanupDetach = () => {\n        cleanupEvent();\n        clearTimeout(exitFallbackTimer);\n        this._cleanupDetach = undefined;\n      };\n      const panel = this.panel.nativeElement;\n      const cleanupEvent = this._renderer.listen(panel, 'animationend', event => {\n        if (event.animationName === '_mat-select-exit') {\n          this._cleanupDetach?.();\n          this._detachOverlay();\n        }\n      });\n      // Since closing the overlay depends on the animation, we have a fallback in case the panel\n      // doesn't animate. This can happen in some internal tests that do `* {animation: none}`.\n      const exitFallbackTimer = setTimeout(() => {\n        this._cleanupDetach?.();\n        this._detachOverlay();\n      }, 200);\n      panel.classList.add('mat-select-panel-exit');\n    }\n    /** Detaches the current overlay directive. */\n    _detachOverlay() {\n      this._overlayDir.detachOverlay();\n      // Some of the overlay detachment logic depends on change detection.\n      // Mark for check to ensure that things get picked up in a timely manner.\n      this._changeDetectorRef.markForCheck();\n    }\n    /**\n     * Sets the select's value. Part of the ControlValueAccessor interface\n     * required to integrate with Angular's core forms API.\n     *\n     * @param value New value to be written to the model.\n     */\n    writeValue(value) {\n      this._assignValue(value);\n    }\n    /**\n     * Saves a callback function to be invoked when the select's value\n     * changes from user input. Part of the ControlValueAccessor interface\n     * required to integrate with Angular's core forms API.\n     *\n     * @param fn Callback to be triggered when the value changes.\n     */\n    registerOnChange(fn) {\n      this._onChange = fn;\n    }\n    /**\n     * Saves a callback function to be invoked when the select is blurred\n     * by the user. Part of the ControlValueAccessor interface required\n     * to integrate with Angular's core forms API.\n     *\n     * @param fn Callback to be triggered when the component has been touched.\n     */\n    registerOnTouched(fn) {\n      this._onTouched = fn;\n    }\n    /**\n     * Disables the select. Part of the ControlValueAccessor interface required\n     * to integrate with Angular's core forms API.\n     *\n     * @param isDisabled Sets whether the component is disabled.\n     */\n    setDisabledState(isDisabled) {\n      this.disabled = isDisabled;\n      this._changeDetectorRef.markForCheck();\n      this.stateChanges.next();\n    }\n    /** Whether or not the overlay panel is open. */\n    get panelOpen() {\n      return this._panelOpen;\n    }\n    /** The currently selected option. */\n    get selected() {\n      return this.multiple ? this._selectionModel?.selected || [] : this._selectionModel?.selected[0];\n    }\n    /** The value displayed in the trigger. */\n    get triggerValue() {\n      if (this.empty) {\n        return '';\n      }\n      if (this._multiple) {\n        const selectedOptions = this._selectionModel.selected.map(option => option.viewValue);\n        if (this._isRtl()) {\n          selectedOptions.reverse();\n        }\n        // TODO(crisbeto): delimiter should be configurable for proper localization.\n        return selectedOptions.join(', ');\n      }\n      return this._selectionModel.selected[0].viewValue;\n    }\n    /** Refreshes the error state of the select. */\n    updateErrorState() {\n      this._errorStateTracker.updateErrorState();\n    }\n    /** Whether the element is in RTL mode. */\n    _isRtl() {\n      return this._dir ? this._dir.value === 'rtl' : false;\n    }\n    /** Handles all keydown events on the select. */\n    _handleKeydown(event) {\n      if (!this.disabled) {\n        this.panelOpen ? this._handleOpenKeydown(event) : this._handleClosedKeydown(event);\n      }\n    }\n    /** Handles keyboard events while the select is closed. */\n    _handleClosedKeydown(event) {\n      const keyCode = event.keyCode;\n      const isArrowKey = keyCode === DOWN_ARROW || keyCode === UP_ARROW || keyCode === LEFT_ARROW || keyCode === RIGHT_ARROW;\n      const isOpenKey = keyCode === ENTER || keyCode === SPACE;\n      const manager = this._keyManager;\n      // Open the select on ALT + arrow key to match the native <select>\n      if (!manager.isTyping() && isOpenKey && !hasModifierKey(event) || (this.multiple || event.altKey) && isArrowKey) {\n        event.preventDefault(); // prevents the page from scrolling down when pressing space\n        this.open();\n      } else if (!this.multiple) {\n        const previouslySelectedOption = this.selected;\n        manager.onKeydown(event);\n        const selectedOption = this.selected;\n        // Since the value has changed, we need to announce it ourselves.\n        if (selectedOption && previouslySelectedOption !== selectedOption) {\n          // We set a duration on the live announcement, because we want the live element to be\n          // cleared after a while so that users can't navigate to it using the arrow keys.\n          this._liveAnnouncer.announce(selectedOption.viewValue, 10000);\n        }\n      }\n    }\n    /** Handles keyboard events when the selected is open. */\n    _handleOpenKeydown(event) {\n      const manager = this._keyManager;\n      const keyCode = event.keyCode;\n      const isArrowKey = keyCode === DOWN_ARROW || keyCode === UP_ARROW;\n      const isTyping = manager.isTyping();\n      if (isArrowKey && event.altKey) {\n        // Close the select on ALT + arrow key to match the native <select>\n        event.preventDefault();\n        this.close();\n        // Don't do anything in this case if the user is typing,\n        // because the typing sequence can include the space key.\n      } else if (!isTyping && (keyCode === ENTER || keyCode === SPACE) && manager.activeItem && !hasModifierKey(event)) {\n        event.preventDefault();\n        manager.activeItem._selectViaInteraction();\n      } else if (!isTyping && this._multiple && keyCode === A && event.ctrlKey) {\n        event.preventDefault();\n        const hasDeselectedOptions = this.options.some(opt => !opt.disabled && !opt.selected);\n        this.options.forEach(option => {\n          if (!option.disabled) {\n            hasDeselectedOptions ? option.select() : option.deselect();\n          }\n        });\n      } else {\n        const previouslyFocusedIndex = manager.activeItemIndex;\n        manager.onKeydown(event);\n        if (this._multiple && isArrowKey && event.shiftKey && manager.activeItem && manager.activeItemIndex !== previouslyFocusedIndex) {\n          manager.activeItem._selectViaInteraction();\n        }\n      }\n    }\n    /** Handles keyboard events coming from the overlay. */\n    _handleOverlayKeydown(event) {\n      // TODO(crisbeto): prior to #30363 this was being handled inside the overlay directive, but we\n      // need control over the animation timing so we do it manually. We should remove the `keydown`\n      // listener from `.mat-mdc-select-panel` and handle all the events here. That may cause\n      // further test breakages so it's left for a follow-up.\n      if (event.keyCode === ESCAPE && !hasModifierKey(event)) {\n        event.preventDefault();\n        this.close();\n      }\n    }\n    _onFocus() {\n      if (!this.disabled) {\n        this._focused = true;\n        this.stateChanges.next();\n      }\n    }\n    /**\n     * Calls the touched callback only if the panel is closed. Otherwise, the trigger will\n     * \"blur\" to the panel when it opens, causing a false positive.\n     */\n    _onBlur() {\n      this._focused = false;\n      this._keyManager?.cancelTypeahead();\n      if (!this.disabled && !this.panelOpen) {\n        this._onTouched();\n        this._changeDetectorRef.markForCheck();\n        this.stateChanges.next();\n      }\n    }\n    /** Returns the theme to be used on the panel. */\n    _getPanelTheme() {\n      return this._parentFormField ? `mat-${this._parentFormField.color}` : '';\n    }\n    /** Whether the select has a value. */\n    get empty() {\n      return !this._selectionModel || this._selectionModel.isEmpty();\n    }\n    _initializeSelection() {\n      // Defer setting the value in order to avoid the \"Expression\n      // has changed after it was checked\" errors from Angular.\n      Promise.resolve().then(() => {\n        if (this.ngControl) {\n          this._value = this.ngControl.value;\n        }\n        this._setSelectionByValue(this._value);\n        this.stateChanges.next();\n      });\n    }\n    /**\n     * Sets the selected option based on a value. If no option can be\n     * found with the designated value, the select trigger is cleared.\n     */\n    _setSelectionByValue(value) {\n      this.options.forEach(option => option.setInactiveStyles());\n      this._selectionModel.clear();\n      if (this.multiple && value) {\n        if (!Array.isArray(value) && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n          throw getMatSelectNonArrayValueError();\n        }\n        value.forEach(currentValue => this._selectOptionByValue(currentValue));\n        this._sortValues();\n      } else {\n        const correspondingOption = this._selectOptionByValue(value);\n        // Shift focus to the active item. Note that we shouldn't do this in multiple\n        // mode, because we don't know what option the user interacted with last.\n        if (correspondingOption) {\n          this._keyManager.updateActiveItem(correspondingOption);\n        } else if (!this.panelOpen) {\n          // Otherwise reset the highlighted option. Note that we only want to do this while\n          // closed, because doing it while open can shift the user's focus unnecessarily.\n          this._keyManager.updateActiveItem(-1);\n        }\n      }\n      this._changeDetectorRef.markForCheck();\n    }\n    /**\n     * Finds and selects and option based on its value.\n     * @returns Option that has the corresponding value.\n     */\n    _selectOptionByValue(value) {\n      const correspondingOption = this.options.find(option => {\n        // Skip options that are already in the model. This allows us to handle cases\n        // where the same primitive value is selected multiple times.\n        if (this._selectionModel.isSelected(option)) {\n          return false;\n        }\n        try {\n          // Treat null as a special reset value.\n          return (option.value != null || this.canSelectNullableOptions) && this._compareWith(option.value, value);\n        } catch (error) {\n          if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            // Notify developers of errors in their comparator.\n            console.warn(error);\n          }\n          return false;\n        }\n      });\n      if (correspondingOption) {\n        this._selectionModel.select(correspondingOption);\n      }\n      return correspondingOption;\n    }\n    /** Assigns a specific value to the select. Returns whether the value has changed. */\n    _assignValue(newValue) {\n      // Always re-assign an array, because it might have been mutated.\n      if (newValue !== this._value || this._multiple && Array.isArray(newValue)) {\n        if (this.options) {\n          this._setSelectionByValue(newValue);\n        }\n        this._value = newValue;\n        return true;\n      }\n      return false;\n    }\n    // `skipPredicate` determines if key manager should avoid putting a given option in the tab\n    // order. Allow disabled list items to receive focus via keyboard to align with WAI ARIA\n    // recommendation.\n    //\n    // Normally WAI ARIA's instructions are to exclude disabled items from the tab order, but it\n    // makes a few exceptions for compound widgets.\n    //\n    // From [Developing a Keyboard Interface](\n    // https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/):\n    //   \"For the following composite widget elements, keep them focusable when disabled: Options in a\n    //   Listbox...\"\n    //\n    // The user can focus disabled options using the keyboard, but the user cannot click disabled\n    // options.\n    _skipPredicate = option => {\n      if (this.panelOpen) {\n        // Support keyboard focusing disabled options in an ARIA listbox.\n        return false;\n      }\n      // When the panel is closed, skip over disabled options. Support options via the UP/DOWN arrow\n      // keys on a closed select. ARIA listbox interaction pattern is less relevant when the panel is\n      // closed.\n      return option.disabled;\n    };\n    /** Gets how wide the overlay panel should be. */\n    _getOverlayWidth(preferredOrigin) {\n      if (this.panelWidth === 'auto') {\n        const refToMeasure = preferredOrigin instanceof CdkOverlayOrigin ? preferredOrigin.elementRef : preferredOrigin || this._elementRef;\n        return refToMeasure.nativeElement.getBoundingClientRect().width;\n      }\n      return this.panelWidth === null ? '' : this.panelWidth;\n    }\n    /** Syncs the parent state with the individual options. */\n    _syncParentProperties() {\n      if (this.options) {\n        for (const option of this.options) {\n          option._changeDetectorRef.markForCheck();\n        }\n      }\n    }\n    /** Sets up a key manager to listen to keyboard events on the overlay panel. */\n    _initKeyManager() {\n      this._keyManager = new ActiveDescendantKeyManager(this.options).withTypeAhead(this.typeaheadDebounceInterval).withVerticalOrientation().withHorizontalOrientation(this._isRtl() ? 'rtl' : 'ltr').withHomeAndEnd().withPageUpDown().withAllowedModifierKeys(['shiftKey']).skipPredicate(this._skipPredicate);\n      this._keyManager.tabOut.subscribe(() => {\n        if (this.panelOpen) {\n          // Select the active item when tabbing away. This is consistent with how the native\n          // select behaves. Note that we only want to do this in single selection mode.\n          if (!this.multiple && this._keyManager.activeItem) {\n            this._keyManager.activeItem._selectViaInteraction();\n          }\n          // Restore focus to the trigger before closing. Ensures that the focus\n          // position won't be lost if the user got focus into the overlay.\n          this.focus();\n          this.close();\n        }\n      });\n      this._keyManager.change.subscribe(() => {\n        if (this._panelOpen && this.panel) {\n          this._scrollOptionIntoView(this._keyManager.activeItemIndex || 0);\n        } else if (!this._panelOpen && !this.multiple && this._keyManager.activeItem) {\n          this._keyManager.activeItem._selectViaInteraction();\n        }\n      });\n    }\n    /** Drops current option subscriptions and IDs and resets from scratch. */\n    _resetOptions() {\n      const changedOrDestroyed = merge(this.options.changes, this._destroy);\n      this.optionSelectionChanges.pipe(takeUntil(changedOrDestroyed)).subscribe(event => {\n        this._onSelect(event.source, event.isUserInput);\n        if (event.isUserInput && !this.multiple && this._panelOpen) {\n          this.close();\n          this.focus();\n        }\n      });\n      // Listen to changes in the internal state of the options and react accordingly.\n      // Handles cases like the labels of the selected options changing.\n      merge(...this.options.map(option => option._stateChanges)).pipe(takeUntil(changedOrDestroyed)).subscribe(() => {\n        // `_stateChanges` can fire as a result of a change in the label's DOM value which may\n        // be the result of an expression changing. We have to use `detectChanges` in order\n        // to avoid \"changed after checked\" errors (see #14793).\n        this._changeDetectorRef.detectChanges();\n        this.stateChanges.next();\n      });\n    }\n    /** Invoked when an option is clicked. */\n    _onSelect(option, isUserInput) {\n      const wasSelected = this._selectionModel.isSelected(option);\n      if (!this.canSelectNullableOptions && option.value == null && !this._multiple) {\n        option.deselect();\n        this._selectionModel.clear();\n        if (this.value != null) {\n          this._propagateChanges(option.value);\n        }\n      } else {\n        if (wasSelected !== option.selected) {\n          option.selected ? this._selectionModel.select(option) : this._selectionModel.deselect(option);\n        }\n        if (isUserInput) {\n          this._keyManager.setActiveItem(option);\n        }\n        if (this.multiple) {\n          this._sortValues();\n          if (isUserInput) {\n            // In case the user selected the option with their mouse, we\n            // want to restore focus back to the trigger, in order to\n            // prevent the select keyboard controls from clashing with\n            // the ones from `mat-option`.\n            this.focus();\n          }\n        }\n      }\n      if (wasSelected !== this._selectionModel.isSelected(option)) {\n        this._propagateChanges();\n      }\n      this.stateChanges.next();\n    }\n    /** Sorts the selected values in the selected based on their order in the panel. */\n    _sortValues() {\n      if (this.multiple) {\n        const options = this.options.toArray();\n        this._selectionModel.sort((a, b) => {\n          return this.sortComparator ? this.sortComparator(a, b, options) : options.indexOf(a) - options.indexOf(b);\n        });\n        this.stateChanges.next();\n      }\n    }\n    /** Emits change event to set the model value. */\n    _propagateChanges(fallbackValue) {\n      let valueToEmit;\n      if (this.multiple) {\n        valueToEmit = this.selected.map(option => option.value);\n      } else {\n        valueToEmit = this.selected ? this.selected.value : fallbackValue;\n      }\n      this._value = valueToEmit;\n      this.valueChange.emit(valueToEmit);\n      this._onChange(valueToEmit);\n      this.selectionChange.emit(this._getChangeEvent(valueToEmit));\n      this._changeDetectorRef.markForCheck();\n    }\n    /**\n     * Highlights the selected item. If no option is selected, it will highlight\n     * the first *enabled* option.\n     */\n    _highlightCorrectOption() {\n      if (this._keyManager) {\n        if (this.empty) {\n          // Find the index of the first *enabled* option. Avoid calling `_keyManager.setActiveItem`\n          // because it activates the first option that passes the skip predicate, rather than the\n          // first *enabled* option.\n          let firstEnabledOptionIndex = -1;\n          for (let index = 0; index < this.options.length; index++) {\n            const option = this.options.get(index);\n            if (!option.disabled) {\n              firstEnabledOptionIndex = index;\n              break;\n            }\n          }\n          this._keyManager.setActiveItem(firstEnabledOptionIndex);\n        } else {\n          this._keyManager.setActiveItem(this._selectionModel.selected[0]);\n        }\n      }\n    }\n    /** Whether the panel is allowed to open. */\n    _canOpen() {\n      return !this._panelOpen && !this.disabled && this.options?.length > 0 && !!this._overlayDir;\n    }\n    /** Focuses the select element. */\n    focus(options) {\n      this._elementRef.nativeElement.focus(options);\n    }\n    /** Gets the aria-labelledby for the select panel. */\n    _getPanelAriaLabelledby() {\n      if (this.ariaLabel) {\n        return null;\n      }\n      const labelId = this._parentFormField?.getLabelId() || null;\n      const labelExpression = labelId ? labelId + ' ' : '';\n      return this.ariaLabelledby ? labelExpression + this.ariaLabelledby : labelId;\n    }\n    /** Determines the `aria-activedescendant` to be set on the host. */\n    _getAriaActiveDescendant() {\n      if (this.panelOpen && this._keyManager && this._keyManager.activeItem) {\n        return this._keyManager.activeItem.id;\n      }\n      return null;\n    }\n    /** Gets the aria-labelledby of the select component trigger. */\n    _getTriggerAriaLabelledby() {\n      if (this.ariaLabel) {\n        return null;\n      }\n      let value = this._parentFormField?.getLabelId() || '';\n      if (this.ariaLabelledby) {\n        value += ' ' + this.ariaLabelledby;\n      }\n      // The value should not be used for the trigger's aria-labelledby,\n      // but this currently \"breaks\" accessibility tests since they complain\n      // there is no aria-labelledby. This is because they are not setting an\n      // appropriate label on the form field or select.\n      // TODO: remove this conditional after fixing clients by ensuring their\n      // selects have a label applied.\n      if (!value) {\n        value = this._valueId;\n      }\n      return value;\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    get describedByIds() {\n      const element = this._elementRef.nativeElement;\n      const existingDescribedBy = element.getAttribute('aria-describedby');\n      return existingDescribedBy?.split(' ') || [];\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    setDescribedByIds(ids) {\n      if (ids.length) {\n        this._elementRef.nativeElement.setAttribute('aria-describedby', ids.join(' '));\n      } else {\n        this._elementRef.nativeElement.removeAttribute('aria-describedby');\n      }\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    onContainerClick() {\n      this.focus();\n      this.open();\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    get shouldLabelFloat() {\n      // Since the panel doesn't overlap the trigger, we\n      // want the label to only float when there's a value.\n      return this.panelOpen || !this.empty || this.focused && !!this.placeholder;\n    }\n    static \u0275fac = function MatSelect_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatSelect)();\n    };\n    static \u0275cmp = /* @__PURE__ */i0.\u0275\u0275defineComponent({\n      type: MatSelect,\n      selectors: [[\"mat-select\"]],\n      contentQueries: function MatSelect_ContentQueries(rf, ctx, dirIndex) {\n        if (rf & 1) {\n          i0.\u0275\u0275contentQuery(dirIndex, MAT_SELECT_TRIGGER, 5);\n          i0.\u0275\u0275contentQuery(dirIndex, MatOption, 5);\n          i0.\u0275\u0275contentQuery(dirIndex, MAT_OPTGROUP, 5);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.\u0275\u0275queryRefresh(_t = i0.\u0275\u0275loadQuery()) && (ctx.customTrigger = _t.first);\n          i0.\u0275\u0275queryRefresh(_t = i0.\u0275\u0275loadQuery()) && (ctx.options = _t);\n          i0.\u0275\u0275queryRefresh(_t = i0.\u0275\u0275loadQuery()) && (ctx.optionGroups = _t);\n        }\n      },\n      viewQuery: function MatSelect_Query(rf, ctx) {\n        if (rf & 1) {\n          i0.\u0275\u0275viewQuery(_c0, 5);\n          i0.\u0275\u0275viewQuery(_c1, 5);\n          i0.\u0275\u0275viewQuery(CdkConnectedOverlay, 5);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.\u0275\u0275queryRefresh(_t = i0.\u0275\u0275loadQuery()) && (ctx.trigger = _t.first);\n          i0.\u0275\u0275queryRefresh(_t = i0.\u0275\u0275loadQuery()) && (ctx.panel = _t.first);\n          i0.\u0275\u0275queryRefresh(_t = i0.\u0275\u0275loadQuery()) && (ctx._overlayDir = _t.first);\n        }\n      },\n      hostAttrs: [\"role\", \"combobox\", \"aria-haspopup\", \"listbox\", 1, \"mat-mdc-select\"],\n      hostVars: 21,\n      hostBindings: function MatSelect_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.\u0275\u0275listener(\"keydown\", function MatSelect_keydown_HostBindingHandler($event) {\n            return ctx._handleKeydown($event);\n          })(\"focus\", function MatSelect_focus_HostBindingHandler() {\n            return ctx._onFocus();\n          })(\"blur\", function MatSelect_blur_HostBindingHandler() {\n            return ctx._onBlur();\n          });\n        }\n        if (rf & 2) {\n          i0.\u0275\u0275attribute(\"id\", ctx.id)(\"tabindex\", ctx.disabled ? -1 : ctx.tabIndex)(\"aria-controls\", ctx.panelOpen ? ctx.id + \"-panel\" : null)(\"aria-expanded\", ctx.panelOpen)(\"aria-label\", ctx.ariaLabel || null)(\"aria-required\", ctx.required.toString())(\"aria-disabled\", ctx.disabled.toString())(\"aria-invalid\", ctx.errorState)(\"aria-activedescendant\", ctx._getAriaActiveDescendant());\n          i0.\u0275\u0275classProp(\"mat-mdc-select-disabled\", ctx.disabled)(\"mat-mdc-select-invalid\", ctx.errorState)(\"mat-mdc-select-required\", ctx.required)(\"mat-mdc-select-empty\", ctx.empty)(\"mat-mdc-select-multiple\", ctx.multiple)(\"mat-select-open\", ctx.panelOpen);\n        }\n      },\n      inputs: {\n        userAriaDescribedBy: [0, \"aria-describedby\", \"userAriaDescribedBy\"],\n        panelClass: \"panelClass\",\n        disabled: [2, \"disabled\", \"disabled\", booleanAttribute],\n        disableRipple: [2, \"disableRipple\", \"disableRipple\", booleanAttribute],\n        tabIndex: [2, \"tabIndex\", \"tabIndex\", value => value == null ? 0 : numberAttribute(value)],\n        hideSingleSelectionIndicator: [2, \"hideSingleSelectionIndicator\", \"hideSingleSelectionIndicator\", booleanAttribute],\n        placeholder: \"placeholder\",\n        required: [2, \"required\", \"required\", booleanAttribute],\n        multiple: [2, \"multiple\", \"multiple\", booleanAttribute],\n        disableOptionCentering: [2, \"disableOptionCentering\", \"disableOptionCentering\", booleanAttribute],\n        compareWith: \"compareWith\",\n        value: \"value\",\n        ariaLabel: [0, \"aria-label\", \"ariaLabel\"],\n        ariaLabelledby: [0, \"aria-labelledby\", \"ariaLabelledby\"],\n        errorStateMatcher: \"errorStateMatcher\",\n        typeaheadDebounceInterval: [2, \"typeaheadDebounceInterval\", \"typeaheadDebounceInterval\", numberAttribute],\n        sortComparator: \"sortComparator\",\n        id: \"id\",\n        panelWidth: \"panelWidth\",\n        canSelectNullableOptions: [2, \"canSelectNullableOptions\", \"canSelectNullableOptions\", booleanAttribute]\n      },\n      outputs: {\n        openedChange: \"openedChange\",\n        _openedStream: \"opened\",\n        _closedStream: \"closed\",\n        selectionChange: \"selectionChange\",\n        valueChange: \"valueChange\"\n      },\n      exportAs: [\"matSelect\"],\n      features: [i0.\u0275\u0275ProvidersFeature([{\n        provide: MatFormFieldControl,\n        useExisting: MatSelect\n      }, {\n        provide: MAT_OPTION_PARENT_COMPONENT,\n        useExisting: MatSelect\n      }]), i0.\u0275\u0275NgOnChangesFeature],\n      ngContentSelectors: _c3,\n      decls: 11,\n      vars: 9,\n      consts: [[\"fallbackOverlayOrigin\", \"cdkOverlayOrigin\", \"trigger\", \"\"], [\"panel\", \"\"], [\"cdk-overlay-origin\", \"\", 1, \"mat-mdc-select-trigger\", 3, \"click\"], [1, \"mat-mdc-select-value\"], [1, \"mat-mdc-select-placeholder\", \"mat-mdc-select-min-line\"], [1, \"mat-mdc-select-value-text\"], [1, \"mat-mdc-select-arrow-wrapper\"], [1, \"mat-mdc-select-arrow\"], [\"viewBox\", \"0 0 24 24\", \"width\", \"24px\", \"height\", \"24px\", \"focusable\", \"false\", \"aria-hidden\", \"true\"], [\"d\", \"M7 10l5 5 5-5z\"], [\"cdk-connected-overlay\", \"\", \"cdkConnectedOverlayLockPosition\", \"\", \"cdkConnectedOverlayHasBackdrop\", \"\", \"cdkConnectedOverlayBackdropClass\", \"cdk-overlay-transparent-backdrop\", 3, \"detach\", \"backdropClick\", \"overlayKeydown\", \"cdkConnectedOverlayDisableClose\", \"cdkConnectedOverlayPanelClass\", \"cdkConnectedOverlayScrollStrategy\", \"cdkConnectedOverlayOrigin\", \"cdkConnectedOverlayPositions\", \"cdkConnectedOverlayWidth\", \"cdkConnectedOverlayFlexibleDimensions\"], [1, \"mat-mdc-select-min-line\"], [\"role\", \"listbox\", \"tabindex\", \"-1\", 3, \"keydown\", \"ngClass\"]],\n      template: function MatSelect_Template(rf, ctx) {\n        if (rf & 1) {\n          const _r1 = i0.\u0275\u0275getCurrentView();\n          i0.\u0275\u0275projectionDef(_c2);\n          i0.\u0275\u0275elementStart(0, \"div\", 2, 0);\n          i0.\u0275\u0275listener(\"click\", function MatSelect_Template_div_click_0_listener() {\n            i0.\u0275\u0275restoreView(_r1);\n            return i0.\u0275\u0275resetView(ctx.open());\n          });\n          i0.\u0275\u0275elementStart(3, \"div\", 3);\n          i0.\u0275\u0275conditionalCreate(4, MatSelect_Conditional_4_Template, 2, 1, \"span\", 4)(5, MatSelect_Conditional_5_Template, 3, 1, \"span\", 5);\n          i0.\u0275\u0275elementEnd();\n          i0.\u0275\u0275elementStart(6, \"div\", 6)(7, \"div\", 7);\n          i0.\u0275\u0275namespaceSVG();\n          i0.\u0275\u0275elementStart(8, \"svg\", 8);\n          i0.\u0275\u0275element(9, \"path\", 9);\n          i0.\u0275\u0275elementEnd()()()();\n          i0.\u0275\u0275template(10, MatSelect_ng_template_10_Template, 3, 10, \"ng-template\", 10);\n          i0.\u0275\u0275listener(\"detach\", function MatSelect_Template_ng_template_detach_10_listener() {\n            i0.\u0275\u0275restoreView(_r1);\n            return i0.\u0275\u0275resetView(ctx.close());\n          })(\"backdropClick\", function MatSelect_Template_ng_template_backdropClick_10_listener() {\n            i0.\u0275\u0275restoreView(_r1);\n            return i0.\u0275\u0275resetView(ctx.close());\n          })(\"overlayKeydown\", function MatSelect_Template_ng_template_overlayKeydown_10_listener($event) {\n            i0.\u0275\u0275restoreView(_r1);\n            return i0.\u0275\u0275resetView(ctx._handleOverlayKeydown($event));\n          });\n        }\n        if (rf & 2) {\n          const fallbackOverlayOrigin_r4 = i0.\u0275\u0275reference(1);\n          i0.\u0275\u0275advance(3);\n          i0.\u0275\u0275attribute(\"id\", ctx._valueId);\n          i0.\u0275\u0275advance();\n          i0.\u0275\u0275conditional(ctx.empty ? 4 : 5);\n          i0.\u0275\u0275advance(6);\n          i0.\u0275\u0275property(\"cdkConnectedOverlayDisableClose\", true)(\"cdkConnectedOverlayPanelClass\", ctx._overlayPanelClass)(\"cdkConnectedOverlayScrollStrategy\", ctx._scrollStrategy)(\"cdkConnectedOverlayOrigin\", ctx._preferredOverlayOrigin || fallbackOverlayOrigin_r4)(\"cdkConnectedOverlayPositions\", ctx._positions)(\"cdkConnectedOverlayWidth\", ctx._overlayWidth)(\"cdkConnectedOverlayFlexibleDimensions\", true);\n        }\n      },\n      dependencies: [CdkOverlayOrigin, CdkConnectedOverlay, NgClass],\n      styles: [\"@keyframes _mat-select-enter{from{opacity:0;transform:scaleY(0.8)}to{opacity:1;transform:none}}@keyframes _mat-select-exit{from{opacity:1}to{opacity:0}}.mat-mdc-select{display:inline-block;width:100%;outline:none;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;color:var(--mat-select-enabled-trigger-text-color, var(--mat-sys-on-surface));font-family:var(--mat-select-trigger-text-font, var(--mat-sys-body-large-font));line-height:var(--mat-select-trigger-text-line-height, var(--mat-sys-body-large-line-height));font-size:var(--mat-select-trigger-text-size, var(--mat-sys-body-large-size));font-weight:var(--mat-select-trigger-text-weight, var(--mat-sys-body-large-weight));letter-spacing:var(--mat-select-trigger-text-tracking, var(--mat-sys-body-large-tracking))}div.mat-mdc-select-panel{box-shadow:var(--mat-select-container-elevation-shadow, 0px 3px 1px -2px rgba(0, 0, 0, 0.2), 0px 2px 2px 0px rgba(0, 0, 0, 0.14), 0px 1px 5px 0px rgba(0, 0, 0, 0.12))}.mat-mdc-select-disabled{color:var(--mat-select-disabled-trigger-text-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mat-mdc-select-disabled .mat-mdc-select-placeholder{color:var(--mat-select-disabled-trigger-text-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mat-mdc-select-trigger{display:inline-flex;align-items:center;cursor:pointer;position:relative;box-sizing:border-box;width:100%}.mat-mdc-select-disabled .mat-mdc-select-trigger{-webkit-user-select:none;user-select:none;cursor:default}.mat-mdc-select-value{width:100%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.mat-mdc-select-value-text{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.mat-mdc-select-arrow-wrapper{height:24px;flex-shrink:0;display:inline-flex;align-items:center}.mat-form-field-appearance-fill .mdc-text-field--no-label .mat-mdc-select-arrow-wrapper{transform:none}.mat-mdc-form-field .mat-mdc-select.mat-mdc-select-invalid .mat-mdc-select-arrow,.mat-form-field-invalid:not(.mat-form-field-disabled) .mat-mdc-form-field-infix::after{color:var(--mat-select-invalid-arrow-color, var(--mat-sys-error))}.mat-mdc-select-arrow{width:10px;height:5px;position:relative;color:var(--mat-select-enabled-arrow-color, var(--mat-sys-on-surface-variant))}.mat-mdc-form-field.mat-focused .mat-mdc-select-arrow{color:var(--mat-select-focused-arrow-color, var(--mat-sys-primary))}.mat-mdc-form-field .mat-mdc-select.mat-mdc-select-disabled .mat-mdc-select-arrow{color:var(--mat-select-disabled-arrow-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mat-select-open .mat-mdc-select-arrow{transform:rotate(180deg)}.mat-form-field-animations-enabled .mat-mdc-select-arrow{transition:transform 80ms linear}.mat-mdc-select-arrow svg{fill:currentColor;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%)}@media(forced-colors: active){.mat-mdc-select-arrow svg{fill:CanvasText}.mat-mdc-select-disabled .mat-mdc-select-arrow svg{fill:GrayText}}div.mat-mdc-select-panel{width:100%;max-height:275px;outline:0;overflow:auto;padding:8px 0;border-radius:4px;box-sizing:border-box;position:relative;background-color:var(--mat-select-panel-background-color, var(--mat-sys-surface-container))}@media(forced-colors: active){div.mat-mdc-select-panel{outline:solid 1px}}.cdk-overlay-pane:not(.mat-mdc-select-panel-above) div.mat-mdc-select-panel{border-top-left-radius:0;border-top-right-radius:0;transform-origin:top center}.mat-mdc-select-panel-above div.mat-mdc-select-panel{border-bottom-left-radius:0;border-bottom-right-radius:0;transform-origin:bottom center}.mat-select-panel-animations-enabled{animation:_mat-select-enter 120ms cubic-bezier(0, 0, 0.2, 1)}.mat-select-panel-animations-enabled.mat-select-panel-exit{animation:_mat-select-exit 100ms linear}.mat-mdc-select-placeholder{transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1);color:var(--mat-select-placeholder-text-color, var(--mat-sys-on-surface-variant))}.mat-mdc-form-field:not(.mat-form-field-animations-enabled) .mat-mdc-select-placeholder,._mat-animation-noopable .mat-mdc-select-placeholder{transition:none}.mat-form-field-hide-placeholder .mat-mdc-select-placeholder{color:rgba(0,0,0,0);-webkit-text-fill-color:rgba(0,0,0,0);transition:none;display:block}.mat-mdc-form-field-type-mat-select:not(.mat-form-field-disabled) .mat-mdc-text-field-wrapper{cursor:pointer}.mat-mdc-form-field-type-mat-select.mat-form-field-appearance-fill .mat-mdc-floating-label{max-width:calc(100% - 18px)}.mat-mdc-form-field-type-mat-select.mat-form-field-appearance-fill .mdc-floating-label--float-above{max-width:calc(100%/0.75 - 24px)}.mat-mdc-form-field-type-mat-select.mat-form-field-appearance-outline .mdc-notched-outline__notch{max-width:calc(100% - 60px)}.mat-mdc-form-field-type-mat-select.mat-form-field-appearance-outline .mdc-text-field--label-floating .mdc-notched-outline__notch{max-width:calc(100% - 24px)}.mat-mdc-select-min-line:empty::before{content:\\\" \\\";white-space:pre;width:1px;display:inline-block;visibility:hidden}.mat-form-field-appearance-fill .mat-mdc-select-arrow-wrapper{transform:var(--mat-select-arrow-transform, translateY(-8px))}\\n\"],\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n  return MatSelect;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Allows the user to customize the trigger that is displayed when the select has a value.\n */\nlet MatSelectTrigger = /*#__PURE__*/(() => {\n  class MatSelectTrigger {\n    static \u0275fac = function MatSelectTrigger_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatSelectTrigger)();\n    };\n    static \u0275dir = /* @__PURE__ */i0.\u0275\u0275defineDirective({\n      type: MatSelectTrigger,\n      selectors: [[\"mat-select-trigger\"]],\n      features: [i0.\u0275\u0275ProvidersFeature([{\n        provide: MAT_SELECT_TRIGGER,\n        useExisting: MatSelectTrigger\n      }])]\n    });\n  }\n  return MatSelectTrigger;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet MatSelectModule = /*#__PURE__*/(() => {\n  class MatSelectModule {\n    static \u0275fac = function MatSelectModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatSelectModule)();\n    };\n    static \u0275mod = /* @__PURE__ */i0.\u0275\u0275defineNgModule({\n      type: MatSelectModule\n    });\n    static \u0275inj = /* @__PURE__ */i0.\u0275\u0275defineInjector({\n      providers: [MAT_SELECT_SCROLL_STRATEGY_PROVIDER],\n      imports: [OverlayModule, MatOptionModule, MatCommonModule, CdkScrollableModule, MatFormFieldModule, MatOptionModule, MatCommonModule]\n    });\n  }\n  return MatSelectModule;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nexport { MAT_SELECT_CONFIG, MAT_SELECT_SCROLL_STRATEGY, MAT_SELECT_SCROLL_STRATEGY_PROVIDER, MAT_SELECT_SCROLL_STRATEGY_PROVIDER_FACTORY, MAT_SELECT_TRIGGER, MatSelect, MatSelectChange, MatSelectModule, MatSelectTrigger };\n"],
  "mappings": "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",
  "names": ["createRepositionScrollStrategy", "CdkConnectedOverlay", "CdkOverlayOrigin", "OverlayModule", "i0", "InjectionToken", "inject", "Injector", "ChangeDetectorRef", "ElementRef", "Renderer2", "signal", "EventEmitter", "HostAttributeToken", "booleanAttribute", "numberAttribute", "ViewportRuler", "CdkScrollableModule", "_IdGenerator", "LiveAnnouncer", "removeAriaReferencedId", "addAriaReferencedId", "ActiveDescendantKeyManager", "Directionality", "SelectionModel", "hasModifierKey", "ENTER", "SPACE", "A", "ESCAPE", "DOWN_ARROW", "UP_ARROW", "LEFT_ARROW", "RIGHT_ARROW", "NgControl", "Validators", "NgForm", "FormGroupDirective", "Subject", "defer", "merge", "startWith", "switchMap", "filter", "map", "takeUntil", "take", "NgClass", "_c0", "_c1", "_c2", "_c3", "MatSelect_Conditional_4_Template", "rf", "ctx", "ctx_r1", "MatSelect_Conditional_5_Conditional_1_Template", "MatSelect_Conditional_5_Conditional_2_Template", "MatSelect_Conditional_5_Template", "MatSelect_ng_template_10_Template", "_r3", "$event", "MAT_SELECT_SCROLL_STRATEGY", "InjectionToken", "injector", "inject", "Injector", "createRepositionScrollStrategy", "MAT_SELECT_SCROLL_STRATEGY_PROVIDER_FACTORY", "_overlay", "MAT_SELECT_CONFIG", "MAT_SELECT_SCROLL_STRATEGY_PROVIDER", "MAT_SELECT_TRIGGER", "MatSelectChange", "source", "value", "MatSelect", "ViewportRuler", "ChangeDetectorRef", "ElementRef", "Directionality", "_IdGenerator", "Renderer2", "MAT_FORM_FIELD", "NgControl", "LiveAnnouncer", "_animationsDisabled", "Subject", "index", "option", "panel", "labelCount", "_countGroupLabelsBeforeOption", "element", "_getOptionScrollPosition", "o1", "o2", "signal", "Validators", "fn", "newValue", "defer", "options", "startWith", "switchMap", "merge", "EventEmitter", "filter", "o", "map", "defaultErrorStateMatcher", "ErrorStateMatcher", "parentForm", "NgForm", "parentFormGroup", "FormGroupDirective", "tabIndex", "HostAttributeToken", "_ErrorStateTracker", "SelectionModel", "takeUntil", "event", "newAriaLabelledby", "ngControl", "changes", "take", "modal", "panelId", "removeAriaReferencedId", "addAriaReferencedId", "cleanupEvent", "exitFallbackTimer", "isDisabled", "selectedOptions", "keyCode", "isArrowKey", "DOWN_ARROW", "UP_ARROW", "LEFT_ARROW", "RIGHT_ARROW", "isOpenKey", "ENTER", "SPACE", "manager", "hasModifierKey", "previouslySelectedOption", "selectedOption", "isTyping", "A", "hasDeselectedOptions", "opt", "previouslyFocusedIndex", "ESCAPE", "currentValue", "correspondingOption", "preferredOrigin", "CdkOverlayOrigin", "ActiveDescendantKeyManager", "changedOrDestroyed", "isUserInput", "wasSelected", "a", "b", "fallbackValue", "valueToEmit", "firstEnabledOptionIndex", "labelId", "labelExpression", "ids", "__ngFactoryType__", "rf", "ctx", "dirIndex", "MatOption", "MAT_OPTGROUP", "_t", "_c0", "_c1", "CdkConnectedOverlay", "$event", "booleanAttribute", "numberAttribute", "MatFormFieldControl", "MAT_OPTION_PARENT_COMPONENT", "_c3", "_r1", "_c2", "MatSelect_Conditional_4_Template", "MatSelect_Conditional_5_Template", "MatSelect_ng_template_10_Template", "fallbackOverlayOrigin_r4", "NgClass", "MatSelectTrigger", "MatSelectModule", "OverlayModule", "MatOptionModule", "MatCommonModule", "CdkScrollableModule", "MatFormFieldModule"]
}
