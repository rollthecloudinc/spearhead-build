{
  "version": 3,
  "sources": ["../../@aws-sdk/eventstream-codec/node_modules/@aws-crypto/crc32/build/aws_crc32.js", "../../@aws-sdk/eventstream-codec/node_modules/@aws-crypto/crc32/build/index.js", "../../@aws-sdk/eventstream-codec/dist-es/EventStreamCodec.js", "../../@aws-sdk/util-hex-encoding/dist-es/index.js", "../../@aws-sdk/eventstream-codec/dist-es/Int64.js", "../../@aws-sdk/eventstream-codec/dist-es/HeaderMarshaller.js", "../../@aws-sdk/eventstream-codec/dist-es/splitMessage.js", "../../@aws-sdk/util-middleware/dist-es/normalizeProvider.js", "../../@aws-sdk/util-utf8/dist-es/fromUtf8.browser.js", "../../@aws-sdk/util-utf8/dist-es/toUint8Array.js", "../../@aws-sdk/util-utf8/dist-es/toUtf8.browser.js", "../../@aws-sdk/signature-v4/dist-es/constants.js", "../../@aws-sdk/signature-v4/dist-es/credentialDerivation.js", "../../@aws-sdk/signature-v4/dist-es/getCanonicalHeaders.js", "../../@aws-sdk/signature-v4/dist-es/getCanonicalQuery.js", "../../@aws-sdk/is-array-buffer/dist-es/index.js", "../../@aws-sdk/signature-v4/dist-es/getPayloadHash.js", "../../@aws-sdk/signature-v4/dist-es/headerUtil.js", "../../@aws-sdk/signature-v4/dist-es/cloneRequest.js", "../../@aws-sdk/signature-v4/dist-es/moveHeadersToQuery.js", "../../@aws-sdk/signature-v4/dist-es/prepareRequest.js", "../../@aws-sdk/signature-v4/dist-es/utilDate.js", "../../@aws-sdk/signature-v4/dist-es/SignatureV4.js"],
  "sourcesContent": ["\"use strict\";\n\n// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AwsCrc32 = void 0;\nvar tslib_1 = require(\"tslib\");\nvar util_1 = require(\"@aws-crypto/util\");\nvar index_1 = require(\"./index\");\nvar AwsCrc32 = /** @class */function () {\n  function AwsCrc32() {\n    this.crc32 = new index_1.Crc32();\n  }\n  AwsCrc32.prototype.update = function (toHash) {\n    if ((0, util_1.isEmptyData)(toHash)) return;\n    this.crc32.update((0, util_1.convertToBuffer)(toHash));\n  };\n  AwsCrc32.prototype.digest = function () {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      return tslib_1.__generator(this, function (_a) {\n        return [2 /*return*/, (0, util_1.numToUint8)(this.crc32.digest())];\n      });\n    });\n  };\n  AwsCrc32.prototype.reset = function () {\n    this.crc32 = new index_1.Crc32();\n  };\n  return AwsCrc32;\n}();\nexports.AwsCrc32 = AwsCrc32;\n", "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AwsCrc32 = exports.Crc32 = exports.crc32 = void 0;\nvar tslib_1 = require(\"tslib\");\nvar util_1 = require(\"@aws-crypto/util\");\nfunction crc32(data) {\n  return new Crc32().update(data).digest();\n}\nexports.crc32 = crc32;\nvar Crc32 = /** @class */function () {\n  function Crc32() {\n    this.checksum = 0xffffffff;\n  }\n  Crc32.prototype.update = function (data) {\n    var e_1, _a;\n    try {\n      for (var data_1 = tslib_1.__values(data), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {\n        var byte = data_1_1.value;\n        this.checksum = this.checksum >>> 8 ^ lookupTable[(this.checksum ^ byte) & 0xff];\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (data_1_1 && !data_1_1.done && (_a = data_1.return)) _a.call(data_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n    return this;\n  };\n  Crc32.prototype.digest = function () {\n    return (this.checksum ^ 0xffffffff) >>> 0;\n  };\n  return Crc32;\n}();\nexports.Crc32 = Crc32;\n// prettier-ignore\nvar a_lookUpTable = [0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7, 0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59, 0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433, 0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65, 0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F, 0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1, 0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B, 0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236, 0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D, 0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777, 0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45, 0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9, 0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D];\nvar lookupTable = (0, util_1.uint32ArrayFrom)(a_lookUpTable);\nvar aws_crc32_1 = require(\"./aws_crc32\");\nObject.defineProperty(exports, \"AwsCrc32\", {\n  enumerable: true,\n  get: function () {\n    return aws_crc32_1.AwsCrc32;\n  }\n});\n", "import { Crc32 } from \"@aws-crypto/crc32\";\nimport { HeaderMarshaller } from \"./HeaderMarshaller\";\nimport { splitMessage } from \"./splitMessage\";\nexport class EventStreamCodec {\n  constructor(toUtf8, fromUtf8) {\n    this.headerMarshaller = new HeaderMarshaller(toUtf8, fromUtf8);\n    this.messageBuffer = [];\n    this.isEndOfStream = false;\n  }\n  feed(message) {\n    this.messageBuffer.push(this.decode(message));\n  }\n  endOfStream() {\n    this.isEndOfStream = true;\n  }\n  getMessage() {\n    const message = this.messageBuffer.pop();\n    const isEndOfStream = this.isEndOfStream;\n    return {\n      getMessage() {\n        return message;\n      },\n      isEndOfStream() {\n        return isEndOfStream;\n      }\n    };\n  }\n  getAvailableMessages() {\n    const messages = this.messageBuffer;\n    this.messageBuffer = [];\n    const isEndOfStream = this.isEndOfStream;\n    return {\n      getMessages() {\n        return messages;\n      },\n      isEndOfStream() {\n        return isEndOfStream;\n      }\n    };\n  }\n  encode({\n    headers: rawHeaders,\n    body\n  }) {\n    const headers = this.headerMarshaller.format(rawHeaders);\n    const length = headers.byteLength + body.byteLength + 16;\n    const out = new Uint8Array(length);\n    const view = new DataView(out.buffer, out.byteOffset, out.byteLength);\n    const checksum = new Crc32();\n    view.setUint32(0, length, false);\n    view.setUint32(4, headers.byteLength, false);\n    view.setUint32(8, checksum.update(out.subarray(0, 8)).digest(), false);\n    out.set(headers, 12);\n    out.set(body, headers.byteLength + 12);\n    view.setUint32(length - 4, checksum.update(out.subarray(8, length - 4)).digest(), false);\n    return out;\n  }\n  decode(message) {\n    const {\n      headers,\n      body\n    } = splitMessage(message);\n    return {\n      headers: this.headerMarshaller.parse(headers),\n      body\n    };\n  }\n  formatHeaders(rawHeaders) {\n    return this.headerMarshaller.format(rawHeaders);\n  }\n}", "const SHORT_TO_HEX = {};\nconst HEX_TO_SHORT = {};\nfor (let i = 0; i < 256; i++) {\n  let encodedByte = i.toString(16).toLowerCase();\n  if (encodedByte.length === 1) {\n    encodedByte = `0${encodedByte}`;\n  }\n  SHORT_TO_HEX[i] = encodedByte;\n  HEX_TO_SHORT[encodedByte] = i;\n}\nexport function fromHex(encoded) {\n  if (encoded.length % 2 !== 0) {\n    throw new Error(\"Hex encoded strings must have an even number length\");\n  }\n  const out = new Uint8Array(encoded.length / 2);\n  for (let i = 0; i < encoded.length; i += 2) {\n    const encodedByte = encoded.slice(i, i + 2).toLowerCase();\n    if (encodedByte in HEX_TO_SHORT) {\n      out[i / 2] = HEX_TO_SHORT[encodedByte];\n    } else {\n      throw new Error(`Cannot decode unrecognized sequence ${encodedByte} as hexadecimal`);\n    }\n  }\n  return out;\n}\nexport function toHex(bytes) {\n  let out = \"\";\n  for (let i = 0; i < bytes.byteLength; i++) {\n    out += SHORT_TO_HEX[bytes[i]];\n  }\n  return out;\n}", "import { toHex } from \"@aws-sdk/util-hex-encoding\";\nexport class Int64 {\n  constructor(bytes) {\n    this.bytes = bytes;\n    if (bytes.byteLength !== 8) {\n      throw new Error(\"Int64 buffers must be exactly 8 bytes\");\n    }\n  }\n  static fromNumber(number) {\n    if (number > 9223372036854776000 || number < -9223372036854776000) {\n      throw new Error(`${number} is too large (or, if negative, too small) to represent as an Int64`);\n    }\n    const bytes = new Uint8Array(8);\n    for (let i = 7, remaining = Math.abs(Math.round(number)); i > -1 && remaining > 0; i--, remaining /= 256) {\n      bytes[i] = remaining;\n    }\n    if (number < 0) {\n      negate(bytes);\n    }\n    return new Int64(bytes);\n  }\n  valueOf() {\n    const bytes = this.bytes.slice(0);\n    const negative = bytes[0] & 0b10000000;\n    if (negative) {\n      negate(bytes);\n    }\n    return parseInt(toHex(bytes), 16) * (negative ? -1 : 1);\n  }\n  toString() {\n    return String(this.valueOf());\n  }\n}\nfunction negate(bytes) {\n  for (let i = 0; i < 8; i++) {\n    bytes[i] ^= 0xff;\n  }\n  for (let i = 7; i > -1; i--) {\n    bytes[i]++;\n    if (bytes[i] !== 0) break;\n  }\n}", "import { fromHex, toHex } from \"@aws-sdk/util-hex-encoding\";\nimport { Int64 } from \"./Int64\";\nexport class HeaderMarshaller {\n  constructor(toUtf8, fromUtf8) {\n    this.toUtf8 = toUtf8;\n    this.fromUtf8 = fromUtf8;\n  }\n  format(headers) {\n    const chunks = [];\n    for (const headerName of Object.keys(headers)) {\n      const bytes = this.fromUtf8(headerName);\n      chunks.push(Uint8Array.from([bytes.byteLength]), bytes, this.formatHeaderValue(headers[headerName]));\n    }\n    const out = new Uint8Array(chunks.reduce((carry, bytes) => carry + bytes.byteLength, 0));\n    let position = 0;\n    for (const chunk of chunks) {\n      out.set(chunk, position);\n      position += chunk.byteLength;\n    }\n    return out;\n  }\n  formatHeaderValue(header) {\n    switch (header.type) {\n      case \"boolean\":\n        return Uint8Array.from([header.value ? 0 : 1]);\n      case \"byte\":\n        return Uint8Array.from([2, header.value]);\n      case \"short\":\n        const shortView = new DataView(new ArrayBuffer(3));\n        shortView.setUint8(0, 3);\n        shortView.setInt16(1, header.value, false);\n        return new Uint8Array(shortView.buffer);\n      case \"integer\":\n        const intView = new DataView(new ArrayBuffer(5));\n        intView.setUint8(0, 4);\n        intView.setInt32(1, header.value, false);\n        return new Uint8Array(intView.buffer);\n      case \"long\":\n        const longBytes = new Uint8Array(9);\n        longBytes[0] = 5;\n        longBytes.set(header.value.bytes, 1);\n        return longBytes;\n      case \"binary\":\n        const binView = new DataView(new ArrayBuffer(3 + header.value.byteLength));\n        binView.setUint8(0, 6);\n        binView.setUint16(1, header.value.byteLength, false);\n        const binBytes = new Uint8Array(binView.buffer);\n        binBytes.set(header.value, 3);\n        return binBytes;\n      case \"string\":\n        const utf8Bytes = this.fromUtf8(header.value);\n        const strView = new DataView(new ArrayBuffer(3 + utf8Bytes.byteLength));\n        strView.setUint8(0, 7);\n        strView.setUint16(1, utf8Bytes.byteLength, false);\n        const strBytes = new Uint8Array(strView.buffer);\n        strBytes.set(utf8Bytes, 3);\n        return strBytes;\n      case \"timestamp\":\n        const tsBytes = new Uint8Array(9);\n        tsBytes[0] = 8;\n        tsBytes.set(Int64.fromNumber(header.value.valueOf()).bytes, 1);\n        return tsBytes;\n      case \"uuid\":\n        if (!UUID_PATTERN.test(header.value)) {\n          throw new Error(`Invalid UUID received: ${header.value}`);\n        }\n        const uuidBytes = new Uint8Array(17);\n        uuidBytes[0] = 9;\n        uuidBytes.set(fromHex(header.value.replace(/\\-/g, \"\")), 1);\n        return uuidBytes;\n    }\n  }\n  parse(headers) {\n    const out = {};\n    let position = 0;\n    while (position < headers.byteLength) {\n      const nameLength = headers.getUint8(position++);\n      const name = this.toUtf8(new Uint8Array(headers.buffer, headers.byteOffset + position, nameLength));\n      position += nameLength;\n      switch (headers.getUint8(position++)) {\n        case 0:\n          out[name] = {\n            type: BOOLEAN_TAG,\n            value: true\n          };\n          break;\n        case 1:\n          out[name] = {\n            type: BOOLEAN_TAG,\n            value: false\n          };\n          break;\n        case 2:\n          out[name] = {\n            type: BYTE_TAG,\n            value: headers.getInt8(position++)\n          };\n          break;\n        case 3:\n          out[name] = {\n            type: SHORT_TAG,\n            value: headers.getInt16(position, false)\n          };\n          position += 2;\n          break;\n        case 4:\n          out[name] = {\n            type: INT_TAG,\n            value: headers.getInt32(position, false)\n          };\n          position += 4;\n          break;\n        case 5:\n          out[name] = {\n            type: LONG_TAG,\n            value: new Int64(new Uint8Array(headers.buffer, headers.byteOffset + position, 8))\n          };\n          position += 8;\n          break;\n        case 6:\n          const binaryLength = headers.getUint16(position, false);\n          position += 2;\n          out[name] = {\n            type: BINARY_TAG,\n            value: new Uint8Array(headers.buffer, headers.byteOffset + position, binaryLength)\n          };\n          position += binaryLength;\n          break;\n        case 7:\n          const stringLength = headers.getUint16(position, false);\n          position += 2;\n          out[name] = {\n            type: STRING_TAG,\n            value: this.toUtf8(new Uint8Array(headers.buffer, headers.byteOffset + position, stringLength))\n          };\n          position += stringLength;\n          break;\n        case 8:\n          out[name] = {\n            type: TIMESTAMP_TAG,\n            value: new Date(new Int64(new Uint8Array(headers.buffer, headers.byteOffset + position, 8)).valueOf())\n          };\n          position += 8;\n          break;\n        case 9:\n          const uuidBytes = new Uint8Array(headers.buffer, headers.byteOffset + position, 16);\n          position += 16;\n          out[name] = {\n            type: UUID_TAG,\n            value: `${toHex(uuidBytes.subarray(0, 4))}-${toHex(uuidBytes.subarray(4, 6))}-${toHex(uuidBytes.subarray(6, 8))}-${toHex(uuidBytes.subarray(8, 10))}-${toHex(uuidBytes.subarray(10))}`\n          };\n          break;\n        default:\n          throw new Error(`Unrecognized header type tag`);\n      }\n    }\n    return out;\n  }\n}\nvar HEADER_VALUE_TYPE = /*#__PURE__*/function (HEADER_VALUE_TYPE) {\n  HEADER_VALUE_TYPE[HEADER_VALUE_TYPE[\"boolTrue\"] = 0] = \"boolTrue\";\n  HEADER_VALUE_TYPE[HEADER_VALUE_TYPE[\"boolFalse\"] = 1] = \"boolFalse\";\n  HEADER_VALUE_TYPE[HEADER_VALUE_TYPE[\"byte\"] = 2] = \"byte\";\n  HEADER_VALUE_TYPE[HEADER_VALUE_TYPE[\"short\"] = 3] = \"short\";\n  HEADER_VALUE_TYPE[HEADER_VALUE_TYPE[\"integer\"] = 4] = \"integer\";\n  HEADER_VALUE_TYPE[HEADER_VALUE_TYPE[\"long\"] = 5] = \"long\";\n  HEADER_VALUE_TYPE[HEADER_VALUE_TYPE[\"byteArray\"] = 6] = \"byteArray\";\n  HEADER_VALUE_TYPE[HEADER_VALUE_TYPE[\"string\"] = 7] = \"string\";\n  HEADER_VALUE_TYPE[HEADER_VALUE_TYPE[\"timestamp\"] = 8] = \"timestamp\";\n  HEADER_VALUE_TYPE[HEADER_VALUE_TYPE[\"uuid\"] = 9] = \"uuid\";\n  return HEADER_VALUE_TYPE;\n}(HEADER_VALUE_TYPE || {});\nconst BOOLEAN_TAG = \"boolean\";\nconst BYTE_TAG = \"byte\";\nconst SHORT_TAG = \"short\";\nconst INT_TAG = \"integer\";\nconst LONG_TAG = \"long\";\nconst BINARY_TAG = \"binary\";\nconst STRING_TAG = \"string\";\nconst TIMESTAMP_TAG = \"timestamp\";\nconst UUID_TAG = \"uuid\";\nconst UUID_PATTERN = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;", "import { Crc32 } from \"@aws-crypto/crc32\";\nconst PRELUDE_MEMBER_LENGTH = 4;\nconst PRELUDE_LENGTH = PRELUDE_MEMBER_LENGTH * 2;\nconst CHECKSUM_LENGTH = 4;\nconst MINIMUM_MESSAGE_LENGTH = PRELUDE_LENGTH + CHECKSUM_LENGTH * 2;\nexport function splitMessage({\n  byteLength,\n  byteOffset,\n  buffer\n}) {\n  if (byteLength < MINIMUM_MESSAGE_LENGTH) {\n    throw new Error(\"Provided message too short to accommodate event stream message overhead\");\n  }\n  const view = new DataView(buffer, byteOffset, byteLength);\n  const messageLength = view.getUint32(0, false);\n  if (byteLength !== messageLength) {\n    throw new Error(\"Reported message length does not match received message length\");\n  }\n  const headerLength = view.getUint32(PRELUDE_MEMBER_LENGTH, false);\n  const expectedPreludeChecksum = view.getUint32(PRELUDE_LENGTH, false);\n  const expectedMessageChecksum = view.getUint32(byteLength - CHECKSUM_LENGTH, false);\n  const checksummer = new Crc32().update(new Uint8Array(buffer, byteOffset, PRELUDE_LENGTH));\n  if (expectedPreludeChecksum !== checksummer.digest()) {\n    throw new Error(`The prelude checksum specified in the message (${expectedPreludeChecksum}) does not match the calculated CRC32 checksum (${checksummer.digest()})`);\n  }\n  checksummer.update(new Uint8Array(buffer, byteOffset + PRELUDE_LENGTH, byteLength - (PRELUDE_LENGTH + CHECKSUM_LENGTH)));\n  if (expectedMessageChecksum !== checksummer.digest()) {\n    throw new Error(`The message checksum (${checksummer.digest()}) did not match the expected value of ${expectedMessageChecksum}`);\n  }\n  return {\n    headers: new DataView(buffer, byteOffset + PRELUDE_LENGTH + CHECKSUM_LENGTH, headerLength),\n    body: new Uint8Array(buffer, byteOffset + PRELUDE_LENGTH + CHECKSUM_LENGTH + headerLength, messageLength - headerLength - (PRELUDE_LENGTH + CHECKSUM_LENGTH + CHECKSUM_LENGTH))\n  };\n}", "export const normalizeProvider = input => {\n  if (typeof input === \"function\") return input;\n  const promisified = Promise.resolve(input);\n  return () => promisified;\n};", "export const fromUtf8 = input => new TextEncoder().encode(input);", "import { fromUtf8 } from \"./fromUtf8\";\nexport const toUint8Array = data => {\n  if (typeof data === \"string\") {\n    return fromUtf8(data);\n  }\n  if (ArrayBuffer.isView(data)) {\n    return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);\n  }\n  return new Uint8Array(data);\n};", "export const toUtf8 = input => new TextDecoder(\"utf-8\").decode(input);", "export const ALGORITHM_QUERY_PARAM = \"X-Amz-Algorithm\";\nexport const CREDENTIAL_QUERY_PARAM = \"X-Amz-Credential\";\nexport const AMZ_DATE_QUERY_PARAM = \"X-Amz-Date\";\nexport const SIGNED_HEADERS_QUERY_PARAM = \"X-Amz-SignedHeaders\";\nexport const EXPIRES_QUERY_PARAM = \"X-Amz-Expires\";\nexport const SIGNATURE_QUERY_PARAM = \"X-Amz-Signature\";\nexport const TOKEN_QUERY_PARAM = \"X-Amz-Security-Token\";\nexport const REGION_SET_PARAM = \"X-Amz-Region-Set\";\nexport const AUTH_HEADER = \"authorization\";\nexport const AMZ_DATE_HEADER = AMZ_DATE_QUERY_PARAM.toLowerCase();\nexport const DATE_HEADER = \"date\";\nexport const GENERATED_HEADERS = [AUTH_HEADER, AMZ_DATE_HEADER, DATE_HEADER];\nexport const SIGNATURE_HEADER = SIGNATURE_QUERY_PARAM.toLowerCase();\nexport const SHA256_HEADER = \"x-amz-content-sha256\";\nexport const TOKEN_HEADER = TOKEN_QUERY_PARAM.toLowerCase();\nexport const HOST_HEADER = \"host\";\nexport const ALWAYS_UNSIGNABLE_HEADERS = {\n  authorization: true,\n  \"cache-control\": true,\n  connection: true,\n  expect: true,\n  from: true,\n  \"keep-alive\": true,\n  \"max-forwards\": true,\n  pragma: true,\n  referer: true,\n  te: true,\n  trailer: true,\n  \"transfer-encoding\": true,\n  upgrade: true,\n  \"user-agent\": true,\n  \"x-amzn-trace-id\": true\n};\nexport const PROXY_HEADER_PATTERN = /^proxy-/;\nexport const SEC_HEADER_PATTERN = /^sec-/;\nexport const UNSIGNABLE_PATTERNS = [/^proxy-/i, /^sec-/i];\nexport const ALGORITHM_IDENTIFIER = \"AWS4-HMAC-SHA256\";\nexport const ALGORITHM_IDENTIFIER_V4A = \"AWS4-ECDSA-P256-SHA256\";\nexport const EVENT_ALGORITHM_IDENTIFIER = \"AWS4-HMAC-SHA256-PAYLOAD\";\nexport const UNSIGNED_PAYLOAD = \"UNSIGNED-PAYLOAD\";\nexport const MAX_CACHE_SIZE = 50;\nexport const KEY_TYPE_IDENTIFIER = \"aws4_request\";\nexport const MAX_PRESIGNED_TTL = 60 * 60 * 24 * 7;", "import { toHex } from \"@aws-sdk/util-hex-encoding\";\nimport { toUint8Array } from \"@aws-sdk/util-utf8\";\nimport { KEY_TYPE_IDENTIFIER, MAX_CACHE_SIZE } from \"./constants\";\nconst signingKeyCache = {};\nconst cacheQueue = [];\nexport const createScope = (shortDate, region, service) => `${shortDate}/${region}/${service}/${KEY_TYPE_IDENTIFIER}`;\nexport const getSigningKey = async (sha256Constructor, credentials, shortDate, region, service) => {\n  const credsHash = await hmac(sha256Constructor, credentials.secretAccessKey, credentials.accessKeyId);\n  const cacheKey = `${shortDate}:${region}:${service}:${toHex(credsHash)}:${credentials.sessionToken}`;\n  if (cacheKey in signingKeyCache) {\n    return signingKeyCache[cacheKey];\n  }\n  cacheQueue.push(cacheKey);\n  while (cacheQueue.length > MAX_CACHE_SIZE) {\n    delete signingKeyCache[cacheQueue.shift()];\n  }\n  let key = `AWS4${credentials.secretAccessKey}`;\n  for (const signable of [shortDate, region, service, KEY_TYPE_IDENTIFIER]) {\n    key = await hmac(sha256Constructor, key, signable);\n  }\n  return signingKeyCache[cacheKey] = key;\n};\nexport const clearCredentialCache = () => {\n  cacheQueue.length = 0;\n  Object.keys(signingKeyCache).forEach(cacheKey => {\n    delete signingKeyCache[cacheKey];\n  });\n};\nconst hmac = (ctor, secret, data) => {\n  const hash = new ctor(secret);\n  hash.update(toUint8Array(data));\n  return hash.digest();\n};", "import { ALWAYS_UNSIGNABLE_HEADERS, PROXY_HEADER_PATTERN, SEC_HEADER_PATTERN } from \"./constants\";\nexport const getCanonicalHeaders = ({\n  headers\n}, unsignableHeaders, signableHeaders) => {\n  const canonical = {};\n  for (const headerName of Object.keys(headers).sort()) {\n    if (headers[headerName] == undefined) {\n      continue;\n    }\n    const canonicalHeaderName = headerName.toLowerCase();\n    if (canonicalHeaderName in ALWAYS_UNSIGNABLE_HEADERS || unsignableHeaders?.has(canonicalHeaderName) || PROXY_HEADER_PATTERN.test(canonicalHeaderName) || SEC_HEADER_PATTERN.test(canonicalHeaderName)) {\n      if (!signableHeaders || signableHeaders && !signableHeaders.has(canonicalHeaderName)) {\n        continue;\n      }\n    }\n    canonical[canonicalHeaderName] = headers[headerName].trim().replace(/\\s+/g, \" \");\n  }\n  return canonical;\n};", "import { escapeUri } from \"@aws-sdk/util-uri-escape\";\nimport { SIGNATURE_HEADER } from \"./constants\";\nexport const getCanonicalQuery = ({\n  query = {}\n}) => {\n  const keys = [];\n  const serialized = {};\n  for (const key of Object.keys(query).sort()) {\n    if (key.toLowerCase() === SIGNATURE_HEADER) {\n      continue;\n    }\n    keys.push(key);\n    const value = query[key];\n    if (typeof value === \"string\") {\n      serialized[key] = `${escapeUri(key)}=${escapeUri(value)}`;\n    } else if (Array.isArray(value)) {\n      serialized[key] = value.slice(0).sort().reduce((encoded, value) => encoded.concat([`${escapeUri(key)}=${escapeUri(value)}`]), []).join(\"&\");\n    }\n  }\n  return keys.map(key => serialized[key]).filter(serialized => serialized).join(\"&\");\n};", "export const isArrayBuffer = arg => typeof ArrayBuffer === \"function\" && arg instanceof ArrayBuffer || Object.prototype.toString.call(arg) === \"[object ArrayBuffer]\";", "import { isArrayBuffer } from \"@aws-sdk/is-array-buffer\";\nimport { toHex } from \"@aws-sdk/util-hex-encoding\";\nimport { toUint8Array } from \"@aws-sdk/util-utf8\";\nimport { SHA256_HEADER, UNSIGNED_PAYLOAD } from \"./constants\";\nexport const getPayloadHash = async ({\n  headers,\n  body\n}, hashConstructor) => {\n  for (const headerName of Object.keys(headers)) {\n    if (headerName.toLowerCase() === SHA256_HEADER) {\n      return headers[headerName];\n    }\n  }\n  if (body == undefined) {\n    return \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\";\n  } else if (typeof body === \"string\" || ArrayBuffer.isView(body) || isArrayBuffer(body)) {\n    const hashCtor = new hashConstructor();\n    hashCtor.update(toUint8Array(body));\n    return toHex(await hashCtor.digest());\n  }\n  return UNSIGNED_PAYLOAD;\n};", "export const hasHeader = (soughtHeader, headers) => {\n  soughtHeader = soughtHeader.toLowerCase();\n  for (const headerName of Object.keys(headers)) {\n    if (soughtHeader === headerName.toLowerCase()) {\n      return true;\n    }\n  }\n  return false;\n};\nexport const getHeaderValue = (soughtHeader, headers) => {\n  soughtHeader = soughtHeader.toLowerCase();\n  for (const headerName of Object.keys(headers)) {\n    if (soughtHeader === headerName.toLowerCase()) {\n      return headers[headerName];\n    }\n  }\n  return undefined;\n};\nexport const deleteHeader = (soughtHeader, headers) => {\n  soughtHeader = soughtHeader.toLowerCase();\n  for (const headerName of Object.keys(headers)) {\n    if (soughtHeader === headerName.toLowerCase()) {\n      delete headers[headerName];\n    }\n  }\n};", "export const cloneRequest = ({\n  headers,\n  query,\n  ...rest\n}) => ({\n  ...rest,\n  headers: {\n    ...headers\n  },\n  query: query ? cloneQuery(query) : undefined\n});\nexport const cloneQuery = query => Object.keys(query).reduce((carry, paramName) => {\n  const param = query[paramName];\n  return {\n    ...carry,\n    [paramName]: Array.isArray(param) ? [...param] : param\n  };\n}, {});", "import { cloneRequest } from \"./cloneRequest\";\nexport const moveHeadersToQuery = (request, options = {}) => {\n  const {\n    headers,\n    query = {}\n  } = typeof request.clone === \"function\" ? request.clone() : cloneRequest(request);\n  for (const name of Object.keys(headers)) {\n    const lname = name.toLowerCase();\n    if (lname.slice(0, 6) === \"x-amz-\" && !options.unhoistableHeaders?.has(lname)) {\n      query[name] = headers[name];\n      delete headers[name];\n    }\n  }\n  return {\n    ...request,\n    headers,\n    query\n  };\n};", "import { cloneRequest } from \"./cloneRequest\";\nimport { GENERATED_HEADERS } from \"./constants\";\nexport const prepareRequest = request => {\n  request = typeof request.clone === \"function\" ? request.clone() : cloneRequest(request);\n  for (const headerName of Object.keys(request.headers)) {\n    if (GENERATED_HEADERS.indexOf(headerName.toLowerCase()) > -1) {\n      delete request.headers[headerName];\n    }\n  }\n  return request;\n};", "export const iso8601 = time => toDate(time).toISOString().replace(/\\.\\d{3}Z$/, \"Z\");\nexport const toDate = time => {\n  if (typeof time === \"number\") {\n    return new Date(time * 1000);\n  }\n  if (typeof time === \"string\") {\n    if (Number(time)) {\n      return new Date(Number(time) * 1000);\n    }\n    return new Date(time);\n  }\n  return time;\n};", "import { HeaderMarshaller } from \"@aws-sdk/eventstream-codec\";\nimport { toHex } from \"@aws-sdk/util-hex-encoding\";\nimport { normalizeProvider } from \"@aws-sdk/util-middleware\";\nimport { fromUtf8, toUint8Array, toUtf8 } from \"@aws-sdk/util-utf8\";\nimport { ALGORITHM_IDENTIFIER, ALGORITHM_QUERY_PARAM, AMZ_DATE_HEADER, AMZ_DATE_QUERY_PARAM, AUTH_HEADER, CREDENTIAL_QUERY_PARAM, EVENT_ALGORITHM_IDENTIFIER, EXPIRES_QUERY_PARAM, MAX_PRESIGNED_TTL, SHA256_HEADER, SIGNATURE_QUERY_PARAM, SIGNED_HEADERS_QUERY_PARAM, TOKEN_HEADER, TOKEN_QUERY_PARAM } from \"./constants\";\nimport { createScope, getSigningKey } from \"./credentialDerivation\";\nimport { getCanonicalHeaders } from \"./getCanonicalHeaders\";\nimport { getCanonicalQuery } from \"./getCanonicalQuery\";\nimport { getPayloadHash } from \"./getPayloadHash\";\nimport { hasHeader } from \"./headerUtil\";\nimport { moveHeadersToQuery } from \"./moveHeadersToQuery\";\nimport { prepareRequest } from \"./prepareRequest\";\nimport { iso8601 } from \"./utilDate\";\nexport class SignatureV4 {\n  constructor({\n    applyChecksum,\n    credentials,\n    region,\n    service,\n    sha256,\n    uriEscapePath = true\n  }) {\n    this.headerMarshaller = new HeaderMarshaller(toUtf8, fromUtf8);\n    this.service = service;\n    this.sha256 = sha256;\n    this.uriEscapePath = uriEscapePath;\n    this.applyChecksum = typeof applyChecksum === \"boolean\" ? applyChecksum : true;\n    this.regionProvider = normalizeProvider(region);\n    this.credentialProvider = normalizeProvider(credentials);\n  }\n  async presign(originalRequest, options = {}) {\n    const {\n      signingDate = new Date(),\n      expiresIn = 3600,\n      unsignableHeaders,\n      unhoistableHeaders,\n      signableHeaders,\n      signingRegion,\n      signingService\n    } = options;\n    const credentials = await this.credentialProvider();\n    this.validateResolvedCredentials(credentials);\n    const region = signingRegion ?? (await this.regionProvider());\n    const {\n      longDate,\n      shortDate\n    } = formatDate(signingDate);\n    if (expiresIn > MAX_PRESIGNED_TTL) {\n      return Promise.reject(\"Signature version 4 presigned URLs\" + \" must have an expiration date less than one week in\" + \" the future\");\n    }\n    const scope = createScope(shortDate, region, signingService ?? this.service);\n    const request = moveHeadersToQuery(prepareRequest(originalRequest), {\n      unhoistableHeaders\n    });\n    if (credentials.sessionToken) {\n      request.query[TOKEN_QUERY_PARAM] = credentials.sessionToken;\n    }\n    request.query[ALGORITHM_QUERY_PARAM] = ALGORITHM_IDENTIFIER;\n    request.query[CREDENTIAL_QUERY_PARAM] = `${credentials.accessKeyId}/${scope}`;\n    request.query[AMZ_DATE_QUERY_PARAM] = longDate;\n    request.query[EXPIRES_QUERY_PARAM] = expiresIn.toString(10);\n    const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);\n    request.query[SIGNED_HEADERS_QUERY_PARAM] = getCanonicalHeaderList(canonicalHeaders);\n    request.query[SIGNATURE_QUERY_PARAM] = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, await getPayloadHash(originalRequest, this.sha256)));\n    return request;\n  }\n  async sign(toSign, options) {\n    if (typeof toSign === \"string\") {\n      return this.signString(toSign, options);\n    } else if (toSign.headers && toSign.payload) {\n      return this.signEvent(toSign, options);\n    } else if (toSign.message) {\n      return this.signMessage(toSign, options);\n    } else {\n      return this.signRequest(toSign, options);\n    }\n  }\n  async signEvent({\n    headers,\n    payload\n  }, {\n    signingDate = new Date(),\n    priorSignature,\n    signingRegion,\n    signingService\n  }) {\n    const region = signingRegion ?? (await this.regionProvider());\n    const {\n      shortDate,\n      longDate\n    } = formatDate(signingDate);\n    const scope = createScope(shortDate, region, signingService ?? this.service);\n    const hashedPayload = await getPayloadHash({\n      headers: {},\n      body: payload\n    }, this.sha256);\n    const hash = new this.sha256();\n    hash.update(headers);\n    const hashedHeaders = toHex(await hash.digest());\n    const stringToSign = [EVENT_ALGORITHM_IDENTIFIER, longDate, scope, priorSignature, hashedHeaders, hashedPayload].join(\"\\n\");\n    return this.signString(stringToSign, {\n      signingDate,\n      signingRegion: region,\n      signingService\n    });\n  }\n  async signMessage(signableMessage, {\n    signingDate = new Date(),\n    signingRegion,\n    signingService\n  }) {\n    const promise = this.signEvent({\n      headers: this.headerMarshaller.format(signableMessage.message.headers),\n      payload: signableMessage.message.body\n    }, {\n      signingDate,\n      signingRegion,\n      signingService,\n      priorSignature: signableMessage.priorSignature\n    });\n    return promise.then(signature => {\n      return {\n        message: signableMessage.message,\n        signature\n      };\n    });\n  }\n  async signString(stringToSign, {\n    signingDate = new Date(),\n    signingRegion,\n    signingService\n  } = {}) {\n    const credentials = await this.credentialProvider();\n    this.validateResolvedCredentials(credentials);\n    const region = signingRegion ?? (await this.regionProvider());\n    const {\n      shortDate\n    } = formatDate(signingDate);\n    const hash = new this.sha256(await this.getSigningKey(credentials, region, shortDate, signingService));\n    hash.update(toUint8Array(stringToSign));\n    return toHex(await hash.digest());\n  }\n  async signRequest(requestToSign, {\n    signingDate = new Date(),\n    signableHeaders,\n    unsignableHeaders,\n    signingRegion,\n    signingService\n  } = {}) {\n    const credentials = await this.credentialProvider();\n    this.validateResolvedCredentials(credentials);\n    const region = signingRegion ?? (await this.regionProvider());\n    const request = prepareRequest(requestToSign);\n    const {\n      longDate,\n      shortDate\n    } = formatDate(signingDate);\n    const scope = createScope(shortDate, region, signingService ?? this.service);\n    request.headers[AMZ_DATE_HEADER] = longDate;\n    if (credentials.sessionToken) {\n      request.headers[TOKEN_HEADER] = credentials.sessionToken;\n    }\n    const payloadHash = await getPayloadHash(request, this.sha256);\n    if (!hasHeader(SHA256_HEADER, request.headers) && this.applyChecksum) {\n      request.headers[SHA256_HEADER] = payloadHash;\n    }\n    const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);\n    const signature = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, payloadHash));\n    request.headers[AUTH_HEADER] = `${ALGORITHM_IDENTIFIER} ` + `Credential=${credentials.accessKeyId}/${scope}, ` + `SignedHeaders=${getCanonicalHeaderList(canonicalHeaders)}, ` + `Signature=${signature}`;\n    return request;\n  }\n  createCanonicalRequest(request, canonicalHeaders, payloadHash) {\n    const sortedHeaders = Object.keys(canonicalHeaders).sort();\n    return `${request.method}\n${this.getCanonicalPath(request)}\n${getCanonicalQuery(request)}\n${sortedHeaders.map(name => `${name}:${canonicalHeaders[name]}`).join(\"\\n\")}\n\n${sortedHeaders.join(\";\")}\n${payloadHash}`;\n  }\n  async createStringToSign(longDate, credentialScope, canonicalRequest) {\n    const hash = new this.sha256();\n    hash.update(toUint8Array(canonicalRequest));\n    const hashedRequest = await hash.digest();\n    return `${ALGORITHM_IDENTIFIER}\n${longDate}\n${credentialScope}\n${toHex(hashedRequest)}`;\n  }\n  getCanonicalPath({\n    path\n  }) {\n    if (this.uriEscapePath) {\n      const normalizedPathSegments = [];\n      for (const pathSegment of path.split(\"/\")) {\n        if (pathSegment?.length === 0) continue;\n        if (pathSegment === \".\") continue;\n        if (pathSegment === \"..\") {\n          normalizedPathSegments.pop();\n        } else {\n          normalizedPathSegments.push(pathSegment);\n        }\n      }\n      const normalizedPath = `${path?.startsWith(\"/\") ? \"/\" : \"\"}${normalizedPathSegments.join(\"/\")}${normalizedPathSegments.length > 0 && path?.endsWith(\"/\") ? \"/\" : \"\"}`;\n      const doubleEncoded = encodeURIComponent(normalizedPath);\n      return doubleEncoded.replace(/%2F/g, \"/\");\n    }\n    return path;\n  }\n  async getSignature(longDate, credentialScope, keyPromise, canonicalRequest) {\n    const stringToSign = await this.createStringToSign(longDate, credentialScope, canonicalRequest);\n    const hash = new this.sha256(await keyPromise);\n    hash.update(toUint8Array(stringToSign));\n    return toHex(await hash.digest());\n  }\n  getSigningKey(credentials, region, shortDate, service) {\n    return getSigningKey(this.sha256, credentials, shortDate, region, service || this.service);\n  }\n  validateResolvedCredentials(credentials) {\n    if (typeof credentials !== \"object\" || typeof credentials.accessKeyId !== \"string\" || typeof credentials.secretAccessKey !== \"string\") {\n      throw new Error(\"Resolved credential object is not valid\");\n    }\n  }\n}\nconst formatDate = now => {\n  const longDate = iso8601(now).replace(/[\\-:]/g, \"\");\n  return {\n    longDate,\n    shortDate: longDate.slice(0, 8)\n  };\n};\nconst getCanonicalHeaderList = headers => Object.keys(headers).sort().join(\";\");"],
  "mappings": "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",
  "names": ["require_aws_crc32", "__commonJSMin", "exports", "tslib_1", "util_1", "index_1", "AwsCrc32", "toHash", "_a", "require_build", "__commonJSMin", "exports", "tslib_1", "util_1", "crc32", "data", "Crc32", "e_1", "_a", "data_1", "data_1_1", "byte", "lookupTable", "e_1_1", "a_lookUpTable", "aws_crc32_1", "import_crc32", "SHORT_TO_HEX", "HEX_TO_SHORT", "i", "encodedByte", "fromHex", "encoded", "out", "toHex", "bytes", "Int64", "_Int64", "bytes", "number", "i", "remaining", "negate", "negative", "toHex", "HeaderMarshaller", "toUtf8", "fromUtf8", "headers", "chunks", "headerName", "bytes", "out", "carry", "position", "chunk", "header", "shortView", "intView", "longBytes", "binView", "binBytes", "utf8Bytes", "strView", "strBytes", "tsBytes", "Int64", "UUID_PATTERN", "uuidBytes", "fromHex", "nameLength", "name", "BOOLEAN_TAG", "BYTE_TAG", "SHORT_TAG", "INT_TAG", "LONG_TAG", "binaryLength", "BINARY_TAG", "stringLength", "STRING_TAG", "TIMESTAMP_TAG", "UUID_TAG", "toHex", "BOOLEAN_TAG", "BYTE_TAG", "SHORT_TAG", "INT_TAG", "LONG_TAG", "BINARY_TAG", "STRING_TAG", "TIMESTAMP_TAG", "UUID_TAG", "UUID_PATTERN", "import_crc32", "PRELUDE_MEMBER_LENGTH", "PRELUDE_LENGTH", "CHECKSUM_LENGTH", "MINIMUM_MESSAGE_LENGTH", "normalizeProvider", "input", "promisified", "fromUtf8", "input", "toUint8Array", "data", "fromUtf8", "toUtf8", "input", "ALGORITHM_QUERY_PARAM", "CREDENTIAL_QUERY_PARAM", "AMZ_DATE_QUERY_PARAM", "SIGNED_HEADERS_QUERY_PARAM", "EXPIRES_QUERY_PARAM", "SIGNATURE_QUERY_PARAM", "TOKEN_QUERY_PARAM", "AUTH_HEADER", "AMZ_DATE_HEADER", "AMZ_DATE_QUERY_PARAM", "DATE_HEADER", "GENERATED_HEADERS", "SIGNATURE_HEADER", "SIGNATURE_QUERY_PARAM", "SHA256_HEADER", "TOKEN_HEADER", "TOKEN_QUERY_PARAM", "ALWAYS_UNSIGNABLE_HEADERS", "PROXY_HEADER_PATTERN", "SEC_HEADER_PATTERN", "ALGORITHM_IDENTIFIER", "EVENT_ALGORITHM_IDENTIFIER", "UNSIGNED_PAYLOAD", "MAX_CACHE_SIZE", "KEY_TYPE_IDENTIFIER", "MAX_PRESIGNED_TTL", "signingKeyCache", "cacheQueue", "createScope", "shortDate", "region", "service", "KEY_TYPE_IDENTIFIER", "getSigningKey", "sha256Constructor", "credentials", "__async", "credsHash", "hmac", "cacheKey", "toHex", "MAX_CACHE_SIZE", "key", "signable", "clearCredentialCache", "ctor", "secret", "data", "hash", "toUint8Array", "getCanonicalHeaders", "headers", "unsignableHeaders", "signableHeaders", "canonical", "headerName", "canonicalHeaderName", "ALWAYS_UNSIGNABLE_HEADERS", "PROXY_HEADER_PATTERN", "SEC_HEADER_PATTERN", "getCanonicalQuery", "query", "keys", "serialized", "key", "SIGNATURE_HEADER", "value", "escapeUri", "encoded", "isArrayBuffer", "arg", "getPayloadHash", "_0", "_1", "__async", "headers", "body", "hashConstructor", "headerName", "SHA256_HEADER", "isArrayBuffer", "hashCtor", "toUint8Array", "toHex", "UNSIGNED_PAYLOAD", "hasHeader", "soughtHeader", "headers", "headerName", "cloneRequest", "_a", "_b", "headers", "query", "rest", "__objRest", "__spreadProps", "__spreadValues", "cloneQuery", "carry", "paramName", "param", "moveHeadersToQuery", "request", "options", "headers", "query", "cloneRequest", "name", "lname", "__spreadProps", "__spreadValues", "prepareRequest", "request", "cloneRequest", "headerName", "GENERATED_HEADERS", "iso8601", "time", "toDate", "SignatureV4", "applyChecksum", "credentials", "region", "service", "sha256", "uriEscapePath", "HeaderMarshaller", "toUtf8", "fromUtf8", "normalizeProvider", "_0", "__async", "originalRequest", "options", "signingDate", "expiresIn", "unsignableHeaders", "unhoistableHeaders", "signableHeaders", "signingRegion", "signingService", "longDate", "shortDate", "formatDate", "MAX_PRESIGNED_TTL", "scope", "createScope", "request", "moveHeadersToQuery", "prepareRequest", "TOKEN_QUERY_PARAM", "ALGORITHM_QUERY_PARAM", "ALGORITHM_IDENTIFIER", "CREDENTIAL_QUERY_PARAM", "AMZ_DATE_QUERY_PARAM", "EXPIRES_QUERY_PARAM", "canonicalHeaders", "getCanonicalHeaders", "SIGNED_HEADERS_QUERY_PARAM", "getCanonicalHeaderList", "SIGNATURE_QUERY_PARAM", "getPayloadHash", "toSign", "_1", "headers", "payload", "priorSignature", "hashedPayload", "hash", "hashedHeaders", "toHex", "stringToSign", "EVENT_ALGORITHM_IDENTIFIER", "signableMessage", "signature", "toUint8Array", "requestToSign", "AMZ_DATE_HEADER", "TOKEN_HEADER", "payloadHash", "hasHeader", "SHA256_HEADER", "AUTH_HEADER", "sortedHeaders", "getCanonicalQuery", "name", "credentialScope", "canonicalRequest", "hashedRequest", "path", "normalizedPathSegments", "pathSegment", "normalizedPath", "keyPromise", "getSigningKey", "now", "iso8601"]
}
