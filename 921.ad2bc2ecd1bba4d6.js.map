{"version":3,"file":"921.ad2bc2ecd1bba4d6.js","mappings":"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","names":["BehaviorSubject","_Subject","_value","_this","_classCallCheck","this","_callSuper","_inherits","_createClass","key","get","getValue","value","subscriber","subscription","_superPropGet","closed","next","hasError","thrownError","_throwIfClosed","Subject","combineLatest","_len","arguments","length","args","Array","_key","scheduler","popScheduler","resultSelector","popResultSelector","_argsArgArrayOrObject","argsArgArrayOrObject","observables","keys","from","result","Observable","combineLatestInit","valueTransform","undefined","identity","maybeSchedule","values","active","remainingFirstValues","_loop","i","source","hasFirstValue","subscribe","createOperatorSubscriber","slice","complete","createObject","pipe","mapOneOrManyArgs","execute","executeSchedule","skip","count","filter","_","index","isArray","getPrototypeOf","Object","objectProto","prototype","getKeys","first","isPOJO","obj","map","reduce","fn","callOrApply","apply","_toConsumableArray","IsFocusableConfig","_defineProperty","InteractivityChecker","_InteractivityChecker","inject","Platform","element","hasAttribute","hasGeometry","offsetWidth","offsetHeight","getClientRects","getComputedStyle","visibility","_platform","isBrowser","frameElement","getFrameElement","window","getWindow","node","ownerDocument","defaultView","getTabIndexValue","isVisible","nodeName","toLowerCase","tabIndexValue","WEBKIT","IOS","isPotentiallyTabbableIOS","inputType","type","FIREFOX","tabIndex","config","isPotentiallyFocusable","isHiddenInput","isInputElement","isNativeFormElement","isAnchorWithHref","isAnchorElement","hasValidTabIndex","isDisabled","ignoreVisibility","__ngFactoryType__","i0","token","factory","Éµfac","providedIn","getAttribute","isNaN","parseInt","FocusTrap","_element","_checker","_ngZone","_document","deferAnchors","_injector","focusLastTabbableElement","focusFirstTabbableElement","attachAnchors","_enabled","set","_startAnchor","_endAnchor","_toggleAnchorTabIndex","startAnchor","endAnchor","removeEventListener","startAnchorListener","remove","endAnchorListener","_hasAttached","_this2","runOutsideAngular","_createAnchor","addEventListener","parentNode","insertBefore","nextSibling","options","_this3","Promise","resolve","_executeOnStable","focusInitialElement","_this4","_this5","bound","markers","querySelectorAll","concat","_getFirstTabbableElement","_getLastTabbableElement","redirectToElement","querySelector","isFocusable","focusableChild","focus","_getRegionBoundary","root","isTabbable","children","tabbableChild","nodeType","ELEMENT_NODE","anchor","createElement","classList","add","setAttribute","isEnabled","removeAttribute","enabled","afterNextRender","injector","setTimeout","FocusTrapFactory","_FocusTrapFactory","NgZone","DOCUMENT","Injector","_CdkPrivateStyleLoader","load","_VisuallyHiddenLoader","CdkTrapFocus","_CdkTrapFocus","ElementRef","platform","focusTrap","_focusTrapFactory","create","_elementRef","nativeElement","_this$focusTrap","_this$focusTrap2","destroy","_previouslyFocusedElement","_this$focusTrap3","autoCapture","_captureFocus","hasAttached","changes","_this$focusTrap4","autoCaptureChange","firstChange","_this$focusTrap5","_getFocusedElementPierceShadowDom","focusInitialElementWhenReady","selectors","inputs","booleanAttribute","exportAs","features","LIVE_ANNOUNCER_ELEMENT_TOKEN","InjectionToken","LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY","LIVE_ANNOUNCER_DEFAULT_OPTIONS","uniqueIds","LiveAnnouncer","_LiveAnnouncer","optional","elementToken","_liveElement","_createLiveElement","message","politeness","duration","_this6","defaultOptions","_defaultOptions","clear","clearTimeout","_previousTimeout","id","_exposeAnnouncerToModals","_currentPromise","_currentResolve","_this6$_currentResolv","textContent","call","_this$_liveElement","_this$_currentResolve","elementClass","previousElements","getElementsByClassName","liveEl","body","appendChild","modals","modal","ariaOwns","indexOf","CdkAriaLive","_CdkAriaLive","ContentObserver","_politeness","_this7","_subscription","unsubscribe","_contentObserver","observe","elementText","_previousAnnouncedText","_liveAnnouncer","announce","HighContrastMode","NONE","BLACK_ON_WHITE","WHITE_ON_BLACK","BLACK_ON_WHITE_CSS_CLASS","WHITE_ON_BLACK_CSS_CLASS","HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS","HighContrastModeDetector","_HighContrastModeDetector","_this8","_breakpointSubscription","BreakpointObserver","_hasCheckedHighContrastMode","_applyBodyHighContrastModeCssClasses","testElement","style","backgroundColor","position","documentWindow","computedStyle","computedColor","replace","bodyClasses","mode","getHighContrastMode","A11yModule","_A11yModule","imports","ObserversModule","mediaQueryStyleNode","mediaQueriesForWebkitCompatibility","Set","MediaMatcher","_MediaMatcher","CSP_NONCE","_matchMedia","matchMedia","bind","noopMatchMedia","query","BLINK","createEmptyStyleRule","nonce","has","document","head","sheet","insertRule","e","console","error","_nonce","matches","media","addListener","removeListener","_BreakpointObserver","Map","_destroySubject","splitQueries","coerceArray","some","mediaQuery","_registerQuery","mql","observable","stateObservable","take","debounceTime","breakpointStates","response","breakpoints","forEach","_ref","_queries","_mediaMatcher","output","observer","handler","_zone","run","startWith","_ref2","takeUntil","queries","split","a1","a2","trim","isFakeMousedownFromScreenReader","event","buttons","detail","isFakeTouchstartFromScreenReader","touch","touches","changedTouches","identifier","radiusX","radiusY","INPUT_MODALITY_DETECTOR_OPTIONS","INPUT_MODALITY_DETECTOR_DEFAULT_OPTIONS","ignoreKeys","ALT","CONTROL","MAC_META","META","SHIFT","modalityEventListenerOptions","passive","capture","InputModalityDetector","_InputModalityDetector","_this$_options","_options","keyCode","_modality","_mostRecentTarget","_getEventTarget","Date","now","_lastTouchMs","ngZone","_objectSpread","modalityDetected","modalityChanged","distinctUntilChanged","renderer","RendererFactory2","createRenderer","_listenerCleanups","listen","_onKeydown","_onMousedown","_onTouchstart","_this$_listenerCleanu","cleanup","FocusMonitorDetectionMode","IMMEDIATE","EVENTUAL","FOCUS_MONITOR_DEFAULT_OPTIONS","captureEventListenerOptions","normalizePassiveListenerOptions","FocusMonitor","_FocusMonitor","_windowFocused","_windowFocusTimeoutId","target","parentElement","_onFocus","_onBlur","_detectionMode","detectionMode","checkChildren","coerceElement","of","rootNode","_getShadowRoot","cachedInfo","_elementInfo","subject","info","_registerGlobalListeners","elementInfo","_setClasses","delete","_removeGlobalListeners","origin","activeElement","_getClosestElementsInfo","_slicedToArray","_originChanged","_setOrigin","_info","stopMonitoring","focusEventTarget","_origin","_originFromTouchInteraction","_shouldBeAttributedToTouch","_lastFocusOrigin","_isLastInteractionFromInputLabel","contains","_inputModalityDetector","toggle","isFromInteraction","_originTimeoutId","_getFocusOrigin","relatedTarget","Node","_emitOrigin","observers","rootNodeFocusListeners","_rootNodeFocusListenerCount","_rootNodeFocusAndBlurListener","_monitoredElementCount","_getWindow","_windowFocusListener","_stopInputModalityDetector","modality","results","currentElement","push","_this$_inputModalityD","mostRecentTarget","mostRecentModality","disabled","labels","CdkMonitorFocus","_CdkMonitorFocus","EventEmitter","_focusOrigin","_monitorSubscription","_focusMonitor","monitor","cdkFocusChange","emit","outputs","MutationObserverFactory","_MutationObserverFactory","callback","MutationObserver","_ContentObserver","_observedElements","_cleanupObserver","elementOrRef","_observeElement","records","record","shouldIgnoreRecord","Comment","addedNodes","removedNodes","_unobserveElement","stream","_mutationObserverFactory","mutations","characterData","childList","subtree","_this$_observedElemen","disconnect","CdkObserveContent","_CdkObserveContent","_disabled","_unsubscribe","_subscribe","_debounce","coerceNumberProperty","_currentSubscription","debounce","_this$_currentSubscri","_ObserversModule","providers","supportsPassiveEvents","supportsPassiveEventListeners","defineProperty","_VisuallyHiddenLoader2","decls","vars","template","rf","ctx","styles","encapsulation","changeDetection"],"ignoreList":[],"sourceRoot":"webpack:///","sources":["./node_modules/rxjs/dist/esm/internal/BehaviorSubject.js","./node_modules/rxjs/dist/esm/internal/observable/combineLatest.js","./node_modules/rxjs/dist/esm/internal/operators/skip.js","./node_modules/rxjs/dist/esm/internal/util/argsArgArrayOrObject.js","./node_modules/rxjs/dist/esm/internal/util/createObject.js","./node_modules/rxjs/dist/esm/internal/util/mapOneOrManyArgs.js","./node_modules/@angular/cdk/fesm2022/a11y-module.mjs","./node_modules/@angular/cdk/fesm2022/breakpoints-observer.mjs","./node_modules/@angular/cdk/fesm2022/fake-event-detection.mjs","./node_modules/@angular/cdk/fesm2022/focus-monitor.mjs","./node_modules/@angular/cdk/fesm2022/observers.mjs","./node_modules/@angular/cdk/fesm2022/passive-listeners.mjs","./node_modules/@angular/cdk/fesm2022/private.mjs"],"sourcesContent":["import { Subject } from './Subject';\nexport class BehaviorSubject extends Subject {\n    constructor(_value) {\n        super();\n        this._value = _value;\n    }\n    get value() {\n        return this.getValue();\n    }\n    _subscribe(subscriber) {\n        const subscription = super._subscribe(subscriber);\n        !subscription.closed && subscriber.next(this._value);\n        return subscription;\n    }\n    getValue() {\n        const { hasError, thrownError, _value } = this;\n        if (hasError) {\n            throw thrownError;\n        }\n        this._throwIfClosed();\n        return _value;\n    }\n    next(value) {\n        super.next((this._value = value));\n    }\n}\n","import { Observable } from '../Observable';\nimport { argsArgArrayOrObject } from '../util/argsArgArrayOrObject';\nimport { from } from './from';\nimport { identity } from '../util/identity';\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\nimport { popResultSelector, popScheduler } from '../util/args';\nimport { createObject } from '../util/createObject';\nimport { createOperatorSubscriber } from '../operators/OperatorSubscriber';\nimport { executeSchedule } from '../util/executeSchedule';\nexport function combineLatest(...args) {\n    const scheduler = popScheduler(args);\n    const resultSelector = popResultSelector(args);\n    const { args: observables, keys } = argsArgArrayOrObject(args);\n    if (observables.length === 0) {\n        return from([], scheduler);\n    }\n    const result = new Observable(combineLatestInit(observables, scheduler, keys\n        ?\n            (values) => createObject(keys, values)\n        :\n            identity));\n    return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;\n}\nexport function combineLatestInit(observables, scheduler, valueTransform = identity) {\n    return (subscriber) => {\n        maybeSchedule(scheduler, () => {\n            const { length } = observables;\n            const values = new Array(length);\n            let active = length;\n            let remainingFirstValues = length;\n            for (let i = 0; i < length; i++) {\n                maybeSchedule(scheduler, () => {\n                    const source = from(observables[i], scheduler);\n                    let hasFirstValue = false;\n                    source.subscribe(createOperatorSubscriber(subscriber, (value) => {\n                        values[i] = value;\n                        if (!hasFirstValue) {\n                            hasFirstValue = true;\n                            remainingFirstValues--;\n                        }\n                        if (!remainingFirstValues) {\n                            subscriber.next(valueTransform(values.slice()));\n                        }\n                    }, () => {\n                        if (!--active) {\n                            subscriber.complete();\n                        }\n                    }));\n                }, subscriber);\n            }\n        }, subscriber);\n    };\n}\nfunction maybeSchedule(scheduler, execute, subscription) {\n    if (scheduler) {\n        executeSchedule(subscription, scheduler, execute);\n    }\n    else {\n        execute();\n    }\n}\n","import { filter } from './filter';\nexport function skip(count) {\n    return filter((_, index) => count <= index);\n}\n","const { isArray } = Array;\nconst { getPrototypeOf, prototype: objectProto, keys: getKeys } = Object;\nexport function argsArgArrayOrObject(args) {\n    if (args.length === 1) {\n        const first = args[0];\n        if (isArray(first)) {\n            return { args: first, keys: null };\n        }\n        if (isPOJO(first)) {\n            const keys = getKeys(first);\n            return {\n                args: keys.map((key) => first[key]),\n                keys,\n            };\n        }\n    }\n    return { args: args, keys: null };\n}\nfunction isPOJO(obj) {\n    return obj && typeof obj === 'object' && getPrototypeOf(obj) === objectProto;\n}\n","export function createObject(keys, values) {\n    return keys.reduce((result, key, i) => ((result[key] = values[i]), result), {});\n}\n","import { map } from \"../operators/map\";\nconst { isArray } = Array;\nfunction callOrApply(fn, args) {\n    return isArray(args) ? fn(...args) : fn(args);\n}\nexport function mapOneOrManyArgs(fn) {\n    return map(args => callOrApply(fn, args));\n}\n","import * as i0 from '@angular/core';\nimport { inject, Injectable, afterNextRender, NgZone, DOCUMENT, Injector, ElementRef, booleanAttribute, Directive, Input, InjectionToken, NgModule } from '@angular/core';\nimport { CdkMonitorFocus } from './focus-monitor.mjs';\nimport { Platform } from './platform2.mjs';\nimport { _getFocusedElementPierceShadowDom } from './shadow-dom.mjs';\nimport { _CdkPrivateStyleLoader } from './style-loader.mjs';\nimport { _VisuallyHiddenLoader } from './private.mjs';\nimport { BreakpointObserver } from './breakpoints-observer.mjs';\nimport { ContentObserver, ObserversModule } from './observers.mjs';\n\n/**\n * Configuration for the isFocusable method.\n */\nclass IsFocusableConfig {\n    /**\n     * Whether to count an element as focusable even if it is not currently visible.\n     */\n    ignoreVisibility = false;\n}\n// The InteractivityChecker leans heavily on the ally.js accessibility utilities.\n// Methods like `isTabbable` are only covering specific edge-cases for the browsers which are\n// supported.\n/**\n * Utility for checking the interactivity of an element, such as whether it is focusable or\n * tabbable.\n */\nclass InteractivityChecker {\n    _platform = inject(Platform);\n    constructor() { }\n    /**\n     * Gets whether an element is disabled.\n     *\n     * @param element Element to be checked.\n     * @returns Whether the element is disabled.\n     */\n    isDisabled(element) {\n        // This does not capture some cases, such as a non-form control with a disabled attribute or\n        // a form control inside of a disabled form, but should capture the most common cases.\n        return element.hasAttribute('disabled');\n    }\n    /**\n     * Gets whether an element is visible for the purposes of interactivity.\n     *\n     * This will capture states like `display: none` and `visibility: hidden`, but not things like\n     * being clipped by an `overflow: hidden` parent or being outside the viewport.\n     *\n     * @returns Whether the element is visible.\n     */\n    isVisible(element) {\n        return hasGeometry(element) && getComputedStyle(element).visibility === 'visible';\n    }\n    /**\n     * Gets whether an element can be reached via Tab key.\n     * Assumes that the element has already been checked with isFocusable.\n     *\n     * @param element Element to be checked.\n     * @returns Whether the element is tabbable.\n     */\n    isTabbable(element) {\n        // Nothing is tabbable on the server ðŸ˜Ž\n        if (!this._platform.isBrowser) {\n            return false;\n        }\n        const frameElement = getFrameElement(getWindow(element));\n        if (frameElement) {\n            // Frame elements inherit their tabindex onto all child elements.\n            if (getTabIndexValue(frameElement) === -1) {\n                return false;\n            }\n            // Browsers disable tabbing to an element inside of an invisible frame.\n            if (!this.isVisible(frameElement)) {\n                return false;\n            }\n        }\n        let nodeName = element.nodeName.toLowerCase();\n        let tabIndexValue = getTabIndexValue(element);\n        if (element.hasAttribute('contenteditable')) {\n            return tabIndexValue !== -1;\n        }\n        if (nodeName === 'iframe' || nodeName === 'object') {\n            // The frame or object's content may be tabbable depending on the content, but it's\n            // not possibly to reliably detect the content of the frames. We always consider such\n            // elements as non-tabbable.\n            return false;\n        }\n        // In iOS, the browser only considers some specific elements as tabbable.\n        if (this._platform.WEBKIT && this._platform.IOS && !isPotentiallyTabbableIOS(element)) {\n            return false;\n        }\n        if (nodeName === 'audio') {\n            // Audio elements without controls enabled are never tabbable, regardless\n            // of the tabindex attribute explicitly being set.\n            if (!element.hasAttribute('controls')) {\n                return false;\n            }\n            // Audio elements with controls are by default tabbable unless the\n            // tabindex attribute is set to `-1` explicitly.\n            return tabIndexValue !== -1;\n        }\n        if (nodeName === 'video') {\n            // For all video elements, if the tabindex attribute is set to `-1`, the video\n            // is not tabbable. Note: We cannot rely on the default `HTMLElement.tabIndex`\n            // property as that one is set to `-1` in Chrome, Edge and Safari v13.1. The\n            // tabindex attribute is the source of truth here.\n            if (tabIndexValue === -1) {\n                return false;\n            }\n            // If the tabindex is explicitly set, and not `-1` (as per check before), the\n            // video element is always tabbable (regardless of whether it has controls or not).\n            if (tabIndexValue !== null) {\n                return true;\n            }\n            // Otherwise (when no explicit tabindex is set), a video is only tabbable if it\n            // has controls enabled. Firefox is special as videos are always tabbable regardless\n            // of whether there are controls or not.\n            return this._platform.FIREFOX || element.hasAttribute('controls');\n        }\n        return element.tabIndex >= 0;\n    }\n    /**\n     * Gets whether an element can be focused by the user.\n     *\n     * @param element Element to be checked.\n     * @param config The config object with options to customize this method's behavior\n     * @returns Whether the element is focusable.\n     */\n    isFocusable(element, config) {\n        // Perform checks in order of left to most expensive.\n        // Again, naive approach that does not capture many edge cases and browser quirks.\n        return (isPotentiallyFocusable(element) &&\n            !this.isDisabled(element) &&\n            (config?.ignoreVisibility || this.isVisible(element)));\n    }\n    static Éµfac = i0.ÉµÉµngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: InteractivityChecker, deps: [], target: i0.ÉµÉµFactoryTarget.Injectable });\n    static Éµprov = i0.ÉµÉµngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: InteractivityChecker, providedIn: 'root' });\n}\ni0.ÉµÉµngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: InteractivityChecker, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [] });\n/**\n * Returns the frame element from a window object. Since browsers like MS Edge throw errors if\n * the frameElement property is being accessed from a different host address, this property\n * should be accessed carefully.\n */\nfunction getFrameElement(window) {\n    try {\n        return window.frameElement;\n    }\n    catch {\n        return null;\n    }\n}\n/** Checks whether the specified element has any geometry / rectangles. */\nfunction hasGeometry(element) {\n    // Use logic from jQuery to check for an invisible element.\n    // See https://github.com/jquery/jquery/blob/master/src/css/hiddenVisibleSelectors.js#L12\n    return !!(element.offsetWidth ||\n        element.offsetHeight ||\n        (typeof element.getClientRects === 'function' && element.getClientRects().length));\n}\n/** Gets whether an element's  */\nfunction isNativeFormElement(element) {\n    let nodeName = element.nodeName.toLowerCase();\n    return (nodeName === 'input' ||\n        nodeName === 'select' ||\n        nodeName === 'button' ||\n        nodeName === 'textarea');\n}\n/** Gets whether an element is an `<input type=\"hidden\">`. */\nfunction isHiddenInput(element) {\n    return isInputElement(element) && element.type == 'hidden';\n}\n/** Gets whether an element is an anchor that has an href attribute. */\nfunction isAnchorWithHref(element) {\n    return isAnchorElement(element) && element.hasAttribute('href');\n}\n/** Gets whether an element is an input element. */\nfunction isInputElement(element) {\n    return element.nodeName.toLowerCase() == 'input';\n}\n/** Gets whether an element is an anchor element. */\nfunction isAnchorElement(element) {\n    return element.nodeName.toLowerCase() == 'a';\n}\n/** Gets whether an element has a valid tabindex. */\nfunction hasValidTabIndex(element) {\n    if (!element.hasAttribute('tabindex') || element.tabIndex === undefined) {\n        return false;\n    }\n    let tabIndex = element.getAttribute('tabindex');\n    return !!(tabIndex && !isNaN(parseInt(tabIndex, 10)));\n}\n/**\n * Returns the parsed tabindex from the element attributes instead of returning the\n * evaluated tabindex from the browsers defaults.\n */\nfunction getTabIndexValue(element) {\n    if (!hasValidTabIndex(element)) {\n        return null;\n    }\n    // See browser issue in Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=1128054\n    const tabIndex = parseInt(element.getAttribute('tabindex') || '', 10);\n    return isNaN(tabIndex) ? -1 : tabIndex;\n}\n/** Checks whether the specified element is potentially tabbable on iOS */\nfunction isPotentiallyTabbableIOS(element) {\n    let nodeName = element.nodeName.toLowerCase();\n    let inputType = nodeName === 'input' && element.type;\n    return (inputType === 'text' ||\n        inputType === 'password' ||\n        nodeName === 'select' ||\n        nodeName === 'textarea');\n}\n/**\n * Gets whether an element is potentially focusable without taking current visible/disabled state\n * into account.\n */\nfunction isPotentiallyFocusable(element) {\n    // Inputs are potentially focusable *unless* they're type=\"hidden\".\n    if (isHiddenInput(element)) {\n        return false;\n    }\n    return (isNativeFormElement(element) ||\n        isAnchorWithHref(element) ||\n        element.hasAttribute('contenteditable') ||\n        hasValidTabIndex(element));\n}\n/** Gets the parent window of a DOM node with regards of being inside of an iframe. */\nfunction getWindow(node) {\n    // ownerDocument is null if `node` itself *is* a document.\n    return (node.ownerDocument && node.ownerDocument.defaultView) || window;\n}\n\n/**\n * Class that allows for trapping focus within a DOM element.\n *\n * This class currently uses a relatively simple approach to focus trapping.\n * It assumes that the tab order is the same as DOM order, which is not necessarily true.\n * Things like `tabIndex > 0`, flex `order`, and shadow roots can cause the two to be misaligned.\n */\nclass FocusTrap {\n    _element;\n    _checker;\n    _ngZone;\n    _document;\n    _injector;\n    _startAnchor;\n    _endAnchor;\n    _hasAttached = false;\n    // Event listeners for the anchors. Need to be regular functions so that we can unbind them later.\n    startAnchorListener = () => this.focusLastTabbableElement();\n    endAnchorListener = () => this.focusFirstTabbableElement();\n    /** Whether the focus trap is active. */\n    get enabled() {\n        return this._enabled;\n    }\n    set enabled(value) {\n        this._enabled = value;\n        if (this._startAnchor && this._endAnchor) {\n            this._toggleAnchorTabIndex(value, this._startAnchor);\n            this._toggleAnchorTabIndex(value, this._endAnchor);\n        }\n    }\n    _enabled = true;\n    constructor(_element, _checker, _ngZone, _document, deferAnchors = false, \n    /** @breaking-change 20.0.0 param to become required */\n    _injector) {\n        this._element = _element;\n        this._checker = _checker;\n        this._ngZone = _ngZone;\n        this._document = _document;\n        this._injector = _injector;\n        if (!deferAnchors) {\n            this.attachAnchors();\n        }\n    }\n    /** Destroys the focus trap by cleaning up the anchors. */\n    destroy() {\n        const startAnchor = this._startAnchor;\n        const endAnchor = this._endAnchor;\n        if (startAnchor) {\n            startAnchor.removeEventListener('focus', this.startAnchorListener);\n            startAnchor.remove();\n        }\n        if (endAnchor) {\n            endAnchor.removeEventListener('focus', this.endAnchorListener);\n            endAnchor.remove();\n        }\n        this._startAnchor = this._endAnchor = null;\n        this._hasAttached = false;\n    }\n    /**\n     * Inserts the anchors into the DOM. This is usually done automatically\n     * in the constructor, but can be deferred for cases like directives with `*ngIf`.\n     * @returns Whether the focus trap managed to attach successfully. This may not be the case\n     * if the target element isn't currently in the DOM.\n     */\n    attachAnchors() {\n        // If we're not on the browser, there can be no focus to trap.\n        if (this._hasAttached) {\n            return true;\n        }\n        this._ngZone.runOutsideAngular(() => {\n            if (!this._startAnchor) {\n                this._startAnchor = this._createAnchor();\n                this._startAnchor.addEventListener('focus', this.startAnchorListener);\n            }\n            if (!this._endAnchor) {\n                this._endAnchor = this._createAnchor();\n                this._endAnchor.addEventListener('focus', this.endAnchorListener);\n            }\n        });\n        if (this._element.parentNode) {\n            this._element.parentNode.insertBefore(this._startAnchor, this._element);\n            this._element.parentNode.insertBefore(this._endAnchor, this._element.nextSibling);\n            this._hasAttached = true;\n        }\n        return this._hasAttached;\n    }\n    /**\n     * Waits for the zone to stabilize, then focuses the first tabbable element.\n     * @returns Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfully.\n     */\n    focusInitialElementWhenReady(options) {\n        return new Promise(resolve => {\n            this._executeOnStable(() => resolve(this.focusInitialElement(options)));\n        });\n    }\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the first tabbable element within the focus trap region.\n     * @returns Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfully.\n     */\n    focusFirstTabbableElementWhenReady(options) {\n        return new Promise(resolve => {\n            this._executeOnStable(() => resolve(this.focusFirstTabbableElement(options)));\n        });\n    }\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the last tabbable element within the focus trap region.\n     * @returns Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfully.\n     */\n    focusLastTabbableElementWhenReady(options) {\n        return new Promise(resolve => {\n            this._executeOnStable(() => resolve(this.focusLastTabbableElement(options)));\n        });\n    }\n    /**\n     * Get the specified boundary element of the trapped region.\n     * @param bound The boundary to get (start or end of trapped region).\n     * @returns The boundary element.\n     */\n    _getRegionBoundary(bound) {\n        // Contains the deprecated version of selector, for temporary backwards comparability.\n        const markers = this._element.querySelectorAll(`[cdk-focus-region-${bound}], ` + `[cdkFocusRegion${bound}], ` + `[cdk-focus-${bound}]`);\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            for (let i = 0; i < markers.length; i++) {\n                // @breaking-change 8.0.0\n                if (markers[i].hasAttribute(`cdk-focus-${bound}`)) {\n                    console.warn(`Found use of deprecated attribute 'cdk-focus-${bound}', ` +\n                        `use 'cdkFocusRegion${bound}' instead. The deprecated ` +\n                        `attribute will be removed in 8.0.0.`, markers[i]);\n                }\n                else if (markers[i].hasAttribute(`cdk-focus-region-${bound}`)) {\n                    console.warn(`Found use of deprecated attribute 'cdk-focus-region-${bound}', ` +\n                        `use 'cdkFocusRegion${bound}' instead. The deprecated attribute ` +\n                        `will be removed in 8.0.0.`, markers[i]);\n                }\n            }\n        }\n        if (bound == 'start') {\n            return markers.length ? markers[0] : this._getFirstTabbableElement(this._element);\n        }\n        return markers.length\n            ? markers[markers.length - 1]\n            : this._getLastTabbableElement(this._element);\n    }\n    /**\n     * Focuses the element that should be focused when the focus trap is initialized.\n     * @returns Whether focus was moved successfully.\n     */\n    focusInitialElement(options) {\n        // Contains the deprecated version of selector, for temporary backwards comparability.\n        const redirectToElement = this._element.querySelector(`[cdk-focus-initial], ` + `[cdkFocusInitial]`);\n        if (redirectToElement) {\n            // @breaking-change 8.0.0\n            if ((typeof ngDevMode === 'undefined' || ngDevMode) &&\n                redirectToElement.hasAttribute(`cdk-focus-initial`)) {\n                console.warn(`Found use of deprecated attribute 'cdk-focus-initial', ` +\n                    `use 'cdkFocusInitial' instead. The deprecated attribute ` +\n                    `will be removed in 8.0.0`, redirectToElement);\n            }\n            // Warn the consumer if the element they've pointed to\n            // isn't focusable, when not in production mode.\n            if ((typeof ngDevMode === 'undefined' || ngDevMode) &&\n                !this._checker.isFocusable(redirectToElement)) {\n                console.warn(`Element matching '[cdkFocusInitial]' is not focusable.`, redirectToElement);\n            }\n            if (!this._checker.isFocusable(redirectToElement)) {\n                const focusableChild = this._getFirstTabbableElement(redirectToElement);\n                focusableChild?.focus(options);\n                return !!focusableChild;\n            }\n            redirectToElement.focus(options);\n            return true;\n        }\n        return this.focusFirstTabbableElement(options);\n    }\n    /**\n     * Focuses the first tabbable element within the focus trap region.\n     * @returns Whether focus was moved successfully.\n     */\n    focusFirstTabbableElement(options) {\n        const redirectToElement = this._getRegionBoundary('start');\n        if (redirectToElement) {\n            redirectToElement.focus(options);\n        }\n        return !!redirectToElement;\n    }\n    /**\n     * Focuses the last tabbable element within the focus trap region.\n     * @returns Whether focus was moved successfully.\n     */\n    focusLastTabbableElement(options) {\n        const redirectToElement = this._getRegionBoundary('end');\n        if (redirectToElement) {\n            redirectToElement.focus(options);\n        }\n        return !!redirectToElement;\n    }\n    /**\n     * Checks whether the focus trap has successfully been attached.\n     */\n    hasAttached() {\n        return this._hasAttached;\n    }\n    /** Get the first tabbable element from a DOM subtree (inclusive). */\n    _getFirstTabbableElement(root) {\n        if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\n            return root;\n        }\n        const children = root.children;\n        for (let i = 0; i < children.length; i++) {\n            const tabbableChild = children[i].nodeType === this._document.ELEMENT_NODE\n                ? this._getFirstTabbableElement(children[i])\n                : null;\n            if (tabbableChild) {\n                return tabbableChild;\n            }\n        }\n        return null;\n    }\n    /** Get the last tabbable element from a DOM subtree (inclusive). */\n    _getLastTabbableElement(root) {\n        if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\n            return root;\n        }\n        // Iterate in reverse DOM order.\n        const children = root.children;\n        for (let i = children.length - 1; i >= 0; i--) {\n            const tabbableChild = children[i].nodeType === this._document.ELEMENT_NODE\n                ? this._getLastTabbableElement(children[i])\n                : null;\n            if (tabbableChild) {\n                return tabbableChild;\n            }\n        }\n        return null;\n    }\n    /** Creates an anchor element. */\n    _createAnchor() {\n        const anchor = this._document.createElement('div');\n        this._toggleAnchorTabIndex(this._enabled, anchor);\n        anchor.classList.add('cdk-visually-hidden');\n        anchor.classList.add('cdk-focus-trap-anchor');\n        anchor.setAttribute('aria-hidden', 'true');\n        return anchor;\n    }\n    /**\n     * Toggles the `tabindex` of an anchor, based on the enabled state of the focus trap.\n     * @param isEnabled Whether the focus trap is enabled.\n     * @param anchor Anchor on which to toggle the tabindex.\n     */\n    _toggleAnchorTabIndex(isEnabled, anchor) {\n        // Remove the tabindex completely, rather than setting it to -1, because if the\n        // element has a tabindex, the user might still hit it when navigating with the arrow keys.\n        isEnabled ? anchor.setAttribute('tabindex', '0') : anchor.removeAttribute('tabindex');\n    }\n    /**\n     * Toggles the`tabindex` of both anchors to either trap Tab focus or allow it to escape.\n     * @param enabled: Whether the anchors should trap Tab.\n     */\n    toggleAnchors(enabled) {\n        if (this._startAnchor && this._endAnchor) {\n            this._toggleAnchorTabIndex(enabled, this._startAnchor);\n            this._toggleAnchorTabIndex(enabled, this._endAnchor);\n        }\n    }\n    /** Executes a function when the zone is stable. */\n    _executeOnStable(fn) {\n        // TODO: remove this conditional when injector is required in the constructor.\n        if (this._injector) {\n            afterNextRender(fn, { injector: this._injector });\n        }\n        else {\n            setTimeout(fn);\n        }\n    }\n}\n/**\n * Factory that allows easy instantiation of focus traps.\n */\nclass FocusTrapFactory {\n    _checker = inject(InteractivityChecker);\n    _ngZone = inject(NgZone);\n    _document = inject(DOCUMENT);\n    _injector = inject(Injector);\n    constructor() {\n        inject(_CdkPrivateStyleLoader).load(_VisuallyHiddenLoader);\n    }\n    /**\n     * Creates a focus-trapped region around the given element.\n     * @param element The element around which focus will be trapped.\n     * @param deferCaptureElements Defers the creation of focus-capturing elements to be done\n     *     manually by the user.\n     * @returns The created focus trap instance.\n     */\n    create(element, deferCaptureElements = false) {\n        return new FocusTrap(element, this._checker, this._ngZone, this._document, deferCaptureElements, this._injector);\n    }\n    static Éµfac = i0.ÉµÉµngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: FocusTrapFactory, deps: [], target: i0.ÉµÉµFactoryTarget.Injectable });\n    static Éµprov = i0.ÉµÉµngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: FocusTrapFactory, providedIn: 'root' });\n}\ni0.ÉµÉµngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: FocusTrapFactory, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [] });\n/** Directive for trapping focus within a region. */\nclass CdkTrapFocus {\n    _elementRef = inject(ElementRef);\n    _focusTrapFactory = inject(FocusTrapFactory);\n    /** Underlying FocusTrap instance. */\n    focusTrap;\n    /** Previously focused element to restore focus to upon destroy when using autoCapture. */\n    _previouslyFocusedElement = null;\n    /** Whether the focus trap is active. */\n    get enabled() {\n        return this.focusTrap?.enabled || false;\n    }\n    set enabled(value) {\n        if (this.focusTrap) {\n            this.focusTrap.enabled = value;\n        }\n    }\n    /**\n     * Whether the directive should automatically move focus into the trapped region upon\n     * initialization and return focus to the previous activeElement upon destruction.\n     */\n    autoCapture;\n    constructor() {\n        const platform = inject(Platform);\n        if (platform.isBrowser) {\n            this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, true);\n        }\n    }\n    ngOnDestroy() {\n        this.focusTrap?.destroy();\n        // If we stored a previously focused element when using autoCapture, return focus to that\n        // element now that the trapped region is being destroyed.\n        if (this._previouslyFocusedElement) {\n            this._previouslyFocusedElement.focus();\n            this._previouslyFocusedElement = null;\n        }\n    }\n    ngAfterContentInit() {\n        this.focusTrap?.attachAnchors();\n        if (this.autoCapture) {\n            this._captureFocus();\n        }\n    }\n    ngDoCheck() {\n        if (this.focusTrap && !this.focusTrap.hasAttached()) {\n            this.focusTrap.attachAnchors();\n        }\n    }\n    ngOnChanges(changes) {\n        const autoCaptureChange = changes['autoCapture'];\n        if (autoCaptureChange &&\n            !autoCaptureChange.firstChange &&\n            this.autoCapture &&\n            this.focusTrap?.hasAttached()) {\n            this._captureFocus();\n        }\n    }\n    _captureFocus() {\n        this._previouslyFocusedElement = _getFocusedElementPierceShadowDom();\n        this.focusTrap?.focusInitialElementWhenReady();\n    }\n    static Éµfac = i0.ÉµÉµngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: CdkTrapFocus, deps: [], target: i0.ÉµÉµFactoryTarget.Directive });\n    static Éµdir = i0.ÉµÉµngDeclareDirective({ minVersion: \"16.1.0\", version: \"20.2.0-next.2\", type: CdkTrapFocus, isStandalone: true, selector: \"[cdkTrapFocus]\", inputs: { enabled: [\"cdkTrapFocus\", \"enabled\", booleanAttribute], autoCapture: [\"cdkTrapFocusAutoCapture\", \"autoCapture\", booleanAttribute] }, exportAs: [\"cdkTrapFocus\"], usesOnChanges: true, ngImport: i0 });\n}\ni0.ÉµÉµngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: CdkTrapFocus, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[cdkTrapFocus]',\n                    exportAs: 'cdkTrapFocus',\n                }]\n        }], ctorParameters: () => [], propDecorators: { enabled: [{\n                type: Input,\n                args: [{ alias: 'cdkTrapFocus', transform: booleanAttribute }]\n            }], autoCapture: [{\n                type: Input,\n                args: [{ alias: 'cdkTrapFocusAutoCapture', transform: booleanAttribute }]\n            }] } });\n\nconst LIVE_ANNOUNCER_ELEMENT_TOKEN = new InjectionToken('liveAnnouncerElement', {\n    providedIn: 'root',\n    factory: LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY,\n});\n/**\n * @docs-private\n * @deprecated No longer used, will be removed.\n * @breaking-change 21.0.0\n */\nfunction LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY() {\n    return null;\n}\n/** Injection token that can be used to configure the default options for the LiveAnnouncer. */\nconst LIVE_ANNOUNCER_DEFAULT_OPTIONS = new InjectionToken('LIVE_ANNOUNCER_DEFAULT_OPTIONS');\n\nlet uniqueIds = 0;\nclass LiveAnnouncer {\n    _ngZone = inject(NgZone);\n    _defaultOptions = inject(LIVE_ANNOUNCER_DEFAULT_OPTIONS, {\n        optional: true,\n    });\n    _liveElement;\n    _document = inject(DOCUMENT);\n    _previousTimeout;\n    _currentPromise;\n    _currentResolve;\n    constructor() {\n        const elementToken = inject(LIVE_ANNOUNCER_ELEMENT_TOKEN, { optional: true });\n        this._liveElement = elementToken || this._createLiveElement();\n    }\n    announce(message, ...args) {\n        const defaultOptions = this._defaultOptions;\n        let politeness;\n        let duration;\n        if (args.length === 1 && typeof args[0] === 'number') {\n            duration = args[0];\n        }\n        else {\n            [politeness, duration] = args;\n        }\n        this.clear();\n        clearTimeout(this._previousTimeout);\n        if (!politeness) {\n            politeness =\n                defaultOptions && defaultOptions.politeness ? defaultOptions.politeness : 'polite';\n        }\n        if (duration == null && defaultOptions) {\n            duration = defaultOptions.duration;\n        }\n        // TODO: ensure changing the politeness works on all environments we support.\n        this._liveElement.setAttribute('aria-live', politeness);\n        if (this._liveElement.id) {\n            this._exposeAnnouncerToModals(this._liveElement.id);\n        }\n        // This 100ms timeout is necessary for some browser + screen-reader combinations:\n        // - Both JAWS and NVDA over IE11 will not announce anything without a non-zero timeout.\n        // - With Chrome and IE11 with NVDA or JAWS, a repeated (identical) message won't be read a\n        //   second time without clearing and then using a non-zero delay.\n        // (using JAWS 17 at time of this writing).\n        return this._ngZone.runOutsideAngular(() => {\n            if (!this._currentPromise) {\n                this._currentPromise = new Promise(resolve => (this._currentResolve = resolve));\n            }\n            clearTimeout(this._previousTimeout);\n            this._previousTimeout = setTimeout(() => {\n                this._liveElement.textContent = message;\n                if (typeof duration === 'number') {\n                    this._previousTimeout = setTimeout(() => this.clear(), duration);\n                }\n                // For some reason in tests this can be undefined\n                // Probably related to ZoneJS and every other thing that patches browser APIs in tests\n                this._currentResolve?.();\n                this._currentPromise = this._currentResolve = undefined;\n            }, 100);\n            return this._currentPromise;\n        });\n    }\n    /**\n     * Clears the current text from the announcer element. Can be used to prevent\n     * screen readers from reading the text out again while the user is going\n     * through the page landmarks.\n     */\n    clear() {\n        if (this._liveElement) {\n            this._liveElement.textContent = '';\n        }\n    }\n    ngOnDestroy() {\n        clearTimeout(this._previousTimeout);\n        this._liveElement?.remove();\n        this._liveElement = null;\n        this._currentResolve?.();\n        this._currentPromise = this._currentResolve = undefined;\n    }\n    _createLiveElement() {\n        const elementClass = 'cdk-live-announcer-element';\n        const previousElements = this._document.getElementsByClassName(elementClass);\n        const liveEl = this._document.createElement('div');\n        // Remove any old containers. This can happen when coming in from a server-side-rendered page.\n        for (let i = 0; i < previousElements.length; i++) {\n            previousElements[i].remove();\n        }\n        liveEl.classList.add(elementClass);\n        liveEl.classList.add('cdk-visually-hidden');\n        liveEl.setAttribute('aria-atomic', 'true');\n        liveEl.setAttribute('aria-live', 'polite');\n        liveEl.id = `cdk-live-announcer-${uniqueIds++}`;\n        this._document.body.appendChild(liveEl);\n        return liveEl;\n    }\n    /**\n     * Some browsers won't expose the accessibility node of the live announcer element if there is an\n     * `aria-modal` and the live announcer is outside of it. This method works around the issue by\n     * pointing the `aria-owns` of all modals to the live announcer element.\n     */\n    _exposeAnnouncerToModals(id) {\n        // TODO(http://github.com/angular/components/issues/26853): consider de-duplicating this with\n        // the `SnakBarContainer` and other usages.\n        //\n        // Note that the selector here is limited to CDK overlays at the moment in order to reduce the\n        // section of the DOM we need to look through. This should cover all the cases we support, but\n        // the selector can be expanded if it turns out to be too narrow.\n        const modals = this._document.querySelectorAll('body > .cdk-overlay-container [aria-modal=\"true\"]');\n        for (let i = 0; i < modals.length; i++) {\n            const modal = modals[i];\n            const ariaOwns = modal.getAttribute('aria-owns');\n            if (!ariaOwns) {\n                modal.setAttribute('aria-owns', id);\n            }\n            else if (ariaOwns.indexOf(id) === -1) {\n                modal.setAttribute('aria-owns', ariaOwns + ' ' + id);\n            }\n        }\n    }\n    static Éµfac = i0.ÉµÉµngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: LiveAnnouncer, deps: [], target: i0.ÉµÉµFactoryTarget.Injectable });\n    static Éµprov = i0.ÉµÉµngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: LiveAnnouncer, providedIn: 'root' });\n}\ni0.ÉµÉµngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: LiveAnnouncer, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [] });\n/**\n * A directive that works similarly to aria-live, but uses the LiveAnnouncer to ensure compatibility\n * with a wider range of browsers and screen readers.\n */\nclass CdkAriaLive {\n    _elementRef = inject(ElementRef);\n    _liveAnnouncer = inject(LiveAnnouncer);\n    _contentObserver = inject(ContentObserver);\n    _ngZone = inject(NgZone);\n    /** The aria-live politeness level to use when announcing messages. */\n    get politeness() {\n        return this._politeness;\n    }\n    set politeness(value) {\n        this._politeness = value === 'off' || value === 'assertive' ? value : 'polite';\n        if (this._politeness === 'off') {\n            if (this._subscription) {\n                this._subscription.unsubscribe();\n                this._subscription = null;\n            }\n        }\n        else if (!this._subscription) {\n            this._subscription = this._ngZone.runOutsideAngular(() => {\n                return this._contentObserver.observe(this._elementRef).subscribe(() => {\n                    // Note that we use textContent here, rather than innerText, in order to avoid a reflow.\n                    const elementText = this._elementRef.nativeElement.textContent;\n                    // The `MutationObserver` fires also for attribute\n                    // changes which we don't want to announce.\n                    if (elementText !== this._previousAnnouncedText) {\n                        this._liveAnnouncer.announce(elementText, this._politeness, this.duration);\n                        this._previousAnnouncedText = elementText;\n                    }\n                });\n            });\n        }\n    }\n    _politeness = 'polite';\n    /** Time in milliseconds after which to clear out the announcer element. */\n    duration;\n    _previousAnnouncedText;\n    _subscription;\n    constructor() {\n        inject(_CdkPrivateStyleLoader).load(_VisuallyHiddenLoader);\n    }\n    ngOnDestroy() {\n        if (this._subscription) {\n            this._subscription.unsubscribe();\n        }\n    }\n    static Éµfac = i0.ÉµÉµngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: CdkAriaLive, deps: [], target: i0.ÉµÉµFactoryTarget.Directive });\n    static Éµdir = i0.ÉµÉµngDeclareDirective({ minVersion: \"14.0.0\", version: \"20.2.0-next.2\", type: CdkAriaLive, isStandalone: true, selector: \"[cdkAriaLive]\", inputs: { politeness: [\"cdkAriaLive\", \"politeness\"], duration: [\"cdkAriaLiveDuration\", \"duration\"] }, exportAs: [\"cdkAriaLive\"], ngImport: i0 });\n}\ni0.ÉµÉµngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: CdkAriaLive, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[cdkAriaLive]',\n                    exportAs: 'cdkAriaLive',\n                }]\n        }], ctorParameters: () => [], propDecorators: { politeness: [{\n                type: Input,\n                args: ['cdkAriaLive']\n            }], duration: [{\n                type: Input,\n                args: ['cdkAriaLiveDuration']\n            }] } });\n\n/** Set of possible high-contrast mode backgrounds. */\nvar HighContrastMode;\n(function (HighContrastMode) {\n    HighContrastMode[HighContrastMode[\"NONE\"] = 0] = \"NONE\";\n    HighContrastMode[HighContrastMode[\"BLACK_ON_WHITE\"] = 1] = \"BLACK_ON_WHITE\";\n    HighContrastMode[HighContrastMode[\"WHITE_ON_BLACK\"] = 2] = \"WHITE_ON_BLACK\";\n})(HighContrastMode || (HighContrastMode = {}));\n/** CSS class applied to the document body when in black-on-white high-contrast mode. */\nconst BLACK_ON_WHITE_CSS_CLASS = 'cdk-high-contrast-black-on-white';\n/** CSS class applied to the document body when in white-on-black high-contrast mode. */\nconst WHITE_ON_BLACK_CSS_CLASS = 'cdk-high-contrast-white-on-black';\n/** CSS class applied to the document body when in high-contrast mode. */\nconst HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS = 'cdk-high-contrast-active';\n/**\n * Service to determine whether the browser is currently in a high-contrast-mode environment.\n *\n * Microsoft Windows supports an accessibility feature called \"High Contrast Mode\". This mode\n * changes the appearance of all applications, including web applications, to dramatically increase\n * contrast.\n *\n * IE, Edge, and Firefox currently support this mode. Chrome does not support Windows High Contrast\n * Mode. This service does not detect high-contrast mode as added by the Chrome \"High Contrast\"\n * browser extension.\n */\nclass HighContrastModeDetector {\n    _platform = inject(Platform);\n    /**\n     * Figuring out the high contrast mode and adding the body classes can cause\n     * some expensive layouts. This flag is used to ensure that we only do it once.\n     */\n    _hasCheckedHighContrastMode;\n    _document = inject(DOCUMENT);\n    _breakpointSubscription;\n    constructor() {\n        this._breakpointSubscription = inject(BreakpointObserver)\n            .observe('(forced-colors: active)')\n            .subscribe(() => {\n            if (this._hasCheckedHighContrastMode) {\n                this._hasCheckedHighContrastMode = false;\n                this._applyBodyHighContrastModeCssClasses();\n            }\n        });\n    }\n    /** Gets the current high-contrast-mode for the page. */\n    getHighContrastMode() {\n        if (!this._platform.isBrowser) {\n            return HighContrastMode.NONE;\n        }\n        // Create a test element with an arbitrary background-color that is neither black nor\n        // white; high-contrast mode will coerce the color to either black or white. Also ensure that\n        // appending the test element to the DOM does not affect layout by absolutely positioning it\n        const testElement = this._document.createElement('div');\n        testElement.style.backgroundColor = 'rgb(1,2,3)';\n        testElement.style.position = 'absolute';\n        this._document.body.appendChild(testElement);\n        // Get the computed style for the background color, collapsing spaces to normalize between\n        // browsers. Once we get this color, we no longer need the test element. Access the `window`\n        // via the document so we can fake it in tests. Note that we have extra null checks, because\n        // this logic will likely run during app bootstrap and throwing can break the entire app.\n        const documentWindow = this._document.defaultView || window;\n        const computedStyle = documentWindow && documentWindow.getComputedStyle\n            ? documentWindow.getComputedStyle(testElement)\n            : null;\n        const computedColor = ((computedStyle && computedStyle.backgroundColor) || '').replace(/ /g, '');\n        testElement.remove();\n        switch (computedColor) {\n            // Pre Windows 11 dark theme.\n            case 'rgb(0,0,0)':\n            // Windows 11 dark themes.\n            case 'rgb(45,50,54)':\n            case 'rgb(32,32,32)':\n                return HighContrastMode.WHITE_ON_BLACK;\n            // Pre Windows 11 light theme.\n            case 'rgb(255,255,255)':\n            // Windows 11 light theme.\n            case 'rgb(255,250,239)':\n                return HighContrastMode.BLACK_ON_WHITE;\n        }\n        return HighContrastMode.NONE;\n    }\n    ngOnDestroy() {\n        this._breakpointSubscription.unsubscribe();\n    }\n    /** Applies CSS classes indicating high-contrast mode to document body (browser-only). */\n    _applyBodyHighContrastModeCssClasses() {\n        if (!this._hasCheckedHighContrastMode && this._platform.isBrowser && this._document.body) {\n            const bodyClasses = this._document.body.classList;\n            bodyClasses.remove(HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS, BLACK_ON_WHITE_CSS_CLASS, WHITE_ON_BLACK_CSS_CLASS);\n            this._hasCheckedHighContrastMode = true;\n            const mode = this.getHighContrastMode();\n            if (mode === HighContrastMode.BLACK_ON_WHITE) {\n                bodyClasses.add(HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS, BLACK_ON_WHITE_CSS_CLASS);\n            }\n            else if (mode === HighContrastMode.WHITE_ON_BLACK) {\n                bodyClasses.add(HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS, WHITE_ON_BLACK_CSS_CLASS);\n            }\n        }\n    }\n    static Éµfac = i0.ÉµÉµngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: HighContrastModeDetector, deps: [], target: i0.ÉµÉµFactoryTarget.Injectable });\n    static Éµprov = i0.ÉµÉµngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: HighContrastModeDetector, providedIn: 'root' });\n}\ni0.ÉµÉµngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: HighContrastModeDetector, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [] });\n\nclass A11yModule {\n    constructor() {\n        inject(HighContrastModeDetector)._applyBodyHighContrastModeCssClasses();\n    }\n    static Éµfac = i0.ÉµÉµngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: A11yModule, deps: [], target: i0.ÉµÉµFactoryTarget.NgModule });\n    static Éµmod = i0.ÉµÉµngDeclareNgModule({ minVersion: \"14.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: A11yModule, imports: [ObserversModule, CdkAriaLive, CdkTrapFocus, CdkMonitorFocus], exports: [CdkAriaLive, CdkTrapFocus, CdkMonitorFocus] });\n    static Éµinj = i0.ÉµÉµngDeclareInjector({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: A11yModule, imports: [ObserversModule] });\n}\ni0.ÉµÉµngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: A11yModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [ObserversModule, CdkAriaLive, CdkTrapFocus, CdkMonitorFocus],\n                    exports: [CdkAriaLive, CdkTrapFocus, CdkMonitorFocus],\n                }]\n        }], ctorParameters: () => [] });\n\nexport { A11yModule, CdkAriaLive, CdkTrapFocus, FocusTrap, FocusTrapFactory, HighContrastMode, HighContrastModeDetector, InteractivityChecker, IsFocusableConfig, LIVE_ANNOUNCER_DEFAULT_OPTIONS, LIVE_ANNOUNCER_ELEMENT_TOKEN, LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY, LiveAnnouncer };\n","import * as i0 from '@angular/core';\nimport { inject, CSP_NONCE, Injectable, NgZone } from '@angular/core';\nimport { Subject, combineLatest, concat, Observable } from 'rxjs';\nimport { take, skip, debounceTime, map, startWith, takeUntil } from 'rxjs/operators';\nimport { Platform } from './platform2.mjs';\nimport { coerceArray } from './array.mjs';\n\n/** Global registry for all dynamically-created, injected media queries. */\nconst mediaQueriesForWebkitCompatibility = new Set();\n/** Style tag that holds all of the dynamically-created media queries. */\nlet mediaQueryStyleNode;\n/** A utility for calling matchMedia queries. */\nclass MediaMatcher {\n    _platform = inject(Platform);\n    _nonce = inject(CSP_NONCE, { optional: true });\n    /** The internal matchMedia method to return back a MediaQueryList like object. */\n    _matchMedia;\n    constructor() {\n        this._matchMedia =\n            this._platform.isBrowser && window.matchMedia\n                ? // matchMedia is bound to the window scope intentionally as it is an illegal invocation to\n                    // call it from a different scope.\n                    window.matchMedia.bind(window)\n                : noopMatchMedia;\n    }\n    /**\n     * Evaluates the given media query and returns the native MediaQueryList from which results\n     * can be retrieved.\n     * Confirms the layout engine will trigger for the selector query provided and returns the\n     * MediaQueryList for the query provided.\n     */\n    matchMedia(query) {\n        if (this._platform.WEBKIT || this._platform.BLINK) {\n            createEmptyStyleRule(query, this._nonce);\n        }\n        return this._matchMedia(query);\n    }\n    static Éµfac = i0.ÉµÉµngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: MediaMatcher, deps: [], target: i0.ÉµÉµFactoryTarget.Injectable });\n    static Éµprov = i0.ÉµÉµngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: MediaMatcher, providedIn: 'root' });\n}\ni0.ÉµÉµngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: MediaMatcher, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [] });\n/**\n * Creates an empty stylesheet that is used to work around browser inconsistencies related to\n * `matchMedia`. At the time of writing, it handles the following cases:\n * 1. On WebKit browsers, a media query has to have at least one rule in order for `matchMedia`\n * to fire. We work around it by declaring a dummy stylesheet with a `@media` declaration.\n * 2. In some cases Blink browsers will stop firing the `matchMedia` listener if none of the rules\n * inside the `@media` match existing elements on the page. We work around it by having one rule\n * targeting the `body`. See https://github.com/angular/components/issues/23546.\n */\nfunction createEmptyStyleRule(query, nonce) {\n    if (mediaQueriesForWebkitCompatibility.has(query)) {\n        return;\n    }\n    try {\n        if (!mediaQueryStyleNode) {\n            mediaQueryStyleNode = document.createElement('style');\n            if (nonce) {\n                mediaQueryStyleNode.setAttribute('nonce', nonce);\n            }\n            mediaQueryStyleNode.setAttribute('type', 'text/css');\n            document.head.appendChild(mediaQueryStyleNode);\n        }\n        if (mediaQueryStyleNode.sheet) {\n            mediaQueryStyleNode.sheet.insertRule(`@media ${query} {body{ }}`, 0);\n            mediaQueriesForWebkitCompatibility.add(query);\n        }\n    }\n    catch (e) {\n        console.error(e);\n    }\n}\n/** No-op matchMedia replacement for non-browser platforms. */\nfunction noopMatchMedia(query) {\n    // Use `as any` here to avoid adding additional necessary properties for\n    // the noop matcher.\n    return {\n        matches: query === 'all' || query === '',\n        media: query,\n        addListener: () => { },\n        removeListener: () => { },\n    };\n}\n\n/** Utility for checking the matching state of `@media` queries. */\nclass BreakpointObserver {\n    _mediaMatcher = inject(MediaMatcher);\n    _zone = inject(NgZone);\n    /**  A map of all media queries currently being listened for. */\n    _queries = new Map();\n    /** A subject for all other observables to takeUntil based on. */\n    _destroySubject = new Subject();\n    constructor() { }\n    /** Completes the active subject, signalling to all other observables to complete. */\n    ngOnDestroy() {\n        this._destroySubject.next();\n        this._destroySubject.complete();\n    }\n    /**\n     * Whether one or more media queries match the current viewport size.\n     * @param value One or more media queries to check.\n     * @returns Whether any of the media queries match.\n     */\n    isMatched(value) {\n        const queries = splitQueries(coerceArray(value));\n        return queries.some(mediaQuery => this._registerQuery(mediaQuery).mql.matches);\n    }\n    /**\n     * Gets an observable of results for the given queries that will emit new results for any changes\n     * in matching of the given queries.\n     * @param value One or more media queries to check.\n     * @returns A stream of matches for the given queries.\n     */\n    observe(value) {\n        const queries = splitQueries(coerceArray(value));\n        const observables = queries.map(query => this._registerQuery(query).observable);\n        let stateObservable = combineLatest(observables);\n        // Emit the first state immediately, and then debounce the subsequent emissions.\n        stateObservable = concat(stateObservable.pipe(take(1)), stateObservable.pipe(skip(1), debounceTime(0)));\n        return stateObservable.pipe(map(breakpointStates => {\n            const response = {\n                matches: false,\n                breakpoints: {},\n            };\n            breakpointStates.forEach(({ matches, query }) => {\n                response.matches = response.matches || matches;\n                response.breakpoints[query] = matches;\n            });\n            return response;\n        }));\n    }\n    /** Registers a specific query to be listened for. */\n    _registerQuery(query) {\n        // Only set up a new MediaQueryList if it is not already being listened for.\n        if (this._queries.has(query)) {\n            return this._queries.get(query);\n        }\n        const mql = this._mediaMatcher.matchMedia(query);\n        // Create callback for match changes and add it is as a listener.\n        const queryObservable = new Observable((observer) => {\n            // Listener callback methods are wrapped to be placed back in ngZone. Callbacks must be placed\n            // back into the zone because matchMedia is only included in Zone.js by loading the\n            // webapis-media-query.js file alongside the zone.js file.  Additionally, some browsers do not\n            // have MediaQueryList inherit from EventTarget, which causes inconsistencies in how Zone.js\n            // patches it.\n            const handler = (e) => this._zone.run(() => observer.next(e));\n            mql.addListener(handler);\n            return () => {\n                mql.removeListener(handler);\n            };\n        }).pipe(startWith(mql), map(({ matches }) => ({ query, matches })), takeUntil(this._destroySubject));\n        // Add the MediaQueryList to the set of queries.\n        const output = { observable: queryObservable, mql };\n        this._queries.set(query, output);\n        return output;\n    }\n    static Éµfac = i0.ÉµÉµngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: BreakpointObserver, deps: [], target: i0.ÉµÉµFactoryTarget.Injectable });\n    static Éµprov = i0.ÉµÉµngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: BreakpointObserver, providedIn: 'root' });\n}\ni0.ÉµÉµngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: BreakpointObserver, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [] });\n/**\n * Split each query string into separate query strings if two queries are provided as comma\n * separated.\n */\nfunction splitQueries(queries) {\n    return queries\n        .map(query => query.split(','))\n        .reduce((a1, a2) => a1.concat(a2))\n        .map(query => query.trim());\n}\n\nexport { BreakpointObserver, MediaMatcher };\n","/** Gets whether an event could be a faked `mousedown` event dispatched by a screen reader. */\nfunction isFakeMousedownFromScreenReader(event) {\n    // Some screen readers will dispatch a fake `mousedown` event when pressing enter or space on\n    // a clickable element. We can distinguish these events when `event.buttons` is zero, or\n    // `event.detail` is zero depending on the browser:\n    // - `event.buttons` works on Firefox, but fails on Chrome.\n    // - `detail` works on Chrome, but fails on Firefox.\n    return event.buttons === 0 || event.detail === 0;\n}\n/** Gets whether an event could be a faked `touchstart` event dispatched by a screen reader. */\nfunction isFakeTouchstartFromScreenReader(event) {\n    const touch = (event.touches && event.touches[0]) || (event.changedTouches && event.changedTouches[0]);\n    // A fake `touchstart` can be distinguished from a real one by looking at the `identifier`\n    // which is typically >= 0 on a real device versus -1 from a screen reader. Just to be safe,\n    // we can also look at `radiusX` and `radiusY`. This behavior was observed against a Windows 10\n    // device with a touch screen running NVDA v2020.4 and Firefox 85 or Chrome 88.\n    return (!!touch &&\n        touch.identifier === -1 &&\n        (touch.radiusX == null || touch.radiusX === 1) &&\n        (touch.radiusY == null || touch.radiusY === 1));\n}\n\nexport { isFakeMousedownFromScreenReader, isFakeTouchstartFromScreenReader };\n","import * as i0 from '@angular/core';\nimport { InjectionToken, inject, NgZone, DOCUMENT, RendererFactory2, Injectable, ElementRef, EventEmitter, Directive, Output } from '@angular/core';\nimport { BehaviorSubject, Subject, of } from 'rxjs';\nimport { skip, distinctUntilChanged, takeUntil } from 'rxjs/operators';\nimport { isFakeMousedownFromScreenReader, isFakeTouchstartFromScreenReader } from './fake-event-detection.mjs';\nimport { ALT, CONTROL, MAC_META, META, SHIFT } from './keycodes2.mjs';\nimport { _getEventTarget, _getShadowRoot } from './shadow-dom.mjs';\nimport { Platform } from './platform2.mjs';\nimport { normalizePassiveListenerOptions } from './passive-listeners.mjs';\nimport { coerceElement } from './element.mjs';\n\n/**\n * Injectable options for the InputModalityDetector. These are shallowly merged with the default\n * options.\n */\nconst INPUT_MODALITY_DETECTOR_OPTIONS = new InjectionToken('cdk-input-modality-detector-options');\n/**\n * Default options for the InputModalityDetector.\n *\n * Modifier keys are ignored by default (i.e. when pressed won't cause the service to detect\n * keyboard input modality) for two reasons:\n *\n * 1. Modifier keys are commonly used with mouse to perform actions such as 'right click' or 'open\n *    in new tab', and are thus less representative of actual keyboard interaction.\n * 2. VoiceOver triggers some keyboard events when linearly navigating with Control + Option (but\n *    confusingly not with Caps Lock). Thus, to have parity with other screen readers, we ignore\n *    these keys so as to not update the input modality.\n *\n * Note that we do not by default ignore the right Meta key on Safari because it has the same key\n * code as the ContextMenu key on other browsers. When we switch to using event.key, we can\n * distinguish between the two.\n */\nconst INPUT_MODALITY_DETECTOR_DEFAULT_OPTIONS = {\n    ignoreKeys: [ALT, CONTROL, MAC_META, META, SHIFT],\n};\n/**\n * The amount of time needed to pass after a touchstart event in order for a subsequent mousedown\n * event to be attributed as mouse and not touch.\n *\n * This is the value used by AngularJS Material. Through trial and error (on iPhone 6S) they found\n * that a value of around 650ms seems appropriate.\n */\nconst TOUCH_BUFFER_MS = 650;\n/**\n * Event listener options that enable capturing and also mark the listener as passive if the browser\n * supports it.\n */\nconst modalityEventListenerOptions = {\n    passive: true,\n    capture: true,\n};\n/**\n * Service that detects the user's input modality.\n *\n * This service does not update the input modality when a user navigates with a screen reader\n * (e.g. linear navigation with VoiceOver, object navigation / browse mode with NVDA, virtual PC\n * cursor mode with JAWS). This is in part due to technical limitations (i.e. keyboard events do not\n * fire as expected in these modes) but is also arguably the correct behavior. Navigating with a\n * screen reader is akin to visually scanning a page, and should not be interpreted as actual user\n * input interaction.\n *\n * When a user is not navigating but *interacting* with a screen reader, this service attempts to\n * update the input modality to keyboard, but in general this service's behavior is largely\n * undefined.\n */\nclass InputModalityDetector {\n    _platform = inject(Platform);\n    _listenerCleanups;\n    /** Emits whenever an input modality is detected. */\n    modalityDetected;\n    /** Emits when the input modality changes. */\n    modalityChanged;\n    /** The most recently detected input modality. */\n    get mostRecentModality() {\n        return this._modality.value;\n    }\n    /**\n     * The most recently detected input modality event target. Is null if no input modality has been\n     * detected or if the associated event target is null for some unknown reason.\n     */\n    _mostRecentTarget = null;\n    /** The underlying BehaviorSubject that emits whenever an input modality is detected. */\n    _modality = new BehaviorSubject(null);\n    /** Options for this InputModalityDetector. */\n    _options;\n    /**\n     * The timestamp of the last touch input modality. Used to determine whether mousedown events\n     * should be attributed to mouse or touch.\n     */\n    _lastTouchMs = 0;\n    /**\n     * Handles keydown events. Must be an arrow function in order to preserve the context when it gets\n     * bound.\n     */\n    _onKeydown = (event) => {\n        // If this is one of the keys we should ignore, then ignore it and don't update the input\n        // modality to keyboard.\n        if (this._options?.ignoreKeys?.some(keyCode => keyCode === event.keyCode)) {\n            return;\n        }\n        this._modality.next('keyboard');\n        this._mostRecentTarget = _getEventTarget(event);\n    };\n    /**\n     * Handles mousedown events. Must be an arrow function in order to preserve the context when it\n     * gets bound.\n     */\n    _onMousedown = (event) => {\n        // Touches trigger both touch and mouse events, so we need to distinguish between mouse events\n        // that were triggered via mouse vs touch. To do so, check if the mouse event occurs closely\n        // after the previous touch event.\n        if (Date.now() - this._lastTouchMs < TOUCH_BUFFER_MS) {\n            return;\n        }\n        // Fake mousedown events are fired by some screen readers when controls are activated by the\n        // screen reader. Attribute them to keyboard input modality.\n        this._modality.next(isFakeMousedownFromScreenReader(event) ? 'keyboard' : 'mouse');\n        this._mostRecentTarget = _getEventTarget(event);\n    };\n    /**\n     * Handles touchstart events. Must be an arrow function in order to preserve the context when it\n     * gets bound.\n     */\n    _onTouchstart = (event) => {\n        // Same scenario as mentioned in _onMousedown, but on touch screen devices, fake touchstart\n        // events are fired. Again, attribute to keyboard input modality.\n        if (isFakeTouchstartFromScreenReader(event)) {\n            this._modality.next('keyboard');\n            return;\n        }\n        // Store the timestamp of this touch event, as it's used to distinguish between mouse events\n        // triggered via mouse vs touch.\n        this._lastTouchMs = Date.now();\n        this._modality.next('touch');\n        this._mostRecentTarget = _getEventTarget(event);\n    };\n    constructor() {\n        const ngZone = inject(NgZone);\n        const document = inject(DOCUMENT);\n        const options = inject(INPUT_MODALITY_DETECTOR_OPTIONS, { optional: true });\n        this._options = {\n            ...INPUT_MODALITY_DETECTOR_DEFAULT_OPTIONS,\n            ...options,\n        };\n        // Skip the first emission as it's null.\n        this.modalityDetected = this._modality.pipe(skip(1));\n        this.modalityChanged = this.modalityDetected.pipe(distinctUntilChanged());\n        // If we're not in a browser, this service should do nothing, as there's no relevant input\n        // modality to detect.\n        if (this._platform.isBrowser) {\n            const renderer = inject(RendererFactory2).createRenderer(null, null);\n            this._listenerCleanups = ngZone.runOutsideAngular(() => {\n                return [\n                    renderer.listen(document, 'keydown', this._onKeydown, modalityEventListenerOptions),\n                    renderer.listen(document, 'mousedown', this._onMousedown, modalityEventListenerOptions),\n                    renderer.listen(document, 'touchstart', this._onTouchstart, modalityEventListenerOptions),\n                ];\n            });\n        }\n    }\n    ngOnDestroy() {\n        this._modality.complete();\n        this._listenerCleanups?.forEach(cleanup => cleanup());\n    }\n    static Éµfac = i0.ÉµÉµngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: InputModalityDetector, deps: [], target: i0.ÉµÉµFactoryTarget.Injectable });\n    static Éµprov = i0.ÉµÉµngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: InputModalityDetector, providedIn: 'root' });\n}\ni0.ÉµÉµngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: InputModalityDetector, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [] });\n\n/** Detection mode used for attributing the origin of a focus event. */\nvar FocusMonitorDetectionMode;\n(function (FocusMonitorDetectionMode) {\n    /**\n     * Any mousedown, keydown, or touchstart event that happened in the previous\n     * tick or the current tick will be used to assign a focus event's origin (to\n     * either mouse, keyboard, or touch). This is the default option.\n     */\n    FocusMonitorDetectionMode[FocusMonitorDetectionMode[\"IMMEDIATE\"] = 0] = \"IMMEDIATE\";\n    /**\n     * A focus event's origin is always attributed to the last corresponding\n     * mousedown, keydown, or touchstart event, no matter how long ago it occurred.\n     */\n    FocusMonitorDetectionMode[FocusMonitorDetectionMode[\"EVENTUAL\"] = 1] = \"EVENTUAL\";\n})(FocusMonitorDetectionMode || (FocusMonitorDetectionMode = {}));\n/** InjectionToken for FocusMonitorOptions. */\nconst FOCUS_MONITOR_DEFAULT_OPTIONS = new InjectionToken('cdk-focus-monitor-default-options');\n/**\n * Event listener options that enable capturing and also\n * mark the listener as passive if the browser supports it.\n */\nconst captureEventListenerOptions = normalizePassiveListenerOptions({\n    passive: true,\n    capture: true,\n});\n/** Monitors mouse and keyboard events to determine the cause of focus events. */\nclass FocusMonitor {\n    _ngZone = inject(NgZone);\n    _platform = inject(Platform);\n    _inputModalityDetector = inject(InputModalityDetector);\n    /** The focus origin that the next focus event is a result of. */\n    _origin = null;\n    /** The FocusOrigin of the last focus event tracked by the FocusMonitor. */\n    _lastFocusOrigin;\n    /** Whether the window has just been focused. */\n    _windowFocused = false;\n    /** The timeout id of the window focus timeout. */\n    _windowFocusTimeoutId;\n    /** The timeout id of the origin clearing timeout. */\n    _originTimeoutId;\n    /**\n     * Whether the origin was determined via a touch interaction. Necessary as properly attributing\n     * focus events to touch interactions requires special logic.\n     */\n    _originFromTouchInteraction = false;\n    /** Map of elements being monitored to their info. */\n    _elementInfo = new Map();\n    /** The number of elements currently being monitored. */\n    _monitoredElementCount = 0;\n    /**\n     * Keeps track of the root nodes to which we've currently bound a focus/blur handler,\n     * as well as the number of monitored elements that they contain. We have to treat focus/blur\n     * handlers differently from the rest of the events, because the browser won't emit events\n     * to the document when focus moves inside of a shadow root.\n     */\n    _rootNodeFocusListenerCount = new Map();\n    /**\n     * The specified detection mode, used for attributing the origin of a focus\n     * event.\n     */\n    _detectionMode;\n    /**\n     * Event listener for `focus` events on the window.\n     * Needs to be an arrow function in order to preserve the context when it gets bound.\n     */\n    _windowFocusListener = () => {\n        // Make a note of when the window regains focus, so we can\n        // restore the origin info for the focused element.\n        this._windowFocused = true;\n        this._windowFocusTimeoutId = setTimeout(() => (this._windowFocused = false));\n    };\n    /** Used to reference correct document/window */\n    _document = inject(DOCUMENT);\n    /** Subject for stopping our InputModalityDetector subscription. */\n    _stopInputModalityDetector = new Subject();\n    constructor() {\n        const options = inject(FOCUS_MONITOR_DEFAULT_OPTIONS, {\n            optional: true,\n        });\n        this._detectionMode = options?.detectionMode || FocusMonitorDetectionMode.IMMEDIATE;\n    }\n    /**\n     * Event listener for `focus` and 'blur' events on the document.\n     * Needs to be an arrow function in order to preserve the context when it gets bound.\n     */\n    _rootNodeFocusAndBlurListener = (event) => {\n        const target = _getEventTarget(event);\n        // We need to walk up the ancestor chain in order to support `checkChildren`.\n        for (let element = target; element; element = element.parentElement) {\n            if (event.type === 'focus') {\n                this._onFocus(event, element);\n            }\n            else {\n                this._onBlur(event, element);\n            }\n        }\n    };\n    monitor(element, checkChildren = false) {\n        const nativeElement = coerceElement(element);\n        // Do nothing if we're not on the browser platform or the passed in node isn't an element.\n        if (!this._platform.isBrowser || nativeElement.nodeType !== 1) {\n            // Note: we don't want the observable to emit at all so we don't pass any parameters.\n            return of();\n        }\n        // If the element is inside the shadow DOM, we need to bind our focus/blur listeners to\n        // the shadow root, rather than the `document`, because the browser won't emit focus events\n        // to the `document`, if focus is moving within the same shadow root.\n        const rootNode = _getShadowRoot(nativeElement) || this._document;\n        const cachedInfo = this._elementInfo.get(nativeElement);\n        // Check if we're already monitoring this element.\n        if (cachedInfo) {\n            if (checkChildren) {\n                // TODO(COMP-318): this can be problematic, because it'll turn all non-checkChildren\n                // observers into ones that behave as if `checkChildren` was turned on. We need a more\n                // robust solution.\n                cachedInfo.checkChildren = true;\n            }\n            return cachedInfo.subject;\n        }\n        // Create monitored element info.\n        const info = {\n            checkChildren: checkChildren,\n            subject: new Subject(),\n            rootNode,\n        };\n        this._elementInfo.set(nativeElement, info);\n        this._registerGlobalListeners(info);\n        return info.subject;\n    }\n    stopMonitoring(element) {\n        const nativeElement = coerceElement(element);\n        const elementInfo = this._elementInfo.get(nativeElement);\n        if (elementInfo) {\n            elementInfo.subject.complete();\n            this._setClasses(nativeElement);\n            this._elementInfo.delete(nativeElement);\n            this._removeGlobalListeners(elementInfo);\n        }\n    }\n    focusVia(element, origin, options) {\n        const nativeElement = coerceElement(element);\n        const focusedElement = this._document.activeElement;\n        // If the element is focused already, calling `focus` again won't trigger the event listener\n        // which means that the focus classes won't be updated. If that's the case, update the classes\n        // directly without waiting for an event.\n        if (nativeElement === focusedElement) {\n            this._getClosestElementsInfo(nativeElement).forEach(([currentElement, info]) => this._originChanged(currentElement, origin, info));\n        }\n        else {\n            this._setOrigin(origin);\n            // `focus` isn't available on the server\n            if (typeof nativeElement.focus === 'function') {\n                nativeElement.focus(options);\n            }\n        }\n    }\n    ngOnDestroy() {\n        this._elementInfo.forEach((_info, element) => this.stopMonitoring(element));\n    }\n    /** Use defaultView of injected document if available or fallback to global window reference */\n    _getWindow() {\n        return this._document.defaultView || window;\n    }\n    _getFocusOrigin(focusEventTarget) {\n        if (this._origin) {\n            // If the origin was realized via a touch interaction, we need to perform additional checks\n            // to determine whether the focus origin should be attributed to touch or program.\n            if (this._originFromTouchInteraction) {\n                return this._shouldBeAttributedToTouch(focusEventTarget) ? 'touch' : 'program';\n            }\n            else {\n                return this._origin;\n            }\n        }\n        // If the window has just regained focus, we can restore the most recent origin from before the\n        // window blurred. Otherwise, we've reached the point where we can't identify the source of the\n        // focus. This typically means one of two things happened:\n        //\n        // 1) The element was programmatically focused, or\n        // 2) The element was focused via screen reader navigation (which generally doesn't fire\n        //    events).\n        //\n        // Because we can't distinguish between these two cases, we default to setting `program`.\n        if (this._windowFocused && this._lastFocusOrigin) {\n            return this._lastFocusOrigin;\n        }\n        // If the interaction is coming from an input label, we consider it a mouse interactions.\n        // This is a special case where focus moves on `click`, rather than `mousedown` which breaks\n        // our detection, because all our assumptions are for `mousedown`. We need to handle this\n        // special case, because it's very common for checkboxes and radio buttons.\n        if (focusEventTarget && this._isLastInteractionFromInputLabel(focusEventTarget)) {\n            return 'mouse';\n        }\n        return 'program';\n    }\n    /**\n     * Returns whether the focus event should be attributed to touch. Recall that in IMMEDIATE mode, a\n     * touch origin isn't immediately reset at the next tick (see _setOrigin). This means that when we\n     * handle a focus event following a touch interaction, we need to determine whether (1) the focus\n     * event was directly caused by the touch interaction or (2) the focus event was caused by a\n     * subsequent programmatic focus call triggered by the touch interaction.\n     * @param focusEventTarget The target of the focus event under examination.\n     */\n    _shouldBeAttributedToTouch(focusEventTarget) {\n        // Please note that this check is not perfect. Consider the following edge case:\n        //\n        // <div #parent tabindex=\"0\">\n        //   <div #child tabindex=\"0\" (click)=\"#parent.focus()\"></div>\n        // </div>\n        //\n        // Suppose there is a FocusMonitor in IMMEDIATE mode attached to #parent. When the user touches\n        // #child, #parent is programmatically focused. This code will attribute the focus to touch\n        // instead of program. This is a relatively minor edge-case that can be worked around by using\n        // focusVia(parent, 'program') to focus #parent.\n        return (this._detectionMode === FocusMonitorDetectionMode.EVENTUAL ||\n            !!focusEventTarget?.contains(this._inputModalityDetector._mostRecentTarget));\n    }\n    /**\n     * Sets the focus classes on the element based on the given focus origin.\n     * @param element The element to update the classes on.\n     * @param origin The focus origin.\n     */\n    _setClasses(element, origin) {\n        element.classList.toggle('cdk-focused', !!origin);\n        element.classList.toggle('cdk-touch-focused', origin === 'touch');\n        element.classList.toggle('cdk-keyboard-focused', origin === 'keyboard');\n        element.classList.toggle('cdk-mouse-focused', origin === 'mouse');\n        element.classList.toggle('cdk-program-focused', origin === 'program');\n    }\n    /**\n     * Updates the focus origin. If we're using immediate detection mode, we schedule an async\n     * function to clear the origin at the end of a timeout. The duration of the timeout depends on\n     * the origin being set.\n     * @param origin The origin to set.\n     * @param isFromInteraction Whether we are setting the origin from an interaction event.\n     */\n    _setOrigin(origin, isFromInteraction = false) {\n        this._ngZone.runOutsideAngular(() => {\n            this._origin = origin;\n            this._originFromTouchInteraction = origin === 'touch' && isFromInteraction;\n            // If we're in IMMEDIATE mode, reset the origin at the next tick (or in `TOUCH_BUFFER_MS` ms\n            // for a touch event). We reset the origin at the next tick because Firefox focuses one tick\n            // after the interaction event. We wait `TOUCH_BUFFER_MS` ms before resetting the origin for\n            // a touch event because when a touch event is fired, the associated focus event isn't yet in\n            // the event queue. Before doing so, clear any pending timeouts.\n            if (this._detectionMode === FocusMonitorDetectionMode.IMMEDIATE) {\n                clearTimeout(this._originTimeoutId);\n                const ms = this._originFromTouchInteraction ? TOUCH_BUFFER_MS : 1;\n                this._originTimeoutId = setTimeout(() => (this._origin = null), ms);\n            }\n        });\n    }\n    /**\n     * Handles focus events on a registered element.\n     * @param event The focus event.\n     * @param element The monitored element.\n     */\n    _onFocus(event, element) {\n        // NOTE(mmalerba): We currently set the classes based on the focus origin of the most recent\n        // focus event affecting the monitored element. If we want to use the origin of the first event\n        // instead we should check for the cdk-focused class here and return if the element already has\n        // it. (This only matters for elements that have includesChildren = true).\n        // If we are not counting child-element-focus as focused, make sure that the event target is the\n        // monitored element itself.\n        const elementInfo = this._elementInfo.get(element);\n        const focusEventTarget = _getEventTarget(event);\n        if (!elementInfo || (!elementInfo.checkChildren && element !== focusEventTarget)) {\n            return;\n        }\n        this._originChanged(element, this._getFocusOrigin(focusEventTarget), elementInfo);\n    }\n    /**\n     * Handles blur events on a registered element.\n     * @param event The blur event.\n     * @param element The monitored element.\n     */\n    _onBlur(event, element) {\n        // If we are counting child-element-focus as focused, make sure that we aren't just blurring in\n        // order to focus another child of the monitored element.\n        const elementInfo = this._elementInfo.get(element);\n        if (!elementInfo ||\n            (elementInfo.checkChildren &&\n                event.relatedTarget instanceof Node &&\n                element.contains(event.relatedTarget))) {\n            return;\n        }\n        this._setClasses(element);\n        this._emitOrigin(elementInfo, null);\n    }\n    _emitOrigin(info, origin) {\n        if (info.subject.observers.length) {\n            this._ngZone.run(() => info.subject.next(origin));\n        }\n    }\n    _registerGlobalListeners(elementInfo) {\n        if (!this._platform.isBrowser) {\n            return;\n        }\n        const rootNode = elementInfo.rootNode;\n        const rootNodeFocusListeners = this._rootNodeFocusListenerCount.get(rootNode) || 0;\n        if (!rootNodeFocusListeners) {\n            this._ngZone.runOutsideAngular(() => {\n                rootNode.addEventListener('focus', this._rootNodeFocusAndBlurListener, captureEventListenerOptions);\n                rootNode.addEventListener('blur', this._rootNodeFocusAndBlurListener, captureEventListenerOptions);\n            });\n        }\n        this._rootNodeFocusListenerCount.set(rootNode, rootNodeFocusListeners + 1);\n        // Register global listeners when first element is monitored.\n        if (++this._monitoredElementCount === 1) {\n            // Note: we listen to events in the capture phase so we\n            // can detect them even if the user stops propagation.\n            this._ngZone.runOutsideAngular(() => {\n                const window = this._getWindow();\n                window.addEventListener('focus', this._windowFocusListener);\n            });\n            // The InputModalityDetector is also just a collection of global listeners.\n            this._inputModalityDetector.modalityDetected\n                .pipe(takeUntil(this._stopInputModalityDetector))\n                .subscribe(modality => {\n                this._setOrigin(modality, true /* isFromInteraction */);\n            });\n        }\n    }\n    _removeGlobalListeners(elementInfo) {\n        const rootNode = elementInfo.rootNode;\n        if (this._rootNodeFocusListenerCount.has(rootNode)) {\n            const rootNodeFocusListeners = this._rootNodeFocusListenerCount.get(rootNode);\n            if (rootNodeFocusListeners > 1) {\n                this._rootNodeFocusListenerCount.set(rootNode, rootNodeFocusListeners - 1);\n            }\n            else {\n                rootNode.removeEventListener('focus', this._rootNodeFocusAndBlurListener, captureEventListenerOptions);\n                rootNode.removeEventListener('blur', this._rootNodeFocusAndBlurListener, captureEventListenerOptions);\n                this._rootNodeFocusListenerCount.delete(rootNode);\n            }\n        }\n        // Unregister global listeners when last element is unmonitored.\n        if (!--this._monitoredElementCount) {\n            const window = this._getWindow();\n            window.removeEventListener('focus', this._windowFocusListener);\n            // Equivalently, stop our InputModalityDetector subscription.\n            this._stopInputModalityDetector.next();\n            // Clear timeouts for all potentially pending timeouts to prevent the leaks.\n            clearTimeout(this._windowFocusTimeoutId);\n            clearTimeout(this._originTimeoutId);\n        }\n    }\n    /** Updates all the state on an element once its focus origin has changed. */\n    _originChanged(element, origin, elementInfo) {\n        this._setClasses(element, origin);\n        this._emitOrigin(elementInfo, origin);\n        this._lastFocusOrigin = origin;\n    }\n    /**\n     * Collects the `MonitoredElementInfo` of a particular element and\n     * all of its ancestors that have enabled `checkChildren`.\n     * @param element Element from which to start the search.\n     */\n    _getClosestElementsInfo(element) {\n        const results = [];\n        this._elementInfo.forEach((info, currentElement) => {\n            if (currentElement === element || (info.checkChildren && currentElement.contains(element))) {\n                results.push([currentElement, info]);\n            }\n        });\n        return results;\n    }\n    /**\n     * Returns whether an interaction is likely to have come from the user clicking the `label` of\n     * an `input` or `textarea` in order to focus it.\n     * @param focusEventTarget Target currently receiving focus.\n     */\n    _isLastInteractionFromInputLabel(focusEventTarget) {\n        const { _mostRecentTarget: mostRecentTarget, mostRecentModality } = this._inputModalityDetector;\n        // If the last interaction used the mouse on an element contained by one of the labels\n        // of an `input`/`textarea` that is currently focused, it is very likely that the\n        // user redirected focus using the label.\n        if (mostRecentModality !== 'mouse' ||\n            !mostRecentTarget ||\n            mostRecentTarget === focusEventTarget ||\n            (focusEventTarget.nodeName !== 'INPUT' && focusEventTarget.nodeName !== 'TEXTAREA') ||\n            focusEventTarget.disabled) {\n            return false;\n        }\n        const labels = focusEventTarget.labels;\n        if (labels) {\n            for (let i = 0; i < labels.length; i++) {\n                if (labels[i].contains(mostRecentTarget)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    static Éµfac = i0.ÉµÉµngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: FocusMonitor, deps: [], target: i0.ÉµÉµFactoryTarget.Injectable });\n    static Éµprov = i0.ÉµÉµngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: FocusMonitor, providedIn: 'root' });\n}\ni0.ÉµÉµngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: FocusMonitor, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [] });\n/**\n * Directive that determines how a particular element was focused (via keyboard, mouse, touch, or\n * programmatically) and adds corresponding classes to the element.\n *\n * There are two variants of this directive:\n * 1) cdkMonitorElementFocus: does not consider an element to be focused if one of its children is\n *    focused.\n * 2) cdkMonitorSubtreeFocus: considers an element focused if it or any of its children are focused.\n */\nclass CdkMonitorFocus {\n    _elementRef = inject(ElementRef);\n    _focusMonitor = inject(FocusMonitor);\n    _monitorSubscription;\n    _focusOrigin = null;\n    cdkFocusChange = new EventEmitter();\n    constructor() { }\n    get focusOrigin() {\n        return this._focusOrigin;\n    }\n    ngAfterViewInit() {\n        const element = this._elementRef.nativeElement;\n        this._monitorSubscription = this._focusMonitor\n            .monitor(element, element.nodeType === 1 && element.hasAttribute('cdkMonitorSubtreeFocus'))\n            .subscribe(origin => {\n            this._focusOrigin = origin;\n            this.cdkFocusChange.emit(origin);\n        });\n    }\n    ngOnDestroy() {\n        this._focusMonitor.stopMonitoring(this._elementRef);\n        if (this._monitorSubscription) {\n            this._monitorSubscription.unsubscribe();\n        }\n    }\n    static Éµfac = i0.ÉµÉµngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: CdkMonitorFocus, deps: [], target: i0.ÉµÉµFactoryTarget.Directive });\n    static Éµdir = i0.ÉµÉµngDeclareDirective({ minVersion: \"14.0.0\", version: \"20.2.0-next.2\", type: CdkMonitorFocus, isStandalone: true, selector: \"[cdkMonitorElementFocus], [cdkMonitorSubtreeFocus]\", outputs: { cdkFocusChange: \"cdkFocusChange\" }, exportAs: [\"cdkMonitorFocus\"], ngImport: i0 });\n}\ni0.ÉµÉµngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: CdkMonitorFocus, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[cdkMonitorElementFocus], [cdkMonitorSubtreeFocus]',\n                    exportAs: 'cdkMonitorFocus',\n                }]\n        }], ctorParameters: () => [], propDecorators: { cdkFocusChange: [{\n                type: Output\n            }] } });\n\nexport { CdkMonitorFocus, FOCUS_MONITOR_DEFAULT_OPTIONS, FocusMonitor, FocusMonitorDetectionMode, INPUT_MODALITY_DETECTOR_DEFAULT_OPTIONS, INPUT_MODALITY_DETECTOR_OPTIONS, InputModalityDetector };\n","import * as i0 from '@angular/core';\nimport { Injectable, inject, NgZone, ElementRef, EventEmitter, booleanAttribute, Directive, Output, Input, NgModule } from '@angular/core';\nimport { Observable, Subject } from 'rxjs';\nimport { map, filter, debounceTime } from 'rxjs/operators';\nimport { coerceNumberProperty, coerceElement } from './element.mjs';\n\n// Angular may add, remove, or edit comment nodes during change detection. We don't care about\n// these changes because they don't affect the user-preceived content, and worse it can cause\n// infinite change detection cycles where the change detection updates a comment, triggering the\n// MutationObserver, triggering another change detection and kicking the cycle off again.\nfunction shouldIgnoreRecord(record) {\n    // Ignore changes to comment text.\n    if (record.type === 'characterData' && record.target instanceof Comment) {\n        return true;\n    }\n    // Ignore addition / removal of comments.\n    if (record.type === 'childList') {\n        for (let i = 0; i < record.addedNodes.length; i++) {\n            if (!(record.addedNodes[i] instanceof Comment)) {\n                return false;\n            }\n        }\n        for (let i = 0; i < record.removedNodes.length; i++) {\n            if (!(record.removedNodes[i] instanceof Comment)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    // Observe everything else.\n    return false;\n}\n/**\n * Factory that creates a new MutationObserver and allows us to stub it out in unit tests.\n * @docs-private\n */\nclass MutationObserverFactory {\n    create(callback) {\n        return typeof MutationObserver === 'undefined' ? null : new MutationObserver(callback);\n    }\n    static Éµfac = i0.ÉµÉµngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: MutationObserverFactory, deps: [], target: i0.ÉµÉµFactoryTarget.Injectable });\n    static Éµprov = i0.ÉµÉµngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: MutationObserverFactory, providedIn: 'root' });\n}\ni0.ÉµÉµngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: MutationObserverFactory, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }] });\n/** An injectable service that allows watching elements for changes to their content. */\nclass ContentObserver {\n    _mutationObserverFactory = inject(MutationObserverFactory);\n    /** Keeps track of the existing MutationObservers so they can be reused. */\n    _observedElements = new Map();\n    _ngZone = inject(NgZone);\n    constructor() { }\n    ngOnDestroy() {\n        this._observedElements.forEach((_, element) => this._cleanupObserver(element));\n    }\n    observe(elementOrRef) {\n        const element = coerceElement(elementOrRef);\n        return new Observable((observer) => {\n            const stream = this._observeElement(element);\n            const subscription = stream\n                .pipe(map(records => records.filter(record => !shouldIgnoreRecord(record))), filter(records => !!records.length))\n                .subscribe(records => {\n                this._ngZone.run(() => {\n                    observer.next(records);\n                });\n            });\n            return () => {\n                subscription.unsubscribe();\n                this._unobserveElement(element);\n            };\n        });\n    }\n    /**\n     * Observes the given element by using the existing MutationObserver if available, or creating a\n     * new one if not.\n     */\n    _observeElement(element) {\n        return this._ngZone.runOutsideAngular(() => {\n            if (!this._observedElements.has(element)) {\n                const stream = new Subject();\n                const observer = this._mutationObserverFactory.create(mutations => stream.next(mutations));\n                if (observer) {\n                    observer.observe(element, {\n                        characterData: true,\n                        childList: true,\n                        subtree: true,\n                    });\n                }\n                this._observedElements.set(element, { observer, stream, count: 1 });\n            }\n            else {\n                this._observedElements.get(element).count++;\n            }\n            return this._observedElements.get(element).stream;\n        });\n    }\n    /**\n     * Un-observes the given element and cleans up the underlying MutationObserver if nobody else is\n     * observing this element.\n     */\n    _unobserveElement(element) {\n        if (this._observedElements.has(element)) {\n            this._observedElements.get(element).count--;\n            if (!this._observedElements.get(element).count) {\n                this._cleanupObserver(element);\n            }\n        }\n    }\n    /** Clean up the underlying MutationObserver for the specified element. */\n    _cleanupObserver(element) {\n        if (this._observedElements.has(element)) {\n            const { observer, stream } = this._observedElements.get(element);\n            if (observer) {\n                observer.disconnect();\n            }\n            stream.complete();\n            this._observedElements.delete(element);\n        }\n    }\n    static Éµfac = i0.ÉµÉµngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: ContentObserver, deps: [], target: i0.ÉµÉµFactoryTarget.Injectable });\n    static Éµprov = i0.ÉµÉµngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: ContentObserver, providedIn: 'root' });\n}\ni0.ÉµÉµngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: ContentObserver, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [] });\n/**\n * Directive that triggers a callback whenever the content of\n * its associated element has changed.\n */\nclass CdkObserveContent {\n    _contentObserver = inject(ContentObserver);\n    _elementRef = inject(ElementRef);\n    /** Event emitted for each change in the element's content. */\n    event = new EventEmitter();\n    /**\n     * Whether observing content is disabled. This option can be used\n     * to disconnect the underlying MutationObserver until it is needed.\n     */\n    get disabled() {\n        return this._disabled;\n    }\n    set disabled(value) {\n        this._disabled = value;\n        this._disabled ? this._unsubscribe() : this._subscribe();\n    }\n    _disabled = false;\n    /** Debounce interval for emitting the changes. */\n    get debounce() {\n        return this._debounce;\n    }\n    set debounce(value) {\n        this._debounce = coerceNumberProperty(value);\n        this._subscribe();\n    }\n    _debounce;\n    _currentSubscription = null;\n    constructor() { }\n    ngAfterContentInit() {\n        if (!this._currentSubscription && !this.disabled) {\n            this._subscribe();\n        }\n    }\n    ngOnDestroy() {\n        this._unsubscribe();\n    }\n    _subscribe() {\n        this._unsubscribe();\n        const stream = this._contentObserver.observe(this._elementRef);\n        this._currentSubscription = (this.debounce ? stream.pipe(debounceTime(this.debounce)) : stream).subscribe(this.event);\n    }\n    _unsubscribe() {\n        this._currentSubscription?.unsubscribe();\n    }\n    static Éµfac = i0.ÉµÉµngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: CdkObserveContent, deps: [], target: i0.ÉµÉµFactoryTarget.Directive });\n    static Éµdir = i0.ÉµÉµngDeclareDirective({ minVersion: \"16.1.0\", version: \"20.2.0-next.2\", type: CdkObserveContent, isStandalone: true, selector: \"[cdkObserveContent]\", inputs: { disabled: [\"cdkObserveContentDisabled\", \"disabled\", booleanAttribute], debounce: \"debounce\" }, outputs: { event: \"cdkObserveContent\" }, exportAs: [\"cdkObserveContent\"], ngImport: i0 });\n}\ni0.ÉµÉµngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: CdkObserveContent, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[cdkObserveContent]',\n                    exportAs: 'cdkObserveContent',\n                }]\n        }], ctorParameters: () => [], propDecorators: { event: [{\n                type: Output,\n                args: ['cdkObserveContent']\n            }], disabled: [{\n                type: Input,\n                args: [{ alias: 'cdkObserveContentDisabled', transform: booleanAttribute }]\n            }], debounce: [{\n                type: Input\n            }] } });\nclass ObserversModule {\n    static Éµfac = i0.ÉµÉµngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: ObserversModule, deps: [], target: i0.ÉµÉµFactoryTarget.NgModule });\n    static Éµmod = i0.ÉµÉµngDeclareNgModule({ minVersion: \"14.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: ObserversModule, imports: [CdkObserveContent], exports: [CdkObserveContent] });\n    static Éµinj = i0.ÉµÉµngDeclareInjector({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: ObserversModule, providers: [MutationObserverFactory] });\n}\ni0.ÉµÉµngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: ObserversModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [CdkObserveContent],\n                    exports: [CdkObserveContent],\n                    providers: [MutationObserverFactory],\n                }]\n        }] });\n\nexport { CdkObserveContent, ContentObserver, MutationObserverFactory, ObserversModule };\n","/** Cached result of whether the user's browser supports passive event listeners. */\nlet supportsPassiveEvents;\n/**\n * Checks whether the user's browser supports passive event listeners.\n * See: https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\n */\nfunction supportsPassiveEventListeners() {\n    if (supportsPassiveEvents == null && typeof window !== 'undefined') {\n        try {\n            window.addEventListener('test', null, Object.defineProperty({}, 'passive', {\n                get: () => (supportsPassiveEvents = true),\n            }));\n        }\n        finally {\n            supportsPassiveEvents = supportsPassiveEvents || false;\n        }\n    }\n    return supportsPassiveEvents;\n}\n/**\n * Normalizes an `AddEventListener` object to something that can be passed\n * to `addEventListener` on any browser, no matter whether it supports the\n * `options` parameter.\n * @param options Object to be normalized.\n */\nfunction normalizePassiveListenerOptions(options) {\n    return supportsPassiveEventListeners() ? options : !!options.capture;\n}\n\nexport { normalizePassiveListenerOptions, supportsPassiveEventListeners };\n","export { _CdkPrivateStyleLoader } from './style-loader.mjs';\nimport * as i0 from '@angular/core';\nimport { Component, ViewEncapsulation, ChangeDetectionStrategy } from '@angular/core';\n\n/**\n * Component used to load the .cdk-visually-hidden styles.\n * @docs-private\n */\nclass _VisuallyHiddenLoader {\n    static Éµfac = i0.ÉµÉµngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: _VisuallyHiddenLoader, deps: [], target: i0.ÉµÉµFactoryTarget.Component });\n    static Éµcmp = i0.ÉµÉµngDeclareComponent({ minVersion: \"14.0.0\", version: \"20.2.0-next.2\", type: _VisuallyHiddenLoader, isStandalone: true, selector: \"ng-component\", exportAs: [\"cdkVisuallyHidden\"], ngImport: i0, template: '', isInline: true, styles: [\".cdk-visually-hidden{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px;white-space:nowrap;outline:0;-webkit-appearance:none;-moz-appearance:none;left:0}[dir=rtl] .cdk-visually-hidden{left:auto;right:0}\\n\"], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None });\n}\ni0.ÉµÉµngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: _VisuallyHiddenLoader, decorators: [{\n            type: Component,\n            args: [{ exportAs: 'cdkVisuallyHidden', encapsulation: ViewEncapsulation.None, template: '', changeDetection: ChangeDetectionStrategy.OnPush, styles: [\".cdk-visually-hidden{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px;white-space:nowrap;outline:0;-webkit-appearance:none;-moz-appearance:none;left:0}[dir=rtl] .cdk-visually-hidden{left:auto;right:0}\\n\"] }]\n        }] });\n\nexport { _VisuallyHiddenLoader };\n"],"x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12]}