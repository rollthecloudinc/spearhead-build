{"version":3,"file":"2714.51824f435e8cb6d7.js","mappings":"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","names":["BehaviorSubject","_Subject","_value","_this","_classCallCheck","this","_callSuper","_inherits","_createClass","key","get","getValue","value","subscriber","subscription","_superPropGet","closed","next","hasError","thrownError","_throwIfClosed","Subject","ConnectableObservable","_Observable","source","subjectFactory","_subject","_refCount","_connection","hasLift","lift","getSubject","subscribe","subject","isStopped","unsubscribe","_this2","connection","Subscription","add","createOperatorSubscriber","undefined","_teardown","complete","err","error","EMPTY","higherOrderRefCount","Observable","combineLatest","_len","arguments","length","args","Array","_key","scheduler","popScheduler","resultSelector","popResultSelector","_argsArgArrayOrObject","argsArgArrayOrObject","observables","keys","from","result","combineLatestInit","valueTransform","identity","maybeSchedule","values","active","remainingFirstValues","_loop","i","hasFirstValue","slice","createObject","pipe","mapOneOrManyArgs","execute","executeSchedule","concatMap","project","isFunction","mergeMap","reduce","accumulator","seed","operate","scanInternals","refCount","refCounter","sharedConnection","conn","connect","hasSeed","emitOnNext","emitBeforeComplete","hasState","state","index","switchMap","innerSubscriber","isComplete","checkComplete","innerIndex","outerIndex","innerFrom","innerValue","isArray","getPrototypeOf","Object","objectProto","prototype","getKeys","first","isPOJO","obj","map","fn","callOrApply","apply","_toConsumableArray","DataSource","isDataSource","DIR_DOCUMENT","InjectionToken","providedIn","factory","DIR_DOCUMENT_FACTORY","inject","DOCUMENT","RTL_LOCALE_PATTERN","_resolveDirectionality","rawValue","_navigator","toLowerCase","navigator","language","test","Directionality","_Directionality","_defineProperty","signal","concat","EventEmitter","_document","optional","valueSignal","set","body","dir","documentElement","change","__ngFactoryType__","i0","token","Éµfac","SelectionModel","_multiple","initiallySelectedValues","_emitChanges","compareWith","Set","forEach","_markSelected","_selectedToEmit","_selected","_selection","_verifyValueAssignment","changed","_hasQueuedChanges","_emitChangeEvent","_this3","_len2","_key2","_unmarkSelected","_this4","_len3","_key3","oldValues","selected","newSelectedSet","_getConcreteValue","filter","has","isSelected","deselect","select","flushEvent","_unmarkAll","size","isEmpty","predicate","sort","_deselectedToEmit","added","removed","push","delete","_this5","inputValue","selection","_step","_iterator","_createForOfIteratorHelper","s","n","done","selectedValue","e","f","getMultipleValuesInSingleSelectionError","Error","BaseTreeControl","dataNode","expansionModel","toggle","_trackByValue","collapseDescendants","expandDescendants","clear","_this$expansionModel","toBeProcessed","getDescendants","_this$expansionModel2","trackBy","FlatTreeControl","_BaseTreeControl2","getLevel","isExpandable","options","results","dataNodes","indexOf","_this$expansionModel3","node","NestedTreeControl","_BaseTreeControl3","getChildren","_this5$options","_this$expansionModel4","_this6","allNodes","descendants","_getDescendants","splice","_this7","childrenNodes","child","isObservable","take","Boolean","children","CDK_TREE_NODE_OUTLET_NODE","CdkTreeNodeOutlet","_CdkTreeNodeOutlet","ViewContainerRef","type","selectors","CdkTreeNodeOutletContext","data","$implicit","CdkTreeNodeDef","_CdkTreeNodeDef","TemplateRef","inputs","when","getTreeNoValidDataSourceError","getTreeMultipleDefaultNodeDefsError","getTreeMissingMatchingNodeDefError","getTreeControlMissingError","getMultipleTreeControlsError","CdkTree","_CdkTree","IterableDiffers","ChangeDetectorRef","ElementRef","Map","start","end","Number","MAX_VALUE","TREE_KEY_MANAGER","_dataSource","dataSource","_switchDataSource","_initializeKeyManager","_updateDefaultNodeDefinition","_subscribeToDataChanges","_this$_keyManager","_nodeOutlet","viewContainer","_nodes","_keyManagerNodes","_nodeType","_flattenedNodes","viewChange","_onDestroy","disconnect","_dataSubscription","_keyManager","destroy","_checkTreeControlUsage","_initializeDataDiffer","_viewInit","defaultNodeDefs","_nodeDefs","def","_defaultNodeDef","newType","_this$_expansionModel","treeControl","_expansionModel","dataStream","_this8","of","_getRenderData","takeUntil","renderingData","_renderDataChanges","_this9","_getExpansionModel","startWith","tap","expansionChanges","_emitExpansionChanges","_ref","_ref2","_slicedToArray","nodeType","renderNodes","flattenedNodes","_computeRenderingData","convertedData","_objectSpread","_updateCachedData","renderNodeChanges","_updateKeyManagerItems","_step2","nodes","_iterator2","_emitExpansionState","_step3","_iterator3","_this0","items","_ref3","_ref4","_getExpansionKey","_keyManagerFactory","skipPredicate","isDisabled","typeAheadDebounceInterval","horizontalOrientation","_dir","_this$trackBy","_this1","_index","item","_dataDiffer","_differs","find","create","_this10","parentData","changes","diff","forEachOperation","adjustedPreviousIndex","currentIndex","previousIndex","insertNode","remove","view","move","forEachIdentityChange","record","newData","context","_changeDetectorRef","markForCheck","detectChanges","nodeData","_this$_parents$get","levelAccessor","_getLevelAccessor","_getNodeDef","_parents","level","_levels","createEmbeddedView","template","CdkTreeNode","mostRecentTreeNode","_this$treeControl","_this$_expansionModel2","isExpanded","expand","collapse","toggleDescendants","_this11","_this12","_this13","expandAll","_forEachExpansionKey","_this13$_expansionMod","_this14","collapseAll","_this14$_expansionMod","_this$treeControl$get","_this$treeControl2","bind","_this$treeControl$get2","_this$treeControl3","childrenAccessor","_this$_expansionModel3","_this$treeControl4","_this15","includes","_ref5","_ref6","_findChildrenByLevel","_childrenAccessor","_getChildrenAccessor","coerceObservable","levelDelta","_this16","startIndex","findIndex","dataNodeLevel","expectedLevel","currentLevel","_getAriaSet","_this17","parent","_this18","_getDirectChildren","event","target","_elementRef","nativeElement","onKeydown","_step4","_iterator4","_step4$value","Infinity","_getAllChildrenRecursively","allChildren","nextChildren","_this19","_step5","_iterator5","_this$expansionKey","_this$expansionKey2","expansionKey","call","parentKey","_ariaSets","cachedNodes","_this$_levels$get","parentIndex","_this$_levels$get2","parentNode","_this20","childNodes","_step6","_iterator6","childKey","_flattenNestedNodesWithExpansion","nestedNodes","_this21","_clearPreviousCache","rootNodes","_ref7","_calculateParents","_ref8","_this$_ariaSets$get","_findParentForNode","group","callback","_this22","toToggle","inner","r","contentQueries","rf","ctx","dirIndex","_t","viewQuery","hostAttrs","hostBindings","$event","_sendKeydownToKeyManager","exportAs","decls","vars","consts","dependencies","encapsulation","_CdkTreeNode","_role","_isExpandable","_inputIsExpandable","_inputIsExpanded","_tree","_data","_this$_elementRef$nat","typeaheadLabel","textContent","trim","_dataChanges","_this$_tree$treeContr","_this$_tree$treeContr2","_this$_tree$treeContr3","_this$_tree$_getLevel","_getLevel","_parentNodeAriaLevel","isLeafNode","String","_getSetSize","_getPositionInSet","_this23","getParentNodeAriaLevel","nodeElement","parentElement","isNodeElement","classList","contains","numberAttribute","getAttribute","distinctUntilChanged","_destroyed","_setNodeTypeIfUnset","_type","_registerNode","_this$_tree$_getNodeP","_getNodeParent","_getNodeChildren","_tabindex","_shouldFocus","focus","activation","focusItem","expanded","expandedChange","emit","hostVars","_setActiveItem","_focusItem","_getAriaExpanded","role","booleanAttribute","outputs","element","CdkNestedTreeNode","_CdkNestedTreeNode","_CdkTreeNode2","_this24","_this25","updateChildrenNodes","nodeOutlet","_clear","outlet","_getNodeOutlet","_children","_this26","outlets","_node","features","provide","useExisting","cssUnitPattern","CdkTreeNodePadding","_CdkTreeNodePadding","_this$_dir","_this27","_setPadding","_treeNode","_level","_setLevelInput","_indent","indent","_setIndentInput","_ref9","nodeLevel","indentUnits","forceChange","padding","_paddingIndent","_currentPadding","_element","paddingProp","resetProp","style","isNaN","units","parts","split","CdkTreeNodeToggle","_CdkTreeNodeToggle","recursive","_toggle","stopPropagation","preventDefault","CdkTreeModule","_CdkTreeModule"],"ignoreList":[],"sourceRoot":"webpack:///","sources":["./node_modules/rxjs/dist/esm/internal/BehaviorSubject.js","./node_modules/rxjs/dist/esm/internal/observable/ConnectableObservable.js","./node_modules/rxjs/dist/esm/internal/observable/combineLatest.js","./node_modules/rxjs/dist/esm/internal/operators/concatMap.js","./node_modules/rxjs/dist/esm/internal/operators/reduce.js","./node_modules/rxjs/dist/esm/internal/operators/refCount.js","./node_modules/rxjs/dist/esm/internal/operators/scanInternals.js","./node_modules/rxjs/dist/esm/internal/operators/switchMap.js","./node_modules/rxjs/dist/esm/internal/util/argsArgArrayOrObject.js","./node_modules/rxjs/dist/esm/internal/util/createObject.js","./node_modules/rxjs/dist/esm/internal/util/mapOneOrManyArgs.js","./node_modules/@angular/cdk/fesm2022/data-source.mjs","./node_modules/@angular/cdk/fesm2022/directionality.mjs","./node_modules/@angular/cdk/fesm2022/selection-model.mjs","./node_modules/@angular/cdk/fesm2022/tree.mjs"],"sourcesContent":["import { Subject } from './Subject';\nexport class BehaviorSubject extends Subject {\n    constructor(_value) {\n        super();\n        this._value = _value;\n    }\n    get value() {\n        return this.getValue();\n    }\n    _subscribe(subscriber) {\n        const subscription = super._subscribe(subscriber);\n        !subscription.closed && subscriber.next(this._value);\n        return subscription;\n    }\n    getValue() {\n        const { hasError, thrownError, _value } = this;\n        if (hasError) {\n            throw thrownError;\n        }\n        this._throwIfClosed();\n        return _value;\n    }\n    next(value) {\n        super.next((this._value = value));\n    }\n}\n","import { Observable } from '../Observable';\nimport { Subscription } from '../Subscription';\nimport { refCount as higherOrderRefCount } from '../operators/refCount';\nimport { createOperatorSubscriber } from '../operators/OperatorSubscriber';\nimport { hasLift } from '../util/lift';\nexport class ConnectableObservable extends Observable {\n    constructor(source, subjectFactory) {\n        super();\n        this.source = source;\n        this.subjectFactory = subjectFactory;\n        this._subject = null;\n        this._refCount = 0;\n        this._connection = null;\n        if (hasLift(source)) {\n            this.lift = source.lift;\n        }\n    }\n    _subscribe(subscriber) {\n        return this.getSubject().subscribe(subscriber);\n    }\n    getSubject() {\n        const subject = this._subject;\n        if (!subject || subject.isStopped) {\n            this._subject = this.subjectFactory();\n        }\n        return this._subject;\n    }\n    _teardown() {\n        this._refCount = 0;\n        const { _connection } = this;\n        this._subject = this._connection = null;\n        _connection === null || _connection === void 0 ? void 0 : _connection.unsubscribe();\n    }\n    connect() {\n        let connection = this._connection;\n        if (!connection) {\n            connection = this._connection = new Subscription();\n            const subject = this.getSubject();\n            connection.add(this.source.subscribe(createOperatorSubscriber(subject, undefined, () => {\n                this._teardown();\n                subject.complete();\n            }, (err) => {\n                this._teardown();\n                subject.error(err);\n            }, () => this._teardown())));\n            if (connection.closed) {\n                this._connection = null;\n                connection = Subscription.EMPTY;\n            }\n        }\n        return connection;\n    }\n    refCount() {\n        return higherOrderRefCount()(this);\n    }\n}\n","import { Observable } from '../Observable';\nimport { argsArgArrayOrObject } from '../util/argsArgArrayOrObject';\nimport { from } from './from';\nimport { identity } from '../util/identity';\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\nimport { popResultSelector, popScheduler } from '../util/args';\nimport { createObject } from '../util/createObject';\nimport { createOperatorSubscriber } from '../operators/OperatorSubscriber';\nimport { executeSchedule } from '../util/executeSchedule';\nexport function combineLatest(...args) {\n    const scheduler = popScheduler(args);\n    const resultSelector = popResultSelector(args);\n    const { args: observables, keys } = argsArgArrayOrObject(args);\n    if (observables.length === 0) {\n        return from([], scheduler);\n    }\n    const result = new Observable(combineLatestInit(observables, scheduler, keys\n        ?\n            (values) => createObject(keys, values)\n        :\n            identity));\n    return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;\n}\nexport function combineLatestInit(observables, scheduler, valueTransform = identity) {\n    return (subscriber) => {\n        maybeSchedule(scheduler, () => {\n            const { length } = observables;\n            const values = new Array(length);\n            let active = length;\n            let remainingFirstValues = length;\n            for (let i = 0; i < length; i++) {\n                maybeSchedule(scheduler, () => {\n                    const source = from(observables[i], scheduler);\n                    let hasFirstValue = false;\n                    source.subscribe(createOperatorSubscriber(subscriber, (value) => {\n                        values[i] = value;\n                        if (!hasFirstValue) {\n                            hasFirstValue = true;\n                            remainingFirstValues--;\n                        }\n                        if (!remainingFirstValues) {\n                            subscriber.next(valueTransform(values.slice()));\n                        }\n                    }, () => {\n                        if (!--active) {\n                            subscriber.complete();\n                        }\n                    }));\n                }, subscriber);\n            }\n        }, subscriber);\n    };\n}\nfunction maybeSchedule(scheduler, execute, subscription) {\n    if (scheduler) {\n        executeSchedule(subscription, scheduler, execute);\n    }\n    else {\n        execute();\n    }\n}\n","import { mergeMap } from './mergeMap';\nimport { isFunction } from '../util/isFunction';\nexport function concatMap(project, resultSelector) {\n    return isFunction(resultSelector) ? mergeMap(project, resultSelector, 1) : mergeMap(project, 1);\n}\n","import { scanInternals } from './scanInternals';\nimport { operate } from '../util/lift';\nexport function reduce(accumulator, seed) {\n    return operate(scanInternals(accumulator, seed, arguments.length >= 2, false, true));\n}\n","import { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function refCount() {\n    return operate((source, subscriber) => {\n        let connection = null;\n        source._refCount++;\n        const refCounter = createOperatorSubscriber(subscriber, undefined, undefined, undefined, () => {\n            if (!source || source._refCount <= 0 || 0 < --source._refCount) {\n                connection = null;\n                return;\n            }\n            const sharedConnection = source._connection;\n            const conn = connection;\n            connection = null;\n            if (sharedConnection && (!conn || sharedConnection === conn)) {\n                sharedConnection.unsubscribe();\n            }\n            subscriber.unsubscribe();\n        });\n        source.subscribe(refCounter);\n        if (!refCounter.closed) {\n            connection = source.connect();\n        }\n    });\n}\n","import { createOperatorSubscriber } from './OperatorSubscriber';\nexport function scanInternals(accumulator, seed, hasSeed, emitOnNext, emitBeforeComplete) {\n    return (source, subscriber) => {\n        let hasState = hasSeed;\n        let state = seed;\n        let index = 0;\n        source.subscribe(createOperatorSubscriber(subscriber, (value) => {\n            const i = index++;\n            state = hasState\n                ?\n                    accumulator(state, value, i)\n                :\n                    ((hasState = true), value);\n            emitOnNext && subscriber.next(state);\n        }, emitBeforeComplete &&\n            (() => {\n                hasState && subscriber.next(state);\n                subscriber.complete();\n            })));\n    };\n}\n","import { innerFrom } from '../observable/innerFrom';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function switchMap(project, resultSelector) {\n    return operate((source, subscriber) => {\n        let innerSubscriber = null;\n        let index = 0;\n        let isComplete = false;\n        const checkComplete = () => isComplete && !innerSubscriber && subscriber.complete();\n        source.subscribe(createOperatorSubscriber(subscriber, (value) => {\n            innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();\n            let innerIndex = 0;\n            const outerIndex = index++;\n            innerFrom(project(value, outerIndex)).subscribe((innerSubscriber = createOperatorSubscriber(subscriber, (innerValue) => subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue), () => {\n                innerSubscriber = null;\n                checkComplete();\n            })));\n        }, () => {\n            isComplete = true;\n            checkComplete();\n        }));\n    });\n}\n","const { isArray } = Array;\nconst { getPrototypeOf, prototype: objectProto, keys: getKeys } = Object;\nexport function argsArgArrayOrObject(args) {\n    if (args.length === 1) {\n        const first = args[0];\n        if (isArray(first)) {\n            return { args: first, keys: null };\n        }\n        if (isPOJO(first)) {\n            const keys = getKeys(first);\n            return {\n                args: keys.map((key) => first[key]),\n                keys,\n            };\n        }\n    }\n    return { args: args, keys: null };\n}\nfunction isPOJO(obj) {\n    return obj && typeof obj === 'object' && getPrototypeOf(obj) === objectProto;\n}\n","export function createObject(keys, values) {\n    return keys.reduce((result, key, i) => ((result[key] = values[i]), result), {});\n}\n","import { map } from \"../operators/map\";\nconst { isArray } = Array;\nfunction callOrApply(fn, args) {\n    return isArray(args) ? fn(...args) : fn(args);\n}\nexport function mapOneOrManyArgs(fn) {\n    return map(args => callOrApply(fn, args));\n}\n","import { ConnectableObservable } from 'rxjs';\n\nclass DataSource {\n}\n/** Checks whether an object is a data source. */\nfunction isDataSource(value) {\n    // Check if the value is a DataSource by observing if it has a connect function. Cannot\n    // be checked as an `instanceof DataSource` since people could create their own sources\n    // that match the interface, but don't extend DataSource. We also can't use `isObservable`\n    // here, because of some internal apps.\n    return value && typeof value.connect === 'function' && !(value instanceof ConnectableObservable);\n}\n\nexport { DataSource, isDataSource };\n","import * as i0 from '@angular/core';\nimport { InjectionToken, inject, DOCUMENT, signal, EventEmitter, Injectable } from '@angular/core';\n\n/**\n * Injection token used to inject the document into Directionality.\n * This is used so that the value can be faked in tests.\n *\n * We can't use the real document in tests because changing the real `dir` causes geometry-based\n * tests in Safari to fail.\n *\n * We also can't re-provide the DOCUMENT token from platform-browser because the unit tests\n * themselves use things like `querySelector` in test code.\n *\n * This token is defined in a separate file from Directionality as a workaround for\n * https://github.com/angular/angular/issues/22559\n *\n * @docs-private\n */\nconst DIR_DOCUMENT = new InjectionToken('cdk-dir-doc', {\n    providedIn: 'root',\n    factory: DIR_DOCUMENT_FACTORY,\n});\n/**\n * @docs-private\n * @deprecated No longer used, will be removed.\n * @breaking-change 21.0.0\n */\nfunction DIR_DOCUMENT_FACTORY() {\n    return inject(DOCUMENT);\n}\n\n/** Regex that matches locales with an RTL script. Taken from `goog.i18n.bidi.isRtlLanguage`. */\nconst RTL_LOCALE_PATTERN = /^(ar|ckb|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|.*[-_](Adlm|Arab|Hebr|Nkoo|Rohg|Thaa))(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)/i;\n/** Resolves a string value to a specific direction. */\nfunction _resolveDirectionality(rawValue) {\n    const value = rawValue?.toLowerCase() || '';\n    if (value === 'auto' && typeof navigator !== 'undefined' && navigator?.language) {\n        return RTL_LOCALE_PATTERN.test(navigator.language) ? 'rtl' : 'ltr';\n    }\n    return value === 'rtl' ? 'rtl' : 'ltr';\n}\n/**\n * The directionality (LTR / RTL) context for the application (or a subtree of it).\n * Exposes the current direction and a stream of direction changes.\n */\nclass Directionality {\n    /** The current 'ltr' or 'rtl' value. */\n    get value() {\n        return this.valueSignal();\n    }\n    /**\n     * The current 'ltr' or 'rtl' value.\n     */\n    valueSignal = signal('ltr', ...(ngDevMode ? [{ debugName: \"valueSignal\" }] : []));\n    /** Stream that emits whenever the 'ltr' / 'rtl' state changes. */\n    change = new EventEmitter();\n    constructor() {\n        const _document = inject(DIR_DOCUMENT, { optional: true });\n        if (_document) {\n            const bodyDir = _document.body ? _document.body.dir : null;\n            const htmlDir = _document.documentElement ? _document.documentElement.dir : null;\n            this.valueSignal.set(_resolveDirectionality(bodyDir || htmlDir || 'ltr'));\n        }\n    }\n    ngOnDestroy() {\n        this.change.complete();\n    }\n    static Éµfac = i0.ÉµÉµngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: Directionality, deps: [], target: i0.ÉµÉµFactoryTarget.Injectable });\n    static Éµprov = i0.ÉµÉµngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: Directionality, providedIn: 'root' });\n}\ni0.ÉµÉµngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: Directionality, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [] });\n\nexport { DIR_DOCUMENT, Directionality, _resolveDirectionality };\n","import { Subject } from 'rxjs';\n\n/**\n * Class to be used to power selecting one or more options from a list.\n */\nclass SelectionModel {\n    _multiple;\n    _emitChanges;\n    compareWith;\n    /** Currently-selected values. */\n    _selection = new Set();\n    /** Keeps track of the deselected options that haven't been emitted by the change event. */\n    _deselectedToEmit = [];\n    /** Keeps track of the selected options that haven't been emitted by the change event. */\n    _selectedToEmit = [];\n    /** Cache for the array value of the selected items. */\n    _selected;\n    /** Selected values. */\n    get selected() {\n        if (!this._selected) {\n            this._selected = Array.from(this._selection.values());\n        }\n        return this._selected;\n    }\n    /** Event emitted when the value has changed. */\n    changed = new Subject();\n    constructor(_multiple = false, initiallySelectedValues, _emitChanges = true, compareWith) {\n        this._multiple = _multiple;\n        this._emitChanges = _emitChanges;\n        this.compareWith = compareWith;\n        if (initiallySelectedValues && initiallySelectedValues.length) {\n            if (_multiple) {\n                initiallySelectedValues.forEach(value => this._markSelected(value));\n            }\n            else {\n                this._markSelected(initiallySelectedValues[0]);\n            }\n            // Clear the array in order to avoid firing the change event for preselected values.\n            this._selectedToEmit.length = 0;\n        }\n    }\n    /**\n     * Selects a value or an array of values.\n     * @param values The values to select\n     * @return Whether the selection changed as a result of this call\n     */\n    select(...values) {\n        this._verifyValueAssignment(values);\n        values.forEach(value => this._markSelected(value));\n        const changed = this._hasQueuedChanges();\n        this._emitChangeEvent();\n        return changed;\n    }\n    /**\n     * Deselects a value or an array of values.\n     * @param values The values to deselect\n     * @return Whether the selection changed as a result of this call\n     */\n    deselect(...values) {\n        this._verifyValueAssignment(values);\n        values.forEach(value => this._unmarkSelected(value));\n        const changed = this._hasQueuedChanges();\n        this._emitChangeEvent();\n        return changed;\n    }\n    /**\n     * Sets the selected values\n     * @param values The new selected values\n     * @return Whether the selection changed as a result of this call\n     */\n    setSelection(...values) {\n        this._verifyValueAssignment(values);\n        const oldValues = this.selected;\n        const newSelectedSet = new Set(values.map(value => this._getConcreteValue(value)));\n        values.forEach(value => this._markSelected(value));\n        oldValues\n            .filter(value => !newSelectedSet.has(this._getConcreteValue(value, newSelectedSet)))\n            .forEach(value => this._unmarkSelected(value));\n        const changed = this._hasQueuedChanges();\n        this._emitChangeEvent();\n        return changed;\n    }\n    /**\n     * Toggles a value between selected and deselected.\n     * @param value The value to toggle\n     * @return Whether the selection changed as a result of this call\n     */\n    toggle(value) {\n        return this.isSelected(value) ? this.deselect(value) : this.select(value);\n    }\n    /**\n     * Clears all of the selected values.\n     * @param flushEvent Whether to flush the changes in an event.\n     *   If false, the changes to the selection will be flushed along with the next event.\n     * @return Whether the selection changed as a result of this call\n     */\n    clear(flushEvent = true) {\n        this._unmarkAll();\n        const changed = this._hasQueuedChanges();\n        if (flushEvent) {\n            this._emitChangeEvent();\n        }\n        return changed;\n    }\n    /**\n     * Determines whether a value is selected.\n     */\n    isSelected(value) {\n        return this._selection.has(this._getConcreteValue(value));\n    }\n    /**\n     * Determines whether the model does not have a value.\n     */\n    isEmpty() {\n        return this._selection.size === 0;\n    }\n    /**\n     * Determines whether the model has a value.\n     */\n    hasValue() {\n        return !this.isEmpty();\n    }\n    /**\n     * Sorts the selected values based on a predicate function.\n     */\n    sort(predicate) {\n        if (this._multiple && this.selected) {\n            this._selected.sort(predicate);\n        }\n    }\n    /**\n     * Gets whether multiple values can be selected.\n     */\n    isMultipleSelection() {\n        return this._multiple;\n    }\n    /** Emits a change event and clears the records of selected and deselected values. */\n    _emitChangeEvent() {\n        // Clear the selected values so they can be re-cached.\n        this._selected = null;\n        if (this._selectedToEmit.length || this._deselectedToEmit.length) {\n            this.changed.next({\n                source: this,\n                added: this._selectedToEmit,\n                removed: this._deselectedToEmit,\n            });\n            this._deselectedToEmit = [];\n            this._selectedToEmit = [];\n        }\n    }\n    /** Selects a value. */\n    _markSelected(value) {\n        value = this._getConcreteValue(value);\n        if (!this.isSelected(value)) {\n            if (!this._multiple) {\n                this._unmarkAll();\n            }\n            if (!this.isSelected(value)) {\n                this._selection.add(value);\n            }\n            if (this._emitChanges) {\n                this._selectedToEmit.push(value);\n            }\n        }\n    }\n    /** Deselects a value. */\n    _unmarkSelected(value) {\n        value = this._getConcreteValue(value);\n        if (this.isSelected(value)) {\n            this._selection.delete(value);\n            if (this._emitChanges) {\n                this._deselectedToEmit.push(value);\n            }\n        }\n    }\n    /** Clears out the selected values. */\n    _unmarkAll() {\n        if (!this.isEmpty()) {\n            this._selection.forEach(value => this._unmarkSelected(value));\n        }\n    }\n    /**\n     * Verifies the value assignment and throws an error if the specified value array is\n     * including multiple values while the selection model is not supporting multiple values.\n     */\n    _verifyValueAssignment(values) {\n        if (values.length > 1 && !this._multiple && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            throw getMultipleValuesInSingleSelectionError();\n        }\n    }\n    /** Whether there are queued up change to be emitted. */\n    _hasQueuedChanges() {\n        return !!(this._deselectedToEmit.length || this._selectedToEmit.length);\n    }\n    /** Returns a value that is comparable to inputValue by applying compareWith function, returns the same inputValue otherwise. */\n    _getConcreteValue(inputValue, selection) {\n        if (!this.compareWith) {\n            return inputValue;\n        }\n        else {\n            selection = selection ?? this._selection;\n            for (let selectedValue of selection) {\n                if (this.compareWith(inputValue, selectedValue)) {\n                    return selectedValue;\n                }\n            }\n            return inputValue;\n        }\n    }\n}\n/**\n * Returns an error that reports that multiple values are passed into a selection model\n * with a single value.\n * @docs-private\n */\nfunction getMultipleValuesInSingleSelectionError() {\n    return Error('Cannot pass multiple values into SelectionModel with single-value mode.');\n}\n\nexport { SelectionModel, getMultipleValuesInSingleSelectionError };\n","import { SelectionModel } from './selection-model.mjs';\nimport { isObservable, Subject, BehaviorSubject, of, combineLatest, EMPTY, concat } from 'rxjs';\nimport { take, filter, takeUntil, startWith, tap, switchMap, map, reduce, concatMap, distinctUntilChanged } from 'rxjs/operators';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, inject, ViewContainerRef, Directive, TemplateRef, IterableDiffers, ChangeDetectorRef, ElementRef, Component, ViewEncapsulation, ChangeDetectionStrategy, Input, ViewChild, ContentChildren, EventEmitter, booleanAttribute, Output, numberAttribute, NgModule } from '@angular/core';\nimport { TREE_KEY_MANAGER } from './tree-key-manager.mjs';\nimport { Directionality } from './directionality.mjs';\nimport { isDataSource } from './data-source.mjs';\nimport { coerceObservable } from './coercion/private.mjs';\nimport './typeahead.mjs';\nimport './keycodes2.mjs';\n\n/**\n * Base tree control. It has basic toggle/expand/collapse operations on a single data node.\n *\n * @deprecated Use one of levelAccessor or childrenAccessor. To be removed in a future version.\n * @breaking-change 21.0.0\n */\nclass BaseTreeControl {\n    /** Saved data node for `expandAll` action. */\n    dataNodes;\n    /** A selection model with multi-selection to track expansion status. */\n    expansionModel = new SelectionModel(true);\n    /**\n     * Returns the identifier by which a dataNode should be tracked, should its\n     * reference change.\n     *\n     * Similar to trackBy for *ngFor\n     */\n    trackBy;\n    /** Get depth of a given data node, return the level number. This is for flat tree node. */\n    getLevel;\n    /**\n     * Whether the data node is expandable. Returns true if expandable.\n     * This is for flat tree node.\n     */\n    isExpandable;\n    /** Gets a stream that emits whenever the given data node's children change. */\n    getChildren;\n    /** Toggles one single data node's expanded/collapsed state. */\n    toggle(dataNode) {\n        this.expansionModel.toggle(this._trackByValue(dataNode));\n    }\n    /** Expands one single data node. */\n    expand(dataNode) {\n        this.expansionModel.select(this._trackByValue(dataNode));\n    }\n    /** Collapses one single data node. */\n    collapse(dataNode) {\n        this.expansionModel.deselect(this._trackByValue(dataNode));\n    }\n    /** Whether a given data node is expanded or not. Returns true if the data node is expanded. */\n    isExpanded(dataNode) {\n        return this.expansionModel.isSelected(this._trackByValue(dataNode));\n    }\n    /** Toggles a subtree rooted at `node` recursively. */\n    toggleDescendants(dataNode) {\n        this.expansionModel.isSelected(this._trackByValue(dataNode))\n            ? this.collapseDescendants(dataNode)\n            : this.expandDescendants(dataNode);\n    }\n    /** Collapse all dataNodes in the tree. */\n    collapseAll() {\n        this.expansionModel.clear();\n    }\n    /** Expands a subtree rooted at given data node recursively. */\n    expandDescendants(dataNode) {\n        let toBeProcessed = [dataNode];\n        toBeProcessed.push(...this.getDescendants(dataNode));\n        this.expansionModel.select(...toBeProcessed.map(value => this._trackByValue(value)));\n    }\n    /** Collapses a subtree rooted at given data node recursively. */\n    collapseDescendants(dataNode) {\n        let toBeProcessed = [dataNode];\n        toBeProcessed.push(...this.getDescendants(dataNode));\n        this.expansionModel.deselect(...toBeProcessed.map(value => this._trackByValue(value)));\n    }\n    _trackByValue(value) {\n        return this.trackBy ? this.trackBy(value) : value;\n    }\n}\n\n/**\n * Flat tree control. Able to expand/collapse a subtree recursively for flattened tree.\n *\n * @deprecated Use one of levelAccessor or childrenAccessor instead. To be removed in a future\n * version.\n * @breaking-change 21.0.0\n */\nclass FlatTreeControl extends BaseTreeControl {\n    getLevel;\n    isExpandable;\n    options;\n    /** Construct with flat tree data node functions getLevel and isExpandable. */\n    constructor(getLevel, isExpandable, options) {\n        super();\n        this.getLevel = getLevel;\n        this.isExpandable = isExpandable;\n        this.options = options;\n        if (this.options) {\n            this.trackBy = this.options.trackBy;\n        }\n    }\n    /**\n     * Gets a list of the data node's subtree of descendent data nodes.\n     *\n     * To make this working, the `dataNodes` of the TreeControl must be flattened tree nodes\n     * with correct levels.\n     */\n    getDescendants(dataNode) {\n        const startIndex = this.dataNodes.indexOf(dataNode);\n        const results = [];\n        // Goes through flattened tree nodes in the `dataNodes` array, and get all descendants.\n        // The level of descendants of a tree node must be greater than the level of the given\n        // tree node.\n        // If we reach a node whose level is equal to the level of the tree node, we hit a sibling.\n        // If we reach a node whose level is greater than the level of the tree node, we hit a\n        // sibling of an ancestor.\n        for (let i = startIndex + 1; i < this.dataNodes.length && this.getLevel(dataNode) < this.getLevel(this.dataNodes[i]); i++) {\n            results.push(this.dataNodes[i]);\n        }\n        return results;\n    }\n    /**\n     * Expands all data nodes in the tree.\n     *\n     * To make this working, the `dataNodes` variable of the TreeControl must be set to all flattened\n     * data nodes of the tree.\n     */\n    expandAll() {\n        this.expansionModel.select(...this.dataNodes.map(node => this._trackByValue(node)));\n    }\n}\n\n/**\n * Nested tree control. Able to expand/collapse a subtree recursively for NestedNode type.\n *\n * @deprecated Use one of levelAccessor or childrenAccessor instead. To be removed in a future\n * version.\n * @breaking-change 21.0.0\n */\nclass NestedTreeControl extends BaseTreeControl {\n    getChildren;\n    options;\n    /** Construct with nested tree function getChildren. */\n    constructor(getChildren, options) {\n        super();\n        this.getChildren = getChildren;\n        this.options = options;\n        if (this.options) {\n            this.trackBy = this.options.trackBy;\n        }\n        if (this.options?.isExpandable) {\n            this.isExpandable = this.options.isExpandable;\n        }\n    }\n    /**\n     * Expands all dataNodes in the tree.\n     *\n     * To make this working, the `dataNodes` variable of the TreeControl must be set to all root level\n     * data nodes of the tree.\n     */\n    expandAll() {\n        this.expansionModel.clear();\n        const allNodes = this.dataNodes.reduce((accumulator, dataNode) => [...accumulator, ...this.getDescendants(dataNode), dataNode], []);\n        this.expansionModel.select(...allNodes.map(node => this._trackByValue(node)));\n    }\n    /** Gets a list of descendant dataNodes of a subtree rooted at given data node recursively. */\n    getDescendants(dataNode) {\n        const descendants = [];\n        this._getDescendants(descendants, dataNode);\n        // Remove the node itself\n        return descendants.splice(1);\n    }\n    /** A helper function to get descendants recursively. */\n    _getDescendants(descendants, dataNode) {\n        descendants.push(dataNode);\n        const childrenNodes = this.getChildren(dataNode);\n        if (Array.isArray(childrenNodes)) {\n            childrenNodes.forEach((child) => this._getDescendants(descendants, child));\n        }\n        else if (isObservable(childrenNodes)) {\n            // TypeScript as of version 3.5 doesn't seem to treat `Boolean` like a function that\n            // returns a `boolean` specifically in the context of `filter`, so we manually clarify that.\n            childrenNodes.pipe(take(1), filter(Boolean)).subscribe(children => {\n                for (const child of children) {\n                    this._getDescendants(descendants, child);\n                }\n            });\n        }\n    }\n}\n\n/**\n * Injection token used to provide a `CdkTreeNode` to its outlet.\n * Used primarily to avoid circular imports.\n * @docs-private\n */\nconst CDK_TREE_NODE_OUTLET_NODE = new InjectionToken('CDK_TREE_NODE_OUTLET_NODE');\n/**\n * Outlet for nested CdkNode. Put `[cdkTreeNodeOutlet]` on a tag to place children dataNodes\n * inside the outlet.\n */\nclass CdkTreeNodeOutlet {\n    viewContainer = inject(ViewContainerRef);\n    _node = inject(CDK_TREE_NODE_OUTLET_NODE, { optional: true });\n    constructor() { }\n    static Éµfac = i0.ÉµÉµngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: CdkTreeNodeOutlet, deps: [], target: i0.ÉµÉµFactoryTarget.Directive });\n    static Éµdir = i0.ÉµÉµngDeclareDirective({ minVersion: \"14.0.0\", version: \"20.2.0-next.2\", type: CdkTreeNodeOutlet, isStandalone: true, selector: \"[cdkTreeNodeOutlet]\", ngImport: i0 });\n}\ni0.ÉµÉµngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: CdkTreeNodeOutlet, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[cdkTreeNodeOutlet]',\n                }]\n        }], ctorParameters: () => [] });\n\n/** Context provided to the tree node component. */\nclass CdkTreeNodeOutletContext {\n    /** Data for the node. */\n    $implicit;\n    /** Depth of the node. */\n    level;\n    /** Index location of the node. */\n    index;\n    /** Length of the number of total dataNodes. */\n    count;\n    constructor(data) {\n        this.$implicit = data;\n    }\n}\n/**\n * Data node definition for the CdkTree.\n * Captures the node's template and a when predicate that describes when this node should be used.\n */\nclass CdkTreeNodeDef {\n    /** @docs-private */\n    template = inject(TemplateRef);\n    /**\n     * Function that should return true if this node template should be used for the provided node\n     * data and index. If left undefined, this node will be considered the default node template to\n     * use when no other when functions return true for the data.\n     * For every node, there must be at least one when function that passes or an undefined to\n     * default.\n     */\n    when;\n    constructor() { }\n    static Éµfac = i0.ÉµÉµngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: CdkTreeNodeDef, deps: [], target: i0.ÉµÉµFactoryTarget.Directive });\n    static Éµdir = i0.ÉµÉµngDeclareDirective({ minVersion: \"14.0.0\", version: \"20.2.0-next.2\", type: CdkTreeNodeDef, isStandalone: true, selector: \"[cdkTreeNodeDef]\", inputs: { when: [\"cdkTreeNodeDefWhen\", \"when\"] }, ngImport: i0 });\n}\ni0.ÉµÉµngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: CdkTreeNodeDef, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[cdkTreeNodeDef]',\n                    inputs: [{ name: 'when', alias: 'cdkTreeNodeDefWhen' }],\n                }]\n        }], ctorParameters: () => [] });\n\n/**\n * Returns an error to be thrown when there is no usable data.\n * @docs-private\n */\nfunction getTreeNoValidDataSourceError() {\n    return Error(`A valid data source must be provided.`);\n}\n/**\n * Returns an error to be thrown when there are multiple nodes that are missing a when function.\n * @docs-private\n */\nfunction getTreeMultipleDefaultNodeDefsError() {\n    return Error(`There can only be one default row without a when predicate function.`);\n}\n/**\n * Returns an error to be thrown when there are no matching node defs for a particular set of data.\n * @docs-private\n */\nfunction getTreeMissingMatchingNodeDefError() {\n    return Error(`Could not find a matching node definition for the provided node data.`);\n}\n/**\n * Returns an error to be thrown when there is no tree control.\n * @docs-private\n */\nfunction getTreeControlMissingError() {\n    return Error(`Could not find a tree control, levelAccessor, or childrenAccessor for the tree.`);\n}\n/**\n * Returns an error to be thrown when there are multiple ways of specifying children or level\n * provided to the tree.\n * @docs-private\n */\nfunction getMultipleTreeControlsError() {\n    return Error(`More than one of tree control, levelAccessor, or childrenAccessor were provided.`);\n}\n\n/**\n * CDK tree component that connects with a data source to retrieve data of type `T` and renders\n * dataNodes with hierarchy. Updates the dataNodes when new data is provided by the data source.\n */\nclass CdkTree {\n    _differs = inject(IterableDiffers);\n    _changeDetectorRef = inject(ChangeDetectorRef);\n    _elementRef = inject(ElementRef);\n    _dir = inject(Directionality);\n    /** Subject that emits when the component has been destroyed. */\n    _onDestroy = new Subject();\n    /** Differ used to find the changes in the data provided by the data source. */\n    _dataDiffer;\n    /** Stores the node definition that does not have a when predicate. */\n    _defaultNodeDef;\n    /** Data subscription */\n    _dataSubscription;\n    /** Level of nodes */\n    _levels = new Map();\n    /** The immediate parents for a node. This is `null` if there is no parent. */\n    _parents = new Map();\n    /**\n     * Nodes grouped into each set, which is a list of nodes displayed together in the DOM.\n     *\n     * Lookup key is the parent of a set. Root nodes have key of null.\n     *\n     * Values is a 'set' of tree nodes. Each tree node maps to a treeitem element. Sets are in the\n     * order that it is rendered. Each set maps directly to aria-posinset and aria-setsize attributes.\n     */\n    _ariaSets = new Map();\n    /**\n     * Provides a stream containing the latest data array to render. Influenced by the tree's\n     * stream of view window (what dataNodes are currently on screen).\n     * Data source can be an observable of data array, or a data array to render.\n     */\n    get dataSource() {\n        return this._dataSource;\n    }\n    set dataSource(dataSource) {\n        if (this._dataSource !== dataSource) {\n            this._switchDataSource(dataSource);\n        }\n    }\n    _dataSource;\n    /**\n     * The tree controller\n     *\n     * @deprecated Use one of `levelAccessor` or `childrenAccessor` instead. To be removed in a\n     * future version.\n     * @breaking-change 21.0.0\n     */\n    treeControl;\n    /**\n     * Given a data node, determines what tree level the node is at.\n     *\n     * One of levelAccessor or childrenAccessor must be specified, not both.\n     * This is enforced at run-time.\n     */\n    levelAccessor;\n    /**\n     * Given a data node, determines what the children of that node are.\n     *\n     * One of levelAccessor or childrenAccessor must be specified, not both.\n     * This is enforced at run-time.\n     */\n    childrenAccessor;\n    /**\n     * Tracking function that will be used to check the differences in data changes. Used similarly\n     * to `ngFor` `trackBy` function. Optimize node operations by identifying a node based on its data\n     * relative to the function to know if a node should be added/removed/moved.\n     * Accepts a function that takes two parameters, `index` and `item`.\n     */\n    trackBy;\n    /**\n     * Given a data node, determines the key by which we determine whether or not this node is expanded.\n     */\n    expansionKey;\n    // Outlets within the tree's template where the dataNodes will be inserted.\n    _nodeOutlet;\n    /** The tree node template for the tree */\n    _nodeDefs;\n    // TODO(tinayuangao): Setup a listener for scrolling, emit the calculated view to viewChange.\n    //     Remove the MAX_VALUE in viewChange\n    /**\n     * Stream containing the latest information on what rows are being displayed on screen.\n     * Can be used by the data source to as a heuristic of what data should be provided.\n     */\n    viewChange = new BehaviorSubject({\n        start: 0,\n        end: Number.MAX_VALUE,\n    });\n    /** Keep track of which nodes are expanded. */\n    _expansionModel;\n    /**\n     * Maintain a synchronous cache of flattened data nodes. This will only be\n     * populated after initial render, and in certain cases, will be delayed due to\n     * relying on Observable `getChildren` calls.\n     */\n    _flattenedNodes = new BehaviorSubject([]);\n    /** The automatically determined node type for the tree. */\n    _nodeType = new BehaviorSubject(null);\n    /** The mapping between data and the node that is rendered. */\n    _nodes = new BehaviorSubject(new Map());\n    /**\n     * Synchronous cache of nodes for the `TreeKeyManager`. This is separate\n     * from `_flattenedNodes` so they can be independently updated at different\n     * times.\n     */\n    _keyManagerNodes = new BehaviorSubject([]);\n    _keyManagerFactory = inject(TREE_KEY_MANAGER);\n    /** The key manager for this tree. Handles focus and activation based on user keyboard input. */\n    _keyManager;\n    _viewInit = false;\n    constructor() { }\n    ngAfterContentInit() {\n        this._initializeKeyManager();\n    }\n    ngAfterContentChecked() {\n        this._updateDefaultNodeDefinition();\n        this._subscribeToDataChanges();\n    }\n    ngOnDestroy() {\n        this._nodeOutlet.viewContainer.clear();\n        this._nodes.complete();\n        this._keyManagerNodes.complete();\n        this._nodeType.complete();\n        this._flattenedNodes.complete();\n        this.viewChange.complete();\n        this._onDestroy.next();\n        this._onDestroy.complete();\n        if (this._dataSource && typeof this._dataSource.disconnect === 'function') {\n            this.dataSource.disconnect(this);\n        }\n        if (this._dataSubscription) {\n            this._dataSubscription.unsubscribe();\n            this._dataSubscription = null;\n        }\n        // In certain tests, the tree might be destroyed before this is initialized\n        // in `ngAfterContentInit`.\n        this._keyManager?.destroy();\n    }\n    ngOnInit() {\n        this._checkTreeControlUsage();\n        this._initializeDataDiffer();\n    }\n    ngAfterViewInit() {\n        this._viewInit = true;\n    }\n    _updateDefaultNodeDefinition() {\n        const defaultNodeDefs = this._nodeDefs.filter(def => !def.when);\n        if (defaultNodeDefs.length > 1 && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            throw getTreeMultipleDefaultNodeDefsError();\n        }\n        this._defaultNodeDef = defaultNodeDefs[0];\n    }\n    /**\n     * Sets the node type for the tree, if it hasn't been set yet.\n     *\n     * This will be called by the first node that's rendered in order for the tree\n     * to determine what data transformations are required.\n     */\n    _setNodeTypeIfUnset(newType) {\n        const currentType = this._nodeType.value;\n        if (currentType === null) {\n            this._nodeType.next(newType);\n        }\n        else if ((typeof ngDevMode === 'undefined' || ngDevMode) && currentType !== newType) {\n            console.warn(`Tree is using conflicting node types which can cause unexpected behavior. ` +\n                `Please use tree nodes of the same type (e.g. only flat or only nested). ` +\n                `Current node type: \"${currentType}\", new node type \"${newType}\".`);\n        }\n    }\n    /**\n     * Switch to the provided data source by resetting the data and unsubscribing from the current\n     * render change subscription if one exists. If the data source is null, interpret this by\n     * clearing the node outlet. Otherwise start listening for new data.\n     */\n    _switchDataSource(dataSource) {\n        if (this._dataSource && typeof this._dataSource.disconnect === 'function') {\n            this.dataSource.disconnect(this);\n        }\n        if (this._dataSubscription) {\n            this._dataSubscription.unsubscribe();\n            this._dataSubscription = null;\n        }\n        // Remove the all dataNodes if there is now no data source\n        if (!dataSource) {\n            this._nodeOutlet.viewContainer.clear();\n        }\n        this._dataSource = dataSource;\n        if (this._nodeDefs) {\n            this._subscribeToDataChanges();\n        }\n    }\n    _getExpansionModel() {\n        if (!this.treeControl) {\n            this._expansionModel ??= new SelectionModel(true);\n            return this._expansionModel;\n        }\n        return this.treeControl.expansionModel;\n    }\n    /** Set up a subscription for the data provided by the data source. */\n    _subscribeToDataChanges() {\n        if (this._dataSubscription) {\n            return;\n        }\n        let dataStream;\n        if (isDataSource(this._dataSource)) {\n            dataStream = this._dataSource.connect(this);\n        }\n        else if (isObservable(this._dataSource)) {\n            dataStream = this._dataSource;\n        }\n        else if (Array.isArray(this._dataSource)) {\n            dataStream = of(this._dataSource);\n        }\n        if (!dataStream) {\n            if (typeof ngDevMode === 'undefined' || ngDevMode) {\n                throw getTreeNoValidDataSourceError();\n            }\n            return;\n        }\n        this._dataSubscription = this._getRenderData(dataStream)\n            .pipe(takeUntil(this._onDestroy))\n            .subscribe(renderingData => {\n            this._renderDataChanges(renderingData);\n        });\n    }\n    /** Given an Observable containing a stream of the raw data, returns an Observable containing the RenderingData */\n    _getRenderData(dataStream) {\n        const expansionModel = this._getExpansionModel();\n        return combineLatest([\n            dataStream,\n            this._nodeType,\n            // We don't use the expansion data directly, however we add it here to essentially\n            // trigger data rendering when expansion changes occur.\n            expansionModel.changed.pipe(startWith(null), tap(expansionChanges => {\n                this._emitExpansionChanges(expansionChanges);\n            })),\n        ]).pipe(switchMap(([data, nodeType]) => {\n            if (nodeType === null) {\n                return of({ renderNodes: data, flattenedNodes: null, nodeType });\n            }\n            // If we're here, then we know what our node type is, and therefore can\n            // perform our usual rendering pipeline, which necessitates converting the data\n            return this._computeRenderingData(data, nodeType).pipe(map(convertedData => ({ ...convertedData, nodeType })));\n        }));\n    }\n    _renderDataChanges(data) {\n        if (data.nodeType === null) {\n            this.renderNodeChanges(data.renderNodes);\n            return;\n        }\n        // If we're here, then we know what our node type is, and therefore can\n        // perform our usual rendering pipeline.\n        this._updateCachedData(data.flattenedNodes);\n        this.renderNodeChanges(data.renderNodes);\n        this._updateKeyManagerItems(data.flattenedNodes);\n    }\n    _emitExpansionChanges(expansionChanges) {\n        if (!expansionChanges) {\n            return;\n        }\n        const nodes = this._nodes.value;\n        for (const added of expansionChanges.added) {\n            const node = nodes.get(added);\n            node?._emitExpansionState(true);\n        }\n        for (const removed of expansionChanges.removed) {\n            const node = nodes.get(removed);\n            node?._emitExpansionState(false);\n        }\n    }\n    _initializeKeyManager() {\n        const items = combineLatest([this._keyManagerNodes, this._nodes]).pipe(map(([keyManagerNodes, renderNodes]) => keyManagerNodes.reduce((items, data) => {\n            const node = renderNodes.get(this._getExpansionKey(data));\n            if (node) {\n                items.push(node);\n            }\n            return items;\n        }, [])));\n        const keyManagerOptions = {\n            trackBy: node => this._getExpansionKey(node.data),\n            skipPredicate: node => !!node.isDisabled,\n            typeAheadDebounceInterval: true,\n            horizontalOrientation: this._dir.value,\n        };\n        this._keyManager = this._keyManagerFactory(items, keyManagerOptions);\n    }\n    _initializeDataDiffer() {\n        // Provide a default trackBy based on `_getExpansionKey` if one isn't provided.\n        const trackBy = this.trackBy ?? ((_index, item) => this._getExpansionKey(item));\n        this._dataDiffer = this._differs.find([]).create(trackBy);\n    }\n    _checkTreeControlUsage() {\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            // Verify that Tree follows API contract of using one of TreeControl, levelAccessor or\n            // childrenAccessor. Throw an appropriate error if contract is not met.\n            let numTreeControls = 0;\n            if (this.treeControl) {\n                numTreeControls++;\n            }\n            if (this.levelAccessor) {\n                numTreeControls++;\n            }\n            if (this.childrenAccessor) {\n                numTreeControls++;\n            }\n            if (!numTreeControls) {\n                throw getTreeControlMissingError();\n            }\n            else if (numTreeControls > 1) {\n                throw getMultipleTreeControlsError();\n            }\n        }\n    }\n    /** Check for changes made in the data and render each change (node added/removed/moved). */\n    renderNodeChanges(data, dataDiffer = this._dataDiffer, viewContainer = this._nodeOutlet.viewContainer, parentData) {\n        const changes = dataDiffer.diff(data);\n        // Some tree consumers expect change detection to propagate to nodes\n        // even when the array itself hasn't changed; we explicitly detect changes\n        // anyways in order for nodes to update their data.\n        //\n        // However, if change detection is called while the component's view is\n        // still initing, then the order of child views initing will be incorrect;\n        // to prevent this, we only exit early if the view hasn't initialized yet.\n        if (!changes && !this._viewInit) {\n            return;\n        }\n        changes?.forEachOperation((item, adjustedPreviousIndex, currentIndex) => {\n            if (item.previousIndex == null) {\n                this.insertNode(data[currentIndex], currentIndex, viewContainer, parentData);\n            }\n            else if (currentIndex == null) {\n                viewContainer.remove(adjustedPreviousIndex);\n            }\n            else {\n                const view = viewContainer.get(adjustedPreviousIndex);\n                viewContainer.move(view, currentIndex);\n            }\n        });\n        // If the data itself changes, but keeps the same trackBy, we need to update the templates'\n        // context to reflect the new object.\n        changes?.forEachIdentityChange((record) => {\n            const newData = record.item;\n            if (record.currentIndex != undefined) {\n                const view = viewContainer.get(record.currentIndex);\n                view.context.$implicit = newData;\n            }\n        });\n        // Note: we only `detectChanges` from a top-level call, otherwise we risk overflowing\n        // the call stack since this method is called recursively (see #29733.)\n        // TODO: change to `this._changeDetectorRef.markForCheck()`,\n        // or just switch this component to use signals.\n        if (parentData) {\n            this._changeDetectorRef.markForCheck();\n        }\n        else {\n            this._changeDetectorRef.detectChanges();\n        }\n    }\n    /**\n     * Finds the matching node definition that should be used for this node data. If there is only\n     * one node definition, it is returned. Otherwise, find the node definition that has a when\n     * predicate that returns true with the data. If none return true, return the default node\n     * definition.\n     */\n    _getNodeDef(data, i) {\n        if (this._nodeDefs.length === 1) {\n            return this._nodeDefs.first;\n        }\n        const nodeDef = this._nodeDefs.find(def => def.when && def.when(i, data)) || this._defaultNodeDef;\n        if (!nodeDef && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            throw getTreeMissingMatchingNodeDefError();\n        }\n        return nodeDef;\n    }\n    /**\n     * Create the embedded view for the data node template and place it in the correct index location\n     * within the data node view container.\n     */\n    insertNode(nodeData, index, viewContainer, parentData) {\n        const levelAccessor = this._getLevelAccessor();\n        const node = this._getNodeDef(nodeData, index);\n        const key = this._getExpansionKey(nodeData);\n        // Node context that will be provided to created embedded view\n        const context = new CdkTreeNodeOutletContext(nodeData);\n        context.index = index;\n        parentData ??= this._parents.get(key) ?? undefined;\n        // If the tree is flat tree, then use the `getLevel` function in flat tree control\n        // Otherwise, use the level of parent node.\n        if (levelAccessor) {\n            context.level = levelAccessor(nodeData);\n        }\n        else if (parentData !== undefined && this._levels.has(this._getExpansionKey(parentData))) {\n            context.level = this._levels.get(this._getExpansionKey(parentData)) + 1;\n        }\n        else {\n            context.level = 0;\n        }\n        this._levels.set(key, context.level);\n        // Use default tree nodeOutlet, or nested node's nodeOutlet\n        const container = viewContainer ? viewContainer : this._nodeOutlet.viewContainer;\n        container.createEmbeddedView(node.template, context, index);\n        // Set the data to just created `CdkTreeNode`.\n        // The `CdkTreeNode` created from `createEmbeddedView` will be saved in static variable\n        //     `mostRecentTreeNode`. We get it from static variable and pass the node data to it.\n        if (CdkTreeNode.mostRecentTreeNode) {\n            CdkTreeNode.mostRecentTreeNode.data = nodeData;\n        }\n    }\n    /** Whether the data node is expanded or collapsed. Returns true if it's expanded. */\n    isExpanded(dataNode) {\n        return !!(this.treeControl?.isExpanded(dataNode) ||\n            this._expansionModel?.isSelected(this._getExpansionKey(dataNode)));\n    }\n    /** If the data node is currently expanded, collapse it. Otherwise, expand it. */\n    toggle(dataNode) {\n        if (this.treeControl) {\n            this.treeControl.toggle(dataNode);\n        }\n        else if (this._expansionModel) {\n            this._expansionModel.toggle(this._getExpansionKey(dataNode));\n        }\n    }\n    /** Expand the data node. If it is already expanded, does nothing. */\n    expand(dataNode) {\n        if (this.treeControl) {\n            this.treeControl.expand(dataNode);\n        }\n        else if (this._expansionModel) {\n            this._expansionModel.select(this._getExpansionKey(dataNode));\n        }\n    }\n    /** Collapse the data node. If it is already collapsed, does nothing. */\n    collapse(dataNode) {\n        if (this.treeControl) {\n            this.treeControl.collapse(dataNode);\n        }\n        else if (this._expansionModel) {\n            this._expansionModel.deselect(this._getExpansionKey(dataNode));\n        }\n    }\n    /**\n     * If the data node is currently expanded, collapse it and all its descendants.\n     * Otherwise, expand it and all its descendants.\n     */\n    toggleDescendants(dataNode) {\n        if (this.treeControl) {\n            this.treeControl.toggleDescendants(dataNode);\n        }\n        else if (this._expansionModel) {\n            if (this.isExpanded(dataNode)) {\n                this.collapseDescendants(dataNode);\n            }\n            else {\n                this.expandDescendants(dataNode);\n            }\n        }\n    }\n    /**\n     * Expand the data node and all its descendants. If they are already expanded, does nothing.\n     */\n    expandDescendants(dataNode) {\n        if (this.treeControl) {\n            this.treeControl.expandDescendants(dataNode);\n        }\n        else if (this._expansionModel) {\n            const expansionModel = this._expansionModel;\n            expansionModel.select(this._getExpansionKey(dataNode));\n            this._getDescendants(dataNode)\n                .pipe(take(1), takeUntil(this._onDestroy))\n                .subscribe(children => {\n                expansionModel.select(...children.map(child => this._getExpansionKey(child)));\n            });\n        }\n    }\n    /** Collapse the data node and all its descendants. If it is already collapsed, does nothing. */\n    collapseDescendants(dataNode) {\n        if (this.treeControl) {\n            this.treeControl.collapseDescendants(dataNode);\n        }\n        else if (this._expansionModel) {\n            const expansionModel = this._expansionModel;\n            expansionModel.deselect(this._getExpansionKey(dataNode));\n            this._getDescendants(dataNode)\n                .pipe(take(1), takeUntil(this._onDestroy))\n                .subscribe(children => {\n                expansionModel.deselect(...children.map(child => this._getExpansionKey(child)));\n            });\n        }\n    }\n    /** Expands all data nodes in the tree. */\n    expandAll() {\n        if (this.treeControl) {\n            this.treeControl.expandAll();\n        }\n        else if (this._expansionModel) {\n            this._forEachExpansionKey(keys => this._expansionModel?.select(...keys));\n        }\n    }\n    /** Collapse all data nodes in the tree. */\n    collapseAll() {\n        if (this.treeControl) {\n            this.treeControl.collapseAll();\n        }\n        else if (this._expansionModel) {\n            this._forEachExpansionKey(keys => this._expansionModel?.deselect(...keys));\n        }\n    }\n    /** Level accessor, used for compatibility between the old Tree and new Tree */\n    _getLevelAccessor() {\n        return this.treeControl?.getLevel?.bind(this.treeControl) ?? this.levelAccessor;\n    }\n    /** Children accessor, used for compatibility between the old Tree and new Tree */\n    _getChildrenAccessor() {\n        return this.treeControl?.getChildren?.bind(this.treeControl) ?? this.childrenAccessor;\n    }\n    /**\n     * Gets the direct children of a node; used for compatibility between the old tree and the\n     * new tree.\n     */\n    _getDirectChildren(dataNode) {\n        const levelAccessor = this._getLevelAccessor();\n        const expansionModel = this._expansionModel ?? this.treeControl?.expansionModel;\n        if (!expansionModel) {\n            return of([]);\n        }\n        const key = this._getExpansionKey(dataNode);\n        const isExpanded = expansionModel.changed.pipe(switchMap(changes => {\n            if (changes.added.includes(key)) {\n                return of(true);\n            }\n            else if (changes.removed.includes(key)) {\n                return of(false);\n            }\n            return EMPTY;\n        }), startWith(this.isExpanded(dataNode)));\n        if (levelAccessor) {\n            return combineLatest([isExpanded, this._flattenedNodes]).pipe(map(([expanded, flattenedNodes]) => {\n                if (!expanded) {\n                    return [];\n                }\n                return this._findChildrenByLevel(levelAccessor, flattenedNodes, dataNode, 1);\n            }));\n        }\n        const childrenAccessor = this._getChildrenAccessor();\n        if (childrenAccessor) {\n            return coerceObservable(childrenAccessor(dataNode) ?? []);\n        }\n        throw getTreeControlMissingError();\n    }\n    /**\n     * Given the list of flattened nodes, the level accessor, and the level range within\n     * which to consider children, finds the children for a given node.\n     *\n     * For example, for direct children, `levelDelta` would be 1. For all descendants,\n     * `levelDelta` would be Infinity.\n     */\n    _findChildrenByLevel(levelAccessor, flattenedNodes, dataNode, levelDelta) {\n        const key = this._getExpansionKey(dataNode);\n        const startIndex = flattenedNodes.findIndex(node => this._getExpansionKey(node) === key);\n        const dataNodeLevel = levelAccessor(dataNode);\n        const expectedLevel = dataNodeLevel + levelDelta;\n        const results = [];\n        // Goes through flattened tree nodes in the `flattenedNodes` array, and get all\n        // descendants within a certain level range.\n        //\n        // If we reach a node whose level is equal to or less than the level of the tree node,\n        // we hit a sibling or parent's sibling, and should stop.\n        for (let i = startIndex + 1; i < flattenedNodes.length; i++) {\n            const currentLevel = levelAccessor(flattenedNodes[i]);\n            if (currentLevel <= dataNodeLevel) {\n                break;\n            }\n            if (currentLevel <= expectedLevel) {\n                results.push(flattenedNodes[i]);\n            }\n        }\n        return results;\n    }\n    /**\n     * Adds the specified node component to the tree's internal registry.\n     *\n     * This primarily facilitates keyboard navigation.\n     */\n    _registerNode(node) {\n        this._nodes.value.set(this._getExpansionKey(node.data), node);\n        this._nodes.next(this._nodes.value);\n    }\n    /** Removes the specified node component from the tree's internal registry. */\n    _unregisterNode(node) {\n        this._nodes.value.delete(this._getExpansionKey(node.data));\n        this._nodes.next(this._nodes.value);\n    }\n    /**\n     * For the given node, determine the level where this node appears in the tree.\n     *\n     * This is intended to be used for `aria-level` but is 0-indexed.\n     */\n    _getLevel(node) {\n        return this._levels.get(this._getExpansionKey(node));\n    }\n    /**\n     * For the given node, determine the size of the parent's child set.\n     *\n     * This is intended to be used for `aria-setsize`.\n     */\n    _getSetSize(dataNode) {\n        const set = this._getAriaSet(dataNode);\n        return set.length;\n    }\n    /**\n     * For the given node, determine the index (starting from 1) of the node in its parent's child set.\n     *\n     * This is intended to be used for `aria-posinset`.\n     */\n    _getPositionInSet(dataNode) {\n        const set = this._getAriaSet(dataNode);\n        const key = this._getExpansionKey(dataNode);\n        return set.findIndex(node => this._getExpansionKey(node) === key) + 1;\n    }\n    /** Given a CdkTreeNode, gets the node that renders that node's parent's data. */\n    _getNodeParent(node) {\n        const parent = this._parents.get(this._getExpansionKey(node.data));\n        return parent && this._nodes.value.get(this._getExpansionKey(parent));\n    }\n    /** Given a CdkTreeNode, gets the nodes that renders that node's child data. */\n    _getNodeChildren(node) {\n        return this._getDirectChildren(node.data).pipe(map(children => children.reduce((nodes, child) => {\n            const value = this._nodes.value.get(this._getExpansionKey(child));\n            if (value) {\n                nodes.push(value);\n            }\n            return nodes;\n        }, [])));\n    }\n    /** `keydown` event handler; this just passes the event to the `TreeKeyManager`. */\n    _sendKeydownToKeyManager(event) {\n        // Only handle events directly on the tree or directly on one of the nodes, otherwise\n        // we risk interfering with events in the projected content (see #29828).\n        if (event.target === this._elementRef.nativeElement) {\n            this._keyManager.onKeydown(event);\n        }\n        else {\n            const nodes = this._nodes.getValue();\n            for (const [, node] of nodes) {\n                if (event.target === node._elementRef.nativeElement) {\n                    this._keyManager.onKeydown(event);\n                    break;\n                }\n            }\n        }\n    }\n    /** Gets all nested descendants of a given node. */\n    _getDescendants(dataNode) {\n        if (this.treeControl) {\n            return of(this.treeControl.getDescendants(dataNode));\n        }\n        if (this.levelAccessor) {\n            const results = this._findChildrenByLevel(this.levelAccessor, this._flattenedNodes.value, dataNode, Infinity);\n            return of(results);\n        }\n        if (this.childrenAccessor) {\n            return this._getAllChildrenRecursively(dataNode).pipe(reduce((allChildren, nextChildren) => {\n                allChildren.push(...nextChildren);\n                return allChildren;\n            }, []));\n        }\n        throw getTreeControlMissingError();\n    }\n    /**\n     * Gets all children and sub-children of the provided node.\n     *\n     * This will emit multiple times, in the order that the children will appear\n     * in the tree, and can be combined with a `reduce` operator.\n     */\n    _getAllChildrenRecursively(dataNode) {\n        if (!this.childrenAccessor) {\n            return of([]);\n        }\n        return coerceObservable(this.childrenAccessor(dataNode)).pipe(take(1), switchMap(children => {\n            // Here, we cache the parents of a particular child so that we can compute the levels.\n            for (const child of children) {\n                this._parents.set(this._getExpansionKey(child), dataNode);\n            }\n            return of(...children).pipe(concatMap(child => concat(of([child]), this._getAllChildrenRecursively(child))));\n        }));\n    }\n    _getExpansionKey(dataNode) {\n        // In the case that a key accessor function was not provided by the\n        // tree user, we'll default to using the node object itself as the key.\n        //\n        // This cast is safe since:\n        // - if an expansionKey is provided, TS will infer the type of K to be\n        //   the return type.\n        // - if it's not, then K will be defaulted to T.\n        return this.expansionKey?.(dataNode) ?? dataNode;\n    }\n    _getAriaSet(node) {\n        const key = this._getExpansionKey(node);\n        const parent = this._parents.get(key);\n        const parentKey = parent ? this._getExpansionKey(parent) : null;\n        const set = this._ariaSets.get(parentKey);\n        return set ?? [node];\n    }\n    /**\n     * Finds the parent for the given node. If this is a root node, this\n     * returns null. If we're unable to determine the parent, for example,\n     * if we don't have cached node data, this returns undefined.\n     */\n    _findParentForNode(node, index, cachedNodes) {\n        // In all cases, we have a mapping from node to level; all we need to do here is backtrack in\n        // our flattened list of nodes to determine the first node that's of a level lower than the\n        // provided node.\n        if (!cachedNodes.length) {\n            return null;\n        }\n        const currentLevel = this._levels.get(this._getExpansionKey(node)) ?? 0;\n        for (let parentIndex = index - 1; parentIndex >= 0; parentIndex--) {\n            const parentNode = cachedNodes[parentIndex];\n            const parentLevel = this._levels.get(this._getExpansionKey(parentNode)) ?? 0;\n            if (parentLevel < currentLevel) {\n                return parentNode;\n            }\n        }\n        return null;\n    }\n    /**\n     * Given a set of root nodes and the current node level, flattens any nested\n     * nodes into a single array.\n     *\n     * If any nodes are not expanded, then their children will not be added into the array.\n     * This will still traverse all nested children in order to build up our internal data\n     * models, but will not include them in the returned array.\n     */\n    _flattenNestedNodesWithExpansion(nodes, level = 0) {\n        const childrenAccessor = this._getChildrenAccessor();\n        // If we're using a level accessor, we don't need to flatten anything.\n        if (!childrenAccessor) {\n            return of([...nodes]);\n        }\n        return of(...nodes).pipe(concatMap(node => {\n            const parentKey = this._getExpansionKey(node);\n            if (!this._parents.has(parentKey)) {\n                this._parents.set(parentKey, null);\n            }\n            this._levels.set(parentKey, level);\n            const children = coerceObservable(childrenAccessor(node));\n            return concat(of([node]), children.pipe(take(1), tap(childNodes => {\n                this._ariaSets.set(parentKey, [...(childNodes ?? [])]);\n                for (const child of childNodes ?? []) {\n                    const childKey = this._getExpansionKey(child);\n                    this._parents.set(childKey, node);\n                    this._levels.set(childKey, level + 1);\n                }\n            }), switchMap(childNodes => {\n                if (!childNodes) {\n                    return of([]);\n                }\n                return this._flattenNestedNodesWithExpansion(childNodes, level + 1).pipe(map(nestedNodes => (this.isExpanded(node) ? nestedNodes : [])));\n            })));\n        }), reduce((results, children) => {\n            results.push(...children);\n            return results;\n        }, []));\n    }\n    /**\n     * Converts children for certain tree configurations.\n     *\n     * This also computes parent, level, and group data.\n     */\n    _computeRenderingData(nodes, nodeType) {\n        // The only situations where we have to convert children types is when\n        // they're mismatched; i.e. if the tree is using a childrenAccessor and the\n        // nodes are flat, or if the tree is using a levelAccessor and the nodes are\n        // nested.\n        if (this.childrenAccessor && nodeType === 'flat') {\n            // clear previously generated data so we don't keep end up retaining data overtime causing\n            // memory leaks.\n            this._clearPreviousCache();\n            // This flattens children into a single array.\n            this._ariaSets.set(null, [...nodes]);\n            return this._flattenNestedNodesWithExpansion(nodes).pipe(map(flattenedNodes => ({\n                renderNodes: flattenedNodes,\n                flattenedNodes,\n            })));\n        }\n        else if (this.levelAccessor && nodeType === 'nested') {\n            // In the nested case, we only look for root nodes. The CdkNestedNode\n            // itself will handle rendering each individual node's children.\n            const levelAccessor = this.levelAccessor;\n            return of(nodes.filter(node => levelAccessor(node) === 0)).pipe(map(rootNodes => ({\n                renderNodes: rootNodes,\n                flattenedNodes: nodes,\n            })), tap(({ flattenedNodes }) => {\n                this._calculateParents(flattenedNodes);\n            }));\n        }\n        else if (nodeType === 'flat') {\n            // In the case of a TreeControl, we know that the node type matches up\n            // with the TreeControl, and so no conversions are necessary. Otherwise,\n            // we've already confirmed that the data model matches up with the\n            // desired node type here.\n            return of({ renderNodes: nodes, flattenedNodes: nodes }).pipe(tap(({ flattenedNodes }) => {\n                this._calculateParents(flattenedNodes);\n            }));\n        }\n        else {\n            // clear previously generated data so we don't keep end up retaining data overtime causing\n            // memory leaks.\n            this._clearPreviousCache();\n            // For nested nodes, we still need to perform the node flattening in order\n            // to maintain our caches for various tree operations.\n            this._ariaSets.set(null, [...nodes]);\n            return this._flattenNestedNodesWithExpansion(nodes).pipe(map(flattenedNodes => ({\n                renderNodes: nodes,\n                flattenedNodes,\n            })));\n        }\n    }\n    _updateCachedData(flattenedNodes) {\n        this._flattenedNodes.next(flattenedNodes);\n    }\n    _updateKeyManagerItems(flattenedNodes) {\n        this._keyManagerNodes.next(flattenedNodes);\n    }\n    /** Traverse the flattened node data and compute parents, levels, and group data. */\n    _calculateParents(flattenedNodes) {\n        const levelAccessor = this._getLevelAccessor();\n        if (!levelAccessor) {\n            return;\n        }\n        // clear previously generated data so we don't keep end up retaining data overtime causing\n        // memory leaks.\n        this._clearPreviousCache();\n        for (let index = 0; index < flattenedNodes.length; index++) {\n            const dataNode = flattenedNodes[index];\n            const key = this._getExpansionKey(dataNode);\n            this._levels.set(key, levelAccessor(dataNode));\n            const parent = this._findParentForNode(dataNode, index, flattenedNodes);\n            this._parents.set(key, parent);\n            const parentKey = parent ? this._getExpansionKey(parent) : null;\n            const group = this._ariaSets.get(parentKey) ?? [];\n            group.splice(index, 0, dataNode);\n            this._ariaSets.set(parentKey, group);\n        }\n    }\n    /** Invokes a callback with all node expansion keys. */\n    _forEachExpansionKey(callback) {\n        const toToggle = [];\n        const observables = [];\n        this._nodes.value.forEach(node => {\n            toToggle.push(this._getExpansionKey(node.data));\n            observables.push(this._getDescendants(node.data));\n        });\n        if (observables.length > 0) {\n            combineLatest(observables)\n                .pipe(take(1), takeUntil(this._onDestroy))\n                .subscribe(results => {\n                results.forEach(inner => inner.forEach(r => toToggle.push(this._getExpansionKey(r))));\n                callback(toToggle);\n            });\n        }\n        else {\n            callback(toToggle);\n        }\n    }\n    /** Clears the maps we use to store parents, level & aria-sets in. */\n    _clearPreviousCache() {\n        this._parents.clear();\n        this._levels.clear();\n        this._ariaSets.clear();\n    }\n    static Éµfac = i0.ÉµÉµngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: CdkTree, deps: [], target: i0.ÉµÉµFactoryTarget.Component });\n    static Éµcmp = i0.ÉµÉµngDeclareComponent({ minVersion: \"14.0.0\", version: \"20.2.0-next.2\", type: CdkTree, isStandalone: true, selector: \"cdk-tree\", inputs: { dataSource: \"dataSource\", treeControl: \"treeControl\", levelAccessor: \"levelAccessor\", childrenAccessor: \"childrenAccessor\", trackBy: \"trackBy\", expansionKey: \"expansionKey\" }, host: { attributes: { \"role\": \"tree\" }, listeners: { \"keydown\": \"_sendKeydownToKeyManager($event)\" }, classAttribute: \"cdk-tree\" }, queries: [{ propertyName: \"_nodeDefs\", predicate: CdkTreeNodeDef, descendants: true }], viewQueries: [{ propertyName: \"_nodeOutlet\", first: true, predicate: CdkTreeNodeOutlet, descendants: true, static: true }], exportAs: [\"cdkTree\"], ngImport: i0, template: `<ng-container cdkTreeNodeOutlet></ng-container>`, isInline: true, dependencies: [{ kind: \"directive\", type: CdkTreeNodeOutlet, selector: \"[cdkTreeNodeOutlet]\" }], changeDetection: i0.ChangeDetectionStrategy.Default, encapsulation: i0.ViewEncapsulation.None });\n}\ni0.ÉµÉµngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: CdkTree, decorators: [{\n            type: Component,\n            args: [{\n                    selector: 'cdk-tree',\n                    exportAs: 'cdkTree',\n                    template: `<ng-container cdkTreeNodeOutlet></ng-container>`,\n                    host: {\n                        'class': 'cdk-tree',\n                        'role': 'tree',\n                        '(keydown)': '_sendKeydownToKeyManager($event)',\n                    },\n                    encapsulation: ViewEncapsulation.None,\n                    // The \"OnPush\" status for the `CdkTree` component is effectively a noop, so we are removing it.\n                    // The view for `CdkTree` consists entirely of templates declared in other views. As they are\n                    // declared elsewhere, they are checked when their declaration points are checked.\n                    // tslint:disable-next-line:validate-decorators\n                    changeDetection: ChangeDetectionStrategy.Default,\n                    imports: [CdkTreeNodeOutlet],\n                }]\n        }], ctorParameters: () => [], propDecorators: { dataSource: [{\n                type: Input\n            }], treeControl: [{\n                type: Input\n            }], levelAccessor: [{\n                type: Input\n            }], childrenAccessor: [{\n                type: Input\n            }], trackBy: [{\n                type: Input\n            }], expansionKey: [{\n                type: Input\n            }], _nodeOutlet: [{\n                type: ViewChild,\n                args: [CdkTreeNodeOutlet, { static: true }]\n            }], _nodeDefs: [{\n                type: ContentChildren,\n                args: [CdkTreeNodeDef, {\n                        // We need to use `descendants: true`, because Ivy will no longer match\n                        // indirect descendants if it's left as false.\n                        descendants: true,\n                    }]\n            }] } });\n/**\n * Tree node for CdkTree. It contains the data in the tree node.\n */\nclass CdkTreeNode {\n    _elementRef = inject(ElementRef);\n    _tree = inject(CdkTree);\n    _tabindex = -1;\n    _type = 'flat';\n    /**\n     * The role of the tree node.\n     *\n     * @deprecated This will be ignored; the tree will automatically determine the appropriate role\n     * for tree node. This input will be removed in a future version.\n     * @breaking-change 21.0.0\n     */\n    get role() {\n        return 'treeitem';\n    }\n    set role(_role) {\n        // ignore any role setting, we handle this internally.\n    }\n    /**\n     * Whether or not this node is expandable.\n     *\n     * If not using `FlatTreeControl`, or if `isExpandable` is not provided to\n     * `NestedTreeControl`, this should be provided for correct node a11y.\n     */\n    get isExpandable() {\n        return this._isExpandable();\n    }\n    set isExpandable(isExpandable) {\n        this._inputIsExpandable = isExpandable;\n        if ((this.data && !this._isExpandable) || !this._inputIsExpandable) {\n            return;\n        }\n        // If the node is being set to expandable, ensure that the status of the\n        // node is propagated\n        if (this._inputIsExpanded) {\n            this.expand();\n        }\n        else if (this._inputIsExpanded === false) {\n            this.collapse();\n        }\n    }\n    get isExpanded() {\n        return this._tree.isExpanded(this._data);\n    }\n    set isExpanded(isExpanded) {\n        this._inputIsExpanded = isExpanded;\n        if (isExpanded) {\n            this.expand();\n        }\n        else {\n            this.collapse();\n        }\n    }\n    /**\n     * Whether or not this node is disabled. If it's disabled, then the user won't be able to focus\n     * or activate this node.\n     */\n    isDisabled;\n    /**\n     * The text used to locate this item during typeahead. If not specified, the `textContent` will\n     * will be used.\n     */\n    typeaheadLabel;\n    getLabel() {\n        return this.typeaheadLabel || this._elementRef.nativeElement.textContent?.trim() || '';\n    }\n    /** This emits when the node has been programatically activated or activated by keyboard. */\n    activation = new EventEmitter();\n    /** This emits when the node's expansion status has been changed. */\n    expandedChange = new EventEmitter();\n    /**\n     * The most recently created `CdkTreeNode`. We save it in static variable so we can retrieve it\n     * in `CdkTree` and set the data to it.\n     */\n    static mostRecentTreeNode = null;\n    /** Subject that emits when the component has been destroyed. */\n    _destroyed = new Subject();\n    /** Emits when the node's data has changed. */\n    _dataChanges = new Subject();\n    _inputIsExpandable = false;\n    _inputIsExpanded = undefined;\n    /**\n     * Flag used to determine whether or not we should be focusing the actual element based on\n     * some user interaction (click or focus). On click, we don't forcibly focus the element\n     * since the click could trigger some other component that wants to grab its own focus\n     * (e.g. menu, dialog).\n     */\n    _shouldFocus = true;\n    _parentNodeAriaLevel;\n    /** The tree node's data. */\n    get data() {\n        return this._data;\n    }\n    set data(value) {\n        if (value !== this._data) {\n            this._data = value;\n            this._dataChanges.next();\n        }\n    }\n    _data;\n    /* If leaf node, return true to not assign aria-expanded attribute */\n    get isLeafNode() {\n        // If flat tree node data returns false for expandable property, it's a leaf node\n        if (this._tree.treeControl?.isExpandable !== undefined &&\n            !this._tree.treeControl.isExpandable(this._data)) {\n            return true;\n            // If nested tree node data returns 0 descendants, it's a leaf node\n        }\n        else if (this._tree.treeControl?.isExpandable === undefined &&\n            this._tree.treeControl?.getDescendants(this._data).length === 0) {\n            return true;\n        }\n        return false;\n    }\n    get level() {\n        // If the tree has a levelAccessor, use it to get the level. Otherwise read the\n        // aria-level off the parent node and use it as the level for this node (note aria-level is\n        // 1-indexed, while this property is 0-indexed, so we don't need to increment).\n        return this._tree._getLevel(this._data) ?? this._parentNodeAriaLevel;\n    }\n    /** Determines if the tree node is expandable. */\n    _isExpandable() {\n        if (this._tree.treeControl) {\n            if (this.isLeafNode) {\n                return false;\n            }\n            // For compatibility with trees created using TreeControl before we added\n            // CdkTreeNode#isExpandable.\n            return true;\n        }\n        return this._inputIsExpandable;\n    }\n    /**\n     * Determines the value for `aria-expanded`.\n     *\n     * For non-expandable nodes, this is `null`.\n     */\n    _getAriaExpanded() {\n        if (!this._isExpandable()) {\n            return null;\n        }\n        return String(this.isExpanded);\n    }\n    /**\n     * Determines the size of this node's parent's child set.\n     *\n     * This is intended to be used for `aria-setsize`.\n     */\n    _getSetSize() {\n        return this._tree._getSetSize(this._data);\n    }\n    /**\n     * Determines the index (starting from 1) of this node in its parent's child set.\n     *\n     * This is intended to be used for `aria-posinset`.\n     */\n    _getPositionInSet() {\n        return this._tree._getPositionInSet(this._data);\n    }\n    _changeDetectorRef = inject(ChangeDetectorRef);\n    constructor() {\n        CdkTreeNode.mostRecentTreeNode = this;\n    }\n    ngOnInit() {\n        this._parentNodeAriaLevel = getParentNodeAriaLevel(this._elementRef.nativeElement);\n        this._tree\n            ._getExpansionModel()\n            .changed.pipe(map(() => this.isExpanded), distinctUntilChanged(), takeUntil(this._destroyed))\n            .pipe(takeUntil(this._destroyed))\n            .subscribe(() => this._changeDetectorRef.markForCheck());\n        this._tree._setNodeTypeIfUnset(this._type);\n        this._tree._registerNode(this);\n    }\n    ngOnDestroy() {\n        // If this is the last tree node being destroyed,\n        // clear out the reference to avoid leaking memory.\n        if (CdkTreeNode.mostRecentTreeNode === this) {\n            CdkTreeNode.mostRecentTreeNode = null;\n        }\n        this._dataChanges.complete();\n        this._destroyed.next();\n        this._destroyed.complete();\n    }\n    getParent() {\n        return this._tree._getNodeParent(this) ?? null;\n    }\n    getChildren() {\n        return this._tree._getNodeChildren(this);\n    }\n    /** Focuses this data node. Implemented for TreeKeyManagerItem. */\n    focus() {\n        this._tabindex = 0;\n        if (this._shouldFocus) {\n            this._elementRef.nativeElement.focus();\n        }\n        this._changeDetectorRef.markForCheck();\n    }\n    /** Defocus this data node. */\n    unfocus() {\n        this._tabindex = -1;\n        this._changeDetectorRef.markForCheck();\n    }\n    /** Emits an activation event. Implemented for TreeKeyManagerItem. */\n    activate() {\n        if (this.isDisabled) {\n            return;\n        }\n        this.activation.next(this._data);\n    }\n    /** Collapses this data node. Implemented for TreeKeyManagerItem. */\n    collapse() {\n        if (this.isExpandable) {\n            this._tree.collapse(this._data);\n        }\n    }\n    /** Expands this data node. Implemented for TreeKeyManagerItem. */\n    expand() {\n        if (this.isExpandable) {\n            this._tree.expand(this._data);\n        }\n    }\n    /** Makes the node focusable. Implemented for TreeKeyManagerItem. */\n    makeFocusable() {\n        this._tabindex = 0;\n        this._changeDetectorRef.markForCheck();\n    }\n    _focusItem() {\n        if (this.isDisabled) {\n            return;\n        }\n        this._tree._keyManager.focusItem(this);\n    }\n    _setActiveItem() {\n        if (this.isDisabled) {\n            return;\n        }\n        this._shouldFocus = false;\n        this._tree._keyManager.focusItem(this);\n        this._shouldFocus = true;\n    }\n    _emitExpansionState(expanded) {\n        this.expandedChange.emit(expanded);\n    }\n    static Éµfac = i0.ÉµÉµngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: CdkTreeNode, deps: [], target: i0.ÉµÉµFactoryTarget.Directive });\n    static Éµdir = i0.ÉµÉµngDeclareDirective({ minVersion: \"16.1.0\", version: \"20.2.0-next.2\", type: CdkTreeNode, isStandalone: true, selector: \"cdk-tree-node\", inputs: { role: \"role\", isExpandable: [\"isExpandable\", \"isExpandable\", booleanAttribute], isExpanded: \"isExpanded\", isDisabled: [\"isDisabled\", \"isDisabled\", booleanAttribute], typeaheadLabel: [\"cdkTreeNodeTypeaheadLabel\", \"typeaheadLabel\"] }, outputs: { activation: \"activation\", expandedChange: \"expandedChange\" }, host: { attributes: { \"role\": \"treeitem\" }, listeners: { \"click\": \"_setActiveItem()\", \"focus\": \"_focusItem()\" }, properties: { \"attr.aria-expanded\": \"_getAriaExpanded()\", \"attr.aria-level\": \"level + 1\", \"attr.aria-posinset\": \"_getPositionInSet()\", \"attr.aria-setsize\": \"_getSetSize()\", \"tabindex\": \"_tabindex\" }, classAttribute: \"cdk-tree-node\" }, exportAs: [\"cdkTreeNode\"], ngImport: i0 });\n}\ni0.ÉµÉµngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: CdkTreeNode, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: 'cdk-tree-node',\n                    exportAs: 'cdkTreeNode',\n                    host: {\n                        'class': 'cdk-tree-node',\n                        '[attr.aria-expanded]': '_getAriaExpanded()',\n                        '[attr.aria-level]': 'level + 1',\n                        '[attr.aria-posinset]': '_getPositionInSet()',\n                        '[attr.aria-setsize]': '_getSetSize()',\n                        '[tabindex]': '_tabindex',\n                        'role': 'treeitem',\n                        '(click)': '_setActiveItem()',\n                        '(focus)': '_focusItem()',\n                    },\n                }]\n        }], ctorParameters: () => [], propDecorators: { role: [{\n                type: Input\n            }], isExpandable: [{\n                type: Input,\n                args: [{ transform: booleanAttribute }]\n            }], isExpanded: [{\n                type: Input\n            }], isDisabled: [{\n                type: Input,\n                args: [{ transform: booleanAttribute }]\n            }], typeaheadLabel: [{\n                type: Input,\n                args: ['cdkTreeNodeTypeaheadLabel']\n            }], activation: [{\n                type: Output\n            }], expandedChange: [{\n                type: Output\n            }] } });\nfunction getParentNodeAriaLevel(nodeElement) {\n    let parent = nodeElement.parentElement;\n    while (parent && !isNodeElement(parent)) {\n        parent = parent.parentElement;\n    }\n    if (!parent) {\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            throw Error('Incorrect tree structure containing detached node.');\n        }\n        else {\n            return -1;\n        }\n    }\n    else if (parent.classList.contains('cdk-nested-tree-node')) {\n        return numberAttribute(parent.getAttribute('aria-level'));\n    }\n    else {\n        // The ancestor element is the cdk-tree itself\n        return 0;\n    }\n}\nfunction isNodeElement(element) {\n    const classList = element.classList;\n    return !!(classList?.contains('cdk-nested-tree-node') || classList?.contains('cdk-tree'));\n}\n\n/**\n * Nested node is a child of `<cdk-tree>`. It works with nested tree.\n * By using `cdk-nested-tree-node` component in tree node template, children of the parent node will\n * be added in the `cdkTreeNodeOutlet` in tree node template.\n * The children of node will be automatically added to `cdkTreeNodeOutlet`.\n */\nclass CdkNestedTreeNode extends CdkTreeNode {\n    _type = 'nested';\n    _differs = inject(IterableDiffers);\n    /** Differ used to find the changes in the data provided by the data source. */\n    _dataDiffer;\n    /** The children data dataNodes of current node. They will be placed in `CdkTreeNodeOutlet`. */\n    _children;\n    /** The children node placeholder. */\n    nodeOutlet;\n    constructor() {\n        super();\n    }\n    ngAfterContentInit() {\n        this._dataDiffer = this._differs.find([]).create(this._tree.trackBy);\n        this._tree\n            ._getDirectChildren(this.data)\n            .pipe(takeUntil(this._destroyed))\n            .subscribe(result => this.updateChildrenNodes(result));\n        this.nodeOutlet.changes\n            .pipe(takeUntil(this._destroyed))\n            .subscribe(() => this.updateChildrenNodes());\n    }\n    ngOnDestroy() {\n        this._clear();\n        super.ngOnDestroy();\n    }\n    /** Add children dataNodes to the NodeOutlet */\n    updateChildrenNodes(children) {\n        const outlet = this._getNodeOutlet();\n        if (children) {\n            this._children = children;\n        }\n        if (outlet && this._children) {\n            const viewContainer = outlet.viewContainer;\n            this._tree.renderNodeChanges(this._children, this._dataDiffer, viewContainer, this._data);\n        }\n        else {\n            // Reset the data differ if there's no children nodes displayed\n            this._dataDiffer.diff([]);\n        }\n    }\n    /** Clear the children dataNodes. */\n    _clear() {\n        const outlet = this._getNodeOutlet();\n        if (outlet) {\n            outlet.viewContainer.clear();\n            this._dataDiffer.diff([]);\n        }\n    }\n    /** Gets the outlet for the current node. */\n    _getNodeOutlet() {\n        const outlets = this.nodeOutlet;\n        // Note that since we use `descendants: true` on the query, we have to ensure\n        // that we don't pick up the outlet of a child node by accident.\n        return outlets && outlets.find(outlet => !outlet._node || outlet._node === this);\n    }\n    static Éµfac = i0.ÉµÉµngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: CdkNestedTreeNode, deps: [], target: i0.ÉµÉµFactoryTarget.Directive });\n    static Éµdir = i0.ÉµÉµngDeclareDirective({ minVersion: \"14.0.0\", version: \"20.2.0-next.2\", type: CdkNestedTreeNode, isStandalone: true, selector: \"cdk-nested-tree-node\", host: { classAttribute: \"cdk-nested-tree-node\" }, providers: [\n            { provide: CdkTreeNode, useExisting: CdkNestedTreeNode },\n            { provide: CDK_TREE_NODE_OUTLET_NODE, useExisting: CdkNestedTreeNode },\n        ], queries: [{ propertyName: \"nodeOutlet\", predicate: CdkTreeNodeOutlet, descendants: true }], exportAs: [\"cdkNestedTreeNode\"], usesInheritance: true, ngImport: i0 });\n}\ni0.ÉµÉµngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: CdkNestedTreeNode, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: 'cdk-nested-tree-node',\n                    exportAs: 'cdkNestedTreeNode',\n                    providers: [\n                        { provide: CdkTreeNode, useExisting: CdkNestedTreeNode },\n                        { provide: CDK_TREE_NODE_OUTLET_NODE, useExisting: CdkNestedTreeNode },\n                    ],\n                    host: {\n                        'class': 'cdk-nested-tree-node',\n                    },\n                }]\n        }], ctorParameters: () => [], propDecorators: { nodeOutlet: [{\n                type: ContentChildren,\n                args: [CdkTreeNodeOutlet, {\n                        // We need to use `descendants: true`, because Ivy will no longer match\n                        // indirect descendants if it's left as false.\n                        descendants: true,\n                    }]\n            }] } });\n\n/** Regex used to split a string on its CSS units. */\nconst cssUnitPattern = /([A-Za-z%]+)$/;\n/**\n * Indent for the children tree dataNodes.\n * This directive will add left-padding to the node to show hierarchy.\n */\nclass CdkTreeNodePadding {\n    _treeNode = inject(CdkTreeNode);\n    _tree = inject(CdkTree);\n    _element = inject(ElementRef);\n    _dir = inject(Directionality, { optional: true });\n    /** Current padding value applied to the element. Used to avoid unnecessarily hitting the DOM. */\n    _currentPadding;\n    /** Subject that emits when the component has been destroyed. */\n    _destroyed = new Subject();\n    /** CSS units used for the indentation value. */\n    indentUnits = 'px';\n    /** The level of depth of the tree node. The padding will be `level * indent` pixels. */\n    get level() {\n        return this._level;\n    }\n    set level(value) {\n        this._setLevelInput(value);\n    }\n    _level;\n    /**\n     * The indent for each level. Can be a number or a CSS string.\n     * Default number 40px from material design menu sub-menu spec.\n     */\n    get indent() {\n        return this._indent;\n    }\n    set indent(indent) {\n        this._setIndentInput(indent);\n    }\n    _indent = 40;\n    constructor() {\n        this._setPadding();\n        this._dir?.change.pipe(takeUntil(this._destroyed)).subscribe(() => this._setPadding(true));\n        // In Ivy the indentation binding might be set before the tree node's data has been added,\n        // which means that we'll miss the first render. We have to subscribe to changes in the\n        // data to ensure that everything is up to date.\n        this._treeNode._dataChanges.subscribe(() => this._setPadding());\n    }\n    ngOnDestroy() {\n        this._destroyed.next();\n        this._destroyed.complete();\n    }\n    /** The padding indent value for the tree node. Returns a string with px numbers if not null. */\n    _paddingIndent() {\n        const nodeLevel = (this._treeNode.data && this._tree._getLevel(this._treeNode.data)) ?? null;\n        const level = this._level == null ? nodeLevel : this._level;\n        return typeof level === 'number' ? `${level * this._indent}${this.indentUnits}` : null;\n    }\n    _setPadding(forceChange = false) {\n        const padding = this._paddingIndent();\n        if (padding !== this._currentPadding || forceChange) {\n            const element = this._element.nativeElement;\n            const paddingProp = this._dir && this._dir.value === 'rtl' ? 'paddingRight' : 'paddingLeft';\n            const resetProp = paddingProp === 'paddingLeft' ? 'paddingRight' : 'paddingLeft';\n            element.style[paddingProp] = padding || '';\n            element.style[resetProp] = '';\n            this._currentPadding = padding;\n        }\n    }\n    /**\n     * This has been extracted to a util because of TS 4 and VE.\n     * View Engine doesn't support property rename inheritance.\n     * TS 4.0 doesn't allow properties to override accessors or vice-versa.\n     * @docs-private\n     */\n    _setLevelInput(value) {\n        // Set to null as the fallback value so that _setPadding can fall back to the node level if the\n        // consumer set the directive as `cdkTreeNodePadding=\"\"`. We still want to take this value if\n        // they set 0 explicitly.\n        this._level = isNaN(value) ? null : value;\n        this._setPadding();\n    }\n    /**\n     * This has been extracted to a util because of TS 4 and VE.\n     * View Engine doesn't support property rename inheritance.\n     * TS 4.0 doesn't allow properties to override accessors or vice-versa.\n     * @docs-private\n     */\n    _setIndentInput(indent) {\n        let value = indent;\n        let units = 'px';\n        if (typeof indent === 'string') {\n            const parts = indent.split(cssUnitPattern);\n            value = parts[0];\n            units = parts[1] || units;\n        }\n        this.indentUnits = units;\n        this._indent = numberAttribute(value);\n        this._setPadding();\n    }\n    static Éµfac = i0.ÉµÉµngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: CdkTreeNodePadding, deps: [], target: i0.ÉµÉµFactoryTarget.Directive });\n    static Éµdir = i0.ÉµÉµngDeclareDirective({ minVersion: \"16.1.0\", version: \"20.2.0-next.2\", type: CdkTreeNodePadding, isStandalone: true, selector: \"[cdkTreeNodePadding]\", inputs: { level: [\"cdkTreeNodePadding\", \"level\", numberAttribute], indent: [\"cdkTreeNodePaddingIndent\", \"indent\"] }, ngImport: i0 });\n}\ni0.ÉµÉµngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: CdkTreeNodePadding, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[cdkTreeNodePadding]',\n                }]\n        }], ctorParameters: () => [], propDecorators: { level: [{\n                type: Input,\n                args: [{ alias: 'cdkTreeNodePadding', transform: numberAttribute }]\n            }], indent: [{\n                type: Input,\n                args: ['cdkTreeNodePaddingIndent']\n            }] } });\n\n/**\n * Node toggle to expand and collapse the node.\n */\nclass CdkTreeNodeToggle {\n    _tree = inject(CdkTree);\n    _treeNode = inject(CdkTreeNode);\n    /** Whether expand/collapse the node recursively. */\n    recursive = false;\n    constructor() { }\n    // Toggle the expanded or collapsed state of this node.\n    //\n    // Focus this node with expanding or collapsing it. This ensures that the active node will always\n    // be visible when expanding and collapsing.\n    _toggle() {\n        this.recursive\n            ? this._tree.toggleDescendants(this._treeNode.data)\n            : this._tree.toggle(this._treeNode.data);\n        this._tree._keyManager.focusItem(this._treeNode);\n    }\n    static Éµfac = i0.ÉµÉµngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: CdkTreeNodeToggle, deps: [], target: i0.ÉµÉµFactoryTarget.Directive });\n    static Éµdir = i0.ÉµÉµngDeclareDirective({ minVersion: \"16.1.0\", version: \"20.2.0-next.2\", type: CdkTreeNodeToggle, isStandalone: true, selector: \"[cdkTreeNodeToggle]\", inputs: { recursive: [\"cdkTreeNodeToggleRecursive\", \"recursive\", booleanAttribute] }, host: { attributes: { \"tabindex\": \"-1\" }, listeners: { \"click\": \"_toggle(); $event.stopPropagation();\", \"keydown.Enter\": \"_toggle(); $event.preventDefault();\", \"keydown.Space\": \"_toggle(); $event.preventDefault();\" } }, ngImport: i0 });\n}\ni0.ÉµÉµngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: CdkTreeNodeToggle, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[cdkTreeNodeToggle]',\n                    host: {\n                        '(click)': '_toggle(); $event.stopPropagation();',\n                        '(keydown.Enter)': '_toggle(); $event.preventDefault();',\n                        '(keydown.Space)': '_toggle(); $event.preventDefault();',\n                        'tabindex': '-1',\n                    },\n                }]\n        }], ctorParameters: () => [], propDecorators: { recursive: [{\n                type: Input,\n                args: [{ alias: 'cdkTreeNodeToggleRecursive', transform: booleanAttribute }]\n            }] } });\n\nconst EXPORTED_DECLARATIONS = [\n    CdkNestedTreeNode,\n    CdkTreeNodeDef,\n    CdkTreeNodePadding,\n    CdkTreeNodeToggle,\n    CdkTree,\n    CdkTreeNode,\n    CdkTreeNodeOutlet,\n];\nclass CdkTreeModule {\n    static Éµfac = i0.ÉµÉµngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: CdkTreeModule, deps: [], target: i0.ÉµÉµFactoryTarget.NgModule });\n    static Éµmod = i0.ÉµÉµngDeclareNgModule({ minVersion: \"14.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: CdkTreeModule, imports: [CdkNestedTreeNode,\n            CdkTreeNodeDef,\n            CdkTreeNodePadding,\n            CdkTreeNodeToggle,\n            CdkTree,\n            CdkTreeNode,\n            CdkTreeNodeOutlet], exports: [CdkNestedTreeNode,\n            CdkTreeNodeDef,\n            CdkTreeNodePadding,\n            CdkTreeNodeToggle,\n            CdkTree,\n            CdkTreeNode,\n            CdkTreeNodeOutlet] });\n    static Éµinj = i0.ÉµÉµngDeclareInjector({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: CdkTreeModule });\n}\ni0.ÉµÉµngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: CdkTreeModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: EXPORTED_DECLARATIONS,\n                    exports: EXPORTED_DECLARATIONS,\n                }]\n        }] });\n\nexport { BaseTreeControl, CDK_TREE_NODE_OUTLET_NODE, CdkNestedTreeNode, CdkTree, CdkTreeModule, CdkTreeNode, CdkTreeNodeDef, CdkTreeNodeOutlet, CdkTreeNodeOutletContext, CdkTreeNodePadding, CdkTreeNodeToggle, FlatTreeControl, NestedTreeControl, getMultipleTreeControlsError, getTreeControlMissingError, getTreeMissingMatchingNodeDefError, getTreeMultipleDefaultNodeDefsError, getTreeNoValidDataSourceError };\n"],"x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14]}