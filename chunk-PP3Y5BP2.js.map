{
  "version": 3,
  "sources": ["../../@angular/cdk/fesm2022/breakpoints-observer.mjs"],
  "sourcesContent": ["import * as i0 from '@angular/core';\nimport { inject, CSP_NONCE, Injectable, NgZone } from '@angular/core';\nimport { Subject, combineLatest, concat, Observable } from 'rxjs';\nimport { take, skip, debounceTime, map, startWith, takeUntil } from 'rxjs/operators';\nimport { Platform } from './platform2.mjs';\nimport { coerceArray } from './array.mjs';\n\n/** Global registry for all dynamically-created, injected media queries. */\nconst mediaQueriesForWebkitCompatibility = /*#__PURE__*/new Set();\n/** Style tag that holds all of the dynamically-created media queries. */\nlet mediaQueryStyleNode;\n/** A utility for calling matchMedia queries. */\nlet MediaMatcher = /*#__PURE__*/(() => {\n  class MediaMatcher {\n    _platform = inject(Platform);\n    _nonce = inject(CSP_NONCE, {\n      optional: true\n    });\n    /** The internal matchMedia method to return back a MediaQueryList like object. */\n    _matchMedia;\n    constructor() {\n      this._matchMedia = this._platform.isBrowser && window.matchMedia ?\n      // matchMedia is bound to the window scope intentionally as it is an illegal invocation to\n      // call it from a different scope.\n      window.matchMedia.bind(window) : noopMatchMedia;\n    }\n    /**\n     * Evaluates the given media query and returns the native MediaQueryList from which results\n     * can be retrieved.\n     * Confirms the layout engine will trigger for the selector query provided and returns the\n     * MediaQueryList for the query provided.\n     */\n    matchMedia(query) {\n      if (this._platform.WEBKIT || this._platform.BLINK) {\n        createEmptyStyleRule(query, this._nonce);\n      }\n      return this._matchMedia(query);\n    }\n    static \u0275fac = function MediaMatcher_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MediaMatcher)();\n    };\n    static \u0275prov = /* @__PURE__ */i0.\u0275\u0275defineInjectable({\n      token: MediaMatcher,\n      factory: MediaMatcher.\u0275fac,\n      providedIn: 'root'\n    });\n  }\n  return MediaMatcher;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Creates an empty stylesheet that is used to work around browser inconsistencies related to\n * `matchMedia`. At the time of writing, it handles the following cases:\n * 1. On WebKit browsers, a media query has to have at least one rule in order for `matchMedia`\n * to fire. We work around it by declaring a dummy stylesheet with a `@media` declaration.\n * 2. In some cases Blink browsers will stop firing the `matchMedia` listener if none of the rules\n * inside the `@media` match existing elements on the page. We work around it by having one rule\n * targeting the `body`. See https://github.com/angular/components/issues/23546.\n */\nfunction createEmptyStyleRule(query, nonce) {\n  if (mediaQueriesForWebkitCompatibility.has(query)) {\n    return;\n  }\n  try {\n    if (!mediaQueryStyleNode) {\n      mediaQueryStyleNode = document.createElement('style');\n      if (nonce) {\n        mediaQueryStyleNode.setAttribute('nonce', nonce);\n      }\n      mediaQueryStyleNode.setAttribute('type', 'text/css');\n      document.head.appendChild(mediaQueryStyleNode);\n    }\n    if (mediaQueryStyleNode.sheet) {\n      mediaQueryStyleNode.sheet.insertRule(`@media ${query} {body{ }}`, 0);\n      mediaQueriesForWebkitCompatibility.add(query);\n    }\n  } catch (e) {\n    console.error(e);\n  }\n}\n/** No-op matchMedia replacement for non-browser platforms. */\nfunction noopMatchMedia(query) {\n  // Use `as any` here to avoid adding additional necessary properties for\n  // the noop matcher.\n  return {\n    matches: query === 'all' || query === '',\n    media: query,\n    addListener: () => {},\n    removeListener: () => {}\n  };\n}\n\n/** Utility for checking the matching state of `@media` queries. */\nlet BreakpointObserver = /*#__PURE__*/(() => {\n  class BreakpointObserver {\n    _mediaMatcher = inject(MediaMatcher);\n    _zone = inject(NgZone);\n    /**  A map of all media queries currently being listened for. */\n    _queries = new Map();\n    /** A subject for all other observables to takeUntil based on. */\n    _destroySubject = new Subject();\n    constructor() {}\n    /** Completes the active subject, signalling to all other observables to complete. */\n    ngOnDestroy() {\n      this._destroySubject.next();\n      this._destroySubject.complete();\n    }\n    /**\n     * Whether one or more media queries match the current viewport size.\n     * @param value One or more media queries to check.\n     * @returns Whether any of the media queries match.\n     */\n    isMatched(value) {\n      const queries = splitQueries(coerceArray(value));\n      return queries.some(mediaQuery => this._registerQuery(mediaQuery).mql.matches);\n    }\n    /**\n     * Gets an observable of results for the given queries that will emit new results for any changes\n     * in matching of the given queries.\n     * @param value One or more media queries to check.\n     * @returns A stream of matches for the given queries.\n     */\n    observe(value) {\n      const queries = splitQueries(coerceArray(value));\n      const observables = queries.map(query => this._registerQuery(query).observable);\n      let stateObservable = combineLatest(observables);\n      // Emit the first state immediately, and then debounce the subsequent emissions.\n      stateObservable = concat(stateObservable.pipe(take(1)), stateObservable.pipe(skip(1), debounceTime(0)));\n      return stateObservable.pipe(map(breakpointStates => {\n        const response = {\n          matches: false,\n          breakpoints: {}\n        };\n        breakpointStates.forEach(({\n          matches,\n          query\n        }) => {\n          response.matches = response.matches || matches;\n          response.breakpoints[query] = matches;\n        });\n        return response;\n      }));\n    }\n    /** Registers a specific query to be listened for. */\n    _registerQuery(query) {\n      // Only set up a new MediaQueryList if it is not already being listened for.\n      if (this._queries.has(query)) {\n        return this._queries.get(query);\n      }\n      const mql = this._mediaMatcher.matchMedia(query);\n      // Create callback for match changes and add it is as a listener.\n      const queryObservable = new Observable(observer => {\n        // Listener callback methods are wrapped to be placed back in ngZone. Callbacks must be placed\n        // back into the zone because matchMedia is only included in Zone.js by loading the\n        // webapis-media-query.js file alongside the zone.js file.  Additionally, some browsers do not\n        // have MediaQueryList inherit from EventTarget, which causes inconsistencies in how Zone.js\n        // patches it.\n        const handler = e => this._zone.run(() => observer.next(e));\n        mql.addListener(handler);\n        return () => {\n          mql.removeListener(handler);\n        };\n      }).pipe(startWith(mql), map(({\n        matches\n      }) => ({\n        query,\n        matches\n      })), takeUntil(this._destroySubject));\n      // Add the MediaQueryList to the set of queries.\n      const output = {\n        observable: queryObservable,\n        mql\n      };\n      this._queries.set(query, output);\n      return output;\n    }\n    static \u0275fac = function BreakpointObserver_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || BreakpointObserver)();\n    };\n    static \u0275prov = /* @__PURE__ */i0.\u0275\u0275defineInjectable({\n      token: BreakpointObserver,\n      factory: BreakpointObserver.\u0275fac,\n      providedIn: 'root'\n    });\n  }\n  return BreakpointObserver;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Split each query string into separate query strings if two queries are provided as comma\n * separated.\n */\nfunction splitQueries(queries) {\n  return queries.map(query => query.split(',')).reduce((a1, a2) => a1.concat(a2)).map(query => query.trim());\n}\nexport { BreakpointObserver, MediaMatcher };\n"],
  "mappings": "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",
  "names": ["i0", "inject", "CSP_NONCE", "NgZone", "Subject", "combineLatest", "concat", "Observable", "take", "skip", "debounceTime", "map", "startWith", "takeUntil", "mediaQueriesForWebkitCompatibility", "mediaQueryStyleNode", "MediaMatcher", "inject", "Platform", "CSP_NONCE", "noopMatchMedia", "query", "createEmptyStyleRule", "__ngFactoryType__", "nonce", "e", "BreakpointObserver", "NgZone", "Subject", "value", "splitQueries", "coerceArray", "mediaQuery", "observables", "stateObservable", "combineLatest", "concat", "take", "skip", "debounceTime", "map", "breakpointStates", "response", "matches", "mql", "output", "Observable", "observer", "handler", "startWith", "takeUntil", "queries", "a1", "a2"]
}
