{
  "version": 3,
  "sources": ["../../@ngrx/effects/fesm2022/ngrx-effects.mjs"],
  "sourcesContent": ["import * as i1 from 'rxjs';\nimport { merge, Observable, Subject } from 'rxjs';\nimport { ignoreElements, materialize, map, catchError, filter, groupBy, mergeMap, exhaustMap, dematerialize, take } from 'rxjs/operators';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, Inject, Injectable, Optional, NgModule, inject, makeEnvironmentProviders, provideEnvironmentInitializer } from '@angular/core';\nimport * as i3 from '@ngrx/store';\nimport { ScannedActionsSubject, createAction, ROOT_STORE_PROVIDER, FEATURE_STATE_PROVIDER, Store } from '@ngrx/store';\nconst DEFAULT_EFFECT_CONFIG = {\n  dispatch: true,\n  functional: false,\n  useEffectsErrorHandler: true\n};\nconst CREATE_EFFECT_METADATA_KEY = '__@ngrx/effects_create__';\n\n/**\n * @description\n *\n * Creates an effect from a source and an `EffectConfig`.\n *\n * @param source A function which returns an observable or observable factory.\n * @param config A `EffectConfig` to configure the effect. By default,\n * `dispatch` is true, `functional` is false, and `useEffectsErrorHandler` is\n * true.\n * @returns If `EffectConfig`#`functional` is true, returns the source function.\n * Else, returns the source function result. When `EffectConfig`#`dispatch` is\n * true, the source function result needs to be `Observable<Action>`.\n *\n * @usageNotes\n *\n * ### Class Effects\n *\n * ```ts\n * @Injectable()\n * export class FeatureEffects {\n *   // mapping to a different action\n *   readonly effect1$ = createEffect(\n *     () => this.actions$.pipe(\n *       ofType(FeatureActions.actionOne),\n *       map(() => FeatureActions.actionTwo())\n *     )\n *   );\n *\n *   // non-dispatching effect\n *   readonly effect2$ = createEffect(\n *     () => this.actions$.pipe(\n *       ofType(FeatureActions.actionTwo),\n *       tap(() => console.log('Action Two Dispatched'))\n *     ),\n *     { dispatch: false } // FeatureActions.actionTwo is not dispatched\n *   );\n *\n *   constructor(private readonly actions$: Actions) {}\n * }\n * ```\n *\n * ### Functional Effects\n *\n * ```ts\n * // mapping to a different action\n * export const loadUsers = createEffect(\n *   (actions$ = inject(Actions), usersService = inject(UsersService)) => {\n *     return actions$.pipe(\n *       ofType(UsersPageActions.opened),\n *       exhaustMap(() => {\n *         return usersService.getAll().pipe(\n *           map((users) => UsersApiActions.usersLoadedSuccess({ users })),\n *           catchError((error) =>\n *             of(UsersApiActions.usersLoadedFailure({ error }))\n *           )\n *         );\n *       })\n *     );\n *   },\n *   { functional: true }\n * );\n *\n * // non-dispatching functional effect\n * export const logDispatchedActions = createEffect(\n *   () => inject(Actions).pipe(tap(console.log)),\n *   { functional: true, dispatch: false }\n * );\n * ```\n */\nfunction createEffect(source, config = {}) {\n  const effect = config.functional ? source : source();\n  const value = {\n    ...DEFAULT_EFFECT_CONFIG,\n    ...config // Overrides any defaults if values are provided\n  };\n  Object.defineProperty(effect, CREATE_EFFECT_METADATA_KEY, {\n    value\n  });\n  return effect;\n}\nfunction getCreateEffectMetadata(instance) {\n  const propertyNames = Object.getOwnPropertyNames(instance);\n  const metadata = propertyNames.filter(propertyName => {\n    if (instance[propertyName] && instance[propertyName].hasOwnProperty(CREATE_EFFECT_METADATA_KEY)) {\n      // If the property type has overridden `hasOwnProperty` we need to ensure\n      // that the metadata is valid (containing a `dispatch` property)\n      // https://github.com/ngrx/platform/issues/2975\n      const property = instance[propertyName];\n      return property[CREATE_EFFECT_METADATA_KEY].hasOwnProperty('dispatch');\n    }\n    return false;\n  }).map(propertyName => {\n    const metaData = instance[propertyName][CREATE_EFFECT_METADATA_KEY];\n    return {\n      propertyName,\n      ...metaData\n    };\n  });\n  return metadata;\n}\nfunction getEffectsMetadata(instance) {\n  return getSourceMetadata(instance).reduce((acc, {\n    propertyName,\n    dispatch,\n    useEffectsErrorHandler\n  }) => {\n    acc[propertyName] = {\n      dispatch,\n      useEffectsErrorHandler\n    };\n    return acc;\n  }, {});\n}\nfunction getSourceMetadata(instance) {\n  return getCreateEffectMetadata(instance);\n}\nfunction getSourceForInstance(instance) {\n  return Object.getPrototypeOf(instance);\n}\nfunction isClassInstance(obj) {\n  return !!obj.constructor && obj.constructor.name !== 'Object' && obj.constructor.name !== 'Function';\n}\nfunction isClass(classOrRecord) {\n  return typeof classOrRecord === 'function';\n}\nfunction getClasses(classesAndRecords) {\n  return classesAndRecords.filter(isClass);\n}\nfunction isToken(tokenOrRecord) {\n  return tokenOrRecord instanceof InjectionToken || isClass(tokenOrRecord);\n}\nfunction mergeEffects(sourceInstance, globalErrorHandler, effectsErrorHandler) {\n  const source = getSourceForInstance(sourceInstance);\n  const isClassBasedEffect = !!source && source.constructor.name !== 'Object';\n  const sourceName = isClassBasedEffect ? source.constructor.name : null;\n  const observables$ = getSourceMetadata(sourceInstance).map(({\n    propertyName,\n    dispatch,\n    useEffectsErrorHandler\n  }) => {\n    const observable$ = typeof sourceInstance[propertyName] === 'function' ? sourceInstance[propertyName]() : sourceInstance[propertyName];\n    const effectAction$ = useEffectsErrorHandler ? effectsErrorHandler(observable$, globalErrorHandler) : observable$;\n    if (dispatch === false) {\n      return effectAction$.pipe(ignoreElements());\n    }\n    const materialized$ = effectAction$.pipe(materialize());\n    return materialized$.pipe(map(notification => ({\n      effect: sourceInstance[propertyName],\n      notification,\n      propertyName,\n      sourceName,\n      sourceInstance\n    })));\n  });\n  return merge(...observables$);\n}\nconst MAX_NUMBER_OF_RETRY_ATTEMPTS = 10;\nfunction defaultEffectsErrorHandler(observable$, errorHandler, retryAttemptLeft = MAX_NUMBER_OF_RETRY_ATTEMPTS) {\n  return observable$.pipe(catchError(error => {\n    if (errorHandler) errorHandler.handleError(error);\n    if (retryAttemptLeft <= 1) {\n      return observable$; // last attempt\n    }\n    // Return observable that produces this particular effect\n    return defaultEffectsErrorHandler(observable$, errorHandler, retryAttemptLeft - 1);\n  }));\n}\nlet Actions = /*#__PURE__*/(() => {\n  class Actions extends Observable {\n    constructor(source) {\n      super();\n      if (source) {\n        this.source = source;\n      }\n    }\n    lift(operator) {\n      const observable = new Actions();\n      observable.source = this;\n      observable.operator = operator;\n      return observable;\n    }\n    /** @nocollapse */\n    static {\n      this.\u0275fac = function Actions_Factory(__ngFactoryType__) {\n        return new (__ngFactoryType__ || Actions)(i0.\u0275\u0275inject(ScannedActionsSubject));\n      };\n    }\n    /** @nocollapse */\n    static {\n      this.\u0275prov = /* @__PURE__ */i0.\u0275\u0275defineInjectable({\n        token: Actions,\n        factory: Actions.\u0275fac,\n        providedIn: 'root'\n      });\n    }\n  }\n  return Actions;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * `ofType` filters an Observable of `Actions` into an Observable of the actions\n * whose type strings are passed to it.\n *\n * For example, if `actions` has type `Actions<AdditionAction|SubstractionAction>`, and\n * the type of the `Addition` action is `add`, then\n * `actions.pipe(ofType('add'))` returns an `Observable<AdditionAction>`.\n *\n * Properly typing this function is hard and requires some advanced TS tricks\n * below.\n *\n * Type narrowing automatically works, as long as your `actions` object\n * starts with a `Actions<SomeUnionOfActions>` instead of generic `Actions`.\n *\n * For backwards compatibility, when one passes a single type argument\n * `ofType<T>('something')` the result is an `Observable<T>`. Note, that `T`\n * completely overrides any possible inference from 'something'.\n *\n * Unfortunately, for unknown 'actions: Actions' these types will produce\n * 'Observable<never>'. In such cases one has to manually set the generic type\n * like `actions.ofType<AdditionAction>('add')`.\n *\n * @usageNotes\n *\n * Filter the Actions stream on the \"customers page loaded\" action\n *\n * ```ts\n * import { ofType } from '@ngrx/effects';\n * import * fromCustomers from '../customers';\n *\n * this.actions$.pipe(\n *  ofType(fromCustomers.pageLoaded)\n * )\n * ```\n */\nfunction ofType(...allowedTypes) {\n  return filter(action => allowedTypes.some(typeOrActionCreator => {\n    if (typeof typeOrActionCreator === 'string') {\n      // Comparing the string to type\n      return typeOrActionCreator === action.type;\n    }\n    // We are filtering by ActionCreator\n    return typeOrActionCreator.type === action.type;\n  }));\n}\nconst _ROOT_EFFECTS_GUARD = /*#__PURE__*/new InjectionToken('@ngrx/effects Internal Root Guard');\nconst USER_PROVIDED_EFFECTS = /*#__PURE__*/new InjectionToken('@ngrx/effects User Provided Effects');\nconst _ROOT_EFFECTS = /*#__PURE__*/new InjectionToken('@ngrx/effects Internal Root Effects');\nconst _ROOT_EFFECTS_INSTANCES = /*#__PURE__*/new InjectionToken('@ngrx/effects Internal Root Effects Instances');\nconst _FEATURE_EFFECTS = /*#__PURE__*/new InjectionToken('@ngrx/effects Internal Feature Effects');\nconst _FEATURE_EFFECTS_INSTANCE_GROUPS = /*#__PURE__*/new InjectionToken('@ngrx/effects Internal Feature Effects Instance Groups');\nconst EFFECTS_ERROR_HANDLER = /*#__PURE__*/new InjectionToken('@ngrx/effects Effects Error Handler', {\n  providedIn: 'root',\n  factory: () => defaultEffectsErrorHandler\n});\nconst ROOT_EFFECTS_INIT = '@ngrx/effects/init';\nconst rootEffectsInit = createAction(ROOT_EFFECTS_INIT);\nfunction reportInvalidActions(output, reporter) {\n  if (output.notification.kind === 'N') {\n    const action = output.notification.value;\n    const isInvalidAction = !isAction(action);\n    if (isInvalidAction) {\n      reporter.handleError(new Error(`Effect ${getEffectName(output)} dispatched an invalid action: ${stringify(action)}`));\n    }\n  }\n}\nfunction isAction(action) {\n  return typeof action !== 'function' && action && action.type && typeof action.type === 'string';\n}\nfunction getEffectName({\n  propertyName,\n  sourceInstance,\n  sourceName\n}) {\n  const isMethod = typeof sourceInstance[propertyName] === 'function';\n  const isClassBasedEffect = !!sourceName;\n  return isClassBasedEffect ? `\"${sourceName}.${String(propertyName)}${isMethod ? '()' : ''}\"` : `\"${String(propertyName)}()\"`;\n}\nfunction stringify(action) {\n  try {\n    return JSON.stringify(action);\n  } catch {\n    return action;\n  }\n}\nconst onIdentifyEffectsKey = 'ngrxOnIdentifyEffects';\nfunction isOnIdentifyEffects(instance) {\n  return isFunction(instance, onIdentifyEffectsKey);\n}\nconst onRunEffectsKey = 'ngrxOnRunEffects';\nfunction isOnRunEffects(instance) {\n  return isFunction(instance, onRunEffectsKey);\n}\nconst onInitEffects = 'ngrxOnInitEffects';\nfunction isOnInitEffects(instance) {\n  return isFunction(instance, onInitEffects);\n}\nfunction isFunction(instance, functionName) {\n  return instance && functionName in instance && typeof instance[functionName] === 'function';\n}\nlet EffectSources = /*#__PURE__*/(() => {\n  class EffectSources extends Subject {\n    constructor(errorHandler, effectsErrorHandler) {\n      super();\n      this.errorHandler = errorHandler;\n      this.effectsErrorHandler = effectsErrorHandler;\n    }\n    addEffects(effectSourceInstance) {\n      this.next(effectSourceInstance);\n    }\n    /**\n     * @internal\n     */\n    toActions() {\n      return this.pipe(groupBy(effectsInstance => isClassInstance(effectsInstance) ? getSourceForInstance(effectsInstance) : effectsInstance), mergeMap(source$ => {\n        return source$.pipe(groupBy(effectsInstance));\n      }), mergeMap(source$ => {\n        const effect$ = source$.pipe(exhaustMap(sourceInstance => {\n          return resolveEffectSource(this.errorHandler, this.effectsErrorHandler)(sourceInstance);\n        }), map(output => {\n          reportInvalidActions(output, this.errorHandler);\n          return output.notification;\n        }), filter(notification => notification.kind === 'N' && notification.value != null), dematerialize());\n        // start the stream with an INIT action\n        // do this only for the first Effect instance\n        const init$ = source$.pipe(take(1), filter(isOnInitEffects), map(instance => instance.ngrxOnInitEffects()));\n        return merge(effect$, init$);\n      }));\n    }\n    /** @nocollapse */\n    static {\n      this.\u0275fac = function EffectSources_Factory(__ngFactoryType__) {\n        return new (__ngFactoryType__ || EffectSources)(i0.\u0275\u0275inject(i0.ErrorHandler), i0.\u0275\u0275inject(EFFECTS_ERROR_HANDLER));\n      };\n    }\n    /** @nocollapse */\n    static {\n      this.\u0275prov = /* @__PURE__ */i0.\u0275\u0275defineInjectable({\n        token: EffectSources,\n        factory: EffectSources.\u0275fac,\n        providedIn: 'root'\n      });\n    }\n  }\n  return EffectSources;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction effectsInstance(sourceInstance) {\n  if (isOnIdentifyEffects(sourceInstance)) {\n    return sourceInstance.ngrxOnIdentifyEffects();\n  }\n  return '';\n}\nfunction resolveEffectSource(errorHandler, effectsErrorHandler) {\n  return sourceInstance => {\n    const mergedEffects$ = mergeEffects(sourceInstance, errorHandler, effectsErrorHandler);\n    if (isOnRunEffects(sourceInstance)) {\n      return sourceInstance.ngrxOnRunEffects(mergedEffects$);\n    }\n    return mergedEffects$;\n  };\n}\nlet EffectsRunner = /*#__PURE__*/(() => {\n  class EffectsRunner {\n    get isStarted() {\n      return !!this.effectsSubscription;\n    }\n    constructor(effectSources, store) {\n      this.effectSources = effectSources;\n      this.store = store;\n      this.effectsSubscription = null;\n    }\n    start() {\n      if (!this.effectsSubscription) {\n        this.effectsSubscription = this.effectSources.toActions().subscribe(this.store);\n      }\n    }\n    ngOnDestroy() {\n      if (this.effectsSubscription) {\n        this.effectsSubscription.unsubscribe();\n        this.effectsSubscription = null;\n      }\n    }\n    /** @nocollapse */\n    static {\n      this.\u0275fac = function EffectsRunner_Factory(__ngFactoryType__) {\n        return new (__ngFactoryType__ || EffectsRunner)(i0.\u0275\u0275inject(EffectSources), i0.\u0275\u0275inject(i3.Store));\n      };\n    }\n    /** @nocollapse */\n    static {\n      this.\u0275prov = /* @__PURE__ */i0.\u0275\u0275defineInjectable({\n        token: EffectsRunner,\n        factory: EffectsRunner.\u0275fac,\n        providedIn: 'root'\n      });\n    }\n  }\n  return EffectsRunner;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet EffectsRootModule = /*#__PURE__*/(() => {\n  class EffectsRootModule {\n    constructor(sources, runner, store, rootEffectsInstances, storeRootModule, storeFeatureModule, guard) {\n      this.sources = sources;\n      runner.start();\n      for (const effectsInstance of rootEffectsInstances) {\n        sources.addEffects(effectsInstance);\n      }\n      store.dispatch({\n        type: ROOT_EFFECTS_INIT\n      });\n    }\n    addEffects(effectsInstance) {\n      this.sources.addEffects(effectsInstance);\n    }\n    /** @nocollapse */\n    static {\n      this.\u0275fac = function EffectsRootModule_Factory(__ngFactoryType__) {\n        return new (__ngFactoryType__ || EffectsRootModule)(i0.\u0275\u0275inject(EffectSources), i0.\u0275\u0275inject(EffectsRunner), i0.\u0275\u0275inject(i3.Store), i0.\u0275\u0275inject(_ROOT_EFFECTS_INSTANCES), i0.\u0275\u0275inject(i3.StoreRootModule, 8), i0.\u0275\u0275inject(i3.StoreFeatureModule, 8), i0.\u0275\u0275inject(_ROOT_EFFECTS_GUARD, 8));\n      };\n    }\n    /** @nocollapse */\n    static {\n      this.\u0275mod = /* @__PURE__ */i0.\u0275\u0275defineNgModule({\n        type: EffectsRootModule\n      });\n    }\n    /** @nocollapse */\n    static {\n      this.\u0275inj = /* @__PURE__ */i0.\u0275\u0275defineInjector({});\n    }\n  }\n  return EffectsRootModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet EffectsFeatureModule = /*#__PURE__*/(() => {\n  class EffectsFeatureModule {\n    constructor(effectsRootModule, effectsInstanceGroups, storeRootModule, storeFeatureModule) {\n      const effectsInstances = effectsInstanceGroups.flat();\n      for (const effectsInstance of effectsInstances) {\n        effectsRootModule.addEffects(effectsInstance);\n      }\n    }\n    /** @nocollapse */\n    static {\n      this.\u0275fac = function EffectsFeatureModule_Factory(__ngFactoryType__) {\n        return new (__ngFactoryType__ || EffectsFeatureModule)(i0.\u0275\u0275inject(EffectsRootModule), i0.\u0275\u0275inject(_FEATURE_EFFECTS_INSTANCE_GROUPS), i0.\u0275\u0275inject(i3.StoreRootModule, 8), i0.\u0275\u0275inject(i3.StoreFeatureModule, 8));\n      };\n    }\n    /** @nocollapse */\n    static {\n      this.\u0275mod = /* @__PURE__ */i0.\u0275\u0275defineNgModule({\n        type: EffectsFeatureModule\n      });\n    }\n    /** @nocollapse */\n    static {\n      this.\u0275inj = /* @__PURE__ */i0.\u0275\u0275defineInjector({});\n    }\n  }\n  return EffectsFeatureModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet EffectsModule = /*#__PURE__*/(() => {\n  class EffectsModule {\n    static forFeature(...featureEffects) {\n      const effects = featureEffects.flat();\n      const effectsClasses = getClasses(effects);\n      return {\n        ngModule: EffectsFeatureModule,\n        providers: [effectsClasses, {\n          provide: _FEATURE_EFFECTS,\n          multi: true,\n          useValue: effects\n        }, {\n          provide: USER_PROVIDED_EFFECTS,\n          multi: true,\n          useValue: []\n        }, {\n          provide: _FEATURE_EFFECTS_INSTANCE_GROUPS,\n          multi: true,\n          useFactory: createEffectsInstances,\n          deps: [_FEATURE_EFFECTS, USER_PROVIDED_EFFECTS]\n        }]\n      };\n    }\n    static forRoot(...rootEffects) {\n      const effects = rootEffects.flat();\n      const effectsClasses = getClasses(effects);\n      return {\n        ngModule: EffectsRootModule,\n        providers: [effectsClasses, {\n          provide: _ROOT_EFFECTS,\n          useValue: [effects]\n        }, {\n          provide: _ROOT_EFFECTS_GUARD,\n          useFactory: _provideForRootGuard\n        }, {\n          provide: USER_PROVIDED_EFFECTS,\n          multi: true,\n          useValue: []\n        }, {\n          provide: _ROOT_EFFECTS_INSTANCES,\n          useFactory: createEffectsInstances,\n          deps: [_ROOT_EFFECTS, USER_PROVIDED_EFFECTS]\n        }]\n      };\n    }\n    /** @nocollapse */\n    static {\n      this.\u0275fac = function EffectsModule_Factory(__ngFactoryType__) {\n        return new (__ngFactoryType__ || EffectsModule)();\n      };\n    }\n    /** @nocollapse */\n    static {\n      this.\u0275mod = /* @__PURE__ */i0.\u0275\u0275defineNgModule({\n        type: EffectsModule\n      });\n    }\n    /** @nocollapse */\n    static {\n      this.\u0275inj = /* @__PURE__ */i0.\u0275\u0275defineInjector({});\n    }\n  }\n  return EffectsModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction createEffectsInstances(effectsGroups, userProvidedEffectsGroups) {\n  const effects = [];\n  for (const effectsGroup of effectsGroups) {\n    effects.push(...effectsGroup);\n  }\n  for (const userProvidedEffectsGroup of userProvidedEffectsGroups) {\n    effects.push(...userProvidedEffectsGroup);\n  }\n  return effects.map(effectsTokenOrRecord => isToken(effectsTokenOrRecord) ? inject(effectsTokenOrRecord) : effectsTokenOrRecord);\n}\nfunction _provideForRootGuard() {\n  const runner = inject(EffectsRunner, {\n    optional: true,\n    skipSelf: true\n  });\n  const rootEffects = inject(_ROOT_EFFECTS, {\n    self: true\n  });\n  // check whether any effects are actually passed\n  const hasEffects = !(rootEffects.length === 1 && rootEffects[0].length === 0);\n  if (hasEffects && runner) {\n    throw new TypeError(`EffectsModule.forRoot() called twice. Feature modules should use EffectsModule.forFeature() instead.`);\n  }\n  return 'guarded';\n}\n\n/**\n * @usageNotes\n *\n * ### Providing effects at the root level\n *\n * ```ts\n * bootstrapApplication(AppComponent, {\n *   providers: [provideEffects(RouterEffects)],\n * });\n * ```\n *\n * ### Providing effects at the feature level\n *\n * ```ts\n * const booksRoutes: Route[] = [\n *   {\n *     path: '',\n *     providers: [provideEffects(BooksApiEffects)],\n *     children: [\n *       { path: '', component: BookListComponent },\n *       { path: ':id', component: BookDetailsComponent },\n *     ],\n *   },\n * ];\n * ```\n */\nfunction provideEffects(...effects) {\n  const effectsClassesAndRecords = effects.flat();\n  const effectsClasses = getClasses(effectsClassesAndRecords);\n  return makeEnvironmentProviders([effectsClasses, provideEnvironmentInitializer(() => {\n    inject(ROOT_STORE_PROVIDER);\n    inject(FEATURE_STATE_PROVIDER, {\n      optional: true\n    });\n    const effectsRunner = inject(EffectsRunner);\n    const effectSources = inject(EffectSources);\n    const shouldInitEffects = !effectsRunner.isStarted;\n    if (shouldInitEffects) {\n      effectsRunner.start();\n    }\n    for (const effectsClassOrRecord of effectsClassesAndRecords) {\n      const effectsInstance = isClass(effectsClassOrRecord) ? inject(effectsClassOrRecord) : effectsClassOrRecord;\n      effectSources.addEffects(effectsInstance);\n    }\n    if (shouldInitEffects) {\n      const store = inject(Store);\n      store.dispatch(rootEffectsInit());\n    }\n  })]);\n}\n\n/**\n * DO NOT EDIT\n *\n * This file is automatically generated at build\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { Actions, EFFECTS_ERROR_HANDLER, EffectSources, EffectsFeatureModule, EffectsModule, EffectsRootModule, EffectsRunner, ROOT_EFFECTS_INIT, USER_PROVIDED_EFFECTS, createEffect, defaultEffectsErrorHandler, getEffectsMetadata, mergeEffects, ofType, provideEffects, rootEffectsInit };\n"],
  "mappings": "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",
  "names": ["merge", "Observable", "Subject", "ignoreElements", "materialize", "map", "catchError", "filter", "groupBy", "mergeMap", "exhaustMap", "dematerialize", "take", "i0", "InjectionToken", "inject", "makeEnvironmentProviders", "provideEnvironmentInitializer", "i3", "ScannedActionsSubject", "createAction", "ROOT_STORE_PROVIDER", "FEATURE_STATE_PROVIDER", "Store", "DEFAULT_EFFECT_CONFIG", "CREATE_EFFECT_METADATA_KEY", "createEffect", "source", "config", "effect", "value", "__spreadValues", "getCreateEffectMetadata", "instance", "propertyName", "metaData", "getEffectsMetadata", "getSourceMetadata", "acc", "dispatch", "useEffectsErrorHandler", "getSourceForInstance", "isClassInstance", "obj", "isClass", "classOrRecord", "getClasses", "classesAndRecords", "isToken", "tokenOrRecord", "InjectionToken", "mergeEffects", "sourceInstance", "globalErrorHandler", "effectsErrorHandler", "sourceName", "observables$", "observable$", "effectAction$", "ignoreElements", "materialize", "map", "notification", "merge", "MAX_NUMBER_OF_RETRY_ATTEMPTS", "defaultEffectsErrorHandler", "errorHandler", "retryAttemptLeft", "catchError", "error", "Actions", "Observable", "operator", "observable", "__ngFactoryType__", "ScannedActionsSubject", "ofType", "allowedTypes", "filter", "action", "typeOrActionCreator", "_ROOT_EFFECTS_GUARD", "USER_PROVIDED_EFFECTS", "_ROOT_EFFECTS", "_ROOT_EFFECTS_INSTANCES", "_FEATURE_EFFECTS", "_FEATURE_EFFECTS_INSTANCE_GROUPS", "EFFECTS_ERROR_HANDLER", "ROOT_EFFECTS_INIT", "rootEffectsInit", "createAction", "reportInvalidActions", "output", "reporter", "isAction", "getEffectName", "stringify", "isMethod", "onIdentifyEffectsKey", "isOnIdentifyEffects", "isFunction", "onRunEffectsKey", "isOnRunEffects", "onInitEffects", "isOnInitEffects", "functionName", "EffectSources", "Subject", "effectSourceInstance", "groupBy", "effectsInstance", "mergeMap", "source$", "effect$", "exhaustMap", "resolveEffectSource", "dematerialize", "init$", "take", "mergedEffects$", "EffectsRunner", "effectSources", "store", "EffectsRootModule", "sources", "runner", "rootEffectsInstances", "storeRootModule", "storeFeatureModule", "guard", "EffectsFeatureModule", "effectsRootModule", "effectsInstanceGroups", "effectsInstances", "EffectsModule", "featureEffects", "effects", "effectsClasses", "createEffectsInstances", "rootEffects", "_provideForRootGuard", "effectsGroups", "userProvidedEffectsGroups", "effectsGroup", "userProvidedEffectsGroup", "effectsTokenOrRecord", "inject", "provideEffects", "effectsClassesAndRecords", "makeEnvironmentProviders", "provideEnvironmentInitializer", "ROOT_STORE_PROVIDER", "FEATURE_STATE_PROVIDER", "effectsRunner", "shouldInitEffects", "effectsClassOrRecord", "Store"]
}
