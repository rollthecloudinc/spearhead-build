{
  "version": 3,
  "sources": ["../../@smithy/core/dist-es/submodules/event-streams/EventStreamSerde.js"],
  "sourcesContent": ["import { fromUtf8 } from \"@smithy/util-utf8\";\nexport class EventStreamSerde {\n  marshaller;\n  serializer;\n  deserializer;\n  serdeContext;\n  defaultContentType;\n  constructor({\n    marshaller,\n    serializer,\n    deserializer,\n    serdeContext,\n    defaultContentType\n  }) {\n    this.marshaller = marshaller;\n    this.serializer = serializer;\n    this.deserializer = deserializer;\n    this.serdeContext = serdeContext;\n    this.defaultContentType = defaultContentType;\n  }\n  async serializeEventStream({\n    eventStream,\n    requestSchema,\n    initialRequest\n  }) {\n    const marshaller = this.marshaller;\n    const eventStreamMember = requestSchema.getEventStreamMember();\n    const unionSchema = requestSchema.getMemberSchema(eventStreamMember);\n    const serializer = this.serializer;\n    const defaultContentType = this.defaultContentType;\n    const initialRequestMarker = Symbol(\"initialRequestMarker\");\n    const eventStreamIterable = {\n      async *[Symbol.asyncIterator]() {\n        if (initialRequest) {\n          const headers = {\n            \":event-type\": {\n              type: \"string\",\n              value: \"initial-request\"\n            },\n            \":message-type\": {\n              type: \"string\",\n              value: \"event\"\n            },\n            \":content-type\": {\n              type: \"string\",\n              value: defaultContentType\n            }\n          };\n          serializer.write(requestSchema, initialRequest);\n          const body = serializer.flush();\n          yield {\n            [initialRequestMarker]: true,\n            headers,\n            body\n          };\n        }\n        for await (const page of eventStream) {\n          yield page;\n        }\n      }\n    };\n    return marshaller.serialize(eventStreamIterable, event => {\n      if (event[initialRequestMarker]) {\n        return {\n          headers: event.headers,\n          body: event.body\n        };\n      }\n      const unionMember = Object.keys(event).find(key => {\n        return key !== \"__type\";\n      }) ?? \"\";\n      const {\n        additionalHeaders,\n        body,\n        eventType,\n        explicitPayloadContentType\n      } = this.writeEventBody(unionMember, unionSchema, event);\n      const headers = {\n        \":event-type\": {\n          type: \"string\",\n          value: eventType\n        },\n        \":message-type\": {\n          type: \"string\",\n          value: \"event\"\n        },\n        \":content-type\": {\n          type: \"string\",\n          value: explicitPayloadContentType ?? defaultContentType\n        },\n        ...additionalHeaders\n      };\n      return {\n        headers,\n        body\n      };\n    });\n  }\n  async deserializeEventStream({\n    response,\n    responseSchema,\n    initialResponseContainer\n  }) {\n    const marshaller = this.marshaller;\n    const eventStreamMember = responseSchema.getEventStreamMember();\n    const unionSchema = responseSchema.getMemberSchema(eventStreamMember);\n    const memberSchemas = unionSchema.getMemberSchemas();\n    const initialResponseMarker = Symbol(\"initialResponseMarker\");\n    const asyncIterable = marshaller.deserialize(response.body, async event => {\n      const unionMember = Object.keys(event).find(key => {\n        return key !== \"__type\";\n      }) ?? \"\";\n      if (unionMember === \"initial-response\") {\n        const dataObject = await this.deserializer.read(responseSchema, event[unionMember].body);\n        delete dataObject[eventStreamMember];\n        return {\n          [initialResponseMarker]: true,\n          ...dataObject\n        };\n      } else if (unionMember in memberSchemas) {\n        const eventStreamSchema = memberSchemas[unionMember];\n        return {\n          [unionMember]: await this.deserializer.read(eventStreamSchema, event[unionMember].body)\n        };\n      } else {\n        return {\n          $unknown: event\n        };\n      }\n    });\n    const asyncIterator = asyncIterable[Symbol.asyncIterator]();\n    const firstEvent = await asyncIterator.next();\n    if (firstEvent.done) {\n      return asyncIterable;\n    }\n    if (firstEvent.value?.[initialResponseMarker]) {\n      if (!responseSchema) {\n        throw new Error(\"@smithy::core/protocols - initial-response event encountered in event stream but no response schema given.\");\n      }\n      for (const [key, value] of Object.entries(firstEvent.value)) {\n        initialResponseContainer[key] = value;\n      }\n    }\n    return {\n      async *[Symbol.asyncIterator]() {\n        if (!firstEvent?.value?.[initialResponseMarker]) {\n          yield firstEvent.value;\n        }\n        while (true) {\n          const {\n            done,\n            value\n          } = await asyncIterator.next();\n          if (done) {\n            break;\n          }\n          yield value;\n        }\n      }\n    };\n  }\n  writeEventBody(unionMember, unionSchema, event) {\n    const serializer = this.serializer;\n    let eventType = unionMember;\n    let explicitPayloadMember = null;\n    let explicitPayloadContentType;\n    const isKnownSchema = (() => {\n      const struct = unionSchema.getSchema();\n      return struct[4].includes(unionMember);\n    })();\n    const additionalHeaders = {};\n    if (!isKnownSchema) {\n      const [type, value] = event[unionMember];\n      eventType = type;\n      serializer.write(15, value);\n    } else {\n      const eventSchema = unionSchema.getMemberSchema(unionMember);\n      if (eventSchema.isStructSchema()) {\n        for (const [memberName, memberSchema] of eventSchema.structIterator()) {\n          const {\n            eventHeader,\n            eventPayload\n          } = memberSchema.getMergedTraits();\n          if (eventPayload) {\n            explicitPayloadMember = memberName;\n            break;\n          } else if (eventHeader) {\n            const value = event[unionMember][memberName];\n            let type = \"binary\";\n            if (memberSchema.isNumericSchema()) {\n              if ((-2) ** 31 <= value && value <= 2 ** 31 - 1) {\n                type = \"integer\";\n              } else {\n                type = \"long\";\n              }\n            } else if (memberSchema.isTimestampSchema()) {\n              type = \"timestamp\";\n            } else if (memberSchema.isStringSchema()) {\n              type = \"string\";\n            } else if (memberSchema.isBooleanSchema()) {\n              type = \"boolean\";\n            }\n            if (value != null) {\n              additionalHeaders[memberName] = {\n                type,\n                value\n              };\n              delete event[unionMember][memberName];\n            }\n          }\n        }\n        if (explicitPayloadMember !== null) {\n          const payloadSchema = eventSchema.getMemberSchema(explicitPayloadMember);\n          if (payloadSchema.isBlobSchema()) {\n            explicitPayloadContentType = \"application/octet-stream\";\n          } else if (payloadSchema.isStringSchema()) {\n            explicitPayloadContentType = \"text/plain\";\n          }\n          serializer.write(payloadSchema, event[unionMember][explicitPayloadMember]);\n        } else {\n          serializer.write(eventSchema, event[unionMember]);\n        }\n      } else {\n        throw new Error(\"@smithy/core/event-streams - non-struct member not supported in event stream union.\");\n      }\n    }\n    const messageSerialization = serializer.flush();\n    const body = typeof messageSerialization === \"string\" ? (this.serdeContext?.utf8Decoder ?? fromUtf8)(messageSerialization) : messageSerialization;\n    return {\n      body,\n      eventType,\n      explicitPayloadContentType,\n      additionalHeaders\n    };\n  }\n}"],
  "mappings": "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",
  "names": ["EventStreamSerde", "marshaller", "serializer", "deserializer", "serdeContext", "defaultContentType", "_0", "__async", "eventStream", "requestSchema", "initialRequest", "eventStreamMember", "unionSchema", "initialRequestMarker", "eventStreamIterable", "__asyncGenerator", "headers", "body", "iter", "__forAwait", "more", "temp", "error", "__await", "page", "event", "unionMember", "key", "additionalHeaders", "eventType", "explicitPayloadContentType", "__spreadValues", "response", "responseSchema", "initialResponseContainer", "memberSchemas", "initialResponseMarker", "asyncIterable", "dataObject", "eventStreamSchema", "asyncIterator", "firstEvent", "value", "done", "explicitPayloadMember", "isKnownSchema", "eventSchema", "memberName", "memberSchema", "eventHeader", "eventPayload", "type", "payloadSchema", "messageSerialization", "fromUtf8"]
}
