{
  "version": 3,
  "sources": ["../../fast-xml-parser/src/util.js", "../../fast-xml-parser/src/node2json.js", "../../fast-xml-parser/src/xmlNode.js", "../../strnum/strnum.js", "../../fast-xml-parser/src/xmlstr2xmlnode.js", "../../fast-xml-parser/src/validator.js", "../../fast-xml-parser/src/nimndata.js", "../../fast-xml-parser/src/node2json_str.js", "../../fast-xml-parser/src/json2xml.js", "../../fast-xml-parser/src/parser.js"],
  "sourcesContent": ["'use strict';\n\nconst nameStartChar = ':A-Za-z_\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD';\nconst nameChar = nameStartChar + '\\\\-.\\\\d\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040';\nconst nameRegexp = '[' + nameStartChar + '][' + nameChar + ']*';\nconst regexName = new RegExp('^' + nameRegexp + '$');\nconst getAllMatches = function (string, regex) {\n  const matches = [];\n  let match = regex.exec(string);\n  while (match) {\n    const allmatches = [];\n    allmatches.startIndex = regex.lastIndex - match[0].length;\n    const len = match.length;\n    for (let index = 0; index < len; index++) {\n      allmatches.push(match[index]);\n    }\n    matches.push(allmatches);\n    match = regex.exec(string);\n  }\n  return matches;\n};\nconst isName = function (string) {\n  const match = regexName.exec(string);\n  return !(match === null || typeof match === 'undefined');\n};\nexports.isExist = function (v) {\n  return typeof v !== 'undefined';\n};\nexports.isEmptyObject = function (obj) {\n  return Object.keys(obj).length === 0;\n};\n\n/**\n * Copy all the properties of a into b.\n * @param {*} target\n * @param {*} a\n */\nexports.merge = function (target, a, arrayMode) {\n  if (a) {\n    const keys = Object.keys(a); // will return an array of own properties\n    const len = keys.length; //don't make it inline\n    for (let i = 0; i < len; i++) {\n      if (arrayMode === 'strict') {\n        target[keys[i]] = [a[keys[i]]];\n      } else {\n        target[keys[i]] = a[keys[i]];\n      }\n    }\n  }\n};\n/* exports.merge =function (b,a){\n  return Object.assign(b,a);\n} */\n\nexports.getValue = function (v) {\n  if (exports.isExist(v)) {\n    return v;\n  } else {\n    return '';\n  }\n};\n\n// const fakeCall = function(a) {return a;};\n// const fakeCallNoReturn = function() {};\n\nexports.buildOptions = function (options, defaultOptions, props) {\n  let newOptions = {};\n  if (!options) {\n    return defaultOptions; //if there are not options\n  }\n  for (let i = 0; i < props.length; i++) {\n    if (options[props[i]] !== undefined) {\n      newOptions[props[i]] = options[props[i]];\n    } else {\n      newOptions[props[i]] = defaultOptions[props[i]];\n    }\n  }\n  return newOptions;\n};\n\n/**\n * Check if a tag name should be treated as array\n *\n * @param tagName the node tagname\n * @param arrayMode the array mode option\n * @param parentTagName the parent tag name\n * @returns {boolean} true if node should be parsed as array\n */\nexports.isTagNameInArrayMode = function (tagName, arrayMode, parentTagName) {\n  if (arrayMode === false) {\n    return false;\n  } else if (arrayMode instanceof RegExp) {\n    return arrayMode.test(tagName);\n  } else if (typeof arrayMode === 'function') {\n    return !!arrayMode(tagName, parentTagName);\n  }\n  return arrayMode === \"strict\";\n};\nexports.isName = isName;\nexports.getAllMatches = getAllMatches;\nexports.nameRegexp = nameRegexp;", "'use strict';\n\nconst util = require('./util');\nconst convertToJson = function (node, options, parentTagName) {\n  const jObj = {};\n\n  // when no child node or attr is present\n  if (!options.alwaysCreateTextNode && (!node.child || util.isEmptyObject(node.child)) && (!node.attrsMap || util.isEmptyObject(node.attrsMap))) {\n    return util.isExist(node.val) ? node.val : '';\n  }\n\n  // otherwise create a textnode if node has some text\n  if (util.isExist(node.val) && !(typeof node.val === 'string' && (node.val === '' || node.val === options.cdataPositionChar))) {\n    const asArray = util.isTagNameInArrayMode(node.tagname, options.arrayMode, parentTagName);\n    jObj[options.textNodeName] = asArray ? [node.val] : node.val;\n  }\n  util.merge(jObj, node.attrsMap, options.arrayMode);\n  const keys = Object.keys(node.child);\n  for (let index = 0; index < keys.length; index++) {\n    const tagName = keys[index];\n    if (node.child[tagName] && node.child[tagName].length > 1) {\n      jObj[tagName] = [];\n      for (let tag in node.child[tagName]) {\n        if (node.child[tagName].hasOwnProperty(tag)) {\n          jObj[tagName].push(convertToJson(node.child[tagName][tag], options, tagName));\n        }\n      }\n    } else {\n      const result = convertToJson(node.child[tagName][0], options, tagName);\n      const asArray = options.arrayMode === true && typeof result === 'object' || util.isTagNameInArrayMode(tagName, options.arrayMode, parentTagName);\n      jObj[tagName] = asArray ? [result] : result;\n    }\n  }\n\n  //add value\n  return jObj;\n};\nexports.convertToJson = convertToJson;", "'use strict';\n\nmodule.exports = function (tagname, parent, val) {\n  this.tagname = tagname;\n  this.parent = parent;\n  this.child = {}; //child tags\n  this.attrsMap = {}; //attributes map\n  this.val = val; //text only\n  this.addChild = function (child) {\n    if (Array.isArray(this.child[child.tagname])) {\n      //already presents\n      this.child[child.tagname].push(child);\n    } else {\n      this.child[child.tagname] = [child];\n    }\n  };\n};", "const hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;\nconst numRegex = /^([\\-\\+])?(0*)([0-9]*(\\.[0-9]*)?)$/;\n// const octRegex = /^0x[a-z0-9]+/;\n// const binRegex = /0x[a-z0-9]+/;\n\nconst consider = {\n  hex: true,\n  // oct: false,\n  leadingZeros: true,\n  decimalPoint: \"\\.\",\n  eNotation: true\n  //skipLike: /regex/\n};\nfunction toNumber(str, options = {}) {\n  options = Object.assign({}, consider, options);\n  if (!str || typeof str !== \"string\") return str;\n  let trimmedStr = str.trim();\n  if (options.skipLike !== undefined && options.skipLike.test(trimmedStr)) return str;else if (str === \"0\") return 0;else if (options.hex && hexRegex.test(trimmedStr)) {\n    return parse_int(trimmedStr, 16);\n    // }else if (options.oct && octRegex.test(str)) {\n    //     return Number.parseInt(val, 8);\n  } else if (trimmedStr.search(/[eE]/) !== -1) {\n    //eNotation\n    const notation = trimmedStr.match(/^([-\\+])?(0*)([0-9]*(\\.[0-9]*)?[eE][-\\+]?[0-9]+)$/);\n    // +00.123 => [ , '+', '00', '.123', ..\n    if (notation) {\n      // console.log(notation)\n      if (options.leadingZeros) {\n        //accept with leading zeros\n        trimmedStr = (notation[1] || \"\") + notation[3];\n      } else {\n        if (notation[2] === \"0\" && notation[3][0] === \".\") {//valid number\n        } else {\n          return str;\n        }\n      }\n      return options.eNotation ? Number(trimmedStr) : str;\n    } else {\n      return str;\n    }\n    // }else if (options.parseBin && binRegex.test(str)) {\n    //     return Number.parseInt(val, 2);\n  } else {\n    //separate negative sign, leading zeros, and rest number\n    const match = numRegex.exec(trimmedStr);\n    // +00.123 => [ , '+', '00', '.123', ..\n    if (match) {\n      const sign = match[1];\n      const leadingZeros = match[2];\n      let numTrimmedByZeros = trimZeros(match[3]); //complete num without leading zeros\n      //trim ending zeros for floating number\n\n      if (!options.leadingZeros && leadingZeros.length > 0 && sign && trimmedStr[2] !== \".\") return str; //-0123\n      else if (!options.leadingZeros && leadingZeros.length > 0 && !sign && trimmedStr[1] !== \".\") return str; //0123\n      else if (options.leadingZeros && leadingZeros === str) return 0; //00\n      else {\n        //no leading zeros or leading zeros are allowed\n        const num = Number(trimmedStr);\n        const numStr = \"\" + num;\n        if (numStr.search(/[eE]/) !== -1) {\n          //given number is long and parsed to eNotation\n          if (options.eNotation) return num;else return str;\n        } else if (trimmedStr.indexOf(\".\") !== -1) {\n          //floating number\n          if (numStr === \"0\" && numTrimmedByZeros === \"\") return num; //0.0\n          else if (numStr === numTrimmedByZeros) return num; //0.456. 0.79000\n          else if (sign && numStr === \"-\" + numTrimmedByZeros) return num;else return str;\n        }\n        if (leadingZeros) {\n          return numTrimmedByZeros === numStr || sign + numTrimmedByZeros === numStr ? num : str;\n        } else {\n          return trimmedStr === numStr || trimmedStr === sign + numStr ? num : str;\n        }\n      }\n    } else {\n      //non-numeric string\n      return str;\n    }\n  }\n}\n\n/**\n * \n * @param {string} numStr without leading zeros\n * @returns \n */\nfunction trimZeros(numStr) {\n  if (numStr && numStr.indexOf(\".\") !== -1) {\n    //float\n    numStr = numStr.replace(/0+$/, \"\"); //remove ending zeros\n    if (numStr === \".\") numStr = \"0\";else if (numStr[0] === \".\") numStr = \"0\" + numStr;else if (numStr[numStr.length - 1] === \".\") numStr = numStr.substr(0, numStr.length - 1);\n    return numStr;\n  }\n  return numStr;\n}\nfunction parse_int(numStr, base) {\n  //polyfill\n  if (parseInt) return parseInt(numStr, base);else if (Number.parseInt) return Number.parseInt(numStr, base);else if (window && window.parseInt) return window.parseInt(numStr, base);else throw new Error(\"parseInt, Number.parseInt, window.parseInt are not supported\");\n}\nmodule.exports = toNumber;", "'use strict';\n\nconst util = require('./util');\nconst buildOptions = require('./util').buildOptions;\nconst xmlNode = require('./xmlNode');\nconst toNumber = require(\"strnum\");\nconst regx = '<((!\\\\[CDATA\\\\[([\\\\s\\\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\\\/)(NAME)\\\\s*>))([^<]*)'.replace(/NAME/g, util.nameRegexp);\n\n//const tagsRegx = new RegExp(\"<(\\\\/?[\\\\w:\\\\-\\._]+)([^>]*)>(\\\\s*\"+cdataRegx+\")*([^<]+)?\",\"g\");\n//const tagsRegx = new RegExp(\"<(\\\\/?)((\\\\w*:)?([\\\\w:\\\\-\\._]+))([^>]*)>([^<]*)(\"+cdataRegx+\"([^<]*))*([^<]+)?\",\"g\");\n\n//polyfill\nif (!Number.parseInt && window.parseInt) {\n  Number.parseInt = window.parseInt;\n}\nif (!Number.parseFloat && window.parseFloat) {\n  Number.parseFloat = window.parseFloat;\n}\nconst defaultOptions = {\n  attributeNamePrefix: '@_',\n  attrNodeName: false,\n  textNodeName: '#text',\n  ignoreAttributes: true,\n  ignoreNameSpace: false,\n  allowBooleanAttributes: false,\n  //a tag can have attributes without any value\n  //ignoreRootElement : false,\n  parseNodeValue: true,\n  parseAttributeValue: false,\n  arrayMode: false,\n  trimValues: true,\n  //Trim string values of tag and attributes\n  cdataTagName: false,\n  cdataPositionChar: '\\\\c',\n  numParseOptions: {\n    hex: true,\n    leadingZeros: true\n  },\n  tagValueProcessor: function (a, tagName) {\n    return a;\n  },\n  attrValueProcessor: function (a, attrName) {\n    return a;\n  },\n  stopNodes: [],\n  alwaysCreateTextNode: false\n  //decodeStrict: false,\n};\nexports.defaultOptions = defaultOptions;\nconst props = ['attributeNamePrefix', 'attrNodeName', 'textNodeName', 'ignoreAttributes', 'ignoreNameSpace', 'allowBooleanAttributes', 'parseNodeValue', 'parseAttributeValue', 'arrayMode', 'trimValues', 'cdataTagName', 'cdataPositionChar', 'tagValueProcessor', 'attrValueProcessor', 'parseTrueNumberOnly', 'numParseOptions', 'stopNodes', 'alwaysCreateTextNode'];\nexports.props = props;\n\n/**\n * Trim -> valueProcessor -> parse value\n * @param {string} tagName\n * @param {string} val\n * @param {object} options\n */\nfunction processTagValue(tagName, val, options) {\n  if (val) {\n    if (options.trimValues) {\n      val = val.trim();\n    }\n    val = options.tagValueProcessor(val, tagName);\n    val = parseValue(val, options.parseNodeValue, options.numParseOptions);\n  }\n  return val;\n}\nfunction resolveNameSpace(tagname, options) {\n  if (options.ignoreNameSpace) {\n    const tags = tagname.split(':');\n    const prefix = tagname.charAt(0) === '/' ? '/' : '';\n    if (tags[0] === 'xmlns') {\n      return '';\n    }\n    if (tags.length === 2) {\n      tagname = prefix + tags[1];\n    }\n  }\n  return tagname;\n}\nfunction parseValue(val, shouldParse, options) {\n  if (shouldParse && typeof val === 'string') {\n    //console.log(options)\n    const newval = val.trim();\n    if (newval === 'true') return true;else if (newval === 'false') return false;else return toNumber(val, options);\n  } else {\n    if (util.isExist(val)) {\n      return val;\n    } else {\n      return '';\n    }\n  }\n}\n\n//TODO: change regex to capture NS\n//const attrsRegx = new RegExp(\"([\\\\w\\\\-\\\\.\\\\:]+)\\\\s*=\\\\s*(['\\\"])((.|\\n)*?)\\\\2\",\"gm\");\nconst attrsRegx = new RegExp('([^\\\\s=]+)\\\\s*(=\\\\s*([\\'\"])(.*?)\\\\3)?', 'g');\nfunction buildAttributesMap(attrStr, options) {\n  if (!options.ignoreAttributes && typeof attrStr === 'string') {\n    attrStr = attrStr.replace(/\\r?\\n/g, ' ');\n    //attrStr = attrStr || attrStr.trim();\n\n    const matches = util.getAllMatches(attrStr, attrsRegx);\n    const len = matches.length; //don't make it inline\n    const attrs = {};\n    for (let i = 0; i < len; i++) {\n      const attrName = resolveNameSpace(matches[i][1], options);\n      if (attrName.length) {\n        if (matches[i][4] !== undefined) {\n          if (options.trimValues) {\n            matches[i][4] = matches[i][4].trim();\n          }\n          matches[i][4] = options.attrValueProcessor(matches[i][4], attrName);\n          attrs[options.attributeNamePrefix + attrName] = parseValue(matches[i][4], options.parseAttributeValue, options.numParseOptions);\n        } else if (options.allowBooleanAttributes) {\n          attrs[options.attributeNamePrefix + attrName] = true;\n        }\n      }\n    }\n    if (!Object.keys(attrs).length) {\n      return;\n    }\n    if (options.attrNodeName) {\n      const attrCollection = {};\n      attrCollection[options.attrNodeName] = attrs;\n      return attrCollection;\n    }\n    return attrs;\n  }\n}\nconst getTraversalObj = function (xmlData, options) {\n  xmlData = xmlData.replace(/\\r\\n?/g, \"\\n\");\n  options = buildOptions(options, defaultOptions, props);\n  const xmlObj = new xmlNode('!xml');\n  let currentNode = xmlObj;\n  let textData = \"\";\n\n  //function match(xmlData){\n  for (let i = 0; i < xmlData.length; i++) {\n    const ch = xmlData[i];\n    if (ch === '<') {\n      if (xmlData[i + 1] === '/') {\n        //Closing Tag\n        const closeIndex = findClosingIndex(xmlData, \">\", i, \"Closing Tag is not closed.\");\n        let tagName = xmlData.substring(i + 2, closeIndex).trim();\n        if (options.ignoreNameSpace) {\n          const colonIndex = tagName.indexOf(\":\");\n          if (colonIndex !== -1) {\n            tagName = tagName.substr(colonIndex + 1);\n          }\n        }\n\n        /* if (currentNode.parent) {\n          currentNode.parent.val = util.getValue(currentNode.parent.val) + '' + processTagValue2(tagName, textData , options);\n        } */\n        if (currentNode) {\n          if (currentNode.val) {\n            currentNode.val = util.getValue(currentNode.val) + '' + processTagValue(tagName, textData, options);\n          } else {\n            currentNode.val = processTagValue(tagName, textData, options);\n          }\n        }\n        if (options.stopNodes.length && options.stopNodes.includes(currentNode.tagname)) {\n          currentNode.child = [];\n          if (currentNode.attrsMap == undefined) {\n            currentNode.attrsMap = {};\n          }\n          currentNode.val = xmlData.substr(currentNode.startIndex + 1, i - currentNode.startIndex - 1);\n        }\n        currentNode = currentNode.parent;\n        textData = \"\";\n        i = closeIndex;\n      } else if (xmlData[i + 1] === '?') {\n        i = findClosingIndex(xmlData, \"?>\", i, \"Pi Tag is not closed.\");\n      } else if (xmlData.substr(i + 1, 3) === '!--') {\n        i = findClosingIndex(xmlData, \"-->\", i, \"Comment is not closed.\");\n      } else if (xmlData.substr(i + 1, 2) === '!D') {\n        const closeIndex = findClosingIndex(xmlData, \">\", i, \"DOCTYPE is not closed.\");\n        const tagExp = xmlData.substring(i, closeIndex);\n        if (tagExp.indexOf(\"[\") >= 0) {\n          i = xmlData.indexOf(\"]>\", i) + 1;\n        } else {\n          i = closeIndex;\n        }\n      } else if (xmlData.substr(i + 1, 2) === '![') {\n        const closeIndex = findClosingIndex(xmlData, \"]]>\", i, \"CDATA is not closed.\") - 2;\n        const tagExp = xmlData.substring(i + 9, closeIndex);\n\n        //considerations\n        //1. CDATA will always have parent node\n        //2. A tag with CDATA is not a leaf node so it's value would be string type.\n        if (textData) {\n          currentNode.val = util.getValue(currentNode.val) + '' + processTagValue(currentNode.tagname, textData, options);\n          textData = \"\";\n        }\n        if (options.cdataTagName) {\n          //add cdata node\n          const childNode = new xmlNode(options.cdataTagName, currentNode, tagExp);\n          currentNode.addChild(childNode);\n          //for backtracking\n          currentNode.val = util.getValue(currentNode.val) + options.cdataPositionChar;\n          //add rest value to parent node\n          if (tagExp) {\n            childNode.val = tagExp;\n          }\n        } else {\n          currentNode.val = (currentNode.val || '') + (tagExp || '');\n        }\n        i = closeIndex + 2;\n      } else {\n        //Opening tag\n        const result = closingIndexForOpeningTag(xmlData, i + 1);\n        let tagExp = result.data;\n        const closeIndex = result.index;\n        const separatorIndex = tagExp.indexOf(\" \");\n        let tagName = tagExp;\n        let shouldBuildAttributesMap = true;\n        if (separatorIndex !== -1) {\n          tagName = tagExp.substr(0, separatorIndex).replace(/\\s\\s*$/, '');\n          tagExp = tagExp.substr(separatorIndex + 1);\n        }\n        if (options.ignoreNameSpace) {\n          const colonIndex = tagName.indexOf(\":\");\n          if (colonIndex !== -1) {\n            tagName = tagName.substr(colonIndex + 1);\n            shouldBuildAttributesMap = tagName !== result.data.substr(colonIndex + 1);\n          }\n        }\n\n        //save text to parent node\n        if (currentNode && textData) {\n          if (currentNode.tagname !== '!xml') {\n            currentNode.val = util.getValue(currentNode.val) + '' + processTagValue(currentNode.tagname, textData, options);\n          }\n        }\n        if (tagExp.length > 0 && tagExp.lastIndexOf(\"/\") === tagExp.length - 1) {\n          //selfClosing tag\n\n          if (tagName[tagName.length - 1] === \"/\") {\n            //remove trailing '/'\n            tagName = tagName.substr(0, tagName.length - 1);\n            tagExp = tagName;\n          } else {\n            tagExp = tagExp.substr(0, tagExp.length - 1);\n          }\n          const childNode = new xmlNode(tagName, currentNode, '');\n          if (tagName !== tagExp) {\n            childNode.attrsMap = buildAttributesMap(tagExp, options);\n          }\n          currentNode.addChild(childNode);\n        } else {\n          //opening tag\n\n          const childNode = new xmlNode(tagName, currentNode);\n          if (options.stopNodes.length && options.stopNodes.includes(childNode.tagname)) {\n            childNode.startIndex = closeIndex;\n          }\n          if (tagName !== tagExp && shouldBuildAttributesMap) {\n            childNode.attrsMap = buildAttributesMap(tagExp, options);\n          }\n          currentNode.addChild(childNode);\n          currentNode = childNode;\n        }\n        textData = \"\";\n        i = closeIndex;\n      }\n    } else {\n      textData += xmlData[i];\n    }\n  }\n  return xmlObj;\n};\nfunction closingIndexForOpeningTag(data, i) {\n  let attrBoundary;\n  let tagExp = \"\";\n  for (let index = i; index < data.length; index++) {\n    let ch = data[index];\n    if (attrBoundary) {\n      if (ch === attrBoundary) attrBoundary = \"\"; //reset\n    } else if (ch === '\"' || ch === \"'\") {\n      attrBoundary = ch;\n    } else if (ch === '>') {\n      return {\n        data: tagExp,\n        index: index\n      };\n    } else if (ch === '\\t') {\n      ch = \" \";\n    }\n    tagExp += ch;\n  }\n}\nfunction findClosingIndex(xmlData, str, i, errMsg) {\n  const closingIndex = xmlData.indexOf(str, i);\n  if (closingIndex === -1) {\n    throw new Error(errMsg);\n  } else {\n    return closingIndex + str.length - 1;\n  }\n}\nexports.getTraversalObj = getTraversalObj;", "'use strict';\n\nconst util = require('./util');\nconst defaultOptions = {\n  allowBooleanAttributes: false //A tag can have attributes without any value\n};\nconst props = ['allowBooleanAttributes'];\n\n//const tagsPattern = new RegExp(\"<\\\\/?([\\\\w:\\\\-_\\.]+)\\\\s*\\/?>\",\"g\");\nexports.validate = function (xmlData, options) {\n  options = util.buildOptions(options, defaultOptions, props);\n\n  //xmlData = xmlData.replace(/(\\r\\n|\\n|\\r)/gm,\"\");//make it single line\n  //xmlData = xmlData.replace(/(^\\s*<\\?xml.*?\\?>)/g,\"\");//Remove XML starting tag\n  //xmlData = xmlData.replace(/(<!DOCTYPE[\\s\\w\\\"\\.\\/\\-\\:]+(\\[.*\\])*\\s*>)/g,\"\");//Remove DOCTYPE\n  const tags = [];\n  let tagFound = false;\n\n  //indicates that the root tag has been closed (aka. depth 0 has been reached)\n  let reachedRoot = false;\n  if (xmlData[0] === '\\ufeff') {\n    // check for byte order mark (BOM)\n    xmlData = xmlData.substr(1);\n  }\n  for (let i = 0; i < xmlData.length; i++) {\n    if (xmlData[i] === '<' && xmlData[i + 1] === '?') {\n      i += 2;\n      i = readPI(xmlData, i);\n      if (i.err) return i;\n    } else if (xmlData[i] === '<') {\n      //starting of tag\n      //read until you reach to '>' avoiding any '>' in attribute value\n      let tagStartPos = i;\n      i++;\n      if (xmlData[i] === '!') {\n        i = readCommentAndCDATA(xmlData, i);\n        continue;\n      } else {\n        let closingTag = false;\n        if (xmlData[i] === '/') {\n          //closing tag\n          closingTag = true;\n          i++;\n        }\n        //read tagname\n        let tagName = '';\n        for (; i < xmlData.length && xmlData[i] !== '>' && xmlData[i] !== ' ' && xmlData[i] !== '\\t' && xmlData[i] !== '\\n' && xmlData[i] !== '\\r'; i++) {\n          tagName += xmlData[i];\n        }\n        tagName = tagName.trim();\n        //console.log(tagName);\n\n        if (tagName[tagName.length - 1] === '/') {\n          //self closing tag without attributes\n          tagName = tagName.substring(0, tagName.length - 1);\n          //continue;\n          i--;\n        }\n        if (!validateTagName(tagName)) {\n          let msg;\n          if (tagName.trim().length === 0) {\n            msg = \"Invalid space after '<'.\";\n          } else {\n            msg = \"Tag '\" + tagName + \"' is an invalid name.\";\n          }\n          return getErrorObject('InvalidTag', msg, getLineNumberForPosition(xmlData, i));\n        }\n        const result = readAttributeStr(xmlData, i);\n        if (result === false) {\n          return getErrorObject('InvalidAttr', \"Attributes for '\" + tagName + \"' have open quote.\", getLineNumberForPosition(xmlData, i));\n        }\n        let attrStr = result.value;\n        i = result.index;\n        if (attrStr[attrStr.length - 1] === '/') {\n          //self closing tag\n          const attrStrStart = i - attrStr.length;\n          attrStr = attrStr.substring(0, attrStr.length - 1);\n          const isValid = validateAttributeString(attrStr, options);\n          if (isValid === true) {\n            tagFound = true;\n            //continue; //text may presents after self closing tag\n          } else {\n            //the result from the nested function returns the position of the error within the attribute\n            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute\n            //this gives us the absolute index in the entire xml, which we can use to find the line at last\n            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));\n          }\n        } else if (closingTag) {\n          if (!result.tagClosed) {\n            return getErrorObject('InvalidTag', \"Closing tag '\" + tagName + \"' doesn't have proper closing.\", getLineNumberForPosition(xmlData, i));\n          } else if (attrStr.trim().length > 0) {\n            return getErrorObject('InvalidTag', \"Closing tag '\" + tagName + \"' can't have attributes or invalid starting.\", getLineNumberForPosition(xmlData, tagStartPos));\n          } else {\n            const otg = tags.pop();\n            if (tagName !== otg.tagName) {\n              let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);\n              return getErrorObject('InvalidTag', \"Expected closing tag '\" + otg.tagName + \"' (opened in line \" + openPos.line + \", col \" + openPos.col + \") instead of closing tag '\" + tagName + \"'.\", getLineNumberForPosition(xmlData, tagStartPos));\n            }\n\n            //when there are no more tags, we reached the root level.\n            if (tags.length == 0) {\n              reachedRoot = true;\n            }\n          }\n        } else {\n          const isValid = validateAttributeString(attrStr, options);\n          if (isValid !== true) {\n            //the result from the nested function returns the position of the error within the attribute\n            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute\n            //this gives us the absolute index in the entire xml, which we can use to find the line at last\n            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + isValid.err.line));\n          }\n\n          //if the root level has been reached before ...\n          if (reachedRoot === true) {\n            return getErrorObject('InvalidXml', 'Multiple possible root nodes found.', getLineNumberForPosition(xmlData, i));\n          } else {\n            tags.push({\n              tagName,\n              tagStartPos\n            });\n          }\n          tagFound = true;\n        }\n\n        //skip tag text value\n        //It may include comments and CDATA value\n        for (i++; i < xmlData.length; i++) {\n          if (xmlData[i] === '<') {\n            if (xmlData[i + 1] === '!') {\n              //comment or CADATA\n              i++;\n              i = readCommentAndCDATA(xmlData, i);\n              continue;\n            } else if (xmlData[i + 1] === '?') {\n              i = readPI(xmlData, ++i);\n              if (i.err) return i;\n            } else {\n              break;\n            }\n          } else if (xmlData[i] === '&') {\n            const afterAmp = validateAmpersand(xmlData, i);\n            if (afterAmp == -1) return getErrorObject('InvalidChar', \"char '&' is not expected.\", getLineNumberForPosition(xmlData, i));\n            i = afterAmp;\n          }\n        } //end of reading tag text value\n        if (xmlData[i] === '<') {\n          i--;\n        }\n      }\n    } else {\n      if (xmlData[i] === ' ' || xmlData[i] === '\\t' || xmlData[i] === '\\n' || xmlData[i] === '\\r') {\n        continue;\n      }\n      return getErrorObject('InvalidChar', \"char '\" + xmlData[i] + \"' is not expected.\", getLineNumberForPosition(xmlData, i));\n    }\n  }\n  if (!tagFound) {\n    return getErrorObject('InvalidXml', 'Start tag expected.', 1);\n  } else if (tags.length == 1) {\n    return getErrorObject('InvalidTag', \"Unclosed tag '\" + tags[0].tagName + \"'.\", getLineNumberForPosition(xmlData, tags[0].tagStartPos));\n  } else if (tags.length > 0) {\n    return getErrorObject('InvalidXml', \"Invalid '\" + JSON.stringify(tags.map(t => t.tagName), null, 4).replace(/\\r?\\n/g, '') + \"' found.\", {\n      line: 1,\n      col: 1\n    });\n  }\n  return true;\n};\n\n/**\n * Read Processing insstructions and skip\n * @param {*} xmlData\n * @param {*} i\n */\nfunction readPI(xmlData, i) {\n  const start = i;\n  for (; i < xmlData.length; i++) {\n    if (xmlData[i] == '?' || xmlData[i] == ' ') {\n      //tagname\n      const tagname = xmlData.substr(start, i - start);\n      if (i > 5 && tagname === 'xml') {\n        return getErrorObject('InvalidXml', 'XML declaration allowed only at the start of the document.', getLineNumberForPosition(xmlData, i));\n      } else if (xmlData[i] == '?' && xmlData[i + 1] == '>') {\n        //check if valid attribut string\n        i++;\n        break;\n      } else {\n        continue;\n      }\n    }\n  }\n  return i;\n}\nfunction readCommentAndCDATA(xmlData, i) {\n  if (xmlData.length > i + 5 && xmlData[i + 1] === '-' && xmlData[i + 2] === '-') {\n    //comment\n    for (i += 3; i < xmlData.length; i++) {\n      if (xmlData[i] === '-' && xmlData[i + 1] === '-' && xmlData[i + 2] === '>') {\n        i += 2;\n        break;\n      }\n    }\n  } else if (xmlData.length > i + 8 && xmlData[i + 1] === 'D' && xmlData[i + 2] === 'O' && xmlData[i + 3] === 'C' && xmlData[i + 4] === 'T' && xmlData[i + 5] === 'Y' && xmlData[i + 6] === 'P' && xmlData[i + 7] === 'E') {\n    let angleBracketsCount = 1;\n    for (i += 8; i < xmlData.length; i++) {\n      if (xmlData[i] === '<') {\n        angleBracketsCount++;\n      } else if (xmlData[i] === '>') {\n        angleBracketsCount--;\n        if (angleBracketsCount === 0) {\n          break;\n        }\n      }\n    }\n  } else if (xmlData.length > i + 9 && xmlData[i + 1] === '[' && xmlData[i + 2] === 'C' && xmlData[i + 3] === 'D' && xmlData[i + 4] === 'A' && xmlData[i + 5] === 'T' && xmlData[i + 6] === 'A' && xmlData[i + 7] === '[') {\n    for (i += 8; i < xmlData.length; i++) {\n      if (xmlData[i] === ']' && xmlData[i + 1] === ']' && xmlData[i + 2] === '>') {\n        i += 2;\n        break;\n      }\n    }\n  }\n  return i;\n}\nconst doubleQuote = '\"';\nconst singleQuote = \"'\";\n\n/**\n * Keep reading xmlData until '<' is found outside the attribute value.\n * @param {string} xmlData\n * @param {number} i\n */\nfunction readAttributeStr(xmlData, i) {\n  let attrStr = '';\n  let startChar = '';\n  let tagClosed = false;\n  for (; i < xmlData.length; i++) {\n    if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {\n      if (startChar === '') {\n        startChar = xmlData[i];\n      } else if (startChar !== xmlData[i]) {\n        //if vaue is enclosed with double quote then single quotes are allowed inside the value and vice versa\n      } else {\n        startChar = '';\n      }\n    } else if (xmlData[i] === '>') {\n      if (startChar === '') {\n        tagClosed = true;\n        break;\n      }\n    }\n    attrStr += xmlData[i];\n  }\n  if (startChar !== '') {\n    return false;\n  }\n  return {\n    value: attrStr,\n    index: i,\n    tagClosed: tagClosed\n  };\n}\n\n/**\n * Select all the attributes whether valid or invalid.\n */\nconst validAttrStrRegxp = new RegExp('(\\\\s*)([^\\\\s=]+)(\\\\s*=)?(\\\\s*([\\'\"])(([\\\\s\\\\S])*?)\\\\5)?', 'g');\n\n//attr, =\"sd\", a=\"amit's\", a=\"sd\"b=\"saf\", ab  cd=\"\"\n\nfunction validateAttributeString(attrStr, options) {\n  //console.log(\"start:\"+attrStr+\":end\");\n\n  //if(attrStr.trim().length === 0) return true; //empty string\n\n  const matches = util.getAllMatches(attrStr, validAttrStrRegxp);\n  const attrNames = {};\n  for (let i = 0; i < matches.length; i++) {\n    if (matches[i][1].length === 0) {\n      //nospace before attribute name: a=\"sd\"b=\"saf\"\n      return getErrorObject('InvalidAttr', \"Attribute '\" + matches[i][2] + \"' has no space in starting.\", getPositionFromMatch(matches[i]));\n    } else if (matches[i][3] === undefined && !options.allowBooleanAttributes) {\n      //independent attribute: ab\n      return getErrorObject('InvalidAttr', \"boolean attribute '\" + matches[i][2] + \"' is not allowed.\", getPositionFromMatch(matches[i]));\n    }\n    /* else if(matches[i][6] === undefined){//attribute without value: ab=\n                    return { err: { code:\"InvalidAttr\",msg:\"attribute \" + matches[i][2] + \" has no value assigned.\"}};\n                } */\n    const attrName = matches[i][2];\n    if (!validateAttrName(attrName)) {\n      return getErrorObject('InvalidAttr', \"Attribute '\" + attrName + \"' is an invalid name.\", getPositionFromMatch(matches[i]));\n    }\n    if (!attrNames.hasOwnProperty(attrName)) {\n      //check for duplicate attribute.\n      attrNames[attrName] = 1;\n    } else {\n      return getErrorObject('InvalidAttr', \"Attribute '\" + attrName + \"' is repeated.\", getPositionFromMatch(matches[i]));\n    }\n  }\n  return true;\n}\nfunction validateNumberAmpersand(xmlData, i) {\n  let re = /\\d/;\n  if (xmlData[i] === 'x') {\n    i++;\n    re = /[\\da-fA-F]/;\n  }\n  for (; i < xmlData.length; i++) {\n    if (xmlData[i] === ';') return i;\n    if (!xmlData[i].match(re)) break;\n  }\n  return -1;\n}\nfunction validateAmpersand(xmlData, i) {\n  // https://www.w3.org/TR/xml/#dt-charref\n  i++;\n  if (xmlData[i] === ';') return -1;\n  if (xmlData[i] === '#') {\n    i++;\n    return validateNumberAmpersand(xmlData, i);\n  }\n  let count = 0;\n  for (; i < xmlData.length; i++, count++) {\n    if (xmlData[i].match(/\\w/) && count < 20) continue;\n    if (xmlData[i] === ';') break;\n    return -1;\n  }\n  return i;\n}\nfunction getErrorObject(code, message, lineNumber) {\n  return {\n    err: {\n      code: code,\n      msg: message,\n      line: lineNumber.line || lineNumber,\n      col: lineNumber.col\n    }\n  };\n}\nfunction validateAttrName(attrName) {\n  return util.isName(attrName);\n}\n\n// const startsWithXML = /^xml/i;\n\nfunction validateTagName(tagname) {\n  return util.isName(tagname) /* && !tagname.match(startsWithXML) */;\n}\n\n//this function returns the line number for the character at the given index\nfunction getLineNumberForPosition(xmlData, index) {\n  const lines = xmlData.substring(0, index).split(/\\r?\\n/);\n  return {\n    line: lines.length,\n    // column number is last line's length + 1, because column numbering starts at 1:\n    col: lines[lines.length - 1].length + 1\n  };\n}\n\n//this function returns the position of the first character of match within attrStr\nfunction getPositionFromMatch(match) {\n  return match.startIndex + match[1].length;\n}", "'use strict';\n\nconst char = function (a) {\n  return String.fromCharCode(a);\n};\nconst chars = {\n  nilChar: char(176),\n  missingChar: char(201),\n  nilPremitive: char(175),\n  missingPremitive: char(200),\n  emptyChar: char(178),\n  emptyValue: char(177),\n  //empty Premitive\n\n  boundryChar: char(179),\n  objStart: char(198),\n  arrStart: char(204),\n  arrayEnd: char(185)\n};\nconst charsArr = [chars.nilChar, chars.nilPremitive, chars.missingChar, chars.missingPremitive, chars.boundryChar, chars.emptyChar, chars.emptyValue, chars.arrayEnd, chars.objStart, chars.arrStart];\nconst _e = function (node, e_schema, options) {\n  if (typeof e_schema === 'string') {\n    //premitive\n    if (node && node[0] && node[0].val !== undefined) {\n      return getValue(node[0].val, e_schema);\n    } else {\n      return getValue(node, e_schema);\n    }\n  } else {\n    const hasValidData = hasData(node);\n    if (hasValidData === true) {\n      let str = '';\n      if (Array.isArray(e_schema)) {\n        //attributes can't be repeated. hence check in children tags only\n        str += chars.arrStart;\n        const itemSchema = e_schema[0];\n        //const itemSchemaType = itemSchema;\n        const arr_len = node.length;\n        if (typeof itemSchema === 'string') {\n          for (let arr_i = 0; arr_i < arr_len; arr_i++) {\n            const r = getValue(node[arr_i].val, itemSchema);\n            str = processValue(str, r);\n          }\n        } else {\n          for (let arr_i = 0; arr_i < arr_len; arr_i++) {\n            const r = _e(node[arr_i], itemSchema, options);\n            str = processValue(str, r);\n          }\n        }\n        str += chars.arrayEnd; //indicates that next item is not array item\n      } else {\n        //object\n        str += chars.objStart;\n        const keys = Object.keys(e_schema);\n        if (Array.isArray(node)) {\n          node = node[0];\n        }\n        for (let i in keys) {\n          const key = keys[i];\n          //a property defined in schema can be present either in attrsMap or children tags\n          //options.textNodeName will not present in both maps, take it's value from val\n          //options.attrNodeName will be present in attrsMap\n          let r;\n          if (!options.ignoreAttributes && node.attrsMap && node.attrsMap[key]) {\n            r = _e(node.attrsMap[key], e_schema[key], options);\n          } else if (key === options.textNodeName) {\n            r = _e(node.val, e_schema[key], options);\n          } else {\n            r = _e(node.child[key], e_schema[key], options);\n          }\n          str = processValue(str, r);\n        }\n      }\n      return str;\n    } else {\n      return hasValidData;\n    }\n  }\n};\nconst getValue = function (a /*, type*/) {\n  switch (a) {\n    case undefined:\n      return chars.missingPremitive;\n    case null:\n      return chars.nilPremitive;\n    case '':\n      return chars.emptyValue;\n    default:\n      return a;\n  }\n};\nconst processValue = function (str, r) {\n  if (!isAppChar(r[0]) && !isAppChar(str[str.length - 1])) {\n    str += chars.boundryChar;\n  }\n  return str + r;\n};\nconst isAppChar = function (ch) {\n  return charsArr.indexOf(ch) !== -1;\n};\nfunction hasData(jObj) {\n  if (jObj === undefined) {\n    return chars.missingChar;\n  } else if (jObj === null) {\n    return chars.nilChar;\n  } else if (jObj.child && Object.keys(jObj.child).length === 0 && (!jObj.attrsMap || Object.keys(jObj.attrsMap).length === 0)) {\n    return chars.emptyChar;\n  } else {\n    return true;\n  }\n}\nconst x2j = require('./xmlstr2xmlnode');\nconst buildOptions = require('./util').buildOptions;\nconst convert2nimn = function (node, e_schema, options) {\n  options = buildOptions(options, x2j.defaultOptions, x2j.props);\n  return _e(node, e_schema, options);\n};\nexports.convert2nimn = convert2nimn;", "'use strict';\n\nconst util = require('./util');\nconst buildOptions = require('./util').buildOptions;\nconst x2j = require('./xmlstr2xmlnode');\n\n//TODO: do it later\nconst convertToJsonString = function (node, options) {\n  options = buildOptions(options, x2j.defaultOptions, x2j.props);\n  options.indentBy = options.indentBy || '';\n  return _cToJsonStr(node, options, 0);\n};\nconst _cToJsonStr = function (node, options, level) {\n  let jObj = '{';\n\n  //traver through all the children\n  const keys = Object.keys(node.child);\n  for (let index = 0; index < keys.length; index++) {\n    const tagname = keys[index];\n    if (node.child[tagname] && node.child[tagname].length > 1) {\n      jObj += '\"' + tagname + '\" : [ ';\n      for (let tag in node.child[tagname]) {\n        jObj += _cToJsonStr(node.child[tagname][tag], options) + ' , ';\n      }\n      jObj = jObj.substr(0, jObj.length - 1) + ' ] '; //remove extra comma in last\n    } else {\n      jObj += '\"' + tagname + '\" : ' + _cToJsonStr(node.child[tagname][0], options) + ' ,';\n    }\n  }\n  util.merge(jObj, node.attrsMap);\n  //add attrsMap as new children\n  if (util.isEmptyObject(jObj)) {\n    return util.isExist(node.val) ? node.val : '';\n  } else {\n    if (util.isExist(node.val)) {\n      if (!(typeof node.val === 'string' && (node.val === '' || node.val === options.cdataPositionChar))) {\n        jObj += '\"' + options.textNodeName + '\" : ' + stringval(node.val);\n      }\n    }\n  }\n  //add value\n  if (jObj[jObj.length - 1] === ',') {\n    jObj = jObj.substr(0, jObj.length - 2);\n  }\n  return jObj + '}';\n};\nfunction stringval(v) {\n  if (v === true || v === false || !isNaN(v)) {\n    return v;\n  } else {\n    return '\"' + v + '\"';\n  }\n}\nfunction indentate(options, level) {\n  return options.indentBy.repeat(level);\n}\nexports.convertToJsonString = convertToJsonString;", "'use strict';\n\n//parse Empty Node as self closing node\nconst buildOptions = require('./util').buildOptions;\nconst defaultOptions = {\n  attributeNamePrefix: '@_',\n  attrNodeName: false,\n  textNodeName: '#text',\n  ignoreAttributes: true,\n  cdataTagName: false,\n  cdataPositionChar: '\\\\c',\n  format: false,\n  indentBy: '  ',\n  supressEmptyNode: false,\n  tagValueProcessor: function (a) {\n    return a;\n  },\n  attrValueProcessor: function (a) {\n    return a;\n  }\n};\nconst props = ['attributeNamePrefix', 'attrNodeName', 'textNodeName', 'ignoreAttributes', 'cdataTagName', 'cdataPositionChar', 'format', 'indentBy', 'supressEmptyNode', 'tagValueProcessor', 'attrValueProcessor', 'rootNodeName' //when array as root\n];\nfunction Parser(options) {\n  this.options = buildOptions(options, defaultOptions, props);\n  if (this.options.ignoreAttributes || this.options.attrNodeName) {\n    this.isAttribute = function /*a*/\n    () {\n      return false;\n    };\n  } else {\n    this.attrPrefixLen = this.options.attributeNamePrefix.length;\n    this.isAttribute = isAttribute;\n  }\n  if (this.options.cdataTagName) {\n    this.isCDATA = isCDATA;\n  } else {\n    this.isCDATA = function /*a*/\n    () {\n      return false;\n    };\n  }\n  this.replaceCDATAstr = replaceCDATAstr;\n  this.replaceCDATAarr = replaceCDATAarr;\n  this.processTextOrObjNode = processTextOrObjNode;\n  if (this.options.format) {\n    this.indentate = indentate;\n    this.tagEndChar = '>\\n';\n    this.newLine = '\\n';\n  } else {\n    this.indentate = function () {\n      return '';\n    };\n    this.tagEndChar = '>';\n    this.newLine = '';\n  }\n  if (this.options.supressEmptyNode) {\n    this.buildTextNode = buildEmptyTextNode;\n    this.buildObjNode = buildEmptyObjNode;\n  } else {\n    this.buildTextNode = buildTextValNode;\n    this.buildObjNode = buildObjectNode;\n  }\n  this.buildTextValNode = buildTextValNode;\n  this.buildObjectNode = buildObjectNode;\n}\nParser.prototype.parse = function (jObj) {\n  if (Array.isArray(jObj) && this.options.rootNodeName && this.options.rootNodeName.length > 1) {\n    jObj = {\n      [this.options.rootNodeName]: jObj\n    };\n  }\n  return this.j2x(jObj, 0).val;\n};\nParser.prototype.j2x = function (jObj, level) {\n  let attrStr = '';\n  let val = '';\n  for (let key in jObj) {\n    if (typeof jObj[key] === 'undefined') {\n      // supress undefined node\n    } else if (jObj[key] === null) {\n      val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\n    } else if (jObj[key] instanceof Date) {\n      val += this.buildTextNode(jObj[key], key, '', level);\n    } else if (typeof jObj[key] !== 'object') {\n      //premitive type\n      const attr = this.isAttribute(key);\n      if (attr) {\n        attrStr += ' ' + attr + '=\"' + this.options.attrValueProcessor('' + jObj[key]) + '\"';\n      } else if (this.isCDATA(key)) {\n        if (jObj[this.options.textNodeName]) {\n          val += this.replaceCDATAstr(jObj[this.options.textNodeName], jObj[key]);\n        } else {\n          val += this.replaceCDATAstr('', jObj[key]);\n        }\n      } else {\n        //tag value\n        if (key === this.options.textNodeName) {\n          if (jObj[this.options.cdataTagName]) {\n            //value will added while processing cdata\n          } else {\n            val += this.options.tagValueProcessor('' + jObj[key]);\n          }\n        } else {\n          val += this.buildTextNode(jObj[key], key, '', level);\n        }\n      }\n    } else if (Array.isArray(jObj[key])) {\n      //repeated nodes\n      if (this.isCDATA(key)) {\n        val += this.indentate(level);\n        if (jObj[this.options.textNodeName]) {\n          val += this.replaceCDATAarr(jObj[this.options.textNodeName], jObj[key]);\n        } else {\n          val += this.replaceCDATAarr('', jObj[key]);\n        }\n      } else {\n        //nested nodes\n        const arrLen = jObj[key].length;\n        for (let j = 0; j < arrLen; j++) {\n          const item = jObj[key][j];\n          if (typeof item === 'undefined') {\n            // supress undefined node\n          } else if (item === null) {\n            val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\n          } else if (typeof item === 'object') {\n            val += this.processTextOrObjNode(item, key, level);\n          } else {\n            val += this.buildTextNode(item, key, '', level);\n          }\n        }\n      }\n    } else {\n      //nested node\n      if (this.options.attrNodeName && key === this.options.attrNodeName) {\n        const Ks = Object.keys(jObj[key]);\n        const L = Ks.length;\n        for (let j = 0; j < L; j++) {\n          attrStr += ' ' + Ks[j] + '=\"' + this.options.attrValueProcessor('' + jObj[key][Ks[j]]) + '\"';\n        }\n      } else {\n        val += this.processTextOrObjNode(jObj[key], key, level);\n      }\n    }\n  }\n  return {\n    attrStr: attrStr,\n    val: val\n  };\n};\nfunction processTextOrObjNode(object, key, level) {\n  const result = this.j2x(object, level + 1);\n  if (object[this.options.textNodeName] !== undefined && Object.keys(object).length === 1) {\n    return this.buildTextNode(result.val, key, result.attrStr, level);\n  } else {\n    return this.buildObjNode(result.val, key, result.attrStr, level);\n  }\n}\nfunction replaceCDATAstr(str, cdata) {\n  str = this.options.tagValueProcessor('' + str);\n  if (this.options.cdataPositionChar === '' || str === '') {\n    return str + '<![CDATA[' + cdata + ']]' + this.tagEndChar;\n  } else {\n    return str.replace(this.options.cdataPositionChar, '<![CDATA[' + cdata + ']]' + this.tagEndChar);\n  }\n}\nfunction replaceCDATAarr(str, cdata) {\n  str = this.options.tagValueProcessor('' + str);\n  if (this.options.cdataPositionChar === '' || str === '') {\n    return str + '<![CDATA[' + cdata.join(']]><![CDATA[') + ']]' + this.tagEndChar;\n  } else {\n    for (let v in cdata) {\n      str = str.replace(this.options.cdataPositionChar, '<![CDATA[' + cdata[v] + ']]>');\n    }\n    return str + this.newLine;\n  }\n}\nfunction buildObjectNode(val, key, attrStr, level) {\n  if (attrStr && val.indexOf('<') === -1) {\n    return this.indentate(level) + '<' + key + attrStr + '>' + val +\n    //+ this.newLine\n    // + this.indentate(level)\n    '</' + key + this.tagEndChar;\n  } else {\n    return this.indentate(level) + '<' + key + attrStr + this.tagEndChar + val +\n    //+ this.newLine\n    this.indentate(level) + '</' + key + this.tagEndChar;\n  }\n}\nfunction buildEmptyObjNode(val, key, attrStr, level) {\n  if (val !== '') {\n    return this.buildObjectNode(val, key, attrStr, level);\n  } else {\n    return this.indentate(level) + '<' + key + attrStr + '/' + this.tagEndChar;\n    //+ this.newLine\n  }\n}\nfunction buildTextValNode(val, key, attrStr, level) {\n  return this.indentate(level) + '<' + key + attrStr + '>' + this.options.tagValueProcessor(val) + '</' + key + this.tagEndChar;\n}\nfunction buildEmptyTextNode(val, key, attrStr, level) {\n  if (val !== '') {\n    return this.buildTextValNode(val, key, attrStr, level);\n  } else {\n    return this.indentate(level) + '<' + key + attrStr + '/' + this.tagEndChar;\n  }\n}\nfunction indentate(level) {\n  return this.options.indentBy.repeat(level);\n}\nfunction isAttribute(name /*, options*/) {\n  if (name.startsWith(this.options.attributeNamePrefix)) {\n    return name.substr(this.attrPrefixLen);\n  } else {\n    return false;\n  }\n}\nfunction isCDATA(name) {\n  return name === this.options.cdataTagName;\n}\n\n//formatting\n//indentation\n//\\n after each closing or self closing tag\n\nmodule.exports = Parser;", "'use strict';\n\nconst nodeToJson = require('./node2json');\nconst xmlToNodeobj = require('./xmlstr2xmlnode');\nconst x2xmlnode = require('./xmlstr2xmlnode');\nconst buildOptions = require('./util').buildOptions;\nconst validator = require('./validator');\nexports.parse = function (xmlData, givenOptions = {}, validationOption) {\n  if (validationOption) {\n    if (validationOption === true) validationOption = {};\n    const result = validator.validate(xmlData, validationOption);\n    if (result !== true) {\n      throw Error(result.err.msg);\n    }\n  }\n  if (givenOptions.parseTrueNumberOnly && givenOptions.parseNodeValue !== false && !givenOptions.numParseOptions) {\n    givenOptions.numParseOptions = {\n      leadingZeros: false\n    };\n  }\n  let options = buildOptions(givenOptions, x2xmlnode.defaultOptions, x2xmlnode.props);\n  const traversableObj = xmlToNodeobj.getTraversalObj(xmlData, options);\n  //print(traversableObj, \"  \");\n  return nodeToJson.convertToJson(traversableObj, options);\n};\nexports.convertTonimn = require('./nimndata').convert2nimn;\nexports.getTraversalObj = xmlToNodeobj.getTraversalObj;\nexports.convertToJson = nodeToJson.convertToJson;\nexports.convertToJsonString = require('./node2json_str').convertToJsonString;\nexports.validate = validator.validate;\nexports.j2xParser = require('./json2xml');\nexports.parseToNimn = function (xmlData, schema, options) {\n  return exports.convertTonimn(exports.getTraversalObj(xmlData, options), schema, options);\n};\nfunction print(xmlNode, indentation) {\n  if (xmlNode) {\n    console.log(indentation + \"{\");\n    console.log(indentation + \"  \\\"tagName\\\": \\\"\" + xmlNode.tagname + \"\\\", \");\n    if (xmlNode.parent) {\n      console.log(indentation + \"  \\\"parent\\\": \\\"\" + xmlNode.parent.tagname + \"\\\", \");\n    }\n    console.log(indentation + \"  \\\"val\\\": \\\"\" + xmlNode.val + \"\\\", \");\n    console.log(indentation + \"  \\\"attrs\\\": \" + JSON.stringify(xmlNode.attrsMap, null, 4) + \", \");\n    if (xmlNode.child) {\n      console.log(indentation + \"\\\"child\\\": {\");\n      const indentation2 = indentation + indentation;\n      Object.keys(xmlNode.child).forEach(function (key) {\n        const node = xmlNode.child[key];\n        if (Array.isArray(node)) {\n          console.log(indentation + \"\\\"\" + key + \"\\\" :[\");\n          node.forEach(function (item, index) {\n            //console.log(indentation + \" \\\"\"+index+\"\\\" : [\")\n            print(item, indentation2);\n          });\n          console.log(indentation + \"],\");\n        } else {\n          console.log(indentation + \" \\\"\" + key + \"\\\" : {\");\n          print(node, indentation2);\n          console.log(indentation + \"},\");\n        }\n      });\n      console.log(indentation + \"},\");\n    }\n    console.log(indentation + \"},\");\n  }\n}"],
  "mappings": "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",
  "names": ["require_util", "__commonJSMin", "exports", "nameStartChar", "nameChar", "nameRegexp", "regexName", "getAllMatches", "string", "regex", "matches", "match", "allmatches", "len", "index", "isName", "v", "obj", "target", "a", "arrayMode", "keys", "i", "options", "defaultOptions", "props", "newOptions", "tagName", "parentTagName", "require_node2json", "__commonJSMin", "exports", "util", "convertToJson", "node", "options", "parentTagName", "jObj", "asArray", "keys", "index", "tagName", "tag", "result", "require_xmlNode", "__commonJSMin", "exports", "module", "tagname", "parent", "val", "child", "require_strnum", "__commonJSMin", "exports", "module", "hexRegex", "numRegex", "consider", "toNumber", "str", "options", "trimmedStr", "parse_int", "notation", "match", "sign", "leadingZeros", "numTrimmedByZeros", "trimZeros", "num", "numStr", "base", "require_xmlstr2xmlnode", "__commonJSMin", "exports", "util", "buildOptions", "xmlNode", "toNumber", "regx", "defaultOptions", "a", "tagName", "attrName", "props", "processTagValue", "val", "options", "parseValue", "resolveNameSpace", "tagname", "tags", "prefix", "shouldParse", "newval", "attrsRegx", "buildAttributesMap", "attrStr", "matches", "len", "attrs", "i", "attrCollection", "getTraversalObj", "xmlData", "xmlObj", "currentNode", "textData", "closeIndex", "findClosingIndex", "colonIndex", "tagExp", "childNode", "result", "closingIndexForOpeningTag", "separatorIndex", "shouldBuildAttributesMap", "data", "attrBoundary", "index", "ch", "str", "errMsg", "closingIndex", "require_validator", "__commonJSMin", "exports", "util", "defaultOptions", "props", "xmlData", "options", "tags", "tagFound", "reachedRoot", "i", "readPI", "tagStartPos", "readCommentAndCDATA", "closingTag", "tagName", "validateTagName", "msg", "getErrorObject", "getLineNumberForPosition", "result", "readAttributeStr", "attrStr", "attrStrStart", "isValid", "validateAttributeString", "otg", "openPos", "afterAmp", "validateAmpersand", "t", "start", "tagname", "angleBracketsCount", "doubleQuote", "singleQuote", "startChar", "tagClosed", "validAttrStrRegxp", "matches", "attrNames", "getPositionFromMatch", "attrName", "validateAttrName", "validateNumberAmpersand", "re", "count", "code", "message", "lineNumber", "index", "lines", "match", "require_nimndata", "__commonJSMin", "exports", "char", "a", "chars", "charsArr", "_e", "node", "e_schema", "options", "getValue", "hasValidData", "hasData", "str", "itemSchema", "arr_len", "arr_i", "r", "processValue", "keys", "i", "key", "isAppChar", "ch", "jObj", "x2j", "buildOptions", "convert2nimn", "require_node2json_str", "__commonJSMin", "exports", "util", "buildOptions", "x2j", "convertToJsonString", "node", "options", "_cToJsonStr", "level", "jObj", "keys", "index", "tagname", "tag", "stringval", "v", "require_json2xml", "__commonJSMin", "exports", "module", "buildOptions", "defaultOptions", "a", "props", "Parser", "options", "isAttribute", "isCDATA", "replaceCDATAstr", "replaceCDATAarr", "processTextOrObjNode", "indentate", "buildEmptyTextNode", "buildEmptyObjNode", "buildTextValNode", "buildObjectNode", "jObj", "level", "attrStr", "val", "key", "attr", "arrLen", "j", "item", "Ks", "L", "object", "result", "str", "cdata", "v", "name", "require_parser", "__commonJSMin", "exports", "nodeToJson", "xmlToNodeobj", "x2xmlnode", "buildOptions", "validator", "xmlData", "givenOptions", "validationOption", "result", "options", "traversableObj", "schema"]
}
