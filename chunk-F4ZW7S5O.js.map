{
  "version": 3,
  "sources": ["../../@angular/core/fesm2022/signal.mjs", "../../@angular/core/fesm2022/effect.mjs"],
  "sourcesContent": ["/**\n * @license Angular v20.3.7\n * (c) 2010-2025 Google LLC. https://angular.dev/\n * License: MIT\n */\n\n/**\n * The currently active consumer `ReactiveNode`, if running code in a reactive context.\n *\n * Change this via `setActiveConsumer`.\n */\nlet activeConsumer = null;\nlet inNotificationPhase = false;\n/**\n * Global epoch counter. Incremented whenever a source signal is set.\n */\nlet epoch = 1;\n/**\n * If set, called after a producer `ReactiveNode` is created.\n */\nlet postProducerCreatedFn = null;\n/**\n * Symbol used to tell `Signal`s apart from other functions.\n *\n * This can be used to auto-unwrap signals in various cases, or to auto-wrap non-signal values.\n */\nconst SIGNAL = /* @__PURE__ */Symbol('SIGNAL');\nfunction setActiveConsumer(consumer) {\n  const prev = activeConsumer;\n  activeConsumer = consumer;\n  return prev;\n}\nfunction getActiveConsumer() {\n  return activeConsumer;\n}\nfunction isInNotificationPhase() {\n  return inNotificationPhase;\n}\nfunction isReactive(value) {\n  return value[SIGNAL] !== undefined;\n}\nconst REACTIVE_NODE = {\n  version: 0,\n  lastCleanEpoch: 0,\n  dirty: false,\n  producers: undefined,\n  producersTail: undefined,\n  consumers: undefined,\n  consumersTail: undefined,\n  recomputing: false,\n  consumerAllowSignalWrites: false,\n  consumerIsAlwaysLive: false,\n  kind: 'unknown',\n  producerMustRecompute: () => false,\n  producerRecomputeValue: () => {},\n  consumerMarkedDirty: () => {},\n  consumerOnSignalRead: () => {}\n};\n/**\n * Called by implementations when a producer's signal is read.\n */\nfunction producerAccessed(node) {\n  if (inNotificationPhase) {\n    throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode ? `Assertion error: signal read during notification phase` : '');\n  }\n  if (activeConsumer === null) {\n    // Accessed outside of a reactive context, so nothing to record.\n    return;\n  }\n  activeConsumer.consumerOnSignalRead(node);\n  const prevProducerLink = activeConsumer.producersTail;\n  // If the last producer we accessed is the same as the current one, we can skip adding a new\n  // link\n  if (prevProducerLink !== undefined && prevProducerLink.producer === node) {\n    return;\n  }\n  let nextProducerLink = undefined;\n  const isRecomputing = activeConsumer.recomputing;\n  if (isRecomputing) {\n    // If we're incrementally rebuilding the producers list, we want to check if the next producer\n    // in the list is the same as the one we're trying to add.\n    // If the previous producer is defined, then the next producer is just the one that follows it.\n    // Otherwise, we should check the head of the producers list (the first node that we accessed the last time this consumer was run).\n    nextProducerLink = prevProducerLink !== undefined ? prevProducerLink.nextProducer : activeConsumer.producers;\n    if (nextProducerLink !== undefined && nextProducerLink.producer === node) {\n      // If the next producer is the same as the one we're trying to add, we can just update the\n      // last read version, update the tail of the producers list of this rerun, and return.\n      activeConsumer.producersTail = nextProducerLink;\n      nextProducerLink.lastReadVersion = node.version;\n      return;\n    }\n  }\n  const prevConsumerLink = node.consumersTail;\n  // If the producer we're accessing already has a link to this consumer, we can skip adding a new\n  // link. This can short circuit the creation of a new link in the case where the consumer reads alternating ReeactiveNodes\n  if (prevConsumerLink !== undefined && prevConsumerLink.consumer === activeConsumer && (\n  // However, we have to make sure that the link we've discovered isn't from a node that is incrementally rebuilding its producer list\n  !isRecomputing || isValidLink(prevConsumerLink, activeConsumer))) {\n    // If we found an existing link to the consumer we can just return.\n    return;\n  }\n  // If we got here, it means that we need to create a new link between the producer and the consumer.\n  const isLive = consumerIsLive(activeConsumer);\n  const newLink = {\n    producer: node,\n    consumer: activeConsumer,\n    // instead of eagerly destroying the previous link, we delay until we've finished recomputing\n    // the producers list, so that we can destroy all of the old links at once.\n    nextProducer: nextProducerLink,\n    prevConsumer: prevConsumerLink,\n    lastReadVersion: node.version,\n    nextConsumer: undefined\n  };\n  activeConsumer.producersTail = newLink;\n  if (prevProducerLink !== undefined) {\n    prevProducerLink.nextProducer = newLink;\n  } else {\n    activeConsumer.producers = newLink;\n  }\n  if (isLive) {\n    producerAddLiveConsumer(node, newLink);\n  }\n}\n/**\n * Increment the global epoch counter.\n *\n * Called by source producers (that is, not computeds) whenever their values change.\n */\nfunction producerIncrementEpoch() {\n  epoch++;\n}\n/**\n * Ensure this producer's `version` is up-to-date.\n */\nfunction producerUpdateValueVersion(node) {\n  if (consumerIsLive(node) && !node.dirty) {\n    // A live consumer will be marked dirty by producers, so a clean state means that its version\n    // is guaranteed to be up-to-date.\n    return;\n  }\n  if (!node.dirty && node.lastCleanEpoch === epoch) {\n    // Even non-live consumers can skip polling if they previously found themselves to be clean at\n    // the current epoch, since their dependencies could not possibly have changed (such a change\n    // would've increased the epoch).\n    return;\n  }\n  if (!node.producerMustRecompute(node) && !consumerPollProducersForChange(node)) {\n    // None of our producers report a change since the last time they were read, so no\n    // recomputation of our value is necessary, and we can consider ourselves clean.\n    producerMarkClean(node);\n    return;\n  }\n  node.producerRecomputeValue(node);\n  // After recomputing the value, we're no longer dirty.\n  producerMarkClean(node);\n}\n/**\n * Propagate a dirty notification to live consumers of this producer.\n */\nfunction producerNotifyConsumers(node) {\n  if (node.consumers === undefined) {\n    return;\n  }\n  // Prevent signal reads when we're updating the graph\n  const prev = inNotificationPhase;\n  inNotificationPhase = true;\n  try {\n    for (let link = node.consumers; link !== undefined; link = link.nextConsumer) {\n      const consumer = link.consumer;\n      if (!consumer.dirty) {\n        consumerMarkDirty(consumer);\n      }\n    }\n  } finally {\n    inNotificationPhase = prev;\n  }\n}\n/**\n * Whether this `ReactiveNode` in its producer capacity is currently allowed to initiate updates,\n * based on the current consumer context.\n */\nfunction producerUpdatesAllowed() {\n  return activeConsumer?.consumerAllowSignalWrites !== false;\n}\nfunction consumerMarkDirty(node) {\n  node.dirty = true;\n  producerNotifyConsumers(node);\n  node.consumerMarkedDirty?.(node);\n}\nfunction producerMarkClean(node) {\n  node.dirty = false;\n  node.lastCleanEpoch = epoch;\n}\n/**\n * Prepare this consumer to run a computation in its reactive context and set\n * it as the active consumer.\n *\n * Must be called by subclasses which represent reactive computations, before those computations\n * begin.\n */\nfunction consumerBeforeComputation(node) {\n  if (node) resetConsumerBeforeComputation(node);\n  return setActiveConsumer(node);\n}\n/**\n * Prepare this consumer to run a computation in its reactive context.\n *\n * We expose this mainly for code where we manually batch effects into a single\n * consumer. In those cases we may wish to \"reopen\" a consumer multiple times\n * in initial render before finalizing it. Most code should just call\n * `consumerBeforeComputation` instead of calling this directly.\n */\nfunction resetConsumerBeforeComputation(node) {\n  node.producersTail = undefined;\n  node.recomputing = true;\n}\n/**\n * Finalize this consumer's state and set previous consumer as the active consumer after a\n * reactive computation has run.\n *\n * Must be called by subclasses which represent reactive computations, after those computations\n * have finished.\n */\nfunction consumerAfterComputation(node, prevConsumer) {\n  setActiveConsumer(prevConsumer);\n  if (node) finalizeConsumerAfterComputation(node);\n}\n/**\n * Finalize this consumer's state after a reactive computation has run.\n *\n * We expose this mainly for code where we manually batch effects into a single\n * consumer. In those cases we may wish to \"reopen\" a consumer multiple times\n * in initial render before finalizing it. Most code should just call\n * `consumerAfterComputation` instead of calling this directly.\n */\nfunction finalizeConsumerAfterComputation(node) {\n  node.recomputing = false;\n  // We've finished incrementally rebuilding the producers list, now if there are any producers\n  // that are after producersTail, they are stale and should be removed.\n  const producersTail = node.producersTail;\n  let toRemove = producersTail !== undefined ? producersTail.nextProducer : node.producers;\n  if (toRemove !== undefined) {\n    if (consumerIsLive(node)) {\n      // For each stale link, we first unlink it from the producers list of consumers\n      do {\n        toRemove = producerRemoveLiveConsumerLink(toRemove);\n      } while (toRemove !== undefined);\n    }\n    // Now, we can truncate the producers list to remove all stale links.\n    if (producersTail !== undefined) {\n      producersTail.nextProducer = undefined;\n    } else {\n      node.producers = undefined;\n    }\n  }\n}\n/**\n * Determine whether this consumer has any dependencies which have changed since the last time\n * they were read.\n */\nfunction consumerPollProducersForChange(node) {\n  // Poll producers for change.\n  for (let link = node.producers; link !== undefined; link = link.nextProducer) {\n    const producer = link.producer;\n    const seenVersion = link.lastReadVersion;\n    // First check the versions. A mismatch means that the producer's value is known to have\n    // changed since the last time we read it.\n    if (seenVersion !== producer.version) {\n      return true;\n    }\n    // The producer's version is the same as the last time we read it, but it might itself be\n    // stale. Force the producer to recompute its version (calculating a new value if necessary).\n    producerUpdateValueVersion(producer);\n    // Now when we do this check, `producer.version` is guaranteed to be up to date, so if the\n    // versions still match then it has not changed since the last time we read it.\n    if (seenVersion !== producer.version) {\n      return true;\n    }\n  }\n  return false;\n}\n/**\n * Disconnect this consumer from the graph.\n */\nfunction consumerDestroy(node) {\n  if (consumerIsLive(node)) {\n    // Drop all connections from the graph to this node.\n    let link = node.producers;\n    while (link !== undefined) {\n      link = producerRemoveLiveConsumerLink(link);\n    }\n  }\n  // Truncate all the linked lists to drop all connection from this node to the graph.\n  node.producers = undefined;\n  node.producersTail = undefined;\n  node.consumers = undefined;\n  node.consumersTail = undefined;\n}\n/**\n * Add `consumer` as a live consumer of this node.\n *\n * Note that this operation is potentially transitive. If this node becomes live, then it becomes\n * a live consumer of all of its current producers.\n */\nfunction producerAddLiveConsumer(node, link) {\n  const consumersTail = node.consumersTail;\n  const wasLive = consumerIsLive(node);\n  if (consumersTail !== undefined) {\n    link.nextConsumer = consumersTail.nextConsumer;\n    consumersTail.nextConsumer = link;\n  } else {\n    link.nextConsumer = undefined;\n    node.consumers = link;\n  }\n  link.prevConsumer = consumersTail;\n  node.consumersTail = link;\n  if (!wasLive) {\n    for (let link = node.producers; link !== undefined; link = link.nextProducer) {\n      producerAddLiveConsumer(link.producer, link);\n    }\n  }\n}\nfunction producerRemoveLiveConsumerLink(link) {\n  const producer = link.producer;\n  const nextProducer = link.nextProducer;\n  const nextConsumer = link.nextConsumer;\n  const prevConsumer = link.prevConsumer;\n  link.nextConsumer = undefined;\n  link.prevConsumer = undefined;\n  if (nextConsumer !== undefined) {\n    nextConsumer.prevConsumer = prevConsumer;\n  } else {\n    producer.consumersTail = prevConsumer;\n  }\n  if (prevConsumer !== undefined) {\n    prevConsumer.nextConsumer = nextConsumer;\n  } else {\n    producer.consumers = nextConsumer;\n    if (!consumerIsLive(producer)) {\n      let producerLink = producer.producers;\n      while (producerLink !== undefined) {\n        producerLink = producerRemoveLiveConsumerLink(producerLink);\n      }\n    }\n  }\n  return nextProducer;\n}\nfunction consumerIsLive(node) {\n  return node.consumerIsAlwaysLive || node.consumers !== undefined;\n}\nfunction runPostProducerCreatedFn(node) {\n  postProducerCreatedFn?.(node);\n}\nfunction setPostProducerCreatedFn(fn) {\n  const prev = postProducerCreatedFn;\n  postProducerCreatedFn = fn;\n  return prev;\n}\n// While a ReactiveNode is recomputing, it may not have destroyed previous links\n// This allows us to check if a given link will be destroyed by a reactivenode if it were to finish running immediately without accesing any more producers\nfunction isValidLink(checkLink, consumer) {\n  const producersTail = consumer.producersTail;\n  if (producersTail !== undefined) {\n    let link = consumer.producers;\n    do {\n      if (link === checkLink) {\n        return true;\n      }\n      if (link === producersTail) {\n        break;\n      }\n      link = link.nextProducer;\n    } while (link !== undefined);\n  }\n  return false;\n}\n\n/**\n * The default equality function used for `signal` and `computed`, which uses referential equality.\n */\nfunction defaultEquals(a, b) {\n  return Object.is(a, b);\n}\n\n/**\n * Create a computed signal which derives a reactive value from an expression.\n */\nfunction createComputed(computation, equal) {\n  const node = Object.create(COMPUTED_NODE);\n  node.computation = computation;\n  if (equal !== undefined) {\n    node.equal = equal;\n  }\n  const computed = () => {\n    // Check if the value needs updating before returning it.\n    producerUpdateValueVersion(node);\n    // Record that someone looked at this signal.\n    producerAccessed(node);\n    if (node.value === ERRORED) {\n      throw node.error;\n    }\n    return node.value;\n  };\n  computed[SIGNAL] = node;\n  if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n    const debugName = node.debugName ? ' (' + node.debugName + ')' : '';\n    computed.toString = () => `[Computed${debugName}: ${node.value}]`;\n  }\n  runPostProducerCreatedFn(node);\n  return computed;\n}\n/**\n * A dedicated symbol used before a computed value has been calculated for the first time.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst UNSET = /* @__PURE__ */Symbol('UNSET');\n/**\n * A dedicated symbol used in place of a computed signal value to indicate that a given computation\n * is in progress. Used to detect cycles in computation chains.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst COMPUTING = /* @__PURE__ */Symbol('COMPUTING');\n/**\n * A dedicated symbol used in place of a computed signal value to indicate that a given computation\n * failed. The thrown error is cached until the computation gets dirty again.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst ERRORED = /* @__PURE__ */Symbol('ERRORED');\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nconst COMPUTED_NODE = /* @__PURE__ */(() => {\n  return {\n    ...REACTIVE_NODE,\n    value: UNSET,\n    dirty: true,\n    error: null,\n    equal: defaultEquals,\n    kind: 'computed',\n    producerMustRecompute(node) {\n      // Force a recomputation if there's no current value, or if the current value is in the\n      // process of being calculated (which should throw an error).\n      return node.value === UNSET || node.value === COMPUTING;\n    },\n    producerRecomputeValue(node) {\n      if (node.value === COMPUTING) {\n        // Our computation somehow led to a cyclic read of itself.\n        throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode ? 'Detected cycle in computations.' : '');\n      }\n      const oldValue = node.value;\n      node.value = COMPUTING;\n      const prevConsumer = consumerBeforeComputation(node);\n      let newValue;\n      let wasEqual = false;\n      try {\n        newValue = node.computation();\n        // We want to mark this node as errored if calling `equal` throws; however, we don't want\n        // to track any reactive reads inside `equal`.\n        setActiveConsumer(null);\n        wasEqual = oldValue !== UNSET && oldValue !== ERRORED && newValue !== ERRORED && node.equal(oldValue, newValue);\n      } catch (err) {\n        newValue = ERRORED;\n        node.error = err;\n      } finally {\n        consumerAfterComputation(node, prevConsumer);\n      }\n      if (wasEqual) {\n        // No change to `valueVersion` - old and new values are\n        // semantically equivalent.\n        node.value = oldValue;\n        return;\n      }\n      node.value = newValue;\n      node.version++;\n    }\n  };\n})();\nfunction defaultThrowError() {\n  throw new Error();\n}\nlet throwInvalidWriteToSignalErrorFn = defaultThrowError;\nfunction throwInvalidWriteToSignalError(node) {\n  throwInvalidWriteToSignalErrorFn(node);\n}\nfunction setThrowInvalidWriteToSignalError(fn) {\n  throwInvalidWriteToSignalErrorFn = fn;\n}\n\n/**\n * If set, called after `WritableSignal`s are updated.\n *\n * This hook can be used to achieve various effects, such as running effects synchronously as part\n * of setting a signal.\n */\nlet postSignalSetFn = null;\n/**\n * Creates a `Signal` getter, setter, and updater function.\n */\nfunction createSignal(initialValue, equal) {\n  const node = Object.create(SIGNAL_NODE);\n  node.value = initialValue;\n  if (equal !== undefined) {\n    node.equal = equal;\n  }\n  const getter = () => signalGetFn(node);\n  getter[SIGNAL] = node;\n  if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n    const debugName = node.debugName ? ' (' + node.debugName + ')' : '';\n    getter.toString = () => `[Signal${debugName}: ${node.value}]`;\n  }\n  runPostProducerCreatedFn(node);\n  const set = newValue => signalSetFn(node, newValue);\n  const update = updateFn => signalUpdateFn(node, updateFn);\n  return [getter, set, update];\n}\nfunction setPostSignalSetFn(fn) {\n  const prev = postSignalSetFn;\n  postSignalSetFn = fn;\n  return prev;\n}\nfunction signalGetFn(node) {\n  producerAccessed(node);\n  return node.value;\n}\nfunction signalSetFn(node, newValue) {\n  if (!producerUpdatesAllowed()) {\n    throwInvalidWriteToSignalError(node);\n  }\n  if (!node.equal(node.value, newValue)) {\n    node.value = newValue;\n    signalValueChanged(node);\n  }\n}\nfunction signalUpdateFn(node, updater) {\n  if (!producerUpdatesAllowed()) {\n    throwInvalidWriteToSignalError(node);\n  }\n  signalSetFn(node, updater(node.value));\n}\nfunction runPostSignalSetFn(node) {\n  postSignalSetFn?.(node);\n}\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nconst SIGNAL_NODE = /* @__PURE__ */(() => {\n  return {\n    ...REACTIVE_NODE,\n    equal: defaultEquals,\n    value: undefined,\n    kind: 'signal'\n  };\n})();\nfunction signalValueChanged(node) {\n  node.version++;\n  producerIncrementEpoch();\n  producerNotifyConsumers(node);\n  postSignalSetFn?.(node);\n}\nexport { COMPUTING, ERRORED, REACTIVE_NODE, SIGNAL, SIGNAL_NODE, UNSET, consumerAfterComputation, consumerBeforeComputation, consumerDestroy, consumerMarkDirty, consumerPollProducersForChange, createComputed, createSignal, defaultEquals, finalizeConsumerAfterComputation, getActiveConsumer, isInNotificationPhase, isReactive, producerAccessed, producerIncrementEpoch, producerMarkClean, producerNotifyConsumers, producerUpdateValueVersion, producerUpdatesAllowed, resetConsumerBeforeComputation, runPostProducerCreatedFn, runPostSignalSetFn, setActiveConsumer, setPostProducerCreatedFn, setPostSignalSetFn, setThrowInvalidWriteToSignalError, signalGetFn, signalSetFn, signalUpdateFn };\n", "/**\n * @license Angular v20.3.7\n * (c) 2010-2025 Google LLC. https://angular.dev/\n * License: MIT\n */\n\nimport { SIGNAL, runPostProducerCreatedFn, producerUpdateValueVersion, signalSetFn, producerMarkClean, signalUpdateFn, REACTIVE_NODE, UNSET, defaultEquals, COMPUTING, consumerBeforeComputation, ERRORED, consumerAfterComputation, producerAccessed, setActiveConsumer, consumerPollProducersForChange } from './signal.mjs';\nfunction createLinkedSignal(sourceFn, computationFn, equalityFn) {\n  const node = Object.create(LINKED_SIGNAL_NODE);\n  node.source = sourceFn;\n  node.computation = computationFn;\n  if (equalityFn != undefined) {\n    node.equal = equalityFn;\n  }\n  const linkedSignalGetter = () => {\n    // Check if the value needs updating before returning it.\n    producerUpdateValueVersion(node);\n    // Record that someone looked at this signal.\n    producerAccessed(node);\n    if (node.value === ERRORED) {\n      throw node.error;\n    }\n    return node.value;\n  };\n  const getter = linkedSignalGetter;\n  getter[SIGNAL] = node;\n  if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n    const debugName = node.debugName ? ' (' + node.debugName + ')' : '';\n    getter.toString = () => `[LinkedSignal${debugName}: ${node.value}]`;\n  }\n  runPostProducerCreatedFn(node);\n  return getter;\n}\nfunction linkedSignalSetFn(node, newValue) {\n  producerUpdateValueVersion(node);\n  signalSetFn(node, newValue);\n  producerMarkClean(node);\n}\nfunction linkedSignalUpdateFn(node, updater) {\n  producerUpdateValueVersion(node);\n  signalUpdateFn(node, updater);\n  producerMarkClean(node);\n}\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `LINKED_SIGNAL_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nconst LINKED_SIGNAL_NODE = /* @__PURE__ */(() => {\n  return {\n    ...REACTIVE_NODE,\n    value: UNSET,\n    dirty: true,\n    error: null,\n    equal: defaultEquals,\n    kind: 'linkedSignal',\n    producerMustRecompute(node) {\n      // Force a recomputation if there's no current value, or if the current value is in the\n      // process of being calculated (which should throw an error).\n      return node.value === UNSET || node.value === COMPUTING;\n    },\n    producerRecomputeValue(node) {\n      if (node.value === COMPUTING) {\n        // Our computation somehow led to a cyclic read of itself.\n        throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode ? 'Detected cycle in computations.' : '');\n      }\n      const oldValue = node.value;\n      node.value = COMPUTING;\n      const prevConsumer = consumerBeforeComputation(node);\n      let newValue;\n      try {\n        const newSourceValue = node.source();\n        const prev = oldValue === UNSET || oldValue === ERRORED ? undefined : {\n          source: node.sourceValue,\n          value: oldValue\n        };\n        newValue = node.computation(newSourceValue, prev);\n        node.sourceValue = newSourceValue;\n      } catch (err) {\n        newValue = ERRORED;\n        node.error = err;\n      } finally {\n        consumerAfterComputation(node, prevConsumer);\n      }\n      if (oldValue !== UNSET && newValue !== ERRORED && node.equal(oldValue, newValue)) {\n        // No change to `valueVersion` - old and new values are\n        // semantically equivalent.\n        node.value = oldValue;\n        return;\n      }\n      node.value = newValue;\n      node.version++;\n    }\n  };\n})();\n\n/**\n * Execute an arbitrary function in a non-reactive (non-tracking) context. The executed function\n * can, optionally, return a value.\n */\nfunction untracked(nonReactiveReadsFn) {\n  const prevConsumer = setActiveConsumer(null);\n  // We are not trying to catch any particular errors here, just making sure that the consumers\n  // stack is restored in case of errors.\n  try {\n    return nonReactiveReadsFn();\n  } finally {\n    setActiveConsumer(prevConsumer);\n  }\n}\nconst BASE_EFFECT_NODE = /* @__PURE__ */(() => ({\n  ...REACTIVE_NODE,\n  consumerIsAlwaysLive: true,\n  consumerAllowSignalWrites: true,\n  dirty: true,\n  kind: 'effect'\n}))();\nfunction runEffect(node) {\n  node.dirty = false;\n  if (node.version > 0 && !consumerPollProducersForChange(node)) {\n    return;\n  }\n  node.version++;\n  const prevNode = consumerBeforeComputation(node);\n  try {\n    node.cleanup();\n    node.fn();\n  } finally {\n    consumerAfterComputation(node, prevNode);\n  }\n}\nexport { BASE_EFFECT_NODE, createLinkedSignal, linkedSignalSetFn, linkedSignalUpdateFn, runEffect, untracked };\n"],
  "mappings": "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",
  "names": ["activeConsumer", "inNotificationPhase", "epoch", "postProducerCreatedFn", "SIGNAL", "setActiveConsumer", "consumer", "prev", "getActiveConsumer", "isInNotificationPhase", "isReactive", "value", "REACTIVE_NODE", "producerAccessed", "node", "prevProducerLink", "nextProducerLink", "isRecomputing", "prevConsumerLink", "isValidLink", "isLive", "consumerIsLive", "newLink", "producerAddLiveConsumer", "producerIncrementEpoch", "producerUpdateValueVersion", "consumerPollProducersForChange", "producerMarkClean", "producerNotifyConsumers", "link", "consumerMarkDirty", "producerUpdatesAllowed", "consumerBeforeComputation", "resetConsumerBeforeComputation", "consumerAfterComputation", "prevConsumer", "finalizeConsumerAfterComputation", "producersTail", "toRemove", "producerRemoveLiveConsumerLink", "producer", "seenVersion", "consumerDestroy", "consumersTail", "wasLive", "nextProducer", "nextConsumer", "producerLink", "runPostProducerCreatedFn", "setPostProducerCreatedFn", "fn", "checkLink", "defaultEquals", "a", "b", "createComputed", "computation", "equal", "COMPUTED_NODE", "computed", "ERRORED", "UNSET", "COMPUTING", "__spreadProps", "__spreadValues", "oldValue", "newValue", "wasEqual", "err", "defaultThrowError", "throwInvalidWriteToSignalErrorFn", "throwInvalidWriteToSignalError", "setThrowInvalidWriteToSignalError", "postSignalSetFn", "createSignal", "initialValue", "SIGNAL_NODE", "getter", "signalGetFn", "signalSetFn", "updateFn", "signalUpdateFn", "setPostSignalSetFn", "signalValueChanged", "updater", "runPostSignalSetFn", "createLinkedSignal", "sourceFn", "computationFn", "equalityFn", "node", "LINKED_SIGNAL_NODE", "getter", "producerUpdateValueVersion", "producerAccessed", "ERRORED", "SIGNAL", "runPostProducerCreatedFn", "linkedSignalSetFn", "newValue", "signalSetFn", "producerMarkClean", "linkedSignalUpdateFn", "updater", "signalUpdateFn", "__spreadProps", "__spreadValues", "REACTIVE_NODE", "UNSET", "defaultEquals", "COMPUTING", "oldValue", "prevConsumer", "consumerBeforeComputation", "newSourceValue", "prev", "err", "consumerAfterComputation", "untracked", "nonReactiveReadsFn", "setActiveConsumer", "BASE_EFFECT_NODE", "runEffect", "consumerPollProducersForChange", "prevNode"]
}
