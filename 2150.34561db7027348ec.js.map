{"version":3,"file":"2150.34561db7027348ec.js","mappings":"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","names":["BehaviorSubject","_Subject","_value","_this","_classCallCheck","this","_callSuper","_inherits","_createClass","key","get","getValue","value","subscriber","subscription","_superPropGet","closed","next","hasError","thrownError","_throwIfClosed","Subject","Observable","subscribe","_subscribe","operator","observable","source","observerOrNext","error","complete","isSubscriber","Subscriber","isObserver","isFunction","isSubscription","SafeSubscriber","errorContext","add","call","_trySubscribe","sink","err","promiseCtor","_this2","getPromiseCtor","resolve","reject","unsubscribe","_a","Symbol_observable","_len","arguments","length","operations","Array","_key","pipeFromArray","_this3","x","create","config","Promise","ObjectUnsubscribedError","createErrorClass","_super","name","message","_Observable","currentObservers","observers","isStopped","subject","AnonymousSubject","from","_step","_iterator","_createForOfIteratorHelper","s","n","done","e","f","shift","_this4","_checkFinalizedStatuses","_innerSubscribe","_this5","EMPTY_SUBSCRIPTION","push","Subscription","arrRemove","destination","_this6","_b","COMPLETE_NOTIFICATION","createNotification","undefined","kind","_Subscription","EMPTY_OBSERVER","handleStoppedNotification","nextNotification","_next","errorNotification","_error","_complete","_bind","Function","prototype","bind","fn","thisArg","ConsumerObserver","partialObserver","handleUnhandledError","_Subscriber","context","useDeprecatedNextContext","Object","useDeprecatedSynchronousErrorHandling","captureError","reportUnhandledError","notification","onStoppedNotification","timeoutProvider","setTimeout","noop","defaultErrorHandler","empty","UnsubscriptionError","errors","concat","map","i","toString","join","initialTeardown","_parentage","_finalizers","isArray","remove","initialFinalizer","_step2","_iterator2","finalizer","execFinalizer","_toConsumableArray","teardown","_hasParent","_addParent","parent","includes","_removeParent","EMPTY","onUnhandledError","createOperatorSubscriber","onNext","onComplete","onError","onFinalize","OperatorSubscriber","shouldUnsubscribe","_setTimeout","_x","_x2","apply","handler","timeout","delegate","args","clearTimeout","_clearTimeout","_x3","handle","Symbol","arr","item","index","indexOf","splice","createImpl","ctorFunc","instance","Error","stack","constructor","cb","isRoot","errorThrown","_context","identity","hasLift","lift","operate","init","liftedSource","TypeError","pipe","fns","input","reduce","prev","_currentInjector","getCurrentInjector","setCurrentInjector","injector","former","NOT_FOUND","isNotFound","Version","full","_defineProperty","parts","split","major","minor","patch","slice","XSS_SECURITY_URL","RuntimeError","_Error","code","formatRuntimeError","_wrapNativeSuper","fullCode","formatRuntimeErrorCode","Math","abs","_global","globalThis","initNgDevMode","getClosureSafeProperty","objWithPropertyToExtract","fillProperties","target","hasOwnProperty","stringify","token","overriddenName","result","newLineIndex","concatStringsWithSpace","before","after","truncateMiddle","str","maxLength","substring","halfLimit","round","__forward_ref__","forwardRef","forwardRefFn","resolveForwardRef","type","isForwardRef","assertNumber","actual","msg","throwError","assertNumberInRange","minInclusive","maxInclusive","assertLessThanOrEqual","expected","assertGreaterThanOrEqual","assertString","assertFunction","assertEqual","assertNotEqual","assertSame","assertNotSame","assertLessThan","assertGreaterThan","assertDefined","comparison","assertDomNode","node","Node","assertElement","Element","assertIndexInRange","maxLen","assertOneOf","validValues","JSON","assertNotReactive","getActiveConsumer","defineInjectable","opts","providedIn","factory","defineInjector","options","providers","imports","getInjectableDef","getOwnDefinition","field","NG_PROV_DEF","isInjectable","getInjectorDef","NG_INJ_DEF","_injectorProfilerContext","prov","inj","InjectionToken","_desc","__NG_ELEMENT_ID__","getInjectorProfilerContext","setInjectorProfilerContext","previous","injectorProfilerCallbacks","NOOP_PROFILER_REMOVAL","setInjectorProfiler","injectorProfiler","removeProfiler","profiler","profilerIdx","event","injectorProfilerCallback","emitProviderConfiguredEvent","eventProvider","isViewProvider","provide","provider","providerRecord","emitInjectorToCreateInstanceEvent","emitInstanceCreatedByInjectorEvent","emitInjectEvent","flags","service","emitEffectCreatedEvent","effect","runInInjectorProfilerContext","callback","prevInjectContext","isEnvironmentProviders","providers","NG_COMP_DEF","cmp","NG_DIR_DEF","dir","NG_PIPE_DEF","pipe","NG_MOD_DEF","mod","NG_FACTORY_DEF","fac","NG_ELEMENT_ID","NG_ENV_ID","__NG_ENV_ID__","renderStringify","String","stringifyForError","debugStringifyTypeForError","componentDef","debugInfo","stringifyTypeFromDebugInfo","filePath","lineNumber","className","_injectImplementation","NG_RUNTIME_ERROR_CODE","ngErrorCode","NG_RUNTIME_ERROR_MESSAGE","ngErrorMessage","NG_TOKEN_PATH","ngTokenPath","cyclicDependencyError","path","createRuntimeError","cyclicDependencyErrorWithDetails","augmentRuntimeError","formatErrorMessage","text","pathDetails","sourceDetails","throwProviderNotFoundError","injectorName","ngDevMode","getInjectImplementation","setInjectImplementation","impl","injectRootLimpMode","notFoundValue","injectableDef","assertInjectImplementationNotEqual","THROW_IF_NOT_FOUND","DI_DECORATOR_FLAG","RetrievingInjector","convertToBitFlags","injectInjectorOnly","currentInjector","convertToInjectOptions","optional","host","self","skipSelf","retrieve","inject","invalidFactoryDep","inject","injectArgs","types","arg","j","meta","flag","getInjectFlag","attachInjectFlag","decorator","getFactoryDef","throwNotFound","arrayEquals","a","b","identityAccessor","valueA","valueB","flatten","list","flat","Number","POSITIVE_INFINITY","deepForEach","forEach","addToArray","removeFromArray","pop","newArray","size","arraySplice","array","count","arrayInsert2","value1","value2","end","keyValueArraySet","keyValueArray","keyValueArrayIndexOf","keyValueArrayGet","_arrayIndexOfSorted","start","middle","current","EMPTY_OBJ","EMPTY_ARRAY","ENVIRONMENT_INITIALIZER","INJECTOR$1","INJECTOR_DEF_TYPES","NullInjector","getNgModuleDef","getNgModuleDefOrThrow","ngModuleDef","getComponentDef","getDirectiveDefOrThrow","def","getDirectiveDef","getPipeDef","isStandalone","standalone","makeEnvironmentProviders","provideEnvironmentInitializer","initializerFn","multi","useValue","importProvidersFrom","_len2","sources","_key2","internalImportProvidersFrom","fromNgModule","checkForStandaloneCmp","injectorTypesWithProviders","providersOut","dedup","Set","collectProviders","_len3","_key3","internalSource","walkProviderTree","processInjectorTypesWithProviders","typesWithProviders","visitor","_loop","_typesWithProviders$i","ngModule","deepForEachProvider","container","parents","defType","injDef","cmpDef","isDuplicate","has","dependencies","deps","importTypesWithProviders","imported","useFactory","defProviders","injectorType","USE_VALUE","isValueProvider","isTypeProvider","isClassProvider","useClass","INJECTOR_SCOPE","NOT_YET","CIRCULAR","NULL_INJECTOR","getNullInjector","EnvironmentInjector","R3Injector","_EnvironmentInjector","scopes","Map","forEachSingleProvider","processProvider","records","set","makeRecord","record","injectorDefTypes","_destroyed","isNotFound$1","assertNotDestroyed","prevConsumer","setActiveConsumer","_step3","_iterator3","_ngOnDestroyHooks","ngOnDestroy","onDestroyHooks","_onDestroyHooks","_step4","_iterator4","hook","clear","removeOnDestroy","previousInjector","previousInjectImplementation","couldBeInjectableType","ngMetadataName","injectableDefInScope","injectableDefOrInjectorDefFactory","hydrate","errorCode","getRuntimeErrorCode","_step5","initializers","_iterator5","initializer","_step6","tokens","_iterator6","keys","providerToRecord","providerToFactory","multiRecord","hasOnDestroy","destroyCBIdx","getUndecoratedInjectableFactory","inheritedInjectableDef","getInheritedInjectableDef","_type$NG_PROV_DEF","ngModuleType","unwrappedProvider","isFactoryProvider","isExistingProvider","useExisting","_","classRef","hasDeps","_construct","destroyed","_step7","_iterator7","runInInjectionContext","internalInjector","prevInjector","isInInjectionContext","assertInInjectionContext","debugFn","HOST","TVIEW","FLAGS","PARENT","NEXT","T_HOST","HYDRATION","CLEANUP","CONTEXT","INJECTOR","ENVIRONMENT","RENDERER","CHILD_HEAD","CHILD_TAIL","DECLARATION_VIEW","DECLARATION_COMPONENT_VIEW","DECLARATION_LCONTAINER","PREORDER_HOOK_FLAGS","QUERIES","ID","EMBEDDED_VIEW_INJECTOR","ON_DESTROY_HOOKS","EFFECTS_TO_SCHEDULE","EFFECTS","REACTIVE_TEMPLATE_CONSUMER","AFTER_RENDER_SEQUENCES_TO_ADD","ANIMATIONS","HEADER_OFFSET","TYPE","DEHYDRATED_VIEWS","NATIVE","VIEW_REFS","MOVED_VIEWS","CONTAINER_HEADER_OFFSET","isLView","isLContainer","isContentQueryHost","tNode","isComponentHost","componentOffset","isDirectiveHost","isComponentDef","template","isRootView","isDestroyed","lView","assertTNodeForLView","assertTNodeForTView","assertTNodeCreationIndex","adjustedIndex","bindingStartIndex","tView","assertTNode","tData","data","assertTIcu","tIcu","currentCaseLViewIndex","assertComponentType","assertNgModuleType","assertHasParent","assertLContainer","assertLView","assertFirstCreatePass","errMessage","firstCreatePass","assertFirstUpdatePass","firstUpdatePass","assertDirectiveDef","obj","selectors","inputs","assertIndexInDeclRange","assertBetween","assertIndexInExpandoRange","expandoStartIndex","lower","upper","assertProjectionSlots","projection","assertParentView","assertNodeInjector","injectorIndex","SVG_NAMESPACE","MATH_ML_NAMESPACE","unwrapRNode","unwrapLView","getNativeByIndex","getNativeByTNode","getTNode","load","view","store","blueprint","getComponentLViewByIndex","nodeIndex","hostView","slotValue","isCreationMode","viewAttachedToChangeDetector","viewAttachedToContainer","getConstant","consts","resetPreOrderHookFlags","markViewForRefresh","markAncestorsForTraversal","walkUpViews","nestingLevel","currentView","requiresRefreshOrTraversal","_lView$REACTIVE_TEMPL","dirty","updateAncestorTraversalFlagsOnAttach","_lView$ENVIRONMENT$ch","changeDetectionScheduler","notify","_lView$ENVIRONMENT$ch2","getLViewParent","storeLViewOnDestroy","onDestroyCallback","removeLViewOnDestroy","getOrCreateLViewCleanup","_view$CLEANUP","getOrCreateTViewCleanup","_tView$cleanup","cleanup","storeCleanupWithContext","cleanupFn","lCleanup","instructionState","lFrame","createLFrame","bindingsEnabled","skipHydrationRootTNode","CheckNoChangesMode","Off","Exhaustive","OnlyDirtyViews","_checkNoChangesMode","_isRefreshingViews","getElementDepthCount","elementDepthCount","increaseElementDepthCount","decreaseElementDepthCount","getBindingsEnabled","isInSkipHydrationBlock","isSkipHydrationRootTNode","enableBindings","enterSkipHydrationBlock","disableBindings","leaveSkipHydrationBlock","getLView","getTView","restoreView","viewToRestore","contextLView","resetView","getCurrentTNode","currentTNode","getCurrentTNodePlaceholderOk","getCurrentParentTNode","isParent","setCurrentTNode","isCurrentTNodeParent","setCurrentTNodeAsNotParent","getContextLView","isInCheckNoChangesMode","isExhaustiveCheckNoChanges","setIsInCheckNoChangesMode","mode","isRefreshingViews","setIsRefreshingViews","getBindingRoot","bindingRootIndex","getBindingIndex","bindingIndex","setBindingIndex","nextBindingIndex","incrementBindingIndex","isInI18nBlock","inI18n","setInI18nBlock","setBindingRootForHostBindings","currentDirectiveIndex","setCurrentDirectiveIndex","getCurrentDirectiveIndex","getCurrentDirectiveDef","getCurrentQueryIndex","currentQueryIndex","setCurrentQueryIndex","getDeclarationTNode","declTNode","enterDI","parentTNode","parentLView","allocLFrame","enterView","newView","newLFrame","firstChild","currentLFrame","childLFrame","child","selectedIndex","currentNamespace","leaveViewLight","oldLFrame","leaveDI","leaveView","nextContextImpl","level","getSelectedIndex","setSelectedIndex","getSelectedTNode","namespaceSVG","namespaceMathML","namespaceHTML","namespaceHTMLInternal","getNamespace","_wasLastNodeCreated","wasLastNodeCreated","lastNodeWasCreated","createInjector","createInjectorWithoutInjectorInstances","resolveInjectorInitializers","additionalProviders","Injector","_options$name","_Injector","DOCUMENT","DestroyRef","injectDestroyRef","NodeInjectorDestroyRef","_DestroyRef2","_lView","ErrorHandler","console","_console","INTERNAL_APPLICATION_ERROR_HANDLER","userErrorHandler","handleError","errorHandlerEnvironmentInitializer","isSignal","SIGNAL","signal","initialValue","_createSignal","createSignal","equal","_createSignal2","_slicedToArray","update","signalFn","asReadonly","signalAsReadonlyFn","readonlyFn","isWritableSignal","assertNotInReactiveContext","extraContext","ViewContext","injectViewContext","ChangeDetectionScheduler","ZONELESS_ENABLED","PROVIDED_ZONELESS","ZONELESS_SCHEDULER_DISABLED","SCHEDULE_IN_ROOT_ZONE","PendingTasksInternal","_PendingTasksInternal","pendingTask","hasPendingTasks","taskId","pendingTasks","delete","PendingTasks","_PendingTasks","internalPendingTasks","scheduler","removeTask","catch","errorHandler","finally","EffectScheduler","_EffectScheduler","ZoneAwareEffectScheduler","enqueue","schedule","dirtyEffectCount","queue","queues","zone","_this7","_step8","ranOneEffect","_iterator8","_loop2","_step8$value","flushQueue","run","_step9","_iterator9","activeConsumer","inNotificationPhase","epoch","postProducerCreatedFn","consumer","isInNotificationPhase","REACTIVE_NODE","version","lastCleanEpoch","producers","producersTail","consumers","consumersTail","recomputing","consumerAllowSignalWrites","consumerIsAlwaysLive","producerMustRecompute","producerRecomputeValue","consumerMarkedDirty","consumerOnSignalRead","producerAccessed","prevProducerLink","producer","nextProducerLink","isRecomputing","nextProducer","lastReadVersion","prevConsumerLink","isValidLink","checkLink","link","isLive","consumerIsLive","newLink","nextConsumer","producerAddLiveConsumer","producerUpdateValueVersion","consumerPollProducersForChange","producerMarkClean","producerNotifyConsumers","consumerMarkDirty","producerUpdatesAllowed","_activeConsumer","_node$consumerMarkedD","consumerBeforeComputation","resetConsumerBeforeComputation","consumerAfterComputation","finalizeConsumerAfterComputation","toRemove","producerRemoveLiveConsumerLink","seenVersion","consumerDestroy","wasLive","producerLink","runPostProducerCreatedFn","_postProducerCreatedF","defaultEquals","is","createComputed","computation","COMPUTED_NODE","computed","ERRORED","UNSET","COMPUTING","_objectSpread","oldValue","newValue","wasEqual","throwInvalidWriteToSignalErrorFn","defaultThrowError","throwInvalidWriteToSignalError","setThrowInvalidWriteToSignalError","postSignalSetFn","SIGNAL_NODE","getter","signalGetFn","signalSetFn","updateFn","signalUpdateFn","updater","signalValueChanged","_postSignalSetFn2","producerIncrementEpoch","_arrayLikeToArray","r","_arrayWithHoles","t","o","getPrototypeOf","A","_possibleConstructorReturn","esm_typeof","_assertThisInitialized","ReferenceError","isNativeReflectConstruct","Reflect","construct","_isNativeReflectConstruct_js__WEBPACK_IMPORTED_MODULE_0__","p","_setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__","_defineProperties","enumerable","configurable","writable","defineProperty","_toPropertyKey_js__WEBPACK_IMPORTED_MODULE_0__","iterator","_unsupportedIterableToArray_js__WEBPACK_IMPORTED_MODULE_0__","_n","F","u","return","_getPrototypeOf","setPrototypeOf","__proto__","_setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__","_isNativeReflectConstruct","Boolean","valueOf","_iterableToArray","_nonIterableRest","ownKeys","getOwnPropertySymbols","filter","getOwnPropertyDescriptor","_objectSpread2","_defineProperty_js__WEBPACK_IMPORTED_MODULE_0__","getOwnPropertyDescriptors","defineProperties","_regeneratorDefine","_invoke","_regenerator","toStringTag","Generator","c","y","G","v","d","l","GeneratorFunction","GeneratorFunctionPrototype","displayName","w","m","_setPrototypeOf","arrayWithHoles","_iterableToArrayLimit","unsupportedIterableToArray","nonIterableRest","_get","_superPropBase","_arrayWithoutHoles","arrayLikeToArray","iterableToArray","_nonIterableSpread","toPropertyKey","toPrimitive","_typeof","_unsupportedIterableToArray","_arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__","test","_isNativeFunction","Wrapper"],"ignoreList":[],"sourceRoot":"webpack:///","sources":["./node_modules/rxjs/dist/esm/internal/BehaviorSubject.js","./node_modules/rxjs/dist/esm/internal/Observable.js","./node_modules/rxjs/dist/esm/internal/util/ObjectUnsubscribedError.js","./node_modules/rxjs/dist/esm/internal/Subject.js","./node_modules/rxjs/dist/esm/internal/NotificationFactories.js","./node_modules/rxjs/dist/esm/internal/Subscriber.js","./node_modules/rxjs/dist/esm/internal/Subscription.js","./node_modules/rxjs/dist/esm/internal/util/UnsubscriptionError.js","./node_modules/rxjs/dist/esm/internal/config.js","./node_modules/rxjs/dist/esm/internal/operators/OperatorSubscriber.js","./node_modules/rxjs/dist/esm/internal/scheduler/timeoutProvider.js","./node_modules/rxjs/dist/esm/internal/symbol/observable.js","./node_modules/rxjs/dist/esm/internal/util/arrRemove.js","./node_modules/rxjs/dist/esm/internal/util/createErrorClass.js","./node_modules/rxjs/dist/esm/internal/util/errorContext.js","./node_modules/rxjs/dist/esm/internal/util/identity.js","./node_modules/rxjs/dist/esm/internal/util/isFunction.js","./node_modules/rxjs/dist/esm/internal/util/lift.js","./node_modules/rxjs/dist/esm/internal/util/noop.js","./node_modules/rxjs/dist/esm/internal/util/pipe.js","./node_modules/rxjs/dist/esm/internal/util/reportUnhandledError.js","./node_modules/@angular/core/fesm2022/not_found.mjs","./node_modules/@angular/core/fesm2022/root_effect_scheduler.mjs","./node_modules/@angular/core/fesm2022/signal.mjs","./node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","./node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","./node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/callSuper.js","./node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","./node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js","./node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/classCallCheck.js","./node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/construct.js","./node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/createClass.js","./node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js","./node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/defineProperty.js","./node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","./node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/inherits.js","./node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js","./node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/iterableToArray.js","./node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","./node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/objectSpread2.js","./node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/regeneratorDefine.js","./node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/regenerator.js","./node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js","./node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/slicedToArray.js","./node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","./node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/get.js","./node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/superPropBase.js","./node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/superPropGet.js","./node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","./node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","./node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","./node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/toPropertyKey.js","./node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/toPrimitive.js","./node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/typeof.js","./node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","./node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js","./node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/isNativeFunction.js"],"sourcesContent":["import { Subject } from './Subject';\nexport class BehaviorSubject extends Subject {\n    constructor(_value) {\n        super();\n        this._value = _value;\n    }\n    get value() {\n        return this.getValue();\n    }\n    _subscribe(subscriber) {\n        const subscription = super._subscribe(subscriber);\n        !subscription.closed && subscriber.next(this._value);\n        return subscription;\n    }\n    getValue() {\n        const { hasError, thrownError, _value } = this;\n        if (hasError) {\n            throw thrownError;\n        }\n        this._throwIfClosed();\n        return _value;\n    }\n    next(value) {\n        super.next((this._value = value));\n    }\n}\n","import { SafeSubscriber, Subscriber } from './Subscriber';\nimport { isSubscription } from './Subscription';\nimport { observable as Symbol_observable } from './symbol/observable';\nimport { pipeFromArray } from './util/pipe';\nimport { config } from './config';\nimport { isFunction } from './util/isFunction';\nimport { errorContext } from './util/errorContext';\nexport class Observable {\n    constructor(subscribe) {\n        if (subscribe) {\n            this._subscribe = subscribe;\n        }\n    }\n    lift(operator) {\n        const observable = new Observable();\n        observable.source = this;\n        observable.operator = operator;\n        return observable;\n    }\n    subscribe(observerOrNext, error, complete) {\n        const subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);\n        errorContext(() => {\n            const { operator, source } = this;\n            subscriber.add(operator\n                ?\n                    operator.call(subscriber, source)\n                : source\n                    ?\n                        this._subscribe(subscriber)\n                    :\n                        this._trySubscribe(subscriber));\n        });\n        return subscriber;\n    }\n    _trySubscribe(sink) {\n        try {\n            return this._subscribe(sink);\n        }\n        catch (err) {\n            sink.error(err);\n        }\n    }\n    forEach(next, promiseCtor) {\n        promiseCtor = getPromiseCtor(promiseCtor);\n        return new promiseCtor((resolve, reject) => {\n            const subscriber = new SafeSubscriber({\n                next: (value) => {\n                    try {\n                        next(value);\n                    }\n                    catch (err) {\n                        reject(err);\n                        subscriber.unsubscribe();\n                    }\n                },\n                error: reject,\n                complete: resolve,\n            });\n            this.subscribe(subscriber);\n        });\n    }\n    _subscribe(subscriber) {\n        var _a;\n        return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);\n    }\n    [Symbol_observable]() {\n        return this;\n    }\n    pipe(...operations) {\n        return pipeFromArray(operations)(this);\n    }\n    toPromise(promiseCtor) {\n        promiseCtor = getPromiseCtor(promiseCtor);\n        return new promiseCtor((resolve, reject) => {\n            let value;\n            this.subscribe((x) => (value = x), (err) => reject(err), () => resolve(value));\n        });\n    }\n}\nObservable.create = (subscribe) => {\n    return new Observable(subscribe);\n};\nfunction getPromiseCtor(promiseCtor) {\n    var _a;\n    return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;\n}\nfunction isObserver(value) {\n    return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);\n}\nfunction isSubscriber(value) {\n    return (value && value instanceof Subscriber) || (isObserver(value) && isSubscription(value));\n}\n","import { createErrorClass } from './createErrorClass';\nexport const ObjectUnsubscribedError = createErrorClass((_super) => function ObjectUnsubscribedErrorImpl() {\n    _super(this);\n    this.name = 'ObjectUnsubscribedError';\n    this.message = 'object unsubscribed';\n});\n","import { Observable } from './Observable';\nimport { Subscription, EMPTY_SUBSCRIPTION } from './Subscription';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { arrRemove } from './util/arrRemove';\nimport { errorContext } from './util/errorContext';\nexport class Subject extends Observable {\n    constructor() {\n        super();\n        this.closed = false;\n        this.currentObservers = null;\n        this.observers = [];\n        this.isStopped = false;\n        this.hasError = false;\n        this.thrownError = null;\n    }\n    lift(operator) {\n        const subject = new AnonymousSubject(this, this);\n        subject.operator = operator;\n        return subject;\n    }\n    _throwIfClosed() {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError();\n        }\n    }\n    next(value) {\n        errorContext(() => {\n            this._throwIfClosed();\n            if (!this.isStopped) {\n                if (!this.currentObservers) {\n                    this.currentObservers = Array.from(this.observers);\n                }\n                for (const observer of this.currentObservers) {\n                    observer.next(value);\n                }\n            }\n        });\n    }\n    error(err) {\n        errorContext(() => {\n            this._throwIfClosed();\n            if (!this.isStopped) {\n                this.hasError = this.isStopped = true;\n                this.thrownError = err;\n                const { observers } = this;\n                while (observers.length) {\n                    observers.shift().error(err);\n                }\n            }\n        });\n    }\n    complete() {\n        errorContext(() => {\n            this._throwIfClosed();\n            if (!this.isStopped) {\n                this.isStopped = true;\n                const { observers } = this;\n                while (observers.length) {\n                    observers.shift().complete();\n                }\n            }\n        });\n    }\n    unsubscribe() {\n        this.isStopped = this.closed = true;\n        this.observers = this.currentObservers = null;\n    }\n    get observed() {\n        var _a;\n        return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;\n    }\n    _trySubscribe(subscriber) {\n        this._throwIfClosed();\n        return super._trySubscribe(subscriber);\n    }\n    _subscribe(subscriber) {\n        this._throwIfClosed();\n        this._checkFinalizedStatuses(subscriber);\n        return this._innerSubscribe(subscriber);\n    }\n    _innerSubscribe(subscriber) {\n        const { hasError, isStopped, observers } = this;\n        if (hasError || isStopped) {\n            return EMPTY_SUBSCRIPTION;\n        }\n        this.currentObservers = null;\n        observers.push(subscriber);\n        return new Subscription(() => {\n            this.currentObservers = null;\n            arrRemove(observers, subscriber);\n        });\n    }\n    _checkFinalizedStatuses(subscriber) {\n        const { hasError, thrownError, isStopped } = this;\n        if (hasError) {\n            subscriber.error(thrownError);\n        }\n        else if (isStopped) {\n            subscriber.complete();\n        }\n    }\n    asObservable() {\n        const observable = new Observable();\n        observable.source = this;\n        return observable;\n    }\n}\nSubject.create = (destination, source) => {\n    return new AnonymousSubject(destination, source);\n};\nexport class AnonymousSubject extends Subject {\n    constructor(destination, source) {\n        super();\n        this.destination = destination;\n        this.source = source;\n    }\n    next(value) {\n        var _a, _b;\n        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);\n    }\n    error(err) {\n        var _a, _b;\n        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);\n    }\n    complete() {\n        var _a, _b;\n        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n    _subscribe(subscriber) {\n        var _a, _b;\n        return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;\n    }\n}\n","export const COMPLETE_NOTIFICATION = (() => createNotification('C', undefined, undefined))();\nexport function errorNotification(error) {\n    return createNotification('E', undefined, error);\n}\nexport function nextNotification(value) {\n    return createNotification('N', value, undefined);\n}\nexport function createNotification(kind, value, error) {\n    return {\n        kind,\n        value,\n        error,\n    };\n}\n","import { isFunction } from './util/isFunction';\nimport { isSubscription, Subscription } from './Subscription';\nimport { config } from './config';\nimport { reportUnhandledError } from './util/reportUnhandledError';\nimport { noop } from './util/noop';\nimport { nextNotification, errorNotification, COMPLETE_NOTIFICATION } from './NotificationFactories';\nimport { timeoutProvider } from './scheduler/timeoutProvider';\nimport { captureError } from './util/errorContext';\nexport class Subscriber extends Subscription {\n    constructor(destination) {\n        super();\n        this.isStopped = false;\n        if (destination) {\n            this.destination = destination;\n            if (isSubscription(destination)) {\n                destination.add(this);\n            }\n        }\n        else {\n            this.destination = EMPTY_OBSERVER;\n        }\n    }\n    static create(next, error, complete) {\n        return new SafeSubscriber(next, error, complete);\n    }\n    next(value) {\n        if (this.isStopped) {\n            handleStoppedNotification(nextNotification(value), this);\n        }\n        else {\n            this._next(value);\n        }\n    }\n    error(err) {\n        if (this.isStopped) {\n            handleStoppedNotification(errorNotification(err), this);\n        }\n        else {\n            this.isStopped = true;\n            this._error(err);\n        }\n    }\n    complete() {\n        if (this.isStopped) {\n            handleStoppedNotification(COMPLETE_NOTIFICATION, this);\n        }\n        else {\n            this.isStopped = true;\n            this._complete();\n        }\n    }\n    unsubscribe() {\n        if (!this.closed) {\n            this.isStopped = true;\n            super.unsubscribe();\n            this.destination = null;\n        }\n    }\n    _next(value) {\n        this.destination.next(value);\n    }\n    _error(err) {\n        try {\n            this.destination.error(err);\n        }\n        finally {\n            this.unsubscribe();\n        }\n    }\n    _complete() {\n        try {\n            this.destination.complete();\n        }\n        finally {\n            this.unsubscribe();\n        }\n    }\n}\nconst _bind = Function.prototype.bind;\nfunction bind(fn, thisArg) {\n    return _bind.call(fn, thisArg);\n}\nclass ConsumerObserver {\n    constructor(partialObserver) {\n        this.partialObserver = partialObserver;\n    }\n    next(value) {\n        const { partialObserver } = this;\n        if (partialObserver.next) {\n            try {\n                partialObserver.next(value);\n            }\n            catch (error) {\n                handleUnhandledError(error);\n            }\n        }\n    }\n    error(err) {\n        const { partialObserver } = this;\n        if (partialObserver.error) {\n            try {\n                partialObserver.error(err);\n            }\n            catch (error) {\n                handleUnhandledError(error);\n            }\n        }\n        else {\n            handleUnhandledError(err);\n        }\n    }\n    complete() {\n        const { partialObserver } = this;\n        if (partialObserver.complete) {\n            try {\n                partialObserver.complete();\n            }\n            catch (error) {\n                handleUnhandledError(error);\n            }\n        }\n    }\n}\nexport class SafeSubscriber extends Subscriber {\n    constructor(observerOrNext, error, complete) {\n        super();\n        let partialObserver;\n        if (isFunction(observerOrNext) || !observerOrNext) {\n            partialObserver = {\n                next: (observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : undefined),\n                error: error !== null && error !== void 0 ? error : undefined,\n                complete: complete !== null && complete !== void 0 ? complete : undefined,\n            };\n        }\n        else {\n            let context;\n            if (this && config.useDeprecatedNextContext) {\n                context = Object.create(observerOrNext);\n                context.unsubscribe = () => this.unsubscribe();\n                partialObserver = {\n                    next: observerOrNext.next && bind(observerOrNext.next, context),\n                    error: observerOrNext.error && bind(observerOrNext.error, context),\n                    complete: observerOrNext.complete && bind(observerOrNext.complete, context),\n                };\n            }\n            else {\n                partialObserver = observerOrNext;\n            }\n        }\n        this.destination = new ConsumerObserver(partialObserver);\n    }\n}\nfunction handleUnhandledError(error) {\n    if (config.useDeprecatedSynchronousErrorHandling) {\n        captureError(error);\n    }\n    else {\n        reportUnhandledError(error);\n    }\n}\nfunction defaultErrorHandler(err) {\n    throw err;\n}\nfunction handleStoppedNotification(notification, subscriber) {\n    const { onStoppedNotification } = config;\n    onStoppedNotification && timeoutProvider.setTimeout(() => onStoppedNotification(notification, subscriber));\n}\nexport const EMPTY_OBSERVER = {\n    closed: true,\n    next: noop,\n    error: defaultErrorHandler,\n    complete: noop,\n};\n","import { isFunction } from './util/isFunction';\nimport { UnsubscriptionError } from './util/UnsubscriptionError';\nimport { arrRemove } from './util/arrRemove';\nexport class Subscription {\n    constructor(initialTeardown) {\n        this.initialTeardown = initialTeardown;\n        this.closed = false;\n        this._parentage = null;\n        this._finalizers = null;\n    }\n    unsubscribe() {\n        let errors;\n        if (!this.closed) {\n            this.closed = true;\n            const { _parentage } = this;\n            if (_parentage) {\n                this._parentage = null;\n                if (Array.isArray(_parentage)) {\n                    for (const parent of _parentage) {\n                        parent.remove(this);\n                    }\n                }\n                else {\n                    _parentage.remove(this);\n                }\n            }\n            const { initialTeardown: initialFinalizer } = this;\n            if (isFunction(initialFinalizer)) {\n                try {\n                    initialFinalizer();\n                }\n                catch (e) {\n                    errors = e instanceof UnsubscriptionError ? e.errors : [e];\n                }\n            }\n            const { _finalizers } = this;\n            if (_finalizers) {\n                this._finalizers = null;\n                for (const finalizer of _finalizers) {\n                    try {\n                        execFinalizer(finalizer);\n                    }\n                    catch (err) {\n                        errors = errors !== null && errors !== void 0 ? errors : [];\n                        if (err instanceof UnsubscriptionError) {\n                            errors = [...errors, ...err.errors];\n                        }\n                        else {\n                            errors.push(err);\n                        }\n                    }\n                }\n            }\n            if (errors) {\n                throw new UnsubscriptionError(errors);\n            }\n        }\n    }\n    add(teardown) {\n        var _a;\n        if (teardown && teardown !== this) {\n            if (this.closed) {\n                execFinalizer(teardown);\n            }\n            else {\n                if (teardown instanceof Subscription) {\n                    if (teardown.closed || teardown._hasParent(this)) {\n                        return;\n                    }\n                    teardown._addParent(this);\n                }\n                (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);\n            }\n        }\n    }\n    _hasParent(parent) {\n        const { _parentage } = this;\n        return _parentage === parent || (Array.isArray(_parentage) && _parentage.includes(parent));\n    }\n    _addParent(parent) {\n        const { _parentage } = this;\n        this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;\n    }\n    _removeParent(parent) {\n        const { _parentage } = this;\n        if (_parentage === parent) {\n            this._parentage = null;\n        }\n        else if (Array.isArray(_parentage)) {\n            arrRemove(_parentage, parent);\n        }\n    }\n    remove(teardown) {\n        const { _finalizers } = this;\n        _finalizers && arrRemove(_finalizers, teardown);\n        if (teardown instanceof Subscription) {\n            teardown._removeParent(this);\n        }\n    }\n}\nSubscription.EMPTY = (() => {\n    const empty = new Subscription();\n    empty.closed = true;\n    return empty;\n})();\nexport const EMPTY_SUBSCRIPTION = Subscription.EMPTY;\nexport function isSubscription(value) {\n    return (value instanceof Subscription ||\n        (value && 'closed' in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe)));\n}\nfunction execFinalizer(finalizer) {\n    if (isFunction(finalizer)) {\n        finalizer();\n    }\n    else {\n        finalizer.unsubscribe();\n    }\n}\n","import { createErrorClass } from './createErrorClass';\nexport const UnsubscriptionError = createErrorClass((_super) => function UnsubscriptionErrorImpl(errors) {\n    _super(this);\n    this.message = errors\n        ? `${errors.length} errors occurred during unsubscription:\n${errors.map((err, i) => `${i + 1}) ${err.toString()}`).join('\\n  ')}`\n        : '';\n    this.name = 'UnsubscriptionError';\n    this.errors = errors;\n});\n","export const config = {\n    onUnhandledError: null,\n    onStoppedNotification: null,\n    Promise: undefined,\n    useDeprecatedSynchronousErrorHandling: false,\n    useDeprecatedNextContext: false,\n};\n","import { Subscriber } from '../Subscriber';\nexport function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {\n    return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);\n}\nexport class OperatorSubscriber extends Subscriber {\n    constructor(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {\n        super(destination);\n        this.onFinalize = onFinalize;\n        this.shouldUnsubscribe = shouldUnsubscribe;\n        this._next = onNext\n            ? function (value) {\n                try {\n                    onNext(value);\n                }\n                catch (err) {\n                    destination.error(err);\n                }\n            }\n            : super._next;\n        this._error = onError\n            ? function (err) {\n                try {\n                    onError(err);\n                }\n                catch (err) {\n                    destination.error(err);\n                }\n                finally {\n                    this.unsubscribe();\n                }\n            }\n            : super._error;\n        this._complete = onComplete\n            ? function () {\n                try {\n                    onComplete();\n                }\n                catch (err) {\n                    destination.error(err);\n                }\n                finally {\n                    this.unsubscribe();\n                }\n            }\n            : super._complete;\n    }\n    unsubscribe() {\n        var _a;\n        if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {\n            const { closed } = this;\n            super.unsubscribe();\n            !closed && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));\n        }\n    }\n}\n","export const timeoutProvider = {\n    setTimeout(handler, timeout, ...args) {\n        const { delegate } = timeoutProvider;\n        if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {\n            return delegate.setTimeout(handler, timeout, ...args);\n        }\n        return setTimeout(handler, timeout, ...args);\n    },\n    clearTimeout(handle) {\n        const { delegate } = timeoutProvider;\n        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);\n    },\n    delegate: undefined,\n};\n","export const observable = (() => (typeof Symbol === 'function' && Symbol.observable) || '@@observable')();\n","export function arrRemove(arr, item) {\n    if (arr) {\n        const index = arr.indexOf(item);\n        0 <= index && arr.splice(index, 1);\n    }\n}\n","export function createErrorClass(createImpl) {\n    const _super = (instance) => {\n        Error.call(instance);\n        instance.stack = new Error().stack;\n    };\n    const ctorFunc = createImpl(_super);\n    ctorFunc.prototype = Object.create(Error.prototype);\n    ctorFunc.prototype.constructor = ctorFunc;\n    return ctorFunc;\n}\n","import { config } from '../config';\nlet context = null;\nexport function errorContext(cb) {\n    if (config.useDeprecatedSynchronousErrorHandling) {\n        const isRoot = !context;\n        if (isRoot) {\n            context = { errorThrown: false, error: null };\n        }\n        cb();\n        if (isRoot) {\n            const { errorThrown, error } = context;\n            context = null;\n            if (errorThrown) {\n                throw error;\n            }\n        }\n    }\n    else {\n        cb();\n    }\n}\nexport function captureError(err) {\n    if (config.useDeprecatedSynchronousErrorHandling && context) {\n        context.errorThrown = true;\n        context.error = err;\n    }\n}\n","export function identity(x) {\n    return x;\n}\n","export function isFunction(value) {\n    return typeof value === 'function';\n}\n","import { isFunction } from './isFunction';\nexport function hasLift(source) {\n    return isFunction(source === null || source === void 0 ? void 0 : source.lift);\n}\nexport function operate(init) {\n    return (source) => {\n        if (hasLift(source)) {\n            return source.lift(function (liftedSource) {\n                try {\n                    return init(liftedSource, this);\n                }\n                catch (err) {\n                    this.error(err);\n                }\n            });\n        }\n        throw new TypeError('Unable to lift unknown Observable type');\n    };\n}\n","export function noop() { }\n","import { identity } from './identity';\nexport function pipe(...fns) {\n    return pipeFromArray(fns);\n}\nexport function pipeFromArray(fns) {\n    if (fns.length === 0) {\n        return identity;\n    }\n    if (fns.length === 1) {\n        return fns[0];\n    }\n    return function piped(input) {\n        return fns.reduce((prev, fn) => fn(prev), input);\n    };\n}\n","import { config } from '../config';\nimport { timeoutProvider } from '../scheduler/timeoutProvider';\nexport function reportUnhandledError(err) {\n    timeoutProvider.setTimeout(() => {\n        const { onUnhandledError } = config;\n        if (onUnhandledError) {\n            onUnhandledError(err);\n        }\n        else {\n            throw err;\n        }\n    });\n}\n","/**\n * @license Angular v20.3.6\n * (c) 2010-2025 Google LLC. https://angular.dev/\n * License: MIT\n */\n\n/**\n * Current injector value used by `inject`.\n * - `undefined`: it is an error to call `inject`\n * - `null`: `inject` can be called but there is no injector (limp-mode).\n * - Injector instance: Use the injector for resolution.\n */\nlet _currentInjector = undefined;\nfunction getCurrentInjector() {\n    return _currentInjector;\n}\nfunction setCurrentInjector(injector) {\n    const former = _currentInjector;\n    _currentInjector = injector;\n    return former;\n}\nfunction inject(token, options) {\n    const currentInjector = getCurrentInjector();\n    if (!currentInjector) {\n        throw new Error('Current injector is not set.');\n    }\n    if (!token.prov) {\n        throw new Error('Token is not an injectable');\n    }\n    return currentInjector.retrieve(token, options);\n}\n\n/**\n * Value returned if the key-value pair couldn't be found in the context\n * hierarchy.\n */\nconst NOT_FOUND = Symbol('NotFound');\n/**\n * Error thrown when the key-value pair couldn't be found in the context\n * hierarchy. Context can be attached below.\n */\nclass NotFoundError extends Error {\n    name = 'NotFound';\n    constructor(message) {\n        super(message);\n    }\n}\n/**\n * Type guard for checking if an unknown value is a NotFound.\n */\nfunction isNotFound(e) {\n    return e === NOT_FOUND || e?.name === 'NotFound';\n}\n\nexport { NOT_FOUND, NotFoundError, getCurrentInjector, inject, isNotFound, setCurrentInjector };\n","/**\n * @license Angular v20.3.6\n * (c) 2010-2025 Google LLC. https://angular.dev/\n * License: MIT\n */\n\nimport { isNotFound, getCurrentInjector, setCurrentInjector } from './not_found.mjs';\nimport { getActiveConsumer, SIGNAL, createSignal } from './signal.mjs';\nimport { BehaviorSubject, Observable } from 'rxjs';\nimport { setActiveConsumer } from '@angular/core/primitives/signals';\nimport { isNotFound as isNotFound$1 } from '@angular/core/primitives/di';\n\n/**\n * @description Represents the version of Angular\n *\n * @publicApi\n */\nclass Version {\n    full;\n    major;\n    minor;\n    patch;\n    constructor(full) {\n        this.full = full;\n        const parts = full.split('.');\n        this.major = parts[0];\n        this.minor = parts[1];\n        this.patch = parts.slice(2).join('.');\n    }\n}\n/**\n * @publicApi\n */\nconst VERSION = /* @__PURE__ */ new Version('20.3.6');\n\n/**\n * Base URL for the error details page.\n *\n * Keep this constant in sync across:\n *  - packages/compiler-cli/src/ngtsc/diagnostics/src/error_details_base_url.ts\n *  - packages/core/src/error_details_base_url.ts\n */\nconst ERROR_DETAILS_PAGE_BASE_URL = (() => {\n    const versionSubDomain = VERSION.major !== '0' ? `v${VERSION.major}.` : '';\n    return `https://${versionSubDomain}angular.dev/errors`;\n})();\n/**\n * URL for the XSS security documentation.\n */\nconst XSS_SECURITY_URL = 'https://angular.dev/best-practices/security#preventing-cross-site-scripting-xss';\n\n/**\n * Class that represents a runtime error.\n * Formats and outputs the error message in a consistent way.\n *\n * Example:\n * ```ts\n *  throw new RuntimeError(\n *    RuntimeErrorCode.INJECTOR_ALREADY_DESTROYED,\n *    ngDevMode && 'Injector has already been destroyed.');\n * ```\n *\n * Note: the `message` argument contains a descriptive error message as a string in development\n * mode (when the `ngDevMode` is defined). In production mode (after tree-shaking pass), the\n * `message` argument becomes `false`, thus we account for it in the typings and the runtime\n * logic.\n */\nclass RuntimeError extends Error {\n    code;\n    constructor(code, message) {\n        super(formatRuntimeError(code, message));\n        this.code = code;\n    }\n}\nfunction formatRuntimeErrorCode(code) {\n    // Error code might be a negative number, which is a special marker that instructs the logic to\n    // generate a link to the error details page on angular.io.\n    // We also prepend `0` to non-compile-time errors.\n    return `NG0${Math.abs(code)}`;\n}\n/**\n * Called to format a runtime error.\n * See additional info on the `message` argument type in the `RuntimeError` class description.\n */\nfunction formatRuntimeError(code, message) {\n    const fullCode = formatRuntimeErrorCode(code);\n    let errorMessage = `${fullCode}${message ? ': ' + message : ''}`;\n    if (ngDevMode && code < 0) {\n        const addPeriodSeparator = !errorMessage.match(/[.,;!?\\n]$/);\n        const separator = addPeriodSeparator ? '.' : '';\n        errorMessage = `${errorMessage}${separator} Find more at ${ERROR_DETAILS_PAGE_BASE_URL}/${fullCode}`;\n    }\n    return errorMessage;\n}\n\nconst _global = globalThis;\n\nfunction ngDevModeResetPerfCounters() {\n    const locationString = typeof location !== 'undefined' ? location.toString() : '';\n    const newCounters = {\n        hydratedNodes: 0,\n        hydratedComponents: 0,\n        dehydratedViewsRemoved: 0,\n        dehydratedViewsCleanupRuns: 0,\n        componentsSkippedHydration: 0,\n        deferBlocksWithIncrementalHydration: 0,\n    };\n    // Make sure to refer to ngDevMode as ['ngDevMode'] for closure.\n    const allowNgDevModeTrue = locationString.indexOf('ngDevMode=false') === -1;\n    if (!allowNgDevModeTrue) {\n        _global['ngDevMode'] = false;\n    }\n    else {\n        if (typeof _global['ngDevMode'] !== 'object') {\n            _global['ngDevMode'] = {};\n        }\n        Object.assign(_global['ngDevMode'], newCounters);\n    }\n    return newCounters;\n}\n/**\n * This function checks to see if the `ngDevMode` has been set. If yes,\n * then we honor it, otherwise we default to dev mode with additional checks.\n *\n * The idea is that unless we are doing production build where we explicitly\n * set `ngDevMode == false` we should be helping the developer by providing\n * as much early warning and errors as possible.\n *\n * `defineComponent` is guaranteed to have been called before any component template functions\n * (and thus Ivy instructions), so a single initialization there is sufficient to ensure ngDevMode\n * is defined for the entire instruction set.\n *\n * When checking `ngDevMode` on toplevel, always init it before referencing it\n * (e.g. `((typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode())`), otherwise you can\n *  get a `ReferenceError` like in https://github.com/angular/angular/issues/31595.\n *\n * Details on possible values for `ngDevMode` can be found on its docstring.\n */\nfunction initNgDevMode() {\n    // The below checks are to ensure that calling `initNgDevMode` multiple times does not\n    // reset the counters.\n    // If the `ngDevMode` is not an object, then it means we have not created the perf counters\n    // yet.\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        if (typeof ngDevMode !== 'object' || Object.keys(ngDevMode).length === 0) {\n            ngDevModeResetPerfCounters();\n        }\n        return typeof ngDevMode !== 'undefined' && !!ngDevMode;\n    }\n    return false;\n}\n\nfunction getClosureSafeProperty(objWithPropertyToExtract) {\n    for (let key in objWithPropertyToExtract) {\n        if (objWithPropertyToExtract[key] === getClosureSafeProperty) {\n            return key;\n        }\n    }\n    // Cannot change it to `RuntimeError` because the `util` target cannot\n    // circularly depend on the `core` target.\n    throw Error(typeof ngDevMode !== 'undefined' && ngDevMode\n        ? 'Could not find renamed property on target object.'\n        : '');\n}\n/**\n * Sets properties on a target object from a source object, but only if\n * the property doesn't already exist on the target object.\n * @param target The target to set properties on\n * @param source The source of the property keys and values to set\n */\nfunction fillProperties(target, source) {\n    for (const key in source) {\n        if (source.hasOwnProperty(key) && !target.hasOwnProperty(key)) {\n            target[key] = source[key];\n        }\n    }\n}\n\nfunction stringify(token) {\n    if (typeof token === 'string') {\n        return token;\n    }\n    if (Array.isArray(token)) {\n        return `[${token.map(stringify).join(', ')}]`;\n    }\n    if (token == null) {\n        return '' + token;\n    }\n    const name = token.overriddenName || token.name;\n    if (name) {\n        return `${name}`;\n    }\n    const result = token.toString();\n    if (result == null) {\n        return '' + result;\n    }\n    const newLineIndex = result.indexOf('\\n');\n    return newLineIndex >= 0 ? result.slice(0, newLineIndex) : result;\n}\n/**\n * Concatenates two strings with separator, allocating new strings only when necessary.\n *\n * @param before before string.\n * @param separator separator string.\n * @param after after string.\n * @returns concatenated string.\n */\nfunction concatStringsWithSpace(before, after) {\n    if (!before)\n        return after || '';\n    if (!after)\n        return before;\n    return `${before} ${after}`;\n}\n/**\n * Ellipses the string in the middle when longer than the max length\n *\n * @param string\n * @param maxLength of the output string\n * @returns ellipsed string with ... in the middle\n */\nfunction truncateMiddle(str, maxLength = 100) {\n    if (!str || maxLength < 1 || str.length <= maxLength)\n        return str;\n    if (maxLength == 1)\n        return str.substring(0, 1) + '...';\n    const halfLimit = Math.round(maxLength / 2);\n    return str.substring(0, halfLimit) + '...' + str.substring(str.length - halfLimit);\n}\n\nconst __forward_ref__ = getClosureSafeProperty({ __forward_ref__: getClosureSafeProperty });\n/**\n * Allows to refer to references which are not yet defined.\n *\n * For instance, `forwardRef` is used when the `token` which we need to refer to for the purposes of\n * DI is declared, but not yet defined. It is also used when the `token` which we use when creating\n * a query is not yet defined.\n *\n * `forwardRef` is also used to break circularities in standalone components imports.\n *\n * @usageNotes\n * ### Circular dependency example\n * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='forward_ref'}\n *\n * ### Circular standalone reference import example\n * ```angular-ts\n * @Component({\n *   imports: [ChildComponent],\n *   selector: 'app-parent',\n *   template: `<app-child [hideParent]=\"hideParent()\"></app-child>`,\n * })\n * export class ParentComponent {\n *    hideParent = input.required<boolean>();\n * }\n *\n *\n * @Component({\n *   imports: [forwardRef(() => ParentComponent)],\n *   selector: 'app-child',\n *   template: `\n *    @if(!hideParent() {\n *       <app-parent/>\n *    }\n *  `,\n * })\n * export class ChildComponent {\n *    hideParent = input.required<boolean>();\n * }\n * ```\n *\n * @publicApi\n */\nfunction forwardRef(forwardRefFn) {\n    forwardRefFn.__forward_ref__ = forwardRef;\n    forwardRefFn.toString = function () {\n        return stringify(this());\n    };\n    return forwardRefFn;\n}\n/**\n * Lazily retrieves the reference value from a forwardRef.\n *\n * Acts as the identity function when given a non-forward-ref value.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='resolve_forward_ref'}\n *\n * @see {@link forwardRef}\n * @publicApi\n */\nfunction resolveForwardRef(type) {\n    return isForwardRef(type) ? type() : type;\n}\n/** Checks whether a function is wrapped by a `forwardRef`. */\nfunction isForwardRef(fn) {\n    return (typeof fn === 'function' &&\n        fn.hasOwnProperty(__forward_ref__) &&\n        fn.__forward_ref__ === forwardRef);\n}\n\n// The functions in this file verify that the assumptions we are making\n// about state in an instruction are correct before implementing any logic.\n// They are meant only to be called in dev mode as sanity checks.\nfunction assertNumber(actual, msg) {\n    if (!(typeof actual === 'number')) {\n        throwError(msg, typeof actual, 'number', '===');\n    }\n}\nfunction assertNumberInRange(actual, minInclusive, maxInclusive) {\n    assertNumber(actual, 'Expected a number');\n    assertLessThanOrEqual(actual, maxInclusive, 'Expected number to be less than or equal to');\n    assertGreaterThanOrEqual(actual, minInclusive, 'Expected number to be greater than or equal to');\n}\nfunction assertString(actual, msg) {\n    if (!(typeof actual === 'string')) {\n        throwError(msg, actual === null ? 'null' : typeof actual, 'string', '===');\n    }\n}\nfunction assertFunction(actual, msg) {\n    if (!(typeof actual === 'function')) {\n        throwError(msg, actual === null ? 'null' : typeof actual, 'function', '===');\n    }\n}\nfunction assertEqual(actual, expected, msg) {\n    if (!(actual == expected)) {\n        throwError(msg, actual, expected, '==');\n    }\n}\nfunction assertNotEqual(actual, expected, msg) {\n    if (!(actual != expected)) {\n        throwError(msg, actual, expected, '!=');\n    }\n}\nfunction assertSame(actual, expected, msg) {\n    if (!(actual === expected)) {\n        throwError(msg, actual, expected, '===');\n    }\n}\nfunction assertNotSame(actual, expected, msg) {\n    if (!(actual !== expected)) {\n        throwError(msg, actual, expected, '!==');\n    }\n}\nfunction assertLessThan(actual, expected, msg) {\n    if (!(actual < expected)) {\n        throwError(msg, actual, expected, '<');\n    }\n}\nfunction assertLessThanOrEqual(actual, expected, msg) {\n    if (!(actual <= expected)) {\n        throwError(msg, actual, expected, '<=');\n    }\n}\nfunction assertGreaterThan(actual, expected, msg) {\n    if (!(actual > expected)) {\n        throwError(msg, actual, expected, '>');\n    }\n}\nfunction assertGreaterThanOrEqual(actual, expected, msg) {\n    if (!(actual >= expected)) {\n        throwError(msg, actual, expected, '>=');\n    }\n}\nfunction assertNotDefined(actual, msg) {\n    if (actual != null) {\n        throwError(msg, actual, null, '==');\n    }\n}\nfunction assertDefined(actual, msg) {\n    if (actual == null) {\n        throwError(msg, actual, null, '!=');\n    }\n}\nfunction throwError(msg, actual, expected, comparison) {\n    throw new Error(`ASSERTION ERROR: ${msg}` +\n        (comparison == null ? '' : ` [Expected=> ${expected} ${comparison} ${actual} <=Actual]`));\n}\nfunction assertDomNode(node) {\n    if (!(node instanceof Node)) {\n        throwError(`The provided value must be an instance of a DOM Node but got ${stringify(node)}`);\n    }\n}\nfunction assertElement(node) {\n    if (!(node instanceof Element)) {\n        throwError(`The provided value must be an element but got ${stringify(node)}`);\n    }\n}\nfunction assertIndexInRange(arr, index) {\n    assertDefined(arr, 'Array must be defined.');\n    const maxLen = arr.length;\n    if (index < 0 || index >= maxLen) {\n        throwError(`Index expected to be less than ${maxLen} but got ${index}`);\n    }\n}\nfunction assertOneOf(value, ...validValues) {\n    if (validValues.indexOf(value) !== -1)\n        return true;\n    throwError(`Expected value to be one of ${JSON.stringify(validValues)} but was ${JSON.stringify(value)}.`);\n}\nfunction assertNotReactive(fn) {\n    if (getActiveConsumer() !== null) {\n        throwError(`${fn}() should never be called in a reactive context.`);\n    }\n}\n\n/**\n * Construct an injectable definition which defines how a token will be constructed by the DI\n * system, and in which injectors (if any) it will be available.\n *\n * This should be assigned to a static `prov` field on a type, which will then be an\n * `InjectableType`.\n *\n * Options:\n * * `providedIn` determines which injectors will include the injectable, by either associating it\n *   with an `@NgModule` or other `InjectorType`, or by specifying that this injectable should be\n *   provided in the `'root'` injector, which will be the application-level injector in most apps.\n * * `factory` gives the zero argument function which will create an instance of the injectable.\n *   The factory can call [`inject`](api/core/inject) to access the `Injector` and request injection\n * of dependencies.\n *\n * @codeGenApi\n * @publicApi This instruction has been emitted by ViewEngine for some time and is deployed to npm.\n */\nfunction defineInjectable(opts) {\n    return {\n        token: opts.token,\n        providedIn: opts.providedIn || null,\n        factory: opts.factory,\n        value: undefined,\n    };\n}\n/**\n * @deprecated in v8, delete after v10. This API should be used only by generated code, and that\n * code should now use defineInjectable instead.\n * @publicApi\n */\nconst defineInjectable = defineInjectable;\n/**\n * Construct an `InjectorDef` which configures an injector.\n *\n * This should be assigned to a static injector def (`inj`) field on a type, which will then be an\n * `InjectorType`.\n *\n * Options:\n *\n * * `providers`: an optional array of providers to add to the injector. Each provider must\n *   either have a factory or point to a type which has a `prov` static property (the\n *   type must be an `InjectableType`).\n * * `imports`: an optional array of imports of other `InjectorType`s or `InjectorTypeWithModule`s\n *   whose providers will also be added to the injector. Locally provided types will override\n *   providers from imports.\n *\n * @codeGenApi\n */\nfunction defineInjector(options) {\n    return { providers: options.providers || [], imports: options.imports || [] };\n}\n/**\n * Read the injectable def (`prov`) for `type` in a way which is immune to accidentally reading\n * inherited value.\n *\n * @param type A type which may have its own (non-inherited) `prov`.\n */\nfunction getInjectableDef(type) {\n    return getOwnDefinition(type, NG_PROV_DEF);\n}\nfunction isInjectable(type) {\n    return getInjectableDef(type) !== null;\n}\n/**\n * Return definition only if it is defined directly on `type` and is not inherited from a base\n * class of `type`.\n */\nfunction getOwnDefinition(type, field) {\n    // if the prov prop exist but is undefined we still want to return null\n    return (type.hasOwnProperty(field) && type[field]) || null;\n}\n/**\n * Read the injectable def (`prov`) for `type` or read the `prov` from one of its ancestors.\n *\n * @param type A type which may have `prov`, via inheritance.\n *\n * @deprecated Will be removed in a future version of Angular, where an error will occur in the\n *     scenario if we find the `prov` on an ancestor only.\n */\nfunction getInheritedInjectableDef(type) {\n    // if the prov prop exist but is undefined we still want to return null\n    const def = type?.[NG_PROV_DEF] ?? null;\n    if (def) {\n        ngDevMode &&\n            console.warn(`DEPRECATED: DI is instantiating a token \"${type.name}\" that inherits its @Injectable decorator but does not provide one itself.\\n` +\n                `This will become an error in a future version of Angular. Please add @Injectable() to the \"${type.name}\" class.`);\n        return def;\n    }\n    else {\n        return null;\n    }\n}\n/**\n * Read the injector def type in a way which is immune to accidentally reading inherited value.\n *\n * @param type type which may have an injector def (`inj`)\n */\nfunction getInjectorDef(type) {\n    return type && type.hasOwnProperty(NG_INJ_DEF) ? type[NG_INJ_DEF] : null;\n}\nconst NG_PROV_DEF = getClosureSafeProperty({ prov: getClosureSafeProperty });\nconst NG_INJ_DEF = getClosureSafeProperty({ inj: getClosureSafeProperty });\n\n/**\n * Creates a token that can be used in a DI Provider.\n *\n * Use an `InjectionToken` whenever the type you are injecting is not reified (does not have a\n * runtime representation) such as when injecting an interface, callable type, array or\n * parameterized type.\n *\n * `InjectionToken` is parameterized on `T` which is the type of object which will be returned by\n * the `Injector`. This provides an additional level of type safety.\n *\n * <div class=\"docs-alert docs-alert-helpful\">\n *\n * **Important Note**: Ensure that you use the same instance of the `InjectionToken` in both the\n * provider and the injection call. Creating a new instance of `InjectionToken` in different places,\n * even with the same description, will be treated as different tokens by Angular's DI system,\n * leading to a `NullInjectorError`.\n *\n * </div>\n *\n * {@example injection-token/src/main.ts region='InjectionToken'}\n *\n * When creating an `InjectionToken`, you can optionally specify a factory function which returns\n * (possibly by creating) a default value of the parameterized type `T`. This sets up the\n * `InjectionToken` using this factory as a provider as if it was defined explicitly in the\n * application's root injector. If the factory function, which takes zero arguments, needs to inject\n * dependencies, it can do so using the [`inject`](api/core/inject) function.\n * As you can see in the Tree-shakable InjectionToken example below.\n *\n * Additionally, if a `factory` is specified you can also specify the `providedIn` option, which\n * overrides the above behavior and marks the token as belonging to a particular `@NgModule` (note:\n * this option is now deprecated). As mentioned above, `'root'` is the default value for\n * `providedIn`.\n *\n * The `providedIn: NgModule` and `providedIn: 'any'` options are deprecated.\n *\n * @usageNotes\n * ### Basic Examples\n *\n * ### Plain InjectionToken\n *\n * {@example core/di/ts/injector_spec.ts region='InjectionToken'}\n *\n * ### Tree-shakable InjectionToken\n *\n * {@example core/di/ts/injector_spec.ts region='ShakableInjectionToken'}\n *\n * @publicApi\n */\nclass InjectionToken {\n    _desc;\n    /** @internal */\n    ngMetadataName = 'InjectionToken';\n    prov;\n    /**\n     * @param _desc   Description for the token,\n     *                used only for debugging purposes,\n     *                it should but does not need to be unique\n     * @param options Options for the token's usage, as described above\n     */\n    constructor(_desc, options) {\n        this._desc = _desc;\n        this.prov = undefined;\n        if (typeof options == 'number') {\n            (typeof ngDevMode === 'undefined' || ngDevMode) &&\n                assertLessThan(options, 0, 'Only negative numbers are supported here');\n            // This is a special hack to assign __NG_ELEMENT_ID__ to this instance.\n            // See `InjectorMarkers`\n            this.__NG_ELEMENT_ID__ = options;\n        }\n        else if (options !== undefined) {\n            this.prov = defineInjectable({\n                token: this,\n                providedIn: options.providedIn || 'root',\n                factory: options.factory,\n            });\n        }\n    }\n    /**\n     * @internal\n     */\n    get multi() {\n        return this;\n    }\n    toString() {\n        return `InjectionToken ${this._desc}`;\n    }\n}\n\nlet _injectorProfilerContext;\nfunction getInjectorProfilerContext() {\n    !ngDevMode && throwError('getInjectorProfilerContext should never be called in production mode');\n    return _injectorProfilerContext;\n}\nfunction setInjectorProfilerContext(context) {\n    !ngDevMode && throwError('setInjectorProfilerContext should never be called in production mode');\n    const previous = _injectorProfilerContext;\n    _injectorProfilerContext = context;\n    return previous;\n}\nconst injectorProfilerCallbacks = [];\nconst NOOP_PROFILER_REMOVAL = () => { };\nfunction removeProfiler(profiler) {\n    const profilerIdx = injectorProfilerCallbacks.indexOf(profiler);\n    if (profilerIdx !== -1) {\n        injectorProfilerCallbacks.splice(profilerIdx, 1);\n    }\n}\n/**\n * Adds a callback function which will be invoked during certain DI events within the\n * runtime (for example: injecting services, creating injectable instances, configuring providers).\n * Multiple profiler callbacks can be set: in this case profiling events are\n * reported to every registered callback.\n *\n * Warning: this function is *INTERNAL* and should not be relied upon in application's code.\n * The contract of the function might be changed in any release and/or the function can be removed\n * completely.\n *\n * @param profiler function provided by the caller or null value to disable profiling.\n * @returns a cleanup function that, when invoked, removes a given profiler callback.\n */\nfunction setInjectorProfiler(injectorProfiler) {\n    !ngDevMode && throwError('setInjectorProfiler should never be called in production mode');\n    if (injectorProfiler !== null) {\n        if (!injectorProfilerCallbacks.includes(injectorProfiler)) {\n            injectorProfilerCallbacks.push(injectorProfiler);\n        }\n        return () => removeProfiler(injectorProfiler);\n    }\n    else {\n        injectorProfilerCallbacks.length = 0;\n        return NOOP_PROFILER_REMOVAL;\n    }\n}\n/**\n * Injector profiler function which emits on DI events executed by the runtime.\n *\n * @param event InjectorProfilerEvent corresponding to the DI event being emitted\n */\nfunction injectorProfiler(event) {\n    !ngDevMode && throwError('Injector profiler should never be called in production mode');\n    for (let i = 0; i < injectorProfilerCallbacks.length; i++) {\n        const injectorProfilerCallback = injectorProfilerCallbacks[i];\n        injectorProfilerCallback(event);\n    }\n}\n/**\n * Emits an InjectorProfilerEventType.ProviderConfigured to the injector profiler. The data in the\n * emitted event includes the raw provider, as well as the token that provider is providing.\n *\n * @param eventProvider A provider object\n */\nfunction emitProviderConfiguredEvent(eventProvider, isViewProvider = false) {\n    !ngDevMode && throwError('Injector profiler should never be called in production mode');\n    let token;\n    // if the provider is a TypeProvider (typeof provider is function) then the token is the\n    // provider itself\n    if (typeof eventProvider === 'function') {\n        token = eventProvider;\n    }\n    // if the provider is an injection token, then the token is the injection token.\n    else if (eventProvider instanceof InjectionToken) {\n        token = eventProvider;\n    }\n    // in all other cases we can access the token via the `provide` property of the provider\n    else {\n        token = resolveForwardRef(eventProvider.provide);\n    }\n    let provider = eventProvider;\n    // Injection tokens may define their own default provider which gets attached to the token itself\n    // as `prov`. In this case, we want to emit the provider that is attached to the token, not the\n    // token itself.\n    if (eventProvider instanceof InjectionToken) {\n        provider = eventProvider.prov || eventProvider;\n    }\n    injectorProfiler({\n        type: 2 /* InjectorProfilerEventType.ProviderConfigured */,\n        context: getInjectorProfilerContext(),\n        providerRecord: { token, provider, isViewProvider },\n    });\n}\n/**\n * Emits an event to the injector profiler when an instance corresponding to a given token is about to be created be an injector. Note that\n * the injector associated with this emission can be accessed by using getDebugInjectContext()\n *\n * @param instance an object created by an injector\n */\nfunction emitInjectorToCreateInstanceEvent(token) {\n    !ngDevMode && throwError('Injector profiler should never be called in production mode');\n    injectorProfiler({\n        type: 4 /* InjectorProfilerEventType.InjectorToCreateInstanceEvent */,\n        context: getInjectorProfilerContext(),\n        token: token,\n    });\n}\n/**\n * Emits an event to the injector profiler with the instance that was created. Note that\n * the injector associated with this emission can be accessed by using getDebugInjectContext()\n *\n * @param instance an object created by an injector\n */\nfunction emitInstanceCreatedByInjectorEvent(instance) {\n    !ngDevMode && throwError('Injector profiler should never be called in production mode');\n    injectorProfiler({\n        type: 1 /* InjectorProfilerEventType.InstanceCreatedByInjector */,\n        context: getInjectorProfilerContext(),\n        instance: { value: instance },\n    });\n}\n/**\n * @param token DI token associated with injected service\n * @param value the instance of the injected service (i.e the result of `inject(token)`)\n * @param flags the flags that the token was injected with\n */\nfunction emitInjectEvent(token, value, flags) {\n    !ngDevMode && throwError('Injector profiler should never be called in production mode');\n    injectorProfiler({\n        type: 0 /* InjectorProfilerEventType.Inject */,\n        context: getInjectorProfilerContext(),\n        service: { token, value, flags },\n    });\n}\nfunction emitEffectCreatedEvent(effect) {\n    !ngDevMode && throwError('Injector profiler should never be called in production mode');\n    injectorProfiler({\n        type: 3 /* InjectorProfilerEventType.EffectCreated */,\n        context: getInjectorProfilerContext(),\n        effect,\n    });\n}\nfunction runInInjectorProfilerContext(injector, token, callback) {\n    !ngDevMode &&\n        throwError('runInInjectorProfilerContext should never be called in production mode');\n    const prevInjectContext = setInjectorProfilerContext({ injector, token });\n    try {\n        callback();\n    }\n    finally {\n        setInjectorProfilerContext(prevInjectContext);\n    }\n}\n\nfunction isEnvironmentProviders(value) {\n    return value && !!value.providers;\n}\n\nconst NG_COMP_DEF = getClosureSafeProperty({ cmp: getClosureSafeProperty });\nconst NG_DIR_DEF = getClosureSafeProperty({ dir: getClosureSafeProperty });\nconst NG_PIPE_DEF = getClosureSafeProperty({ pipe: getClosureSafeProperty });\nconst NG_MOD_DEF = getClosureSafeProperty({ mod: getClosureSafeProperty });\nconst NG_FACTORY_DEF = getClosureSafeProperty({ fac: getClosureSafeProperty });\n/**\n * If a directive is diPublic, bloomAdd sets a property on the type with this constant as\n * the key and the directive's unique ID as the value. This allows us to map directives to their\n * bloom filter bit for DI.\n */\n// TODO(misko): This is wrong. The NG_ELEMENT_ID should never be minified.\nconst NG_ELEMENT_ID = getClosureSafeProperty({\n    __NG_ELEMENT_ID__: getClosureSafeProperty,\n});\n/**\n * The `NG_ENV_ID` field on a DI token indicates special processing in the `EnvironmentInjector`:\n * getting such tokens from the `EnvironmentInjector` will bypass the standard DI resolution\n * strategy and instead will return implementation produced by the `NG_ENV_ID` factory function.\n *\n * This particular retrieval of DI tokens is mostly done to eliminate circular dependencies and\n * improve tree-shaking.\n */\nconst NG_ENV_ID = getClosureSafeProperty({ __NG_ENV_ID__: getClosureSafeProperty });\n\n/**\n * Used for stringify render output in Ivy.\n * Important! This function is very performance-sensitive and we should\n * be extra careful not to introduce megamorphic reads in it.\n * Check `core/test/render3/perf/render_stringify` for benchmarks and alternate implementations.\n */\nfunction renderStringify(value) {\n    if (typeof value === 'string')\n        return value;\n    if (value == null)\n        return '';\n    // Use `String` so that it invokes the `toString` method of the value. Note that this\n    // appears to be faster than calling `value.toString` (see `render_stringify` benchmark).\n    return String(value);\n}\n/**\n * Used to stringify a value so that it can be displayed in an error message.\n *\n * Important! This function contains a megamorphic read and should only be\n * used for error messages.\n */\nfunction stringifyForError(value) {\n    if (typeof value === 'function')\n        return value.name || value.toString();\n    if (typeof value === 'object' && value != null && typeof value.type === 'function') {\n        return value.type.name || value.type.toString();\n    }\n    return renderStringify(value);\n}\n/**\n * Used to stringify a `Type` and including the file path and line number in which it is defined, if\n * possible, for better debugging experience.\n *\n * Important! This function contains a megamorphic read and should only be used for error messages.\n */\nfunction debugStringifyTypeForError(type) {\n    // TODO(pmvald): Do some refactoring so that we can use getComponentDef here without creating\n    // circular deps.\n    let componentDef = type[NG_COMP_DEF] || null;\n    if (componentDef !== null && componentDef.debugInfo) {\n        return stringifyTypeFromDebugInfo(componentDef.debugInfo);\n    }\n    return stringifyForError(type);\n}\n// TODO(pmvald): Do some refactoring so that we can use the type ClassDebugInfo for the param\n// debugInfo here without creating circular deps.\nfunction stringifyTypeFromDebugInfo(debugInfo) {\n    if (!debugInfo.filePath || !debugInfo.lineNumber) {\n        return debugInfo.className;\n    }\n    else {\n        return `${debugInfo.className} (at ${debugInfo.filePath}:${debugInfo.lineNumber})`;\n    }\n}\n\nconst NG_RUNTIME_ERROR_CODE = getClosureSafeProperty({ 'ngErrorCode': getClosureSafeProperty });\nconst NG_RUNTIME_ERROR_MESSAGE = getClosureSafeProperty({ 'ngErrorMessage': getClosureSafeProperty });\nconst NG_TOKEN_PATH = getClosureSafeProperty({ 'ngTokenPath': getClosureSafeProperty });\n/** Creates a circular dependency runtime error. */\nfunction cyclicDependencyError(token, path) {\n    const message = ngDevMode ? `Circular dependency detected for \\`${token}\\`.` : '';\n    return createRuntimeError(message, -200 /* RuntimeErrorCode.CYCLIC_DI_DEPENDENCY */, path);\n}\n/** Creates a circular dependency runtime error including a dependency path in the error message. */\nfunction cyclicDependencyErrorWithDetails(token, path) {\n    return augmentRuntimeError(cyclicDependencyError(token, path), null);\n}\nfunction throwMixedMultiProviderError() {\n    throw new Error(`Cannot mix multi providers and regular providers`);\n}\nfunction throwInvalidProviderError(ngModuleType, providers, provider) {\n    if (ngModuleType && providers) {\n        const providerDetail = providers.map((v) => (v == provider ? '?' + provider + '?' : '...'));\n        throw new Error(`Invalid provider for the NgModule '${stringify(ngModuleType)}' - only instances of Provider and Type are allowed, got: [${providerDetail.join(', ')}]`);\n    }\n    else if (isEnvironmentProviders(provider)) {\n        if (provider.fromNgModule) {\n            throw new RuntimeError(207 /* RuntimeErrorCode.PROVIDER_IN_WRONG_CONTEXT */, `Invalid providers from 'importProvidersFrom' present in a non-environment injector. 'importProvidersFrom' can't be used for component providers.`);\n        }\n        else {\n            throw new RuntimeError(207 /* RuntimeErrorCode.PROVIDER_IN_WRONG_CONTEXT */, `Invalid providers present in a non-environment injector. 'EnvironmentProviders' can't be used for component providers.`);\n        }\n    }\n    else {\n        throw new Error('Invalid provider');\n    }\n}\n/** Throws an error when a token is not found in DI. */\nfunction throwProviderNotFoundError(token, injectorName) {\n    const errorMessage = ngDevMode &&\n        `No provider for ${stringifyForError(token)} found${injectorName ? ` in ${injectorName}` : ''}`;\n    throw new RuntimeError(-201 /* RuntimeErrorCode.PROVIDER_NOT_FOUND */, errorMessage);\n}\n/**\n * Given an Error instance and the current token - update the monkey-patched\n * dependency path info to include that token.\n *\n * @param error Current instance of the Error class.\n * @param token Extra token that should be appended.\n */\nfunction prependTokenToDependencyPath(error, token) {\n    error[NG_TOKEN_PATH] ??= [];\n    // Append current token to the current token path. Since the error\n    // is bubbling up, add the token in front of other tokens.\n    const currentPath = error[NG_TOKEN_PATH];\n    // Do not append the same token multiple times.\n    let pathStr;\n    if (typeof token === 'object' && 'multi' in token && token?.multi === true) {\n        assertDefined(token.provide, 'Token with multi: true should have a provide property');\n        pathStr = stringifyForError(token.provide);\n    }\n    else {\n        pathStr = stringifyForError(token);\n    }\n    if (currentPath[0] !== pathStr) {\n        error[NG_TOKEN_PATH].unshift(pathStr);\n    }\n}\n/**\n * Modifies an Error instance with an updated error message\n * based on the accumulated dependency path.\n *\n * @param error Current instance of the Error class.\n * @param source Extra info about the injector which started\n *    the resolution process, which eventually failed.\n */\nfunction augmentRuntimeError(error, source) {\n    const tokenPath = error[NG_TOKEN_PATH];\n    const errorCode = error[NG_RUNTIME_ERROR_CODE];\n    const message = error[NG_RUNTIME_ERROR_MESSAGE] || error.message;\n    error.message = formatErrorMessage(message, errorCode, tokenPath, source);\n    return error;\n}\n/**\n * Creates an initial RuntimeError instance when a problem is detected.\n * Monkey-patches extra info in the RuntimeError instance, so that it can\n * be reused later, before throwing the final error.\n */\nfunction createRuntimeError(message, code, path) {\n    // Cast to `any`, so that extra info can be monkey-patched onto this instance.\n    const error = new RuntimeError(code, message);\n    // Monkey-patch a runtime error code and a path onto an Error instance.\n    error[NG_RUNTIME_ERROR_CODE] = code;\n    error[NG_RUNTIME_ERROR_MESSAGE] = message;\n    if (path) {\n        error[NG_TOKEN_PATH] = path;\n    }\n    return error;\n}\n/**\n * Reads monkey-patched error code from the given Error instance.\n */\nfunction getRuntimeErrorCode(error) {\n    return error[NG_RUNTIME_ERROR_CODE];\n}\nfunction formatErrorMessage(text, code, path = [], source = null) {\n    let pathDetails = '';\n    // If the path is empty or contains only one element (self) -\n    // do not append additional info the error message.\n    if (path && path.length > 1) {\n        pathDetails = ` Path: ${path.join(' -> ')}.`;\n    }\n    const sourceDetails = source ? ` Source: ${source}.` : '';\n    return formatRuntimeError(code, `${text}${sourceDetails}${pathDetails}`);\n}\n\n/**\n * Current implementation of inject.\n *\n * By default, it is `injectInjectorOnly`, which makes it `Injector`-only aware. It can be changed\n * to `directiveInject`, which brings in the `NodeInjector` system of ivy. It is designed this\n * way for two reasons:\n *  1. `Injector` should not depend on ivy logic.\n *  2. To maintain tree shake-ability we don't want to bring in unnecessary code.\n */\nlet _injectImplementation;\nfunction getInjectImplementation() {\n    return _injectImplementation;\n}\n/**\n * Sets the current inject implementation.\n */\nfunction setInjectImplementation(impl) {\n    const previous = _injectImplementation;\n    _injectImplementation = impl;\n    return previous;\n}\n/**\n * Injects `root` tokens in limp mode.\n *\n * If no injector exists, we can still inject tree-shakable providers which have `providedIn` set to\n * `\"root\"`. This is known as the limp mode injection. In such case the value is stored in the\n * injectable definition.\n */\nfunction injectRootLimpMode(token, notFoundValue, flags) {\n    const injectableDef = getInjectableDef(token);\n    if (injectableDef && injectableDef.providedIn == 'root') {\n        return injectableDef.value === undefined\n            ? (injectableDef.value = injectableDef.factory())\n            : injectableDef.value;\n    }\n    if (flags & 8 /* InternalInjectFlags.Optional */)\n        return null;\n    if (notFoundValue !== undefined)\n        return notFoundValue;\n    throwProviderNotFoundError(token, 'Injector');\n}\n/**\n * Assert that `_injectImplementation` is not `fn`.\n *\n * This is useful, to prevent infinite recursion.\n *\n * @param fn Function which it should not equal to\n */\nfunction assertInjectImplementationNotEqual(fn) {\n    ngDevMode &&\n        assertNotEqual(_injectImplementation, fn, 'Calling inject would cause infinite recursion');\n}\n\nconst _THROW_IF_NOT_FOUND = {};\nconst THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;\n/*\n * Name of a property (that we patch onto DI decorator), which is used as an annotation of which\n * InjectFlag this decorator represents. This allows to avoid direct references to the DI decorators\n * in the code, thus making them tree-shakable.\n */\nconst DI_DECORATOR_FLAG = '__NG_DI_FLAG__';\n/**\n * A wrapper around an `Injector` that implements the `PrimitivesInjector` interface.\n *\n * This is used to allow the `inject` function to be used with the new primitives-based DI system.\n */\nclass RetrievingInjector {\n    injector;\n    constructor(injector) {\n        this.injector = injector;\n    }\n    retrieve(token, options) {\n        const flags = convertToBitFlags(options) || 0 /* InternalInjectFlags.Default */;\n        try {\n            return this.injector.get(token, \n            // When a dependency is requested with an optional flag, DI returns null as the default value.\n            (flags & 8 /* InternalInjectFlags.Optional */ ? null : THROW_IF_NOT_FOUND), flags);\n        }\n        catch (e) {\n            if (isNotFound(e)) {\n                return e;\n            }\n            throw e;\n        }\n    }\n}\nfunction injectInjectorOnly(token, flags = 0 /* InternalInjectFlags.Default */) {\n    const currentInjector = getCurrentInjector();\n    if (currentInjector === undefined) {\n        throw new RuntimeError(-203 /* RuntimeErrorCode.MISSING_INJECTION_CONTEXT */, ngDevMode &&\n            `The \\`${stringify(token)}\\` token injection failed. \\`inject()\\` function must be called from an injection context such as a constructor, a factory function, a field initializer, or a function used with \\`runInInjectionContext\\`.`);\n    }\n    else if (currentInjector === null) {\n        return injectRootLimpMode(token, undefined, flags);\n    }\n    else {\n        const options = convertToInjectOptions(flags);\n        // TODO: improve the typings here.\n        // `token` can be a multi: true provider definition, which is considered as a Token but not represented in the typings\n        const value = currentInjector.retrieve(token, options);\n        ngDevMode && emitInjectEvent(token, value, flags);\n        if (isNotFound(value)) {\n            if (options.optional) {\n                return null;\n            }\n            throw value;\n        }\n        return value;\n    }\n}\nfunction inject(token, flags = 0 /* InternalInjectFlags.Default */) {\n    return (getInjectImplementation() || injectInjectorOnly)(resolveForwardRef(token), flags);\n}\n/**\n * Throws an error indicating that a factory function could not be generated by the compiler for a\n * particular class.\n *\n * The name of the class is not mentioned here, but will be in the generated factory function name\n * and thus in the stack trace.\n *\n * @codeGenApi\n */\nfunction invalidFactoryDep(index) {\n    throw new RuntimeError(202 /* RuntimeErrorCode.INVALID_FACTORY_DEPENDENCY */, ngDevMode &&\n        `This constructor is not compatible with Angular Dependency Injection because its dependency at index ${index} of the parameter list is invalid.\nThis can happen if the dependency type is a primitive like a string or if an ancestor of this class is missing an Angular decorator.\n\nPlease check that 1) the type for the parameter at index ${index} is correct and 2) the correct Angular decorators are defined for this class and its ancestors.`);\n}\n/**\n * Injects a token from the currently active injector.\n * `inject` is only supported in an [injection context](guide/di/dependency-injection-context). It\n * can be used during:\n * - Construction (via the `constructor`) of a class being instantiated by the DI system, such\n * as an `@Injectable` or `@Component`.\n * - In the initializer for fields of such classes.\n * - In the factory function specified for `useFactory` of a `Provider` or an `@Injectable`.\n * - In the `factory` function specified for an `InjectionToken`.\n * - In a stackframe of a function call in a DI context\n *\n * @param token A token that represents a dependency that should be injected.\n * @param flags Optional flags that control how injection is executed.\n * The flags correspond to injection strategies that can be specified with\n * parameter decorators `@Host`, `@Self`, `@SkipSelf`, and `@Optional`.\n * @returns the injected value if operation is successful, `null` otherwise.\n * @throws if called outside of a supported context.\n *\n * @usageNotes\n * In practice the `inject()` calls are allowed in a constructor, a constructor parameter and a\n * field initializer:\n *\n * ```ts\n * @Injectable({providedIn: 'root'})\n * export class Car {\n *   radio: Radio|undefined;\n *   // OK: field initializer\n *   spareTyre = inject(Tyre);\n *\n *   constructor() {\n *     // OK: constructor body\n *     this.radio = inject(Radio);\n *   }\n * }\n * ```\n *\n * It is also legal to call `inject` from a provider's factory:\n *\n * ```ts\n * providers: [\n *   {provide: Car, useFactory: () => {\n *     // OK: a class factory\n *     const engine = inject(Engine);\n *     return new Car(engine);\n *   }}\n * ]\n * ```\n *\n * Calls to the `inject()` function outside of the class creation context will result in error. Most\n * notably, calls to `inject()` are disallowed after a class instance was created, in methods\n * (including lifecycle hooks):\n *\n * ```ts\n * @Component({ ... })\n * export class CarComponent {\n *   ngOnInit() {\n *     // ERROR: too late, the component instance was already created\n *     const engine = inject(Engine);\n *     engine.start();\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nfunction inject(token, options) {\n    // The `as any` here _shouldn't_ be necessary, but without it JSCompiler\n    // throws a disambiguation  error due to the multiple signatures.\n    return inject(token, convertToBitFlags(options));\n}\n// Converts object-based DI flags (`InjectOptions`) to bit flags (`InjectFlags`).\nfunction convertToBitFlags(flags) {\n    if (typeof flags === 'undefined' || typeof flags === 'number') {\n        return flags;\n    }\n    // While TypeScript doesn't accept it without a cast, bitwise OR with false-y values in\n    // JavaScript is a no-op. We can use that for a very codesize-efficient conversion from\n    // `InjectOptions` to `InjectFlags`.\n    return (0 /* InternalInjectFlags.Default */ | // comment to force a line break in the formatter\n        (flags.optional && 8 /* InternalInjectFlags.Optional */) |\n        (flags.host && 1 /* InternalInjectFlags.Host */) |\n        (flags.self && 2 /* InternalInjectFlags.Self */) |\n        (flags.skipSelf && 4 /* InternalInjectFlags.SkipSelf */));\n}\n// Converts bitflags to inject options\nfunction convertToInjectOptions(flags) {\n    return {\n        optional: !!(flags & 8 /* InternalInjectFlags.Optional */),\n        host: !!(flags & 1 /* InternalInjectFlags.Host */),\n        self: !!(flags & 2 /* InternalInjectFlags.Self */),\n        skipSelf: !!(flags & 4 /* InternalInjectFlags.SkipSelf */),\n    };\n}\nfunction injectArgs(types) {\n    const args = [];\n    for (let i = 0; i < types.length; i++) {\n        const arg = resolveForwardRef(types[i]);\n        if (Array.isArray(arg)) {\n            if (arg.length === 0) {\n                throw new RuntimeError(900 /* RuntimeErrorCode.INVALID_DIFFER_INPUT */, ngDevMode && 'Arguments array must have arguments.');\n            }\n            let type = undefined;\n            let flags = 0 /* InternalInjectFlags.Default */;\n            for (let j = 0; j < arg.length; j++) {\n                const meta = arg[j];\n                const flag = getInjectFlag(meta);\n                if (typeof flag === 'number') {\n                    // Special case when we handle @Inject decorator.\n                    if (flag === -1 /* DecoratorFlags.Inject */) {\n                        type = meta.token;\n                    }\n                    else {\n                        flags |= flag;\n                    }\n                }\n                else {\n                    type = meta;\n                }\n            }\n            args.push(inject(type, flags));\n        }\n        else {\n            args.push(inject(arg));\n        }\n    }\n    return args;\n}\n/**\n * Attaches a given InjectFlag to a given decorator using monkey-patching.\n * Since DI decorators can be used in providers `deps` array (when provider is configured using\n * `useFactory`) without initialization (e.g. `Host`) and as an instance (e.g. `new Host()`), we\n * attach the flag to make it available both as a static property and as a field on decorator\n * instance.\n *\n * @param decorator Provided DI decorator.\n * @param flag InjectFlag that should be applied.\n */\nfunction attachInjectFlag(decorator, flag) {\n    decorator[DI_DECORATOR_FLAG] = flag;\n    decorator.prototype[DI_DECORATOR_FLAG] = flag;\n    return decorator;\n}\n/**\n * Reads monkey-patched property that contains InjectFlag attached to a decorator.\n *\n * @param token Token that may contain monkey-patched DI flags property.\n */\nfunction getInjectFlag(token) {\n    return token[DI_DECORATOR_FLAG];\n}\n\nfunction getFactoryDef(type, throwNotFound) {\n    const hasFactoryDef = type.hasOwnProperty(NG_FACTORY_DEF);\n    if (!hasFactoryDef && throwNotFound === true && ngDevMode) {\n        throw new Error(`Type ${stringify(type)} does not have 'fac' property.`);\n    }\n    return hasFactoryDef ? type[NG_FACTORY_DEF] : null;\n}\n\n/**\n * Determines if the contents of two arrays is identical\n *\n * @param a first array\n * @param b second array\n * @param identityAccessor Optional function for extracting stable object identity from a value in\n *     the array.\n */\nfunction arrayEquals(a, b, identityAccessor) {\n    if (a.length !== b.length)\n        return false;\n    for (let i = 0; i < a.length; i++) {\n        let valueA = a[i];\n        let valueB = b[i];\n        if (identityAccessor) {\n            valueA = identityAccessor(valueA);\n            valueB = identityAccessor(valueB);\n        }\n        if (valueB !== valueA) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Flattens an array.\n */\nfunction flatten(list) {\n    return list.flat(Number.POSITIVE_INFINITY);\n}\nfunction deepForEach(input, fn) {\n    input.forEach((value) => (Array.isArray(value) ? deepForEach(value, fn) : fn(value)));\n}\nfunction addToArray(arr, index, value) {\n    // perf: array.push is faster than array.splice!\n    if (index >= arr.length) {\n        arr.push(value);\n    }\n    else {\n        arr.splice(index, 0, value);\n    }\n}\nfunction removeFromArray(arr, index) {\n    // perf: array.pop is faster than array.splice!\n    if (index >= arr.length - 1) {\n        return arr.pop();\n    }\n    else {\n        return arr.splice(index, 1)[0];\n    }\n}\nfunction newArray(size, value) {\n    const list = [];\n    for (let i = 0; i < size; i++) {\n        list.push(value);\n    }\n    return list;\n}\n/**\n * Remove item from array (Same as `Array.splice()` but faster.)\n *\n * `Array.splice()` is not as fast because it has to allocate an array for the elements which were\n * removed. This causes memory pressure and slows down code when most of the time we don't\n * care about the deleted items array.\n *\n * https://jsperf.com/fast-array-splice (About 20x faster)\n *\n * @param array Array to splice\n * @param index Index of element in array to remove.\n * @param count Number of items to remove.\n */\nfunction arraySplice(array, index, count) {\n    const length = array.length - count;\n    while (index < length) {\n        array[index] = array[index + count];\n        index++;\n    }\n    while (count--) {\n        array.pop(); // shrink the array\n    }\n}\n/**\n * Same as `Array.splice2(index, 0, value1, value2)` but faster.\n *\n * `Array.splice()` is not fast because it has to allocate an array for the elements which were\n * removed. This causes memory pressure and slows down code when most of the time we don't\n * care about the deleted items array.\n *\n * @param array Array to splice.\n * @param index Index in array where the `value` should be added.\n * @param value1 Value to add to array.\n * @param value2 Value to add to array.\n */\nfunction arrayInsert2(array, index, value1, value2) {\n    ngDevMode && assertLessThanOrEqual(index, array.length, \"Can't insert past array end.\");\n    let end = array.length;\n    if (end == index) {\n        // inserting at the end.\n        array.push(value1, value2);\n    }\n    else if (end === 1) {\n        // corner case when we have less items in array than we have items to insert.\n        array.push(value2, array[0]);\n        array[0] = value1;\n    }\n    else {\n        end--;\n        array.push(array[end - 1], array[end]);\n        while (end > index) {\n            const previousEnd = end - 2;\n            array[end] = array[previousEnd];\n            end--;\n        }\n        array[index] = value1;\n        array[index + 1] = value2;\n    }\n}\n/**\n * Set a `value` for a `key`.\n *\n * @param keyValueArray to modify.\n * @param key The key to locate or create.\n * @param value The value to set for a `key`.\n * @returns index (always even) of where the value vas set.\n */\nfunction keyValueArraySet(keyValueArray, key, value) {\n    let index = keyValueArrayIndexOf(keyValueArray, key);\n    if (index >= 0) {\n        // if we found it set it.\n        keyValueArray[index | 1] = value;\n    }\n    else {\n        index = ~index;\n        arrayInsert2(keyValueArray, index, key, value);\n    }\n    return index;\n}\n/**\n * Retrieve a `value` for a `key` (on `undefined` if not found.)\n *\n * @param keyValueArray to search.\n * @param key The key to locate.\n * @return The `value` stored at the `key` location or `undefined if not found.\n */\nfunction keyValueArrayGet(keyValueArray, key) {\n    const index = keyValueArrayIndexOf(keyValueArray, key);\n    if (index >= 0) {\n        // if we found it retrieve it.\n        return keyValueArray[index | 1];\n    }\n    return undefined;\n}\n/**\n * Retrieve a `key` index value in the array or `-1` if not found.\n *\n * @param keyValueArray to search.\n * @param key The key to locate.\n * @returns index of where the key is (or should have been.)\n *   - positive (even) index if key found.\n *   - negative index if key not found. (`~index` (even) to get the index where it should have\n *     been inserted.)\n */\nfunction keyValueArrayIndexOf(keyValueArray, key) {\n    return _arrayIndexOfSorted(keyValueArray, key, 1);\n}\n/**\n * INTERNAL: Get an index of an `value` in a sorted `array` by grouping search by `shift`.\n *\n * NOTE:\n * - This uses binary search algorithm for fast removals.\n *\n * @param array A sorted array to binary search.\n * @param value The value to look for.\n * @param shift grouping shift.\n *   - `0` means look at every location\n *   - `1` means only look at every other (even) location (the odd locations are to be ignored as\n *         they are values.)\n * @returns index of the value.\n *   - positive index if value found.\n *   - negative index if value not found. (`~index` to get the value where it should have been\n * inserted)\n */\nfunction _arrayIndexOfSorted(array, value, shift) {\n    ngDevMode && assertEqual(Array.isArray(array), true, 'Expecting an array');\n    let start = 0;\n    let end = array.length >> shift;\n    while (end !== start) {\n        const middle = start + ((end - start) >> 1); // find the middle.\n        const current = array[middle << shift];\n        if (value === current) {\n            return middle << shift;\n        }\n        else if (current > value) {\n            end = middle;\n        }\n        else {\n            start = middle + 1; // We already searched middle so make it non-inclusive by adding 1\n        }\n    }\n    return ~(end << shift);\n}\n\n/**\n * This file contains reuseable \"empty\" symbols that can be used as default return values\n * in different parts of the rendering code. Because the same symbols are returned, this\n * allows for identity checks against these values to be consistently used by the framework\n * code.\n */\nconst EMPTY_OBJ = {};\nconst EMPTY_ARRAY = [];\n// freezing the values prevents any code from accidentally inserting new values in\nif ((typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode()) {\n    // These property accesses can be ignored because ngDevMode will be set to false\n    // when optimizing code and the whole if statement will be dropped.\n    // tslint:disable-next-line:no-toplevel-property-access\n    Object.freeze(EMPTY_OBJ);\n    // tslint:disable-next-line:no-toplevel-property-access\n    Object.freeze(EMPTY_ARRAY);\n}\n\n/**\n * A multi-provider token for initialization functions that will run upon construction of an\n * environment injector.\n *\n * @deprecated from v19.0.0, use provideEnvironmentInitializer instead\n *\n * @see {@link provideEnvironmentInitializer}\n *\n * Note: As opposed to the `APP_INITIALIZER` token, the `ENVIRONMENT_INITIALIZER` functions are not awaited,\n * hence they should not be `async`.\n *\n * @publicApi\n */\nconst ENVIRONMENT_INITIALIZER = new InjectionToken(ngDevMode ? 'ENVIRONMENT_INITIALIZER' : '');\n\n/**\n * An InjectionToken that gets the current `Injector` for `createInjector()`-style injectors.\n *\n * Requesting this token instead of `Injector` allows `StaticInjector` to be tree-shaken from a\n * project.\n *\n * @publicApi\n */\nconst INJECTOR$1 = new InjectionToken(ngDevMode ? 'INJECTOR' : '', \n// Disable tslint because this is const enum which gets inlined not top level prop access.\n// tslint:disable-next-line: no-toplevel-property-access\n-1 /* InjectorMarkers.Injector */);\n\nconst INJECTOR_DEF_TYPES = new InjectionToken(ngDevMode ? 'INJECTOR_DEF_TYPES' : '');\n\nclass NullInjector {\n    get(token, notFoundValue = THROW_IF_NOT_FOUND) {\n        if (notFoundValue === THROW_IF_NOT_FOUND) {\n            const message = ngDevMode ? `No provider found for \\`${stringify(token)}\\`.` : '';\n            const error = createRuntimeError(message, -201 /* RuntimeErrorCode.PROVIDER_NOT_FOUND */);\n            // Note: This is the name used by the primitives to identify a not found error.\n            error.name = 'NotFound';\n            throw error;\n        }\n        return notFoundValue;\n    }\n}\n\nfunction getNgModuleDef(type) {\n    return type[NG_MOD_DEF] || null;\n}\nfunction getNgModuleDefOrThrow(type) {\n    const ngModuleDef = getNgModuleDef(type);\n    if (!ngModuleDef) {\n        throw new RuntimeError(915 /* RuntimeErrorCode.MISSING_NG_MODULE_DEFINITION */, (typeof ngDevMode === 'undefined' || ngDevMode) &&\n            `Type ${stringify(type)} does not have 'mod' property.`);\n    }\n    return ngModuleDef;\n}\n/**\n * The following getter methods retrieve the definition from the type. Currently the retrieval\n * honors inheritance, but in the future we may change the rule to require that definitions are\n * explicit. This would require some sort of migration strategy.\n */\nfunction getComponentDef(type) {\n    return type[NG_COMP_DEF] || null;\n}\nfunction getDirectiveDefOrThrow(type) {\n    const def = getDirectiveDef(type);\n    if (!def) {\n        throw new RuntimeError(916 /* RuntimeErrorCode.MISSING_DIRECTIVE_DEFINITION */, (typeof ngDevMode === 'undefined' || ngDevMode) &&\n            `Type ${stringify(type)} does not have 'dir' property.`);\n    }\n    return def;\n}\nfunction getDirectiveDef(type) {\n    return type[NG_DIR_DEF] || null;\n}\nfunction getPipeDef(type) {\n    return type[NG_PIPE_DEF] || null;\n}\n/**\n * Checks whether a given Component, Directive or Pipe is marked as standalone.\n * This will return false if passed anything other than a Component, Directive, or Pipe class\n * See [this guide](guide/components/importing) for additional information:\n *\n * @param type A reference to a Component, Directive or Pipe.\n * @publicApi\n */\nfunction isStandalone(type) {\n    const def = getComponentDef(type) || getDirectiveDef(type) || getPipeDef(type);\n    return def !== null && def.standalone;\n}\n\n/**\n * Wrap an array of `Provider`s into `EnvironmentProviders`, preventing them from being accidentally\n * referenced in `@Component` in a component injector.\n *\n * @publicApi\n */\nfunction makeEnvironmentProviders(providers) {\n    return {\n        providers: providers,\n    };\n}\n/**\n * @description\n * This function is used to provide initialization functions that will be executed upon construction\n * of an environment injector.\n *\n * Note that the provided initializer is run in the injection context.\n *\n * Previously, this was achieved using the `ENVIRONMENT_INITIALIZER` token which is now deprecated.\n *\n * @see {@link ENVIRONMENT_INITIALIZER}\n *\n * @usageNotes\n * The following example illustrates how to configure an initialization function using\n * `provideEnvironmentInitializer()`\n * ```ts\n * createEnvironmentInjector(\n *   [\n *     provideEnvironmentInitializer(() => {\n *       console.log('environment initialized');\n *     }),\n *   ],\n *   parentInjector\n * );\n * ```\n *\n * @publicApi\n */\nfunction provideEnvironmentInitializer(initializerFn) {\n    return makeEnvironmentProviders([\n        {\n            provide: ENVIRONMENT_INITIALIZER,\n            multi: true,\n            useValue: initializerFn,\n        },\n    ]);\n}\n/**\n * Collects providers from all NgModules and standalone components, including transitively imported\n * ones.\n *\n * Providers extracted via `importProvidersFrom` are only usable in an application injector or\n * another environment injector (such as a route injector). They should not be used in component\n * providers.\n *\n * More information about standalone components can be found in [this\n * guide](guide/components/importing).\n *\n * @usageNotes\n * The results of the `importProvidersFrom` call can be used in the `bootstrapApplication` call:\n *\n * ```ts\n * await bootstrapApplication(RootComponent, {\n *   providers: [\n *     importProvidersFrom(NgModuleOne, NgModuleTwo)\n *   ]\n * });\n * ```\n *\n * You can also use the `importProvidersFrom` results in the `providers` field of a route, when a\n * standalone component is used:\n *\n * ```ts\n * export const ROUTES: Route[] = [\n *   {\n *     path: 'foo',\n *     providers: [\n *       importProvidersFrom(NgModuleOne, NgModuleTwo)\n *     ],\n *     component: YourStandaloneComponent\n *   }\n * ];\n * ```\n *\n * @returns Collected providers from the specified list of types.\n * @publicApi\n */\nfunction importProvidersFrom(...sources) {\n    return {\n        providers: internalImportProvidersFrom(true, sources),\n        fromNgModule: true,\n    };\n}\nfunction internalImportProvidersFrom(checkForStandaloneCmp, ...sources) {\n    const providersOut = [];\n    const dedup = new Set(); // already seen types\n    let injectorTypesWithProviders;\n    const collectProviders = (provider) => {\n        providersOut.push(provider);\n    };\n    deepForEach(sources, (source) => {\n        if ((typeof ngDevMode === 'undefined' || ngDevMode) && checkForStandaloneCmp) {\n            const cmpDef = getComponentDef(source);\n            if (cmpDef?.standalone) {\n                throw new RuntimeError(800 /* RuntimeErrorCode.IMPORT_PROVIDERS_FROM_STANDALONE */, `Importing providers supports NgModule or ModuleWithProviders but got a standalone component \"${stringifyForError(source)}\"`);\n            }\n        }\n        // Narrow `source` to access the internal type analogue for `ModuleWithProviders`.\n        const internalSource = source;\n        if (walkProviderTree(internalSource, collectProviders, [], dedup)) {\n            injectorTypesWithProviders ||= [];\n            injectorTypesWithProviders.push(internalSource);\n        }\n    });\n    // Collect all providers from `ModuleWithProviders` types.\n    if (injectorTypesWithProviders !== undefined) {\n        processInjectorTypesWithProviders(injectorTypesWithProviders, collectProviders);\n    }\n    return providersOut;\n}\n/**\n * Collects all providers from the list of `ModuleWithProviders` and appends them to the provided\n * array.\n */\nfunction processInjectorTypesWithProviders(typesWithProviders, visitor) {\n    for (let i = 0; i < typesWithProviders.length; i++) {\n        const { ngModule, providers } = typesWithProviders[i];\n        deepForEachProvider(providers, (provider) => {\n            ngDevMode && validateProvider(provider, providers || EMPTY_ARRAY, ngModule);\n            visitor(provider, ngModule);\n        });\n    }\n}\n/**\n * The logic visits an `InjectorType`, an `InjectorTypeWithProviders`, or a standalone\n * `ComponentType`, and all of its transitive providers and collects providers.\n *\n * If an `InjectorTypeWithProviders` that declares providers besides the type is specified,\n * the function will return \"true\" to indicate that the providers of the type definition need\n * to be processed. This allows us to process providers of injector types after all imports of\n * an injector definition are processed. (following View Engine semantics: see FW-1349)\n */\nfunction walkProviderTree(container, visitor, parents, dedup) {\n    container = resolveForwardRef(container);\n    if (!container)\n        return false;\n    // The actual type which had the definition. Usually `container`, but may be an unwrapped type\n    // from `InjectorTypeWithProviders`.\n    let defType = null;\n    let injDef = getInjectorDef(container);\n    const cmpDef = !injDef && getComponentDef(container);\n    if (!injDef && !cmpDef) {\n        // `container` is not an injector type or a component type. It might be:\n        //  * An `InjectorTypeWithProviders` that wraps an injector type.\n        //  * A standalone directive or pipe that got pulled in from a standalone component's\n        //    dependencies.\n        // Try to unwrap it as an `InjectorTypeWithProviders` first.\n        const ngModule = container\n            .ngModule;\n        injDef = getInjectorDef(ngModule);\n        if (injDef) {\n            defType = ngModule;\n        }\n        else {\n            // Not a component or injector type, so ignore it.\n            return false;\n        }\n    }\n    else if (cmpDef && !cmpDef.standalone) {\n        return false;\n    }\n    else {\n        defType = container;\n    }\n    // Check for circular dependencies.\n    if (ngDevMode && parents.indexOf(defType) !== -1) {\n        const defName = stringify(defType);\n        const path = parents.map(stringify).concat(defName);\n        throw cyclicDependencyErrorWithDetails(defName, path);\n    }\n    // Check for multiple imports of the same module\n    const isDuplicate = dedup.has(defType);\n    if (cmpDef) {\n        if (isDuplicate) {\n            // This component definition has already been processed.\n            return false;\n        }\n        dedup.add(defType);\n        if (cmpDef.dependencies) {\n            const deps = typeof cmpDef.dependencies === 'function' ? cmpDef.dependencies() : cmpDef.dependencies;\n            for (const dep of deps) {\n                walkProviderTree(dep, visitor, parents, dedup);\n            }\n        }\n    }\n    else if (injDef) {\n        // First, include providers from any imports.\n        if (injDef.imports != null && !isDuplicate) {\n            // Before processing defType's imports, add it to the set of parents. This way, if it ends\n            // up deeply importing itself, this can be detected.\n            ngDevMode && parents.push(defType);\n            // Add it to the set of dedups. This way we can detect multiple imports of the same module\n            dedup.add(defType);\n            let importTypesWithProviders;\n            try {\n                deepForEach(injDef.imports, (imported) => {\n                    if (walkProviderTree(imported, visitor, parents, dedup)) {\n                        importTypesWithProviders ||= [];\n                        // If the processed import is an injector type with providers, we store it in the\n                        // list of import types with providers, so that we can process those afterwards.\n                        importTypesWithProviders.push(imported);\n                    }\n                });\n            }\n            finally {\n                // Remove it from the parents set when finished.\n                ngDevMode && parents.pop();\n            }\n            // Imports which are declared with providers (TypeWithProviders) need to be processed\n            // after all imported modules are processed. This is similar to how View Engine\n            // processes/merges module imports in the metadata resolver. See: FW-1349.\n            if (importTypesWithProviders !== undefined) {\n                processInjectorTypesWithProviders(importTypesWithProviders, visitor);\n            }\n        }\n        if (!isDuplicate) {\n            // Track the InjectorType and add a provider for it.\n            // It's important that this is done after the def's imports.\n            const factory = getFactoryDef(defType) || (() => new defType());\n            // Append extra providers to make more info available for consumers (to retrieve an injector\n            // type), as well as internally (to calculate an injection scope correctly and eagerly\n            // instantiate a `defType` when an injector is created).\n            // Provider to create `defType` using its factory.\n            visitor({ provide: defType, useFactory: factory, deps: EMPTY_ARRAY }, defType);\n            // Make this `defType` available to an internal logic that calculates injector scope.\n            visitor({ provide: INJECTOR_DEF_TYPES, useValue: defType, multi: true }, defType);\n            // Provider to eagerly instantiate `defType` via `INJECTOR_INITIALIZER`.\n            visitor({ provide: ENVIRONMENT_INITIALIZER, useValue: () => inject(defType), multi: true }, defType);\n        }\n        // Next, include providers listed on the definition itself.\n        const defProviders = injDef.providers;\n        if (defProviders != null && !isDuplicate) {\n            const injectorType = container;\n            deepForEachProvider(defProviders, (provider) => {\n                ngDevMode && validateProvider(provider, defProviders, injectorType);\n                visitor(provider, injectorType);\n            });\n        }\n    }\n    else {\n        // Should not happen, but just in case.\n        return false;\n    }\n    return (defType !== container && container.providers !== undefined);\n}\nfunction validateProvider(provider, providers, containerType) {\n    if (isTypeProvider(provider) ||\n        isValueProvider(provider) ||\n        isFactoryProvider(provider) ||\n        isExistingProvider(provider)) {\n        return;\n    }\n    // Here we expect the provider to be a `useClass` provider (by elimination).\n    const classRef = resolveForwardRef(provider && (provider.useClass || provider.provide));\n    if (!classRef) {\n        throwInvalidProviderError(containerType, providers, provider);\n    }\n}\nfunction deepForEachProvider(providers, fn) {\n    for (let provider of providers) {\n        if (isEnvironmentProviders(provider)) {\n            provider = provider.providers;\n        }\n        if (Array.isArray(provider)) {\n            deepForEachProvider(provider, fn);\n        }\n        else {\n            fn(provider);\n        }\n    }\n}\nconst USE_VALUE = getClosureSafeProperty({\n    provide: String,\n    useValue: getClosureSafeProperty,\n});\nfunction isValueProvider(value) {\n    return value !== null && typeof value == 'object' && USE_VALUE in value;\n}\nfunction isExistingProvider(value) {\n    return !!(value && value.useExisting);\n}\nfunction isFactoryProvider(value) {\n    return !!(value && value.useFactory);\n}\nfunction isTypeProvider(value) {\n    return typeof value === 'function';\n}\nfunction isClassProvider(value) {\n    return !!value.useClass;\n}\n\n/**\n * An internal token whose presence in an injector indicates that the injector should treat itself\n * as a root scoped injector when processing requests for unknown tokens which may indicate\n * they are provided in the root scope.\n */\nconst INJECTOR_SCOPE = new InjectionToken(ngDevMode ? 'Set Injector scope.' : '');\n\n/**\n * Marker which indicates that a value has not yet been created from the factory function.\n */\nconst NOT_YET = {};\n/**\n * Marker which indicates that the factory function for a token is in the process of being called.\n *\n * If the injector is asked to inject a token with its value set to CIRCULAR, that indicates\n * injection of a dependency has recursively attempted to inject the original token, and there is\n * a circular dependency among the providers.\n */\nconst CIRCULAR = {};\n/**\n * A lazily initialized NullInjector.\n */\nlet NULL_INJECTOR = undefined;\nfunction getNullInjector() {\n    if (NULL_INJECTOR === undefined) {\n        NULL_INJECTOR = new NullInjector();\n    }\n    return NULL_INJECTOR;\n}\n/**\n * An `Injector` that's part of the environment injector hierarchy, which exists outside of the\n * component tree.\n *\n * @publicApi\n */\nclass EnvironmentInjector {\n}\nclass R3Injector extends EnvironmentInjector {\n    parent;\n    source;\n    scopes;\n    /**\n     * Map of tokens to records which contain the instances of those tokens.\n     * - `null` value implies that we don't have the record. Used by tree-shakable injectors\n     * to prevent further searches.\n     */\n    records = new Map();\n    /**\n     * Set of values instantiated by this injector which contain `ngOnDestroy` lifecycle hooks.\n     */\n    _ngOnDestroyHooks = new Set();\n    _onDestroyHooks = [];\n    /**\n     * Flag indicating that this injector was previously destroyed.\n     */\n    get destroyed() {\n        return this._destroyed;\n    }\n    _destroyed = false;\n    injectorDefTypes;\n    constructor(providers, parent, source, scopes) {\n        super();\n        this.parent = parent;\n        this.source = source;\n        this.scopes = scopes;\n        // Start off by creating Records for every provider.\n        forEachSingleProvider(providers, (provider) => this.processProvider(provider));\n        // Make sure the INJECTOR token provides this injector.\n        this.records.set(INJECTOR$1, makeRecord(undefined, this));\n        // And `EnvironmentInjector` if the current injector is supposed to be env-scoped.\n        if (scopes.has('environment')) {\n            this.records.set(EnvironmentInjector, makeRecord(undefined, this));\n        }\n        // Detect whether this injector has the APP_ROOT_SCOPE token and thus should provide\n        // any injectable scoped to APP_ROOT_SCOPE.\n        const record = this.records.get(INJECTOR_SCOPE);\n        if (record != null && typeof record.value === 'string') {\n            this.scopes.add(record.value);\n        }\n        this.injectorDefTypes = new Set(this.get(INJECTOR_DEF_TYPES, EMPTY_ARRAY, { self: true }));\n    }\n    retrieve(token, options) {\n        const flags = convertToBitFlags(options) || 0 /* InternalInjectFlags.Default */;\n        try {\n            return this.get(token, \n            // When a dependency is requested with an optional flag, DI returns null as the default value.\n            THROW_IF_NOT_FOUND, flags);\n        }\n        catch (e) {\n            if (isNotFound$1(e)) {\n                return e;\n            }\n            throw e;\n        }\n    }\n    /**\n     * Destroy the injector and release references to every instance or provider associated with it.\n     *\n     * Also calls the `OnDestroy` lifecycle hooks of every instance that was created for which a\n     * hook was found.\n     */\n    destroy() {\n        assertNotDestroyed(this);\n        // Set destroyed = true first, in case lifecycle hooks re-enter destroy().\n        this._destroyed = true;\n        const prevConsumer = setActiveConsumer(null);\n        try {\n            // Call all the lifecycle hooks.\n            for (const service of this._ngOnDestroyHooks) {\n                service.ngOnDestroy();\n            }\n            const onDestroyHooks = this._onDestroyHooks;\n            // Reset the _onDestroyHooks array before iterating over it to prevent hooks that unregister\n            // themselves from mutating the array during iteration.\n            this._onDestroyHooks = [];\n            for (const hook of onDestroyHooks) {\n                hook();\n            }\n        }\n        finally {\n            // Release all references.\n            this.records.clear();\n            this._ngOnDestroyHooks.clear();\n            this.injectorDefTypes.clear();\n            setActiveConsumer(prevConsumer);\n        }\n    }\n    onDestroy(callback) {\n        assertNotDestroyed(this);\n        this._onDestroyHooks.push(callback);\n        return () => this.removeOnDestroy(callback);\n    }\n    runInContext(fn) {\n        assertNotDestroyed(this);\n        const previousInjector = setCurrentInjector(this);\n        const previousInjectImplementation = setInjectImplementation(undefined);\n        let prevInjectContext;\n        if (ngDevMode) {\n            prevInjectContext = setInjectorProfilerContext({ injector: this, token: null });\n        }\n        try {\n            return fn();\n        }\n        finally {\n            setCurrentInjector(previousInjector);\n            setInjectImplementation(previousInjectImplementation);\n            ngDevMode && setInjectorProfilerContext(prevInjectContext);\n        }\n    }\n    get(token, notFoundValue = THROW_IF_NOT_FOUND, options) {\n        assertNotDestroyed(this);\n        if (token.hasOwnProperty(NG_ENV_ID)) {\n            return token[NG_ENV_ID](this);\n        }\n        const flags = convertToBitFlags(options);\n        // Set the injection context.\n        let prevInjectContext;\n        if (ngDevMode) {\n            prevInjectContext = setInjectorProfilerContext({ injector: this, token: token });\n        }\n        const previousInjector = setCurrentInjector(this);\n        const previousInjectImplementation = setInjectImplementation(undefined);\n        try {\n            // Check for the SkipSelf flag.\n            if (!(flags & 4 /* InternalInjectFlags.SkipSelf */)) {\n                // SkipSelf isn't set, check if the record belongs to this injector.\n                let record = this.records.get(token);\n                if (record === undefined) {\n                    // No record, but maybe the token is scoped to this injector. Look for an injectable\n                    // def with a scope matching this injector.\n                    const def = couldBeInjectableType(token) && getInjectableDef(token);\n                    if (def && this.injectableDefInScope(def)) {\n                        // Found an injectable def and it's scoped to this injector. Pretend as if it was here\n                        // all along.\n                        if (ngDevMode) {\n                            runInInjectorProfilerContext(this, token, () => {\n                                emitProviderConfiguredEvent(token);\n                            });\n                        }\n                        record = makeRecord(injectableDefOrInjectorDefFactory(token), NOT_YET);\n                    }\n                    else {\n                        record = null;\n                    }\n                    this.records.set(token, record);\n                }\n                // If a record was found, get the instance for it and return it.\n                if (record != null /* NOT null || undefined */) {\n                    return this.hydrate(token, record, flags);\n                }\n            }\n            // Select the next injector based on the Self flag - if self is set, the next injector is\n            // the NullInjector, otherwise it's the parent.\n            const nextInjector = !(flags & 2 /* InternalInjectFlags.Self */) ? this.parent : getNullInjector();\n            // Set the notFoundValue based on the Optional flag - if optional is set and notFoundValue\n            // is undefined, the value is null, otherwise it's the notFoundValue.\n            notFoundValue =\n                flags & 8 /* InternalInjectFlags.Optional */ && notFoundValue === THROW_IF_NOT_FOUND\n                    ? null\n                    : notFoundValue;\n            return nextInjector.get(token, notFoundValue);\n        }\n        catch (error) {\n            // If there was a cyclic dependency error or a token was not found,\n            // an error is thrown at the level where the problem was detected.\n            // The error propagates up the call stack and the code below appends\n            // the current token into the path. As a result, the full path is assembled\n            // at the very top of the call stack, so the final error message can be\n            // formatted to include that path.\n            const errorCode = getRuntimeErrorCode(error);\n            if (errorCode === -200 /* RuntimeErrorCode.CYCLIC_DI_DEPENDENCY */ ||\n                errorCode === -201 /* RuntimeErrorCode.PROVIDER_NOT_FOUND */) {\n                // Note: we use `if (ngDevMode) { ... }` instead of an early return.\n                // ESBuild is conservative about removing dead code that follows `return;`\n                // inside a function body, so the block may remain in the bundle.\n                // Using a conditional ensures the dev-only logic is reliably tree-shaken\n                // in production builds.\n                if (ngDevMode) {\n                    prependTokenToDependencyPath(error, token);\n                    if (previousInjector) {\n                        // We still have a parent injector, keep throwing\n                        throw error;\n                    }\n                    else {\n                        // Format & throw the final error message when we don't have any previous injector\n                        throw augmentRuntimeError(error, this.source);\n                    }\n                }\n                else {\n                    throw new RuntimeError(errorCode, null);\n                }\n            }\n            else {\n                throw error;\n            }\n        }\n        finally {\n            // Lastly, restore the previous injection context.\n            setInjectImplementation(previousInjectImplementation);\n            setCurrentInjector(previousInjector);\n            ngDevMode && setInjectorProfilerContext(prevInjectContext);\n        }\n    }\n    /** @internal */\n    resolveInjectorInitializers() {\n        const prevConsumer = setActiveConsumer(null);\n        const previousInjector = setCurrentInjector(this);\n        const previousInjectImplementation = setInjectImplementation(undefined);\n        let prevInjectContext;\n        if (ngDevMode) {\n            prevInjectContext = setInjectorProfilerContext({ injector: this, token: null });\n        }\n        try {\n            const initializers = this.get(ENVIRONMENT_INITIALIZER, EMPTY_ARRAY, { self: true });\n            if (ngDevMode && !Array.isArray(initializers)) {\n                throw new RuntimeError(-209 /* RuntimeErrorCode.INVALID_MULTI_PROVIDER */, 'Unexpected type of the `ENVIRONMENT_INITIALIZER` token value ' +\n                    `(expected an array, but got ${typeof initializers}). ` +\n                    'Please check that the `ENVIRONMENT_INITIALIZER` token is configured as a ' +\n                    '`multi: true` provider.');\n            }\n            for (const initializer of initializers) {\n                initializer();\n            }\n        }\n        finally {\n            setCurrentInjector(previousInjector);\n            setInjectImplementation(previousInjectImplementation);\n            ngDevMode && setInjectorProfilerContext(prevInjectContext);\n            setActiveConsumer(prevConsumer);\n        }\n    }\n    toString() {\n        const tokens = [];\n        const records = this.records;\n        for (const token of records.keys()) {\n            tokens.push(stringify(token));\n        }\n        return `R3Injector[${tokens.join(', ')}]`;\n    }\n    /**\n     * Process a `SingleProvider` and add it.\n     */\n    processProvider(provider) {\n        // Determine the token from the provider. Either it's its own token, or has a {provide: ...}\n        // property.\n        provider = resolveForwardRef(provider);\n        let token = isTypeProvider(provider)\n            ? provider\n            : resolveForwardRef(provider && provider.provide);\n        // Construct a `Record` for the provider.\n        const record = providerToRecord(provider);\n        if (ngDevMode) {\n            runInInjectorProfilerContext(this, token, () => {\n                // Emit InjectorProfilerEventType.Create if provider is a value provider because\n                // these are the only providers that do not go through the value hydration logic\n                // where this event would normally be emitted from.\n                if (isValueProvider(provider)) {\n                    emitInjectorToCreateInstanceEvent(token);\n                    emitInstanceCreatedByInjectorEvent(provider.useValue);\n                }\n                emitProviderConfiguredEvent(provider);\n            });\n        }\n        if (!isTypeProvider(provider) && provider.multi === true) {\n            // If the provider indicates that it's a multi-provider, process it specially.\n            // First check whether it's been defined already.\n            let multiRecord = this.records.get(token);\n            if (multiRecord) {\n                // It has. Throw a nice error if\n                if (ngDevMode && multiRecord.multi === undefined) {\n                    throwMixedMultiProviderError();\n                }\n            }\n            else {\n                multiRecord = makeRecord(undefined, NOT_YET, true);\n                multiRecord.factory = () => injectArgs(multiRecord.multi);\n                this.records.set(token, multiRecord);\n            }\n            token = provider;\n            multiRecord.multi.push(provider);\n        }\n        else {\n            if (ngDevMode) {\n                const existing = this.records.get(token);\n                if (existing && existing.multi !== undefined) {\n                    throwMixedMultiProviderError();\n                }\n            }\n        }\n        this.records.set(token, record);\n    }\n    hydrate(token, record, flags) {\n        const prevConsumer = setActiveConsumer(null);\n        try {\n            if (record.value === CIRCULAR) {\n                throw cyclicDependencyError(stringify(token));\n            }\n            else if (record.value === NOT_YET) {\n                record.value = CIRCULAR;\n                if (ngDevMode) {\n                    runInInjectorProfilerContext(this, token, () => {\n                        emitInjectorToCreateInstanceEvent(token);\n                        record.value = record.factory(undefined, flags);\n                        emitInstanceCreatedByInjectorEvent(record.value);\n                    });\n                }\n                else {\n                    record.value = record.factory(undefined, flags);\n                }\n            }\n            if (typeof record.value === 'object' && record.value && hasOnDestroy(record.value)) {\n                this._ngOnDestroyHooks.add(record.value);\n            }\n            return record.value;\n        }\n        finally {\n            setActiveConsumer(prevConsumer);\n        }\n    }\n    injectableDefInScope(def) {\n        if (!def.providedIn) {\n            return false;\n        }\n        const providedIn = resolveForwardRef(def.providedIn);\n        if (typeof providedIn === 'string') {\n            return providedIn === 'any' || this.scopes.has(providedIn);\n        }\n        else {\n            return this.injectorDefTypes.has(providedIn);\n        }\n    }\n    removeOnDestroy(callback) {\n        const destroyCBIdx = this._onDestroyHooks.indexOf(callback);\n        if (destroyCBIdx !== -1) {\n            this._onDestroyHooks.splice(destroyCBIdx, 1);\n        }\n    }\n}\nfunction injectableDefOrInjectorDefFactory(token) {\n    // Most tokens will have an injectable def directly on them, which specifies a factory directly.\n    const injectableDef = getInjectableDef(token);\n    const factory = injectableDef !== null ? injectableDef.factory : getFactoryDef(token);\n    if (factory !== null) {\n        return factory;\n    }\n    // InjectionTokens should have an injectable def (prov) and thus should be handled above.\n    // If it's missing that, it's an error.\n    if (token instanceof InjectionToken) {\n        throw new RuntimeError(204 /* RuntimeErrorCode.INVALID_INJECTION_TOKEN */, ngDevMode && `Token ${stringify(token)} is missing a prov definition.`);\n    }\n    // Undecorated types can sometimes be created if they have no constructor arguments.\n    if (token instanceof Function) {\n        return getUndecoratedInjectableFactory(token);\n    }\n    // There was no way to resolve a factory for this token.\n    throw new RuntimeError(204 /* RuntimeErrorCode.INVALID_INJECTION_TOKEN */, ngDevMode && 'unreachable');\n}\nfunction getUndecoratedInjectableFactory(token) {\n    // If the token has parameters then it has dependencies that we cannot resolve implicitly.\n    const paramLength = token.length;\n    if (paramLength > 0) {\n        throw new RuntimeError(204 /* RuntimeErrorCode.INVALID_INJECTION_TOKEN */, ngDevMode &&\n            `Can't resolve all parameters for ${stringify(token)}: (${newArray(paramLength, '?').join(', ')}).`);\n    }\n    // The constructor function appears to have no parameters.\n    // This might be because it inherits from a super-class. In which case, use an injectable\n    // def from an ancestor if there is one.\n    // Otherwise this really is a simple class with no dependencies, so return a factory that\n    // just instantiates the zero-arg constructor.\n    const inheritedInjectableDef = getInheritedInjectableDef(token);\n    if (inheritedInjectableDef !== null) {\n        return () => inheritedInjectableDef.factory(token);\n    }\n    else {\n        return () => new token();\n    }\n}\nfunction providerToRecord(provider) {\n    if (isValueProvider(provider)) {\n        return makeRecord(undefined, provider.useValue);\n    }\n    else {\n        const factory = providerToFactory(provider);\n        return makeRecord(factory, NOT_YET);\n    }\n}\n/**\n * Converts a `SingleProvider` into a factory function.\n *\n * @param provider provider to convert to factory\n */\nfunction providerToFactory(provider, ngModuleType, providers) {\n    let factory = undefined;\n    if (ngDevMode && isEnvironmentProviders(provider)) {\n        throwInvalidProviderError(undefined, providers, provider);\n    }\n    if (isTypeProvider(provider)) {\n        const unwrappedProvider = resolveForwardRef(provider);\n        return getFactoryDef(unwrappedProvider) || injectableDefOrInjectorDefFactory(unwrappedProvider);\n    }\n    else {\n        if (isValueProvider(provider)) {\n            factory = () => resolveForwardRef(provider.useValue);\n        }\n        else if (isFactoryProvider(provider)) {\n            factory = () => provider.useFactory(...injectArgs(provider.deps || []));\n        }\n        else if (isExistingProvider(provider)) {\n            factory = (_, flags) => inject(resolveForwardRef(provider.useExisting), flags !== undefined && flags & 8 /* InternalInjectFlags.Optional */\n                ? 8 /* InternalInjectFlags.Optional */\n                : undefined);\n        }\n        else {\n            const classRef = resolveForwardRef(provider &&\n                (provider.useClass || provider.provide));\n            if (ngDevMode && !classRef) {\n                throwInvalidProviderError(ngModuleType, providers, provider);\n            }\n            if (hasDeps(provider)) {\n                factory = () => new classRef(...injectArgs(provider.deps));\n            }\n            else {\n                return getFactoryDef(classRef) || injectableDefOrInjectorDefFactory(classRef);\n            }\n        }\n    }\n    return factory;\n}\nfunction assertNotDestroyed(injector) {\n    if (injector.destroyed) {\n        throw new RuntimeError(205 /* RuntimeErrorCode.INJECTOR_ALREADY_DESTROYED */, ngDevMode && 'Injector has already been destroyed.');\n    }\n}\nfunction makeRecord(factory, value, multi = false) {\n    return {\n        factory: factory,\n        value: value,\n        multi: multi ? [] : undefined,\n    };\n}\nfunction hasDeps(value) {\n    return !!value.deps;\n}\nfunction hasOnDestroy(value) {\n    return (value !== null &&\n        typeof value === 'object' &&\n        typeof value.ngOnDestroy === 'function');\n}\nfunction couldBeInjectableType(value) {\n    return (typeof value === 'function' ||\n        (typeof value === 'object' && value.ngMetadataName === 'InjectionToken'));\n}\nfunction forEachSingleProvider(providers, fn) {\n    for (const provider of providers) {\n        if (Array.isArray(provider)) {\n            forEachSingleProvider(provider, fn);\n        }\n        else if (provider && isEnvironmentProviders(provider)) {\n            forEachSingleProvider(provider.providers, fn);\n        }\n        else {\n            fn(provider);\n        }\n    }\n}\n\n/**\n * Runs the given function in the [context](guide/di/dependency-injection-context) of the given\n * `Injector`.\n *\n * Within the function's stack frame, [`inject`](api/core/inject) can be used to inject dependencies\n * from the given `Injector`. Note that `inject` is only usable synchronously, and cannot be used in\n * any asynchronous callbacks or after any `await` points.\n *\n * @param injector the injector which will satisfy calls to [`inject`](api/core/inject) while `fn`\n *     is executing\n * @param fn the closure to be run in the context of `injector`\n * @returns the return value of the function, if any\n * @publicApi\n */\nfunction runInInjectionContext(injector, fn) {\n    let internalInjector;\n    if (injector instanceof R3Injector) {\n        assertNotDestroyed(injector);\n        internalInjector = injector;\n    }\n    else {\n        internalInjector = new RetrievingInjector(injector);\n    }\n    let prevInjectorProfilerContext;\n    if (ngDevMode) {\n        prevInjectorProfilerContext = setInjectorProfilerContext({ injector, token: null });\n    }\n    const prevInjector = setCurrentInjector(internalInjector);\n    const previousInjectImplementation = setInjectImplementation(undefined);\n    try {\n        return fn();\n    }\n    finally {\n        setCurrentInjector(prevInjector);\n        ngDevMode && setInjectorProfilerContext(prevInjectorProfilerContext);\n        setInjectImplementation(previousInjectImplementation);\n    }\n}\n/**\n * Whether the current stack frame is inside an injection context.\n */\nfunction isInInjectionContext() {\n    return getInjectImplementation() !== undefined || getCurrentInjector() != null;\n}\n/**\n * Asserts that the current stack frame is within an [injection\n * context](guide/di/dependency-injection-context) and has access to `inject`.\n *\n * @param debugFn a reference to the function making the assertion (used for the error message).\n *\n * @see [Asserts the context](guide/di/dependency-injection-context#asserts-the-context)\n *\n * @publicApi\n */\nfunction assertInInjectionContext(debugFn) {\n    // Taking a `Function` instead of a string name here prevents the unminified name of the function\n    // from being retained in the bundle regardless of minification.\n    if (!isInInjectionContext()) {\n        throw new RuntimeError(-203 /* RuntimeErrorCode.MISSING_INJECTION_CONTEXT */, ngDevMode &&\n            debugFn.name +\n                '() can only be used within an injection context such as a constructor, a factory function, a field initializer, or a function used with `runInInjectionContext`');\n    }\n}\n\n// Below are constants for LView indices to help us look up LView members\n// without having to remember the specific indices.\n// Uglify will inline these when minifying so there shouldn't be a cost.\nconst HOST = 0;\nconst TVIEW = 1;\n// Shared with LContainer\nconst FLAGS = 2;\nconst PARENT = 3;\nconst NEXT = 4;\nconst T_HOST = 5;\n// End shared with LContainer\nconst HYDRATION = 6;\nconst CLEANUP = 7;\nconst CONTEXT = 8;\nconst INJECTOR = 9;\nconst ENVIRONMENT = 10;\nconst RENDERER = 11;\nconst CHILD_HEAD = 12;\nconst CHILD_TAIL = 13;\n// FIXME(misko): Investigate if the three declarations aren't all same thing.\nconst DECLARATION_VIEW = 14;\nconst DECLARATION_COMPONENT_VIEW = 15;\nconst DECLARATION_LCONTAINER = 16;\nconst PREORDER_HOOK_FLAGS = 17;\nconst QUERIES = 18;\nconst ID = 19;\nconst EMBEDDED_VIEW_INJECTOR = 20;\nconst ON_DESTROY_HOOKS = 21;\nconst EFFECTS_TO_SCHEDULE = 22;\nconst EFFECTS = 23;\nconst REACTIVE_TEMPLATE_CONSUMER = 24;\nconst AFTER_RENDER_SEQUENCES_TO_ADD = 25;\nconst ANIMATIONS = 26;\n/**\n * Size of LView's header. Necessary to adjust for it when setting slots.\n *\n * IMPORTANT: `HEADER_OFFSET` should only be referred to the in the `*` instructions to translate\n * instruction index into `LView` index. All other indexes should be in the `LView` index space and\n * there should be no need to refer to `HEADER_OFFSET` anywhere else.\n */\nconst HEADER_OFFSET = 27;\n\n/**\n * Special location which allows easy identification of type. If we have an array which was\n * retrieved from the `LView` and that array has `true` at `TYPE` location, we know it is\n * `LContainer`.\n */\nconst TYPE = 1;\n/**\n * Below are constants for LContainer indices to help us look up LContainer members\n * without having to remember the specific indices.\n * Uglify will inline these when minifying so there shouldn't be a cost.\n */\n// FLAGS, PARENT, NEXT, and T_HOST are indices 2, 3, 4, and 5\n// As we already have these constants in LView, we don't need to re-create them.\nconst DEHYDRATED_VIEWS = 6;\nconst NATIVE = 7;\nconst VIEW_REFS = 8;\nconst MOVED_VIEWS = 9;\n/**\n * Size of LContainer's header. Represents the index after which all views in the\n * container will be inserted. We need to keep a record of current views so we know\n * which views are already in the DOM (and don't need to be re-added) and so we can\n * remove views from the DOM when they are no longer required.\n */\nconst CONTAINER_HEADER_OFFSET = 10;\n\n/**\n * True if `value` is `LView`.\n * @param value wrapped value of `RNode`, `LView`, `LContainer`\n */\nfunction isLView(value) {\n    return Array.isArray(value) && typeof value[TYPE] === 'object';\n}\n/**\n * True if `value` is `LContainer`.\n * @param value wrapped value of `RNode`, `LView`, `LContainer`\n */\nfunction isLContainer(value) {\n    return Array.isArray(value) && value[TYPE] === true;\n}\nfunction isContentQueryHost(tNode) {\n    return (tNode.flags & 4 /* TNodeFlags.hasContentQuery */) !== 0;\n}\nfunction isComponentHost(tNode) {\n    return tNode.componentOffset > -1;\n}\nfunction isDirectiveHost(tNode) {\n    return (tNode.flags & 1 /* TNodeFlags.isDirectiveHost */) === 1 /* TNodeFlags.isDirectiveHost */;\n}\nfunction isComponentDef(def) {\n    return !!def.template;\n}\nfunction isRootView(target) {\n    // Determines whether a given LView is marked as a root view.\n    return (target[FLAGS] & 512 /* LViewFlags.IsRoot */) !== 0;\n}\nfunction isProjectionTNode(tNode) {\n    return (tNode.type & 16 /* TNodeType.Projection */) === 16 /* TNodeType.Projection */;\n}\nfunction hasI18n(lView) {\n    return (lView[FLAGS] & 32 /* LViewFlags.HasI18n */) === 32 /* LViewFlags.HasI18n */;\n}\nfunction isDestroyed(lView) {\n    // Determines whether a given LView is marked as destroyed.\n    return (lView[FLAGS] & 256 /* LViewFlags.Destroyed */) === 256 /* LViewFlags.Destroyed */;\n}\n\n// [Assert functions do not constraint type when they are guarded by a truthy\n// expression.](https://github.com/microsoft/TypeScript/issues/37295)\nfunction assertTNodeForLView(tNode, lView) {\n    assertTNodeForTView(tNode, lView[TVIEW]);\n}\nfunction assertTNodeCreationIndex(lView, index) {\n    const adjustedIndex = index + HEADER_OFFSET;\n    assertIndexInRange(lView, adjustedIndex);\n    assertLessThan(adjustedIndex, lView[TVIEW].bindingStartIndex, 'TNodes should be created before any bindings');\n}\nfunction assertTNodeForTView(tNode, tView) {\n    assertTNode(tNode);\n    const tData = tView.data;\n    for (let i = HEADER_OFFSET; i < tData.length; i++) {\n        if (tData[i] === tNode) {\n            return;\n        }\n    }\n    throwError('This TNode does not belong to this TView.');\n}\nfunction assertTNode(tNode) {\n    assertDefined(tNode, 'TNode must be defined');\n    if (!(tNode && typeof tNode === 'object' && tNode.hasOwnProperty('directiveStylingLast'))) {\n        throwError('Not of type TNode, got: ' + tNode);\n    }\n}\nfunction assertTIcu(tIcu) {\n    assertDefined(tIcu, 'Expected TIcu to be defined');\n    if (!(typeof tIcu.currentCaseLViewIndex === 'number')) {\n        throwError('Object is not of TIcu type.');\n    }\n}\nfunction assertComponentType(actual, msg = \"Type passed in is not ComponentType, it does not have 'cmp' property.\") {\n    if (!getComponentDef(actual)) {\n        throwError(msg);\n    }\n}\nfunction assertNgModuleType(actual, msg = \"Type passed in is not NgModuleType, it does not have 'mod' property.\") {\n    if (!getNgModuleDef(actual)) {\n        throwError(msg);\n    }\n}\nfunction assertHasParent(tNode) {\n    assertDefined(tNode, 'currentTNode should exist!');\n    assertDefined(tNode.parent, 'currentTNode should have a parent');\n}\nfunction assertLContainer(value) {\n    assertDefined(value, 'LContainer must be defined');\n    assertEqual(isLContainer(value), true, 'Expecting LContainer');\n}\nfunction assertLViewOrUndefined(value) {\n    value && assertEqual(isLView(value), true, 'Expecting LView or undefined or null');\n}\nfunction assertLView(value) {\n    assertDefined(value, 'LView must be defined');\n    assertEqual(isLView(value), true, 'Expecting LView');\n}\nfunction assertFirstCreatePass(tView, errMessage) {\n    assertEqual(tView.firstCreatePass, true, errMessage || 'Should only be called in first create pass.');\n}\nfunction assertFirstUpdatePass(tView, errMessage) {\n    assertEqual(tView.firstUpdatePass, true, 'Should only be called in first update pass.');\n}\n/**\n * This is a basic sanity check that an object is probably a directive def. DirectiveDef is\n * an interface, so we can't do a direct instanceof check.\n */\nfunction assertDirectiveDef(obj) {\n    if (obj.type === undefined || obj.selectors == undefined || obj.inputs === undefined) {\n        throwError(`Expected a DirectiveDef/ComponentDef and this object does not seem to have the expected shape.`);\n    }\n}\nfunction assertIndexInDeclRange(tView, index) {\n    assertBetween(HEADER_OFFSET, tView.bindingStartIndex, index);\n}\nfunction assertIndexInExpandoRange(lView, index) {\n    const tView = lView[1];\n    assertBetween(tView.expandoStartIndex, lView.length, index);\n}\nfunction assertBetween(lower, upper, index) {\n    if (!(lower <= index && index < upper)) {\n        throwError(`Index out of range (expecting ${lower} <= ${index} < ${upper})`);\n    }\n}\nfunction assertProjectionSlots(lView, errMessage) {\n    assertDefined(lView[DECLARATION_COMPONENT_VIEW], 'Component views should exist.');\n    assertDefined(lView[DECLARATION_COMPONENT_VIEW][T_HOST].projection, 'Components with projection nodes (<ng-content>) must have projection slots defined.');\n}\nfunction assertParentView(lView, errMessage) {\n    assertDefined(lView, \"Component views should always have a parent view (component's host view)\");\n}\n/**\n * This is a basic sanity check that the `injectorIndex` seems to point to what looks like a\n * NodeInjector data structure.\n *\n * @param lView `LView` which should be checked.\n * @param injectorIndex index into the `LView` where the `NodeInjector` is expected.\n */\nfunction assertNodeInjector(lView, injectorIndex) {\n    assertIndexInExpandoRange(lView, injectorIndex);\n    assertIndexInExpandoRange(lView, injectorIndex + 8 /* NodeInjectorOffset.PARENT */);\n    assertNumber(lView[injectorIndex + 0], 'injectorIndex should point to a bloom filter');\n    assertNumber(lView[injectorIndex + 1], 'injectorIndex should point to a bloom filter');\n    assertNumber(lView[injectorIndex + 2], 'injectorIndex should point to a bloom filter');\n    assertNumber(lView[injectorIndex + 3], 'injectorIndex should point to a bloom filter');\n    assertNumber(lView[injectorIndex + 4], 'injectorIndex should point to a bloom filter');\n    assertNumber(lView[injectorIndex + 5], 'injectorIndex should point to a bloom filter');\n    assertNumber(lView[injectorIndex + 6], 'injectorIndex should point to a bloom filter');\n    assertNumber(lView[injectorIndex + 7], 'injectorIndex should point to a bloom filter');\n    assertNumber(lView[injectorIndex + 8 /* NodeInjectorOffset.PARENT */], 'injectorIndex should point to parent injector');\n}\n\nconst SVG_NAMESPACE = 'svg';\nconst MATH_ML_NAMESPACE = 'math';\n\n/**\n * For efficiency reasons we often put several different data types (`RNode`, `LView`, `LContainer`)\n * in same location in `LView`. This is because we don't want to pre-allocate space for it\n * because the storage is sparse. This file contains utilities for dealing with such data types.\n *\n * How do we know what is stored at a given location in `LView`.\n * - `Array.isArray(value) === false` => `RNode` (The normal storage value)\n * - `Array.isArray(value) === true` => then the `value[0]` represents the wrapped value.\n *   - `typeof value[TYPE] === 'object'` => `LView`\n *      - This happens when we have a component at a given location\n *   - `typeof value[TYPE] === true` => `LContainer`\n *      - This happens when we have `LContainer` binding at a given location.\n *\n *\n * NOTE: it is assumed that `Array.isArray` and `typeof` operations are very efficient.\n */\n/**\n * Returns `RNode`.\n * @param value wrapped value of `RNode`, `LView`, `LContainer`\n */\nfunction unwrapRNode(value) {\n    while (Array.isArray(value)) {\n        value = value[HOST];\n    }\n    return value;\n}\n/**\n * Returns `LView` or `null` if not found.\n * @param value wrapped value of `RNode`, `LView`, `LContainer`\n */\nfunction unwrapLView(value) {\n    while (Array.isArray(value)) {\n        // This check is same as `isLView()` but we don't call at as we don't want to call\n        // `Array.isArray()` twice and give JITer more work for inlining.\n        if (typeof value[TYPE] === 'object')\n            return value;\n        value = value[HOST];\n    }\n    return null;\n}\n/**\n * Retrieves an element value from the provided `viewData`, by unwrapping\n * from any containers, component views, or style contexts.\n */\nfunction getNativeByIndex(index, lView) {\n    ngDevMode && assertIndexInRange(lView, index);\n    ngDevMode && assertGreaterThanOrEqual(index, HEADER_OFFSET, 'Expected to be past HEADER_OFFSET');\n    return unwrapRNode(lView[index]);\n}\n/**\n * Retrieve an `RNode` for a given `TNode` and `LView`.\n *\n * This function guarantees in dev mode to retrieve a non-null `RNode`.\n *\n * @param tNode\n * @param lView\n */\nfunction getNativeByTNode(tNode, lView) {\n    ngDevMode && assertTNodeForLView(tNode, lView);\n    ngDevMode && assertIndexInRange(lView, tNode.index);\n    const node = unwrapRNode(lView[tNode.index]);\n    return node;\n}\n/**\n * Retrieve an `RNode` or `null` for a given `TNode` and `LView`.\n *\n * Some `TNode`s don't have associated `RNode`s. For example `Projection`\n *\n * @param tNode\n * @param lView\n */\nfunction getNativeByTNodeOrNull(tNode, lView) {\n    const index = tNode === null ? -1 : tNode.index;\n    if (index !== -1) {\n        ngDevMode && assertTNodeForLView(tNode, lView);\n        const node = unwrapRNode(lView[index]);\n        return node;\n    }\n    return null;\n}\n// fixme(misko): The return Type should be `TNode|null`\nfunction getTNode(tView, index) {\n    ngDevMode && assertGreaterThan(index, -1, 'wrong index for TNode');\n    ngDevMode && assertLessThan(index, tView.data.length, 'wrong index for TNode');\n    const tNode = tView.data[index];\n    ngDevMode && tNode !== null && assertTNode(tNode);\n    return tNode;\n}\n/** Retrieves a value from any `LView` or `TData`. */\nfunction load(view, index) {\n    ngDevMode && assertIndexInRange(view, index);\n    return view[index];\n}\n/** Store a value in the `data` at a given `index`. */\nfunction store(tView, lView, index, value) {\n    // We don't store any static data for local variables, so the first time\n    // we see the template, we should store as null to avoid a sparse array\n    if (index >= tView.data.length) {\n        tView.data[index] = null;\n        tView.blueprint[index] = null;\n    }\n    lView[index] = value;\n}\nfunction getComponentLViewByIndex(nodeIndex, hostView) {\n    // Could be an LView or an LContainer. If LContainer, unwrap to find LView.\n    ngDevMode && assertIndexInRange(hostView, nodeIndex);\n    const slotValue = hostView[nodeIndex];\n    const lView = isLView(slotValue) ? slotValue : slotValue[HOST];\n    return lView;\n}\n/** Checks whether a given view is in creation mode */\nfunction isCreationMode(view) {\n    return (view[FLAGS] & 4 /* LViewFlags.CreationMode */) === 4 /* LViewFlags.CreationMode */;\n}\n/**\n * Returns a boolean for whether the view is attached to the change detection tree.\n *\n * Note: This determines whether a view should be checked, not whether it's inserted\n * into a container. For that, you'll want `viewAttachedToContainer` below.\n */\nfunction viewAttachedToChangeDetector(view) {\n    return (view[FLAGS] & 128 /* LViewFlags.Attached */) === 128 /* LViewFlags.Attached */;\n}\n/** Returns a boolean for whether the view is attached to a container. */\nfunction viewAttachedToContainer(view) {\n    return isLContainer(view[PARENT]);\n}\nfunction getConstant(consts, index) {\n    if (index === null || index === undefined)\n        return null;\n    ngDevMode && assertIndexInRange(consts, index);\n    return consts[index];\n}\n/**\n * Resets the pre-order hook flags of the view.\n * @param lView the LView on which the flags are reset\n */\nfunction resetPreOrderHookFlags(lView) {\n    lView[PREORDER_HOOK_FLAGS] = 0;\n}\n/**\n * Adds the `RefreshView` flag from the lView and updates HAS_CHILD_VIEWS_TO_REFRESH flag of\n * parents.\n */\nfunction markViewForRefresh(lView) {\n    if (lView[FLAGS] & 1024 /* LViewFlags.RefreshView */) {\n        return;\n    }\n    lView[FLAGS] |= 1024 /* LViewFlags.RefreshView */;\n    if (viewAttachedToChangeDetector(lView)) {\n        markAncestorsForTraversal(lView);\n    }\n}\n/**\n * Walks up the LView hierarchy.\n * @param nestingLevel Number of times to walk up in hierarchy.\n * @param currentView View from which to start the lookup.\n */\nfunction walkUpViews(nestingLevel, currentView) {\n    while (nestingLevel > 0) {\n        ngDevMode &&\n            assertDefined(currentView[DECLARATION_VIEW], 'Declaration view should be defined if nesting level is greater than 0.');\n        currentView = currentView[DECLARATION_VIEW];\n        nestingLevel--;\n    }\n    return currentView;\n}\nfunction requiresRefreshOrTraversal(lView) {\n    return !!(lView[FLAGS] & (1024 /* LViewFlags.RefreshView */ | 8192 /* LViewFlags.HasChildViewsToRefresh */) ||\n        lView[REACTIVE_TEMPLATE_CONSUMER]?.dirty);\n}\n/**\n * Updates the `HasChildViewsToRefresh` flag on the parents of the `LView` as well as the\n * parents above.\n */\nfunction updateAncestorTraversalFlagsOnAttach(lView) {\n    lView[ENVIRONMENT].changeDetectionScheduler?.notify(8 /* NotificationSource.ViewAttached */);\n    if (lView[FLAGS] & 64 /* LViewFlags.Dirty */) {\n        lView[FLAGS] |= 1024 /* LViewFlags.RefreshView */;\n    }\n    if (requiresRefreshOrTraversal(lView)) {\n        markAncestorsForTraversal(lView);\n    }\n}\n/**\n * Ensures views above the given `lView` are traversed during change detection even when they are\n * not dirty.\n *\n * This is done by setting the `HAS_CHILD_VIEWS_TO_REFRESH` flag up to the root, stopping when the\n * flag is already `true` or the `lView` is detached.\n */\nfunction markAncestorsForTraversal(lView) {\n    lView[ENVIRONMENT].changeDetectionScheduler?.notify(0 /* NotificationSource.MarkAncestorsForTraversal */);\n    let parent = getLViewParent(lView);\n    while (parent !== null) {\n        // We stop adding markers to the ancestors once we reach one that already has the marker. This\n        // is to avoid needlessly traversing all the way to the root when the marker already exists.\n        if (parent[FLAGS] & 8192 /* LViewFlags.HasChildViewsToRefresh */) {\n            break;\n        }\n        parent[FLAGS] |= 8192 /* LViewFlags.HasChildViewsToRefresh */;\n        if (!viewAttachedToChangeDetector(parent)) {\n            break;\n        }\n        parent = getLViewParent(parent);\n    }\n}\n/**\n * Stores a LView-specific destroy callback.\n */\nfunction storeLViewOnDestroy(lView, onDestroyCallback) {\n    if (isDestroyed(lView)) {\n        throw new RuntimeError(911 /* RuntimeErrorCode.VIEW_ALREADY_DESTROYED */, ngDevMode && 'View has already been destroyed.');\n    }\n    if (lView[ON_DESTROY_HOOKS] === null) {\n        lView[ON_DESTROY_HOOKS] = [];\n    }\n    lView[ON_DESTROY_HOOKS].push(onDestroyCallback);\n}\n/**\n * Removes previously registered LView-specific destroy callback.\n */\nfunction removeLViewOnDestroy(lView, onDestroyCallback) {\n    if (lView[ON_DESTROY_HOOKS] === null)\n        return;\n    const destroyCBIdx = lView[ON_DESTROY_HOOKS].indexOf(onDestroyCallback);\n    if (destroyCBIdx !== -1) {\n        lView[ON_DESTROY_HOOKS].splice(destroyCBIdx, 1);\n    }\n}\n/**\n * Gets the parent LView of the passed LView, if the PARENT is an LContainer, will get the parent of\n * that LContainer, which is an LView\n * @param lView the lView whose parent to get\n */\nfunction getLViewParent(lView) {\n    ngDevMode && assertLView(lView);\n    const parent = lView[PARENT];\n    return isLContainer(parent) ? parent[PARENT] : parent;\n}\nfunction getOrCreateLViewCleanup(view) {\n    // top level variables should not be exported for performance reasons (PERF_NOTES.md)\n    return (view[CLEANUP] ??= []);\n}\nfunction getOrCreateTViewCleanup(tView) {\n    return (tView.cleanup ??= []);\n}\n/**\n * Saves context for this cleanup function in LView.cleanupInstances.\n *\n * On the first template pass, saves in TView:\n * - Cleanup function\n * - Index of context we just saved in LView.cleanupInstances\n */\nfunction storeCleanupWithContext(tView, lView, context, cleanupFn) {\n    const lCleanup = getOrCreateLViewCleanup(lView);\n    // Historically the `storeCleanupWithContext` was used to register both framework-level and\n    // user-defined cleanup callbacks, but over time those two types of cleanups were separated.\n    // This dev mode checks assures that user-level cleanup callbacks are _not_ stored in data\n    // structures reserved for framework-specific hooks.\n    ngDevMode &&\n        assertDefined(context, 'Cleanup context is mandatory when registering framework-level destroy hooks');\n    lCleanup.push(context);\n    if (tView.firstCreatePass) {\n        getOrCreateTViewCleanup(tView).push(cleanupFn, lCleanup.length - 1);\n    }\n    else {\n        // Make sure that no new framework-level cleanup functions are registered after the first\n        // template pass is done (and TView data structures are meant to fully constructed).\n        if (ngDevMode) {\n            Object.freeze(getOrCreateTViewCleanup(tView));\n        }\n    }\n}\n\nconst instructionState = {\n    lFrame: createLFrame(null),\n    bindingsEnabled: true,\n    skipHydrationRootTNode: null,\n};\nvar CheckNoChangesMode;\n(function (CheckNoChangesMode) {\n    CheckNoChangesMode[CheckNoChangesMode[\"Off\"] = 0] = \"Off\";\n    CheckNoChangesMode[CheckNoChangesMode[\"Exhaustive\"] = 1] = \"Exhaustive\";\n    CheckNoChangesMode[CheckNoChangesMode[\"OnlyDirtyViews\"] = 2] = \"OnlyDirtyViews\";\n})(CheckNoChangesMode || (CheckNoChangesMode = {}));\n/**\n * In this mode, any changes in bindings will throw an ExpressionChangedAfterChecked error.\n *\n * Necessary to support ChangeDetectorRef.checkNoChanges().\n *\n * The `checkNoChanges` function is invoked only in ngDevMode=true and verifies that no unintended\n * changes exist in the change detector or its children.\n */\nlet _checkNoChangesMode = 0; /* CheckNoChangesMode.Off */\n/**\n * Flag used to indicate that we are in the middle running change detection on a view\n *\n * @see detectChangesInViewWhileDirty\n */\nlet _isRefreshingViews = false;\nfunction getElementDepthCount() {\n    return instructionState.lFrame.elementDepthCount;\n}\nfunction increaseElementDepthCount() {\n    instructionState.lFrame.elementDepthCount++;\n}\nfunction decreaseElementDepthCount() {\n    instructionState.lFrame.elementDepthCount--;\n}\nfunction getBindingsEnabled() {\n    return instructionState.bindingsEnabled;\n}\n/**\n * Returns true if currently inside a skip hydration block.\n * @returns boolean\n */\nfunction isInSkipHydrationBlock() {\n    return instructionState.skipHydrationRootTNode !== null;\n}\n/**\n * Returns true if this is the root TNode of the skip hydration block.\n * @param tNode the current TNode\n * @returns boolean\n */\nfunction isSkipHydrationRootTNode(tNode) {\n    return instructionState.skipHydrationRootTNode === tNode;\n}\n/**\n * Enables directive matching on elements.\n *\n *  * Example:\n * ```html\n * <my-comp my-directive>\n *   Should match component / directive.\n * </my-comp>\n * <div ngNonBindable>\n *   <!-- disableBindings() -->\n *   <my-comp my-directive>\n *     Should not match component / directive because we are in ngNonBindable.\n *   </my-comp>\n *   <!-- enableBindings() -->\n * </div>\n * ```\n *\n * @codeGenApi\n */\nfunction enableBindings() {\n    instructionState.bindingsEnabled = true;\n}\n/**\n * Sets a flag to specify that the TNode is in a skip hydration block.\n * @param tNode the current TNode\n */\nfunction enterSkipHydrationBlock(tNode) {\n    instructionState.skipHydrationRootTNode = tNode;\n}\n/**\n * Disables directive matching on element.\n *\n *  * Example:\n * ```html\n * <my-comp my-directive>\n *   Should match component / directive.\n * </my-comp>\n * <div ngNonBindable>\n *   <!-- disableBindings() -->\n *   <my-comp my-directive>\n *     Should not match component / directive because we are in ngNonBindable.\n *   </my-comp>\n *   <!-- enableBindings() -->\n * </div>\n * ```\n *\n * @codeGenApi\n */\nfunction disableBindings() {\n    instructionState.bindingsEnabled = false;\n}\n/**\n * Clears the root skip hydration node when leaving a skip hydration block.\n */\nfunction leaveSkipHydrationBlock() {\n    instructionState.skipHydrationRootTNode = null;\n}\n/**\n * Return the current `LView`.\n */\nfunction getLView() {\n    return instructionState.lFrame.lView;\n}\n/**\n * Return the current `TView`.\n */\nfunction getTView() {\n    return instructionState.lFrame.tView;\n}\n/**\n * Restores `contextViewData` to the given OpaqueViewState instance.\n *\n * Used in conjunction with the getCurrentView() instruction to save a snapshot\n * of the current view and restore it when listeners are invoked. This allows\n * walking the declaration view tree in listeners to get vars from parent views.\n *\n * @param viewToRestore The OpaqueViewState instance to restore.\n * @returns Context of the restored OpaqueViewState instance.\n *\n * @codeGenApi\n */\nfunction restoreView(viewToRestore) {\n    instructionState.lFrame.contextLView = viewToRestore;\n    return viewToRestore[CONTEXT];\n}\n/**\n * Clears the view set in `restoreView` from memory. Returns the passed in\n * value so that it can be used as a return value of an instruction.\n *\n * @codeGenApi\n */\nfunction resetView(value) {\n    instructionState.lFrame.contextLView = null;\n    return value;\n}\nfunction getCurrentTNode() {\n    let currentTNode = getCurrentTNodePlaceholderOk();\n    while (currentTNode !== null && currentTNode.type === 64 /* TNodeType.Placeholder */) {\n        currentTNode = currentTNode.parent;\n    }\n    return currentTNode;\n}\nfunction getCurrentTNodePlaceholderOk() {\n    return instructionState.lFrame.currentTNode;\n}\nfunction getCurrentParentTNode() {\n    const lFrame = instructionState.lFrame;\n    const currentTNode = lFrame.currentTNode;\n    return lFrame.isParent ? currentTNode : currentTNode.parent;\n}\nfunction setCurrentTNode(tNode, isParent) {\n    ngDevMode && tNode && assertTNodeForTView(tNode, instructionState.lFrame.tView);\n    const lFrame = instructionState.lFrame;\n    lFrame.currentTNode = tNode;\n    lFrame.isParent = isParent;\n}\nfunction isCurrentTNodeParent() {\n    return instructionState.lFrame.isParent;\n}\nfunction setCurrentTNodeAsNotParent() {\n    instructionState.lFrame.isParent = false;\n}\nfunction getContextLView() {\n    const contextLView = instructionState.lFrame.contextLView;\n    ngDevMode && assertDefined(contextLView, 'contextLView must be defined.');\n    return contextLView;\n}\nfunction isInCheckNoChangesMode() {\n    !ngDevMode && throwError('Must never be called in production mode');\n    return _checkNoChangesMode !== CheckNoChangesMode.Off;\n}\nfunction isExhaustiveCheckNoChanges() {\n    !ngDevMode && throwError('Must never be called in production mode');\n    return _checkNoChangesMode === CheckNoChangesMode.Exhaustive;\n}\nfunction setIsInCheckNoChangesMode(mode) {\n    !ngDevMode && throwError('Must never be called in production mode');\n    _checkNoChangesMode = mode;\n}\nfunction isRefreshingViews() {\n    return _isRefreshingViews;\n}\nfunction setIsRefreshingViews(mode) {\n    const prev = _isRefreshingViews;\n    _isRefreshingViews = mode;\n    return prev;\n}\n// top level variables should not be exported for performance reasons (PERF_NOTES.md)\nfunction getBindingRoot() {\n    const lFrame = instructionState.lFrame;\n    let index = lFrame.bindingRootIndex;\n    if (index === -1) {\n        index = lFrame.bindingRootIndex = lFrame.tView.bindingStartIndex;\n    }\n    return index;\n}\nfunction getBindingIndex() {\n    return instructionState.lFrame.bindingIndex;\n}\nfunction setBindingIndex(value) {\n    return (instructionState.lFrame.bindingIndex = value);\n}\nfunction nextBindingIndex() {\n    return instructionState.lFrame.bindingIndex++;\n}\nfunction incrementBindingIndex(count) {\n    const lFrame = instructionState.lFrame;\n    const index = lFrame.bindingIndex;\n    lFrame.bindingIndex = lFrame.bindingIndex + count;\n    return index;\n}\nfunction isInI18nBlock() {\n    return instructionState.lFrame.inI18n;\n}\nfunction setInI18nBlock(isInI18nBlock) {\n    instructionState.lFrame.inI18n = isInI18nBlock;\n}\n/**\n * Set a new binding root index so that host template functions can execute.\n *\n * Bindings inside the host template are 0 index. But because we don't know ahead of time\n * how many host bindings we have we can't pre-compute them. For this reason they are all\n * 0 index and we just shift the root so that they match next available location in the LView.\n *\n * @param bindingRootIndex Root index for `hostBindings`\n * @param currentDirectiveIndex `TData[currentDirectiveIndex]` will point to the current directive\n *        whose `hostBindings` are being processed.\n */\nfunction setBindingRootForHostBindings(bindingRootIndex, currentDirectiveIndex) {\n    const lFrame = instructionState.lFrame;\n    lFrame.bindingIndex = lFrame.bindingRootIndex = bindingRootIndex;\n    setCurrentDirectiveIndex(currentDirectiveIndex);\n}\n/**\n * When host binding is executing this points to the directive index.\n * `TView.data[getCurrentDirectiveIndex()]` is `DirectiveDef`\n * `LView[getCurrentDirectiveIndex()]` is directive instance.\n */\nfunction getCurrentDirectiveIndex() {\n    return instructionState.lFrame.currentDirectiveIndex;\n}\n/**\n * Sets an index of a directive whose `hostBindings` are being processed.\n *\n * @param currentDirectiveIndex `TData` index where current directive instance can be found.\n */\nfunction setCurrentDirectiveIndex(currentDirectiveIndex) {\n    instructionState.lFrame.currentDirectiveIndex = currentDirectiveIndex;\n}\n/**\n * Retrieve the current `DirectiveDef` which is active when `hostBindings` instruction is being\n * executed.\n *\n * @param tData Current `TData` where the `DirectiveDef` will be looked up at.\n */\nfunction getCurrentDirectiveDef(tData) {\n    const currentDirectiveIndex = instructionState.lFrame.currentDirectiveIndex;\n    return currentDirectiveIndex === -1 ? null : tData[currentDirectiveIndex];\n}\nfunction getCurrentQueryIndex() {\n    return instructionState.lFrame.currentQueryIndex;\n}\nfunction setCurrentQueryIndex(value) {\n    instructionState.lFrame.currentQueryIndex = value;\n}\n/**\n * Returns a `TNode` of the location where the current `LView` is declared at.\n *\n * @param lView an `LView` that we want to find parent `TNode` for.\n */\nfunction getDeclarationTNode(lView) {\n    const tView = lView[TVIEW];\n    // Return the declaration parent for embedded views\n    if (tView.type === 2 /* TViewType.Embedded */) {\n        ngDevMode && assertDefined(tView.declTNode, 'Embedded TNodes should have declaration parents.');\n        return tView.declTNode;\n    }\n    // Components don't have `TView.declTNode` because each instance of component could be\n    // inserted in different location, hence `TView.declTNode` is meaningless.\n    // Falling back to `T_HOST` in case we cross component boundary.\n    if (tView.type === 1 /* TViewType.Component */) {\n        return lView[T_HOST];\n    }\n    // Remaining TNode type is `TViewType.Root` which doesn't have a parent TNode.\n    return null;\n}\n/**\n * This is a light weight version of the `enterView` which is needed by the DI system.\n *\n * @param lView `LView` location of the DI context.\n * @param tNode `TNode` for DI context\n * @param flags DI context flags. if `SkipSelf` flag is set than we walk up the declaration\n *     tree from `tNode`  until we find parent declared `TElementNode`.\n * @returns `true` if we have successfully entered DI associated with `tNode` (or with declared\n *     `TNode` if `flags` has  `SkipSelf`). Failing to enter DI implies that no associated\n *     `NodeInjector` can be found and we should instead use `ModuleInjector`.\n *     - If `true` than this call must be fallowed by `leaveDI`\n *     - If `false` than this call failed and we should NOT call `leaveDI`\n */\nfunction enterDI(lView, tNode, flags) {\n    ngDevMode && assertLViewOrUndefined(lView);\n    if (flags & 4 /* InternalInjectFlags.SkipSelf */) {\n        ngDevMode && assertTNodeForTView(tNode, lView[TVIEW]);\n        let parentTNode = tNode;\n        let parentLView = lView;\n        while (true) {\n            ngDevMode && assertDefined(parentTNode, 'Parent TNode should be defined');\n            parentTNode = parentTNode.parent;\n            if (parentTNode === null && !(flags & 1 /* InternalInjectFlags.Host */)) {\n                parentTNode = getDeclarationTNode(parentLView);\n                if (parentTNode === null)\n                    break;\n                // In this case, a parent exists and is definitely an element. So it will definitely\n                // have an existing lView as the declaration view, which is why we can assume it's defined.\n                ngDevMode && assertDefined(parentLView, 'Parent LView should be defined');\n                parentLView = parentLView[DECLARATION_VIEW];\n                // In Ivy there are Comment nodes that correspond to ngIf and NgFor embedded directives\n                // We want to skip those and look only at Elements and ElementContainers to ensure\n                // we're looking at true parent nodes, and not content or other types.\n                if (parentTNode.type & (2 /* TNodeType.Element */ | 8 /* TNodeType.ElementContainer */)) {\n                    break;\n                }\n            }\n            else {\n                break;\n            }\n        }\n        if (parentTNode === null) {\n            // If we failed to find a parent TNode this means that we should use module injector.\n            return false;\n        }\n        else {\n            tNode = parentTNode;\n            lView = parentLView;\n        }\n    }\n    ngDevMode && assertTNodeForLView(tNode, lView);\n    const lFrame = (instructionState.lFrame = allocLFrame());\n    lFrame.currentTNode = tNode;\n    lFrame.lView = lView;\n    return true;\n}\n/**\n * Swap the current lView with a new lView.\n *\n * For performance reasons we store the lView in the top level of the module.\n * This way we minimize the number of properties to read. Whenever a new view\n * is entered we have to store the lView for later, and when the view is\n * exited the state has to be restored\n *\n * @param newView New lView to become active\n * @returns the previously active lView;\n */\nfunction enterView(newView) {\n    ngDevMode && assertNotEqual(newView[0], newView[1], '????');\n    ngDevMode && assertLViewOrUndefined(newView);\n    const newLFrame = allocLFrame();\n    if (ngDevMode) {\n        assertEqual(newLFrame.isParent, true, 'Expected clean LFrame');\n        assertEqual(newLFrame.lView, null, 'Expected clean LFrame');\n        assertEqual(newLFrame.tView, null, 'Expected clean LFrame');\n        assertEqual(newLFrame.selectedIndex, -1, 'Expected clean LFrame');\n        assertEqual(newLFrame.elementDepthCount, 0, 'Expected clean LFrame');\n        assertEqual(newLFrame.currentDirectiveIndex, -1, 'Expected clean LFrame');\n        assertEqual(newLFrame.currentNamespace, null, 'Expected clean LFrame');\n        assertEqual(newLFrame.bindingRootIndex, -1, 'Expected clean LFrame');\n        assertEqual(newLFrame.currentQueryIndex, 0, 'Expected clean LFrame');\n    }\n    const tView = newView[TVIEW];\n    instructionState.lFrame = newLFrame;\n    ngDevMode && tView.firstChild && assertTNodeForTView(tView.firstChild, tView);\n    newLFrame.currentTNode = tView.firstChild;\n    newLFrame.lView = newView;\n    newLFrame.tView = tView;\n    newLFrame.contextLView = newView;\n    newLFrame.bindingIndex = tView.bindingStartIndex;\n    newLFrame.inI18n = false;\n}\n/**\n * Allocates next free LFrame. This function tries to reuse the `LFrame`s to lower memory pressure.\n */\nfunction allocLFrame() {\n    const currentLFrame = instructionState.lFrame;\n    const childLFrame = currentLFrame === null ? null : currentLFrame.child;\n    const newLFrame = childLFrame === null ? createLFrame(currentLFrame) : childLFrame;\n    return newLFrame;\n}\nfunction createLFrame(parent) {\n    const lFrame = {\n        currentTNode: null,\n        isParent: true,\n        lView: null,\n        tView: null,\n        selectedIndex: -1,\n        contextLView: null,\n        elementDepthCount: 0,\n        currentNamespace: null,\n        currentDirectiveIndex: -1,\n        bindingRootIndex: -1,\n        bindingIndex: -1,\n        currentQueryIndex: 0,\n        parent: parent,\n        child: null,\n        inI18n: false,\n    };\n    parent !== null && (parent.child = lFrame); // link the new LFrame for reuse.\n    return lFrame;\n}\n/**\n * A lightweight version of leave which is used with DI.\n *\n * This function only resets `currentTNode` and `LView` as those are the only properties\n * used with DI (`enterDI()`).\n *\n * NOTE: This function is reexported as `leaveDI`. However `leaveDI` has return type of `void` where\n * as `leaveViewLight` has `LFrame`. This is so that `leaveViewLight` can be used in `leaveView`.\n */\nfunction leaveViewLight() {\n    const oldLFrame = instructionState.lFrame;\n    instructionState.lFrame = oldLFrame.parent;\n    oldLFrame.currentTNode = null;\n    oldLFrame.lView = null;\n    return oldLFrame;\n}\n/**\n * This is a lightweight version of the `leaveView` which is needed by the DI system.\n *\n * NOTE: this function is an alias so that we can change the type of the function to have `void`\n * return type.\n */\nconst leaveDI = leaveViewLight;\n/**\n * Leave the current `LView`\n *\n * This pops the `LFrame` with the associated `LView` from the stack.\n *\n * IMPORTANT: We must zero out the `LFrame` values here otherwise they will be retained. This is\n * because for performance reasons we don't release `LFrame` but rather keep it for next use.\n */\nfunction leaveView() {\n    const oldLFrame = leaveViewLight();\n    oldLFrame.isParent = true;\n    oldLFrame.tView = null;\n    oldLFrame.selectedIndex = -1;\n    oldLFrame.contextLView = null;\n    oldLFrame.elementDepthCount = 0;\n    oldLFrame.currentDirectiveIndex = -1;\n    oldLFrame.currentNamespace = null;\n    oldLFrame.bindingRootIndex = -1;\n    oldLFrame.bindingIndex = -1;\n    oldLFrame.currentQueryIndex = 0;\n}\nfunction nextContextImpl(level) {\n    const contextLView = (instructionState.lFrame.contextLView = walkUpViews(level, instructionState.lFrame.contextLView));\n    return contextLView[CONTEXT];\n}\n/**\n * Gets the currently selected element index.\n *\n * Used with {@link property} instruction (and more in the future) to identify the index in the\n * current `LView` to act on.\n */\nfunction getSelectedIndex() {\n    return instructionState.lFrame.selectedIndex;\n}\n/**\n * Sets the most recent index passed to {@link select}\n *\n * Used with {@link property} instruction (and more in the future) to identify the index in the\n * current `LView` to act on.\n *\n * (Note that if an \"exit function\" was set earlier (via `setElementExitFn()`) then that will be\n * run if and when the provided `index` value is different from the current selected index value.)\n */\nfunction setSelectedIndex(index) {\n    ngDevMode &&\n        index !== -1 &&\n        assertGreaterThanOrEqual(index, HEADER_OFFSET, 'Index must be past HEADER_OFFSET (or -1).');\n    ngDevMode &&\n        assertLessThan(index, instructionState.lFrame.lView.length, \"Can't set index passed end of LView\");\n    instructionState.lFrame.selectedIndex = index;\n}\n/**\n * Gets the `tNode` that represents currently selected element.\n */\nfunction getSelectedTNode() {\n    const lFrame = instructionState.lFrame;\n    return getTNode(lFrame.tView, lFrame.selectedIndex);\n}\n/**\n * Sets the namespace used to create elements to `'http://www.w3.org/2000/svg'` in global state.\n *\n * @codeGenApi\n */\nfunction namespaceSVG() {\n    instructionState.lFrame.currentNamespace = SVG_NAMESPACE;\n}\n/**\n * Sets the namespace used to create elements to `'http://www.w3.org/1998/MathML/'` in global state.\n *\n * @codeGenApi\n */\nfunction namespaceMathML() {\n    instructionState.lFrame.currentNamespace = MATH_ML_NAMESPACE;\n}\n/**\n * Sets the namespace used to create elements to `null`, which forces element creation to use\n * `createElement` rather than `createElementNS`.\n *\n * @codeGenApi\n */\nfunction namespaceHTML() {\n    namespaceHTMLInternal();\n}\n/**\n * Sets the namespace used to create elements to `null`, which forces element creation to use\n * `createElement` rather than `createElementNS`.\n */\nfunction namespaceHTMLInternal() {\n    instructionState.lFrame.currentNamespace = null;\n}\nfunction getNamespace() {\n    return instructionState.lFrame.currentNamespace;\n}\nlet _wasLastNodeCreated = true;\n/**\n * Retrieves a global flag that indicates whether the most recent DOM node\n * was created or hydrated.\n */\nfunction wasLastNodeCreated() {\n    return _wasLastNodeCreated;\n}\n/**\n * Sets a global flag to indicate whether the most recent DOM node\n * was created or hydrated.\n */\nfunction lastNodeWasCreated(flag) {\n    _wasLastNodeCreated = flag;\n}\n\n/**\n * Create a new `Injector` which is configured using a `defType` of `InjectorType<any>`s.\n */\nfunction createInjector(defType, parent = null, additionalProviders = null, name) {\n    const injector = createInjectorWithoutInjectorInstances(defType, parent, additionalProviders, name);\n    injector.resolveInjectorInitializers();\n    return injector;\n}\n/**\n * Creates a new injector without eagerly resolving its injector types. Can be used in places\n * where resolving the injector types immediately can lead to an infinite loop. The injector types\n * should be resolved at a later point by calling `_resolveInjectorDefTypes`.\n */\nfunction createInjectorWithoutInjectorInstances(defType, parent = null, additionalProviders = null, name, scopes = new Set()) {\n    const providers = [additionalProviders || EMPTY_ARRAY, importProvidersFrom(defType)];\n    name = name || (typeof defType === 'object' ? undefined : stringify(defType));\n    return new R3Injector(providers, parent || getNullInjector(), name || null, scopes);\n}\n\n/**\n * Concrete injectors implement this interface. Injectors are configured\n * with [providers](guide/di/dependency-injection-providers) that associate\n * dependencies of various types with [injection tokens](guide/di/dependency-injection-providers).\n *\n * @see [DI Providers](guide/di/dependency-injection-providers).\n * @see {@link StaticProvider}\n *\n * @usageNotes\n *\n *  The following example creates a service injector instance.\n *\n * {@example core/di/ts/provider_spec.ts region='ConstructorProvider'}\n *\n * ### Usage example\n *\n * {@example core/di/ts/injector_spec.ts region='Injector'}\n *\n * `Injector` returns itself when given `Injector` as a token:\n *\n * {@example core/di/ts/injector_spec.ts region='injectInjector'}\n *\n * @publicApi\n */\nclass Injector {\n    static THROW_IF_NOT_FOUND = THROW_IF_NOT_FOUND;\n    static NULL = new NullInjector();\n    static create(options, parent) {\n        if (Array.isArray(options)) {\n            return createInjector({ name: '' }, parent, options, '');\n        }\n        else {\n            const name = options.name ?? '';\n            return createInjector({ name }, options.parent, options.providers, name);\n        }\n    }\n    /** @nocollapse */\n    static prov = /** @pureOrBreakMyCode */ /* @__PURE__ */ defineInjectable({\n        token: Injector,\n        providedIn: 'any',\n        factory: () => inject(INJECTOR$1),\n    });\n    /**\n     * @internal\n     * @nocollapse\n     */\n    static __NG_ELEMENT_ID__ = -1 /* InjectorMarkers.Injector */;\n}\n\n/**\n * A DI Token representing the main rendering context.\n * In a browser and SSR this is the DOM Document.\n * When using SSR, that document is created by [Domino](https://github.com/angular/domino).\n *\n * @publicApi\n */\nconst DOCUMENT = new InjectionToken(ngDevMode ? 'DocumentToken' : '');\n\n/**\n * `DestroyRef` lets you set callbacks to run for any cleanup or destruction behavior.\n * The scope of this destruction depends on where `DestroyRef` is injected. If `DestroyRef`\n * is injected in a component or directive, the callbacks run when that component or\n * directive is destroyed. Otherwise the callbacks run when a corresponding injector is destroyed.\n *\n * @publicApi\n */\nclass DestroyRef {\n    /**\n     * @internal\n     * @nocollapse\n     */\n    static __NG_ELEMENT_ID__ = injectDestroyRef;\n    /**\n     * @internal\n     * @nocollapse\n     */\n    static __NG_ENV_ID__ = (injector) => injector;\n}\nclass NodeInjectorDestroyRef extends DestroyRef {\n    _lView;\n    constructor(_lView) {\n        super();\n        this._lView = _lView;\n    }\n    get destroyed() {\n        return isDestroyed(this._lView);\n    }\n    onDestroy(callback) {\n        const lView = this._lView;\n        storeLViewOnDestroy(lView, callback);\n        return () => removeLViewOnDestroy(lView, callback);\n    }\n}\nfunction injectDestroyRef() {\n    return new NodeInjectorDestroyRef(getLView());\n}\n\n/**\n * Provides a hook for centralized exception handling.\n *\n * The default implementation of `ErrorHandler` prints error messages to the `console`. To\n * intercept error handling, write a custom exception handler that replaces this default as\n * appropriate for your app.\n *\n * @usageNotes\n * ### Example\n *\n * ```ts\n * class MyErrorHandler implements ErrorHandler {\n *   handleError(error) {\n *     // do something with the exception\n *   }\n * }\n *\n * // Provide in standalone apps\n * bootstrapApplication(AppComponent, {\n *   providers: [{provide: ErrorHandler, useClass: MyErrorHandler}]\n * })\n *\n * // Provide in module-based apps\n * @NgModule({\n *   providers: [{provide: ErrorHandler, useClass: MyErrorHandler}]\n * })\n * class MyModule {}\n * ```\n *\n * @publicApi\n *\n * @see [Unhandled errors in Angular](best-practices/error-handling)\n *\n */\nclass ErrorHandler {\n    /**\n     * @internal\n     */\n    _console = console;\n    handleError(error) {\n        this._console.error('ERROR', error);\n    }\n}\n/**\n * `InjectionToken` used to configure how to call the `ErrorHandler`.\n */\nconst INTERNAL_APPLICATION_ERROR_HANDLER = new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'internal error handler' : '', {\n    providedIn: 'root',\n    factory: () => {\n        // The user's error handler may depend on things that create a circular dependency\n        // so we inject it lazily.\n        const injector = inject(EnvironmentInjector);\n        let userErrorHandler;\n        return (e) => {\n            if (injector.destroyed && !userErrorHandler) {\n                setTimeout(() => {\n                    throw e;\n                });\n            }\n            else {\n                userErrorHandler ??= injector.get(ErrorHandler);\n                userErrorHandler.handleError(e);\n            }\n        };\n    },\n});\nconst errorHandlerEnvironmentInitializer = {\n    provide: ENVIRONMENT_INITIALIZER,\n    useValue: () => void inject(ErrorHandler),\n    multi: true,\n};\nconst globalErrorListeners = new InjectionToken(ngDevMode ? 'GlobalErrorListeners' : '', {\n    providedIn: 'root',\n    factory: () => {\n        if (typeof ngServerMode !== 'undefined' && ngServerMode) {\n            return;\n        }\n        const window = inject(DOCUMENT).defaultView;\n        if (!window) {\n            return;\n        }\n        const errorHandler = inject(INTERNAL_APPLICATION_ERROR_HANDLER);\n        const rejectionListener = (e) => {\n            errorHandler(e.reason);\n            e.preventDefault();\n        };\n        const errorListener = (e) => {\n            if (e.error) {\n                errorHandler(e.error);\n            }\n            else {\n                errorHandler(new Error(ngDevMode\n                    ? `An ErrorEvent with no error occurred. See Error.cause for details: ${e.message}`\n                    : e.message, { cause: e }));\n            }\n            e.preventDefault();\n        };\n        const setupEventListeners = () => {\n            window.addEventListener('unhandledrejection', rejectionListener);\n            window.addEventListener('error', errorListener);\n        };\n        // Angular doesn't have to run change detection whenever any asynchronous tasks are invoked in\n        // the scope of this functionality.\n        if (typeof Zone !== 'undefined') {\n            Zone.root.run(setupEventListeners);\n        }\n        else {\n            setupEventListeners();\n        }\n        inject(DestroyRef).onDestroy(() => {\n            window.removeEventListener('error', errorListener);\n            window.removeEventListener('unhandledrejection', rejectionListener);\n        });\n    },\n});\n/**\n * Provides an environment initializer which forwards unhandled errors to the ErrorHandler.\n *\n * The listeners added are for the window's 'unhandledrejection' and 'error' events.\n *\n * @publicApi\n */\nfunction provideBrowserGlobalErrorListeners() {\n    return makeEnvironmentProviders([\n        provideEnvironmentInitializer(() => void inject(globalErrorListeners)),\n    ]);\n}\n\n/**\n * Checks if the given `value` is a reactive `Signal`.\n *\n * @publicApi 17.0\n */\nfunction isSignal(value) {\n    return typeof value === 'function' && value[SIGNAL] !== undefined;\n}\n\n/**\n * Utility function used during template type checking to extract the value from a `WritableSignal`.\n * @codeGenApi\n */\nfunction unwrapWritableSignal(value) {\n    // Note: the function uses `WRITABLE_SIGNAL` as a brand instead of `WritableSignal<T>`,\n    // because the latter incorrectly unwraps non-signal getter functions.\n    return null;\n}\n/**\n * Create a `Signal` that can be set or updated directly.\n */\nfunction signal(initialValue, options) {\n    const [get, set, update] = createSignal(initialValue, options?.equal);\n    const signalFn = get;\n    const node = signalFn[SIGNAL];\n    signalFn.set = set;\n    signalFn.update = update;\n    signalFn.asReadonly = signalAsReadonlyFn.bind(signalFn);\n    if (ngDevMode) {\n        signalFn.toString = () => `[Signal: ${signalFn()}]`;\n        node.debugName = options?.debugName;\n    }\n    return signalFn;\n}\nfunction signalAsReadonlyFn() {\n    const node = this[SIGNAL];\n    if (node.readonlyFn === undefined) {\n        const readonlyFn = () => this();\n        readonlyFn[SIGNAL] = node;\n        node.readonlyFn = readonlyFn;\n    }\n    return node.readonlyFn;\n}\n/**\n * Checks if the given `value` is a writeable signal.\n */\nfunction isWritableSignal(value) {\n    return isSignal(value) && typeof value.set === 'function';\n}\n\n/**\n * Asserts that the current stack frame is not within a reactive context. Useful\n * to disallow certain code from running inside a reactive context (see {@link /api/core/rxjs-interop/toSignal toSignal})\n *\n * @param debugFn a reference to the function making the assertion (used for the error message).\n *\n * @publicApi\n */\nfunction assertNotInReactiveContext(debugFn, extraContext) {\n    // Taking a `Function` instead of a string name here prevents the un-minified name of the function\n    // from being retained in the bundle regardless of minification.\n    if (getActiveConsumer() !== null) {\n        throw new RuntimeError(-602 /* RuntimeErrorCode.ASSERTION_NOT_INSIDE_REACTIVE_CONTEXT */, ngDevMode &&\n            `${debugFn.name}() cannot be called from within a reactive context.${extraContext ? ` ${extraContext}` : ''}`);\n    }\n}\n\nclass ViewContext {\n    view;\n    node;\n    constructor(view, node) {\n        this.view = view;\n        this.node = node;\n    }\n    /**\n     * @internal\n     * @nocollapse\n     */\n    static __NG_ELEMENT_ID__ = injectViewContext;\n}\nfunction injectViewContext() {\n    return new ViewContext(getLView(), getCurrentTNode());\n}\n\n/**\n * Injectable that is notified when an `LView` is made aware of changes to application state.\n */\nclass ChangeDetectionScheduler {\n}\n/** Token used to indicate if zoneless was enabled via provideZonelessChangeDetection(). */\nconst ZONELESS_ENABLED = new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'Zoneless enabled' : '', { providedIn: 'root', factory: () => false });\n/** Token used to indicate `provideZonelessChangeDetection` was used. */\nconst PROVIDED_ZONELESS = new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'Zoneless provided' : '', { providedIn: 'root', factory: () => false });\nconst ZONELESS_SCHEDULER_DISABLED = new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'scheduler disabled' : '');\n// TODO(atscott): Remove in v19. Scheduler should be done with runOutsideAngular.\nconst SCHEDULE_IN_ROOT_ZONE = new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'run changes outside zone in root' : '');\n\n/**\n * Internal implementation of the pending tasks service.\n */\nclass PendingTasksInternal {\n    taskId = 0;\n    pendingTasks = new Set();\n    destroyed = false;\n    pendingTask = new BehaviorSubject(false);\n    get hasPendingTasks() {\n        // Accessing the value of a closed `BehaviorSubject` throws an error.\n        return this.destroyed ? false : this.pendingTask.value;\n    }\n    /**\n     * In case the service is about to be destroyed, return a self-completing observable.\n     * Otherwise, return the observable that emits the current state of pending tasks.\n     */\n    get hasPendingTasksObservable() {\n        if (this.destroyed) {\n            // Manually creating the observable pulls less symbols from RxJS than `of(false)`.\n            return new Observable((subscriber) => {\n                subscriber.next(false);\n                subscriber.complete();\n            });\n        }\n        return this.pendingTask;\n    }\n    add() {\n        // Emitting a value to a closed subject throws an error.\n        if (!this.hasPendingTasks && !this.destroyed) {\n            this.pendingTask.next(true);\n        }\n        const taskId = this.taskId++;\n        this.pendingTasks.add(taskId);\n        return taskId;\n    }\n    has(taskId) {\n        return this.pendingTasks.has(taskId);\n    }\n    remove(taskId) {\n        this.pendingTasks.delete(taskId);\n        if (this.pendingTasks.size === 0 && this.hasPendingTasks) {\n            this.pendingTask.next(false);\n        }\n    }\n    ngOnDestroy() {\n        this.pendingTasks.clear();\n        if (this.hasPendingTasks) {\n            this.pendingTask.next(false);\n        }\n        // We call `unsubscribe()` to release observers, as users may forget to\n        // unsubscribe manually when subscribing to `isStable`. We do not call\n        // `complete()` because it is unsafe; if someone subscribes using the `first`\n        // operator and the observable completes before emitting a value,\n        // RxJS will throw an error.\n        this.destroyed = true;\n        this.pendingTask.unsubscribe();\n    }\n    /** @nocollapse */\n    static prov = /** @pureOrBreakMyCode */ /* @__PURE__ */ defineInjectable({\n        token: PendingTasksInternal,\n        providedIn: 'root',\n        factory: () => new PendingTasksInternal(),\n    });\n}\n/**\n * Service that keeps track of pending tasks contributing to the stableness of Angular\n * application. While several existing Angular services (ex.: `HttpClient`) will internally manage\n * tasks influencing stability, this API gives control over stability to library and application\n * developers for specific cases not covered by Angular internals.\n *\n * The concept of stability comes into play in several important scenarios:\n * - SSR process needs to wait for the application stability before serializing and sending rendered\n * HTML;\n * - tests might want to delay assertions until the application becomes stable;\n *\n * @usageNotes\n * ```ts\n * const pendingTasks = inject(PendingTasks);\n * const taskCleanup = pendingTasks.add();\n * // do work that should block application's stability and then:\n * taskCleanup();\n * ```\n *\n * @publicApi 20.0\n */\nclass PendingTasks {\n    internalPendingTasks = inject(PendingTasksInternal);\n    scheduler = inject(ChangeDetectionScheduler);\n    errorHandler = inject(INTERNAL_APPLICATION_ERROR_HANDLER);\n    /**\n     * Adds a new task that should block application's stability.\n     * @returns A cleanup function that removes a task when called.\n     */\n    add() {\n        const taskId = this.internalPendingTasks.add();\n        return () => {\n            if (!this.internalPendingTasks.has(taskId)) {\n                // This pending task has already been cleared.\n                return;\n            }\n            // Notifying the scheduler will hold application stability open until the next tick.\n            this.scheduler.notify(11 /* NotificationSource.PendingTaskRemoved */);\n            this.internalPendingTasks.remove(taskId);\n        };\n    }\n    /**\n     * Runs an asynchronous function and blocks the application's stability until the function completes.\n     *\n     * ```ts\n     * pendingTasks.run(async () => {\n     *   const userData = await fetch('/api/user');\n     *   this.userData.set(userData);\n     * });\n     * ```\n     *\n     * @param fn The asynchronous function to execute\n     * @developerPreview 19.0\n     */\n    run(fn) {\n        const removeTask = this.add();\n        fn().catch(this.errorHandler).finally(removeTask);\n    }\n    /** @nocollapse */\n    static prov = /** @pureOrBreakMyCode */ /* @__PURE__ */ defineInjectable({\n        token: PendingTasks,\n        providedIn: 'root',\n        factory: () => new PendingTasks(),\n    });\n}\n\nfunction noop(...args) {\n    // Do nothing.\n}\n\n/**\n * A scheduler which manages the execution of effects.\n */\nclass EffectScheduler {\n    /** @nocollapse */\n    static prov = /** @pureOrBreakMyCode */ /* @__PURE__ */ defineInjectable({\n        token: EffectScheduler,\n        providedIn: 'root',\n        factory: () => new ZoneAwareEffectScheduler(),\n    });\n}\n/**\n * A wrapper around `ZoneAwareQueueingScheduler` that schedules flushing via the microtask queue\n * when.\n */\nclass ZoneAwareEffectScheduler {\n    dirtyEffectCount = 0;\n    queues = new Map();\n    add(handle) {\n        this.enqueue(handle);\n        this.schedule(handle);\n    }\n    schedule(handle) {\n        if (!handle.dirty) {\n            return;\n        }\n        this.dirtyEffectCount++;\n    }\n    remove(handle) {\n        const zone = handle.zone;\n        const queue = this.queues.get(zone);\n        if (!queue.has(handle)) {\n            return;\n        }\n        queue.delete(handle);\n        if (handle.dirty) {\n            this.dirtyEffectCount--;\n        }\n    }\n    enqueue(handle) {\n        const zone = handle.zone;\n        if (!this.queues.has(zone)) {\n            this.queues.set(zone, new Set());\n        }\n        const queue = this.queues.get(zone);\n        if (queue.has(handle)) {\n            return;\n        }\n        queue.add(handle);\n    }\n    /**\n     * Run all scheduled effects.\n     *\n     * Execution order of effects within the same zone is guaranteed to be FIFO, but there is no\n     * ordering guarantee between effects scheduled in different zones.\n     */\n    flush() {\n        while (this.dirtyEffectCount > 0) {\n            let ranOneEffect = false;\n            for (const [zone, queue] of this.queues) {\n                // `zone` here must be defined.\n                if (zone === null) {\n                    ranOneEffect ||= this.flushQueue(queue);\n                }\n                else {\n                    ranOneEffect ||= zone.run(() => this.flushQueue(queue));\n                }\n            }\n            // Safeguard against infinite looping if somehow our dirty effect count gets out of sync with\n            // the dirty flag across all the effects.\n            if (!ranOneEffect) {\n                this.dirtyEffectCount = 0;\n            }\n        }\n    }\n    flushQueue(queue) {\n        let ranOneEffect = false;\n        for (const handle of queue) {\n            if (!handle.dirty) {\n                continue;\n            }\n            this.dirtyEffectCount--;\n            ranOneEffect = true;\n            // TODO: what happens if this throws an error?\n            handle.run();\n        }\n        return ranOneEffect;\n    }\n}\n\nexport { AFTER_RENDER_SEQUENCES_TO_ADD, ANIMATIONS, CHILD_HEAD, CHILD_TAIL, CLEANUP, CONTAINER_HEADER_OFFSET, CONTEXT, ChangeDetectionScheduler, CheckNoChangesMode, DECLARATION_COMPONENT_VIEW, DECLARATION_LCONTAINER, DECLARATION_VIEW, DEHYDRATED_VIEWS, DOCUMENT, DestroyRef, EFFECTS, EFFECTS_TO_SCHEDULE, EMBEDDED_VIEW_INJECTOR, EMPTY_ARRAY, EMPTY_OBJ, ENVIRONMENT, ENVIRONMENT_INITIALIZER, EffectScheduler, EnvironmentInjector, ErrorHandler, FLAGS, HEADER_OFFSET, HOST, HYDRATION, ID, INJECTOR$1 as INJECTOR, INJECTOR as INJECTOR$1, INJECTOR_DEF_TYPES, INJECTOR_SCOPE, INTERNAL_APPLICATION_ERROR_HANDLER, InjectionToken, Injector, MATH_ML_NAMESPACE, MOVED_VIEWS, NATIVE, NEXT, NG_COMP_DEF, NG_DIR_DEF, NG_ELEMENT_ID, NG_FACTORY_DEF, NG_INJ_DEF, NG_MOD_DEF, NG_PIPE_DEF, NG_PROV_DEF, NodeInjectorDestroyRef, NullInjector, ON_DESTROY_HOOKS, PARENT, PREORDER_HOOK_FLAGS, PROVIDED_ZONELESS, PendingTasks, PendingTasksInternal, QUERIES, R3Injector, REACTIVE_TEMPLATE_CONSUMER, RENDERER, RuntimeError, SCHEDULE_IN_ROOT_ZONE, SVG_NAMESPACE, TVIEW, T_HOST, VERSION, VIEW_REFS, Version, ViewContext, XSS_SECURITY_URL, ZONELESS_ENABLED, ZONELESS_SCHEDULER_DISABLED, _global, addToArray, arrayEquals, arrayInsert2, arraySplice, assertComponentType, assertDefined, assertDirectiveDef, assertDomNode, assertElement, assertEqual, assertFirstCreatePass, assertFirstUpdatePass, assertFunction, assertGreaterThan, assertGreaterThanOrEqual, assertHasParent, assertInInjectionContext, assertIndexInDeclRange, assertIndexInExpandoRange, assertIndexInRange, assertInjectImplementationNotEqual, assertLContainer, assertLView, assertLessThan, assertNgModuleType, assertNodeInjector, assertNotDefined, assertNotEqual, assertNotInReactiveContext, assertNotReactive, assertNotSame, assertNumber, assertNumberInRange, assertOneOf, assertParentView, assertProjectionSlots, assertSame, assertString, assertTIcu, assertTNode, assertTNodeCreationIndex, assertTNodeForLView, assertTNodeForTView, attachInjectFlag, concatStringsWithSpace, convertToBitFlags, createInjector, createInjectorWithoutInjectorInstances, cyclicDependencyError, cyclicDependencyErrorWithDetails, debugStringifyTypeForError, decreaseElementDepthCount, deepForEach, defineInjectable, emitEffectCreatedEvent, emitInjectEvent, emitInjectorToCreateInstanceEvent, emitInstanceCreatedByInjectorEvent, emitProviderConfiguredEvent, enterDI, enterSkipHydrationBlock, enterView, errorHandlerEnvironmentInitializer, fillProperties, flatten, formatRuntimeError, forwardRef, getBindingIndex, getBindingRoot, getBindingsEnabled, getClosureSafeProperty, getComponentDef, getComponentLViewByIndex, getConstant, getContextLView, getCurrentDirectiveDef, getCurrentDirectiveIndex, getCurrentParentTNode, getCurrentQueryIndex, getCurrentTNode, getCurrentTNodePlaceholderOk, getDirectiveDef, getDirectiveDefOrThrow, getElementDepthCount, getFactoryDef, getInjectableDef, getInjectorDef, getLView, getLViewParent, getNamespace, getNativeByIndex, getNativeByTNode, getNativeByTNodeOrNull, getNgModuleDef, getNgModuleDefOrThrow, getNullInjector, getOrCreateLViewCleanup, getOrCreateTViewCleanup, getPipeDef, getSelectedIndex, getSelectedTNode, getTNode, getTView, hasI18n, importProvidersFrom, increaseElementDepthCount, incrementBindingIndex, initNgDevMode, inject, injectRootLimpMode, internalImportProvidersFrom, isClassProvider, isComponentDef, isComponentHost, isContentQueryHost, isCreationMode, isCurrentTNodeParent, isDestroyed, isDirectiveHost, isEnvironmentProviders, isExhaustiveCheckNoChanges, isForwardRef, isInCheckNoChangesMode, isInI18nBlock, isInInjectionContext, isInSkipHydrationBlock, isInjectable, isLContainer, isLView, isProjectionTNode, isRefreshingViews, isRootView, isSignal, isSkipHydrationRootTNode, isStandalone, isTypeProvider, isWritableSignal, keyValueArrayGet, keyValueArrayIndexOf, keyValueArraySet, lastNodeWasCreated, leaveDI, leaveSkipHydrationBlock, leaveView, load, makeEnvironmentProviders, markAncestorsForTraversal, markViewForRefresh, newArray, nextBindingIndex, nextContextImpl, noop, provideBrowserGlobalErrorListeners, provideEnvironmentInitializer, providerToFactory, removeFromArray, removeLViewOnDestroy, renderStringify, requiresRefreshOrTraversal, resetPreOrderHookFlags, resolveForwardRef, runInInjectionContext, runInInjectorProfilerContext, setBindingIndex, setBindingRootForHostBindings, setCurrentDirectiveIndex, setCurrentQueryIndex, setCurrentTNode, setCurrentTNodeAsNotParent, setInI18nBlock, setInjectImplementation, setInjectorProfiler, setInjectorProfilerContext, setIsInCheckNoChangesMode, setIsRefreshingViews, setSelectedIndex, signal, signalAsReadonlyFn, store, storeCleanupWithContext, storeLViewOnDestroy, stringify, stringifyForError, throwError, throwProviderNotFoundError, truncateMiddle, unwrapLView, unwrapRNode, updateAncestorTraversalFlagsOnAttach, viewAttachedToChangeDetector, viewAttachedToContainer, walkProviderTree, walkUpViews, wasLastNodeCreated, unwrapWritableSignal, defineInjectable, defineInjector, disableBindings, enableBindings, inject, invalidFactoryDep, namespaceHTML, namespaceMathML, namespaceSVG, resetView, restoreView };\n","/**\n * @license Angular v20.3.6\n * (c) 2010-2025 Google LLC. https://angular.dev/\n * License: MIT\n */\n\n/**\n * The currently active consumer `ReactiveNode`, if running code in a reactive context.\n *\n * Change this via `setActiveConsumer`.\n */\nlet activeConsumer = null;\nlet inNotificationPhase = false;\n/**\n * Global epoch counter. Incremented whenever a source signal is set.\n */\nlet epoch = 1;\n/**\n * If set, called after a producer `ReactiveNode` is created.\n */\nlet postProducerCreatedFn = null;\n/**\n * Symbol used to tell `Signal`s apart from other functions.\n *\n * This can be used to auto-unwrap signals in various cases, or to auto-wrap non-signal values.\n */\nconst SIGNAL = /* @__PURE__ */ Symbol('SIGNAL');\nfunction setActiveConsumer(consumer) {\n    const prev = activeConsumer;\n    activeConsumer = consumer;\n    return prev;\n}\nfunction getActiveConsumer() {\n    return activeConsumer;\n}\nfunction isInNotificationPhase() {\n    return inNotificationPhase;\n}\nfunction isReactive(value) {\n    return value[SIGNAL] !== undefined;\n}\nconst REACTIVE_NODE = {\n    version: 0,\n    lastCleanEpoch: 0,\n    dirty: false,\n    producers: undefined,\n    producersTail: undefined,\n    consumers: undefined,\n    consumersTail: undefined,\n    recomputing: false,\n    consumerAllowSignalWrites: false,\n    consumerIsAlwaysLive: false,\n    kind: 'unknown',\n    producerMustRecompute: () => false,\n    producerRecomputeValue: () => { },\n    consumerMarkedDirty: () => { },\n    consumerOnSignalRead: () => { },\n};\n/**\n * Called by implementations when a producer's signal is read.\n */\nfunction producerAccessed(node) {\n    if (inNotificationPhase) {\n        throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode\n            ? `Assertion error: signal read during notification phase`\n            : '');\n    }\n    if (activeConsumer === null) {\n        // Accessed outside of a reactive context, so nothing to record.\n        return;\n    }\n    activeConsumer.consumerOnSignalRead(node);\n    const prevProducerLink = activeConsumer.producersTail;\n    // If the last producer we accessed is the same as the current one, we can skip adding a new\n    // link\n    if (prevProducerLink !== undefined && prevProducerLink.producer === node) {\n        return;\n    }\n    let nextProducerLink = undefined;\n    const isRecomputing = activeConsumer.recomputing;\n    if (isRecomputing) {\n        // If we're incrementally rebuilding the producers list, we want to check if the next producer\n        // in the list is the same as the one we're trying to add.\n        // If the previous producer is defined, then the next producer is just the one that follows it.\n        // Otherwise, we should check the head of the producers list (the first node that we accessed the last time this consumer was run).\n        nextProducerLink =\n            prevProducerLink !== undefined ? prevProducerLink.nextProducer : activeConsumer.producers;\n        if (nextProducerLink !== undefined && nextProducerLink.producer === node) {\n            // If the next producer is the same as the one we're trying to add, we can just update the\n            // last read version, update the tail of the producers list of this rerun, and return.\n            activeConsumer.producersTail = nextProducerLink;\n            nextProducerLink.lastReadVersion = node.version;\n            return;\n        }\n    }\n    const prevConsumerLink = node.consumersTail;\n    // If the producer we're accessing already has a link to this consumer, we can skip adding a new\n    // link. This can short circuit the creation of a new link in the case where the consumer reads alternating ReeactiveNodes\n    if (prevConsumerLink !== undefined &&\n        prevConsumerLink.consumer === activeConsumer &&\n        // However, we have to make sure that the link we've discovered isn't from a node that is incrementally rebuilding its producer list\n        (!isRecomputing || isValidLink(prevConsumerLink, activeConsumer))) {\n        // If we found an existing link to the consumer we can just return.\n        return;\n    }\n    // If we got here, it means that we need to create a new link between the producer and the consumer.\n    const isLive = consumerIsLive(activeConsumer);\n    const newLink = {\n        producer: node,\n        consumer: activeConsumer,\n        // instead of eagerly destroying the previous link, we delay until we've finished recomputing\n        // the producers list, so that we can destroy all of the old links at once.\n        nextProducer: nextProducerLink,\n        prevConsumer: prevConsumerLink,\n        lastReadVersion: node.version,\n        nextConsumer: undefined,\n    };\n    activeConsumer.producersTail = newLink;\n    if (prevProducerLink !== undefined) {\n        prevProducerLink.nextProducer = newLink;\n    }\n    else {\n        activeConsumer.producers = newLink;\n    }\n    if (isLive) {\n        producerAddLiveConsumer(node, newLink);\n    }\n}\n/**\n * Increment the global epoch counter.\n *\n * Called by source producers (that is, not computeds) whenever their values change.\n */\nfunction producerIncrementEpoch() {\n    epoch++;\n}\n/**\n * Ensure this producer's `version` is up-to-date.\n */\nfunction producerUpdateValueVersion(node) {\n    if (consumerIsLive(node) && !node.dirty) {\n        // A live consumer will be marked dirty by producers, so a clean state means that its version\n        // is guaranteed to be up-to-date.\n        return;\n    }\n    if (!node.dirty && node.lastCleanEpoch === epoch) {\n        // Even non-live consumers can skip polling if they previously found themselves to be clean at\n        // the current epoch, since their dependencies could not possibly have changed (such a change\n        // would've increased the epoch).\n        return;\n    }\n    if (!node.producerMustRecompute(node) && !consumerPollProducersForChange(node)) {\n        // None of our producers report a change since the last time they were read, so no\n        // recomputation of our value is necessary, and we can consider ourselves clean.\n        producerMarkClean(node);\n        return;\n    }\n    node.producerRecomputeValue(node);\n    // After recomputing the value, we're no longer dirty.\n    producerMarkClean(node);\n}\n/**\n * Propagate a dirty notification to live consumers of this producer.\n */\nfunction producerNotifyConsumers(node) {\n    if (node.consumers === undefined) {\n        return;\n    }\n    // Prevent signal reads when we're updating the graph\n    const prev = inNotificationPhase;\n    inNotificationPhase = true;\n    try {\n        for (let link = node.consumers; link !== undefined; link = link.nextConsumer) {\n            const consumer = link.consumer;\n            if (!consumer.dirty) {\n                consumerMarkDirty(consumer);\n            }\n        }\n    }\n    finally {\n        inNotificationPhase = prev;\n    }\n}\n/**\n * Whether this `ReactiveNode` in its producer capacity is currently allowed to initiate updates,\n * based on the current consumer context.\n */\nfunction producerUpdatesAllowed() {\n    return activeConsumer?.consumerAllowSignalWrites !== false;\n}\nfunction consumerMarkDirty(node) {\n    node.dirty = true;\n    producerNotifyConsumers(node);\n    node.consumerMarkedDirty?.(node);\n}\nfunction producerMarkClean(node) {\n    node.dirty = false;\n    node.lastCleanEpoch = epoch;\n}\n/**\n * Prepare this consumer to run a computation in its reactive context and set\n * it as the active consumer.\n *\n * Must be called by subclasses which represent reactive computations, before those computations\n * begin.\n */\nfunction consumerBeforeComputation(node) {\n    if (node)\n        resetConsumerBeforeComputation(node);\n    return setActiveConsumer(node);\n}\n/**\n * Prepare this consumer to run a computation in its reactive context.\n *\n * We expose this mainly for code where we manually batch effects into a single\n * consumer. In those cases we may wish to \"reopen\" a consumer multiple times\n * in initial render before finalizing it. Most code should just call\n * `consumerBeforeComputation` instead of calling this directly.\n */\nfunction resetConsumerBeforeComputation(node) {\n    node.producersTail = undefined;\n    node.recomputing = true;\n}\n/**\n * Finalize this consumer's state and set previous consumer as the active consumer after a\n * reactive computation has run.\n *\n * Must be called by subclasses which represent reactive computations, after those computations\n * have finished.\n */\nfunction consumerAfterComputation(node, prevConsumer) {\n    setActiveConsumer(prevConsumer);\n    if (node)\n        finalizeConsumerAfterComputation(node);\n}\n/**\n * Finalize this consumer's state after a reactive computation has run.\n *\n * We expose this mainly for code where we manually batch effects into a single\n * consumer. In those cases we may wish to \"reopen\" a consumer multiple times\n * in initial render before finalizing it. Most code should just call\n * `consumerAfterComputation` instead of calling this directly.\n */\nfunction finalizeConsumerAfterComputation(node) {\n    node.recomputing = false;\n    // We've finished incrementally rebuilding the producers list, now if there are any producers\n    // that are after producersTail, they are stale and should be removed.\n    const producersTail = node.producersTail;\n    let toRemove = producersTail !== undefined ? producersTail.nextProducer : node.producers;\n    if (toRemove !== undefined) {\n        if (consumerIsLive(node)) {\n            // For each stale link, we first unlink it from the producers list of consumers\n            do {\n                toRemove = producerRemoveLiveConsumerLink(toRemove);\n            } while (toRemove !== undefined);\n        }\n        // Now, we can truncate the producers list to remove all stale links.\n        if (producersTail !== undefined) {\n            producersTail.nextProducer = undefined;\n        }\n        else {\n            node.producers = undefined;\n        }\n    }\n}\n/**\n * Determine whether this consumer has any dependencies which have changed since the last time\n * they were read.\n */\nfunction consumerPollProducersForChange(node) {\n    // Poll producers for change.\n    for (let link = node.producers; link !== undefined; link = link.nextProducer) {\n        const producer = link.producer;\n        const seenVersion = link.lastReadVersion;\n        // First check the versions. A mismatch means that the producer's value is known to have\n        // changed since the last time we read it.\n        if (seenVersion !== producer.version) {\n            return true;\n        }\n        // The producer's version is the same as the last time we read it, but it might itself be\n        // stale. Force the producer to recompute its version (calculating a new value if necessary).\n        producerUpdateValueVersion(producer);\n        // Now when we do this check, `producer.version` is guaranteed to be up to date, so if the\n        // versions still match then it has not changed since the last time we read it.\n        if (seenVersion !== producer.version) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Disconnect this consumer from the graph.\n */\nfunction consumerDestroy(node) {\n    if (consumerIsLive(node)) {\n        // Drop all connections from the graph to this node.\n        let link = node.producers;\n        while (link !== undefined) {\n            link = producerRemoveLiveConsumerLink(link);\n        }\n    }\n    // Truncate all the linked lists to drop all connection from this node to the graph.\n    node.producers = undefined;\n    node.producersTail = undefined;\n    node.consumers = undefined;\n    node.consumersTail = undefined;\n}\n/**\n * Add `consumer` as a live consumer of this node.\n *\n * Note that this operation is potentially transitive. If this node becomes live, then it becomes\n * a live consumer of all of its current producers.\n */\nfunction producerAddLiveConsumer(node, link) {\n    const consumersTail = node.consumersTail;\n    const wasLive = consumerIsLive(node);\n    if (consumersTail !== undefined) {\n        link.nextConsumer = consumersTail.nextConsumer;\n        consumersTail.nextConsumer = link;\n    }\n    else {\n        link.nextConsumer = undefined;\n        node.consumers = link;\n    }\n    link.prevConsumer = consumersTail;\n    node.consumersTail = link;\n    if (!wasLive) {\n        for (let link = node.producers; link !== undefined; link = link.nextProducer) {\n            producerAddLiveConsumer(link.producer, link);\n        }\n    }\n}\nfunction producerRemoveLiveConsumerLink(link) {\n    const producer = link.producer;\n    const nextProducer = link.nextProducer;\n    const nextConsumer = link.nextConsumer;\n    const prevConsumer = link.prevConsumer;\n    link.nextConsumer = undefined;\n    link.prevConsumer = undefined;\n    if (nextConsumer !== undefined) {\n        nextConsumer.prevConsumer = prevConsumer;\n    }\n    else {\n        producer.consumersTail = prevConsumer;\n    }\n    if (prevConsumer !== undefined) {\n        prevConsumer.nextConsumer = nextConsumer;\n    }\n    else {\n        producer.consumers = nextConsumer;\n        if (!consumerIsLive(producer)) {\n            let producerLink = producer.producers;\n            while (producerLink !== undefined) {\n                producerLink = producerRemoveLiveConsumerLink(producerLink);\n            }\n        }\n    }\n    return nextProducer;\n}\nfunction consumerIsLive(node) {\n    return node.consumerIsAlwaysLive || node.consumers !== undefined;\n}\nfunction runPostProducerCreatedFn(node) {\n    postProducerCreatedFn?.(node);\n}\nfunction setPostProducerCreatedFn(fn) {\n    const prev = postProducerCreatedFn;\n    postProducerCreatedFn = fn;\n    return prev;\n}\n// While a ReactiveNode is recomputing, it may not have destroyed previous links\n// This allows us to check if a given link will be destroyed by a reactivenode if it were to finish running immediately without accesing any more producers\nfunction isValidLink(checkLink, consumer) {\n    const producersTail = consumer.producersTail;\n    if (producersTail !== undefined) {\n        let link = consumer.producers;\n        do {\n            if (link === checkLink) {\n                return true;\n            }\n            if (link === producersTail) {\n                break;\n            }\n            link = link.nextProducer;\n        } while (link !== undefined);\n    }\n    return false;\n}\n\n/**\n * The default equality function used for `signal` and `computed`, which uses referential equality.\n */\nfunction defaultEquals(a, b) {\n    return Object.is(a, b);\n}\n\n/**\n * Create a computed signal which derives a reactive value from an expression.\n */\nfunction createComputed(computation, equal) {\n    const node = Object.create(COMPUTED_NODE);\n    node.computation = computation;\n    if (equal !== undefined) {\n        node.equal = equal;\n    }\n    const computed = () => {\n        // Check if the value needs updating before returning it.\n        producerUpdateValueVersion(node);\n        // Record that someone looked at this signal.\n        producerAccessed(node);\n        if (node.value === ERRORED) {\n            throw node.error;\n        }\n        return node.value;\n    };\n    computed[SIGNAL] = node;\n    if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n        const debugName = node.debugName ? ' (' + node.debugName + ')' : '';\n        computed.toString = () => `[Computed${debugName}: ${node.value}]`;\n    }\n    runPostProducerCreatedFn(node);\n    return computed;\n}\n/**\n * A dedicated symbol used before a computed value has been calculated for the first time.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst UNSET = /* @__PURE__ */ Symbol('UNSET');\n/**\n * A dedicated symbol used in place of a computed signal value to indicate that a given computation\n * is in progress. Used to detect cycles in computation chains.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst COMPUTING = /* @__PURE__ */ Symbol('COMPUTING');\n/**\n * A dedicated symbol used in place of a computed signal value to indicate that a given computation\n * failed. The thrown error is cached until the computation gets dirty again.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst ERRORED = /* @__PURE__ */ Symbol('ERRORED');\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nconst COMPUTED_NODE = /* @__PURE__ */ (() => {\n    return {\n        ...REACTIVE_NODE,\n        value: UNSET,\n        dirty: true,\n        error: null,\n        equal: defaultEquals,\n        kind: 'computed',\n        producerMustRecompute(node) {\n            // Force a recomputation if there's no current value, or if the current value is in the\n            // process of being calculated (which should throw an error).\n            return node.value === UNSET || node.value === COMPUTING;\n        },\n        producerRecomputeValue(node) {\n            if (node.value === COMPUTING) {\n                // Our computation somehow led to a cyclic read of itself.\n                throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode ? 'Detected cycle in computations.' : '');\n            }\n            const oldValue = node.value;\n            node.value = COMPUTING;\n            const prevConsumer = consumerBeforeComputation(node);\n            let newValue;\n            let wasEqual = false;\n            try {\n                newValue = node.computation();\n                // We want to mark this node as errored if calling `equal` throws; however, we don't want\n                // to track any reactive reads inside `equal`.\n                setActiveConsumer(null);\n                wasEqual =\n                    oldValue !== UNSET &&\n                        oldValue !== ERRORED &&\n                        newValue !== ERRORED &&\n                        node.equal(oldValue, newValue);\n            }\n            catch (err) {\n                newValue = ERRORED;\n                node.error = err;\n            }\n            finally {\n                consumerAfterComputation(node, prevConsumer);\n            }\n            if (wasEqual) {\n                // No change to `valueVersion` - old and new values are\n                // semantically equivalent.\n                node.value = oldValue;\n                return;\n            }\n            node.value = newValue;\n            node.version++;\n        },\n    };\n})();\n\nfunction defaultThrowError() {\n    throw new Error();\n}\nlet throwInvalidWriteToSignalErrorFn = defaultThrowError;\nfunction throwInvalidWriteToSignalError(node) {\n    throwInvalidWriteToSignalErrorFn(node);\n}\nfunction setThrowInvalidWriteToSignalError(fn) {\n    throwInvalidWriteToSignalErrorFn = fn;\n}\n\n/**\n * If set, called after `WritableSignal`s are updated.\n *\n * This hook can be used to achieve various effects, such as running effects synchronously as part\n * of setting a signal.\n */\nlet postSignalSetFn = null;\n/**\n * Creates a `Signal` getter, setter, and updater function.\n */\nfunction createSignal(initialValue, equal) {\n    const node = Object.create(SIGNAL_NODE);\n    node.value = initialValue;\n    if (equal !== undefined) {\n        node.equal = equal;\n    }\n    const getter = (() => signalGetFn(node));\n    getter[SIGNAL] = node;\n    if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n        const debugName = node.debugName ? ' (' + node.debugName + ')' : '';\n        getter.toString = () => `[Signal${debugName}: ${node.value}]`;\n    }\n    runPostProducerCreatedFn(node);\n    const set = (newValue) => signalSetFn(node, newValue);\n    const update = (updateFn) => signalUpdateFn(node, updateFn);\n    return [getter, set, update];\n}\nfunction setPostSignalSetFn(fn) {\n    const prev = postSignalSetFn;\n    postSignalSetFn = fn;\n    return prev;\n}\nfunction signalGetFn(node) {\n    producerAccessed(node);\n    return node.value;\n}\nfunction signalSetFn(node, newValue) {\n    if (!producerUpdatesAllowed()) {\n        throwInvalidWriteToSignalError(node);\n    }\n    if (!node.equal(node.value, newValue)) {\n        node.value = newValue;\n        signalValueChanged(node);\n    }\n}\nfunction signalUpdateFn(node, updater) {\n    if (!producerUpdatesAllowed()) {\n        throwInvalidWriteToSignalError(node);\n    }\n    signalSetFn(node, updater(node.value));\n}\nfunction runPostSignalSetFn(node) {\n    postSignalSetFn?.(node);\n}\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nconst SIGNAL_NODE = /* @__PURE__ */ (() => {\n    return {\n        ...REACTIVE_NODE,\n        equal: defaultEquals,\n        value: undefined,\n        kind: 'signal',\n    };\n})();\nfunction signalValueChanged(node) {\n    node.version++;\n    producerIncrementEpoch();\n    producerNotifyConsumers(node);\n    postSignalSetFn?.(node);\n}\n\nexport { COMPUTING, ERRORED, REACTIVE_NODE, SIGNAL, SIGNAL_NODE, UNSET, consumerAfterComputation, consumerBeforeComputation, consumerDestroy, consumerMarkDirty, consumerPollProducersForChange, createComputed, createSignal, defaultEquals, finalizeConsumerAfterComputation, getActiveConsumer, isInNotificationPhase, isReactive, producerAccessed, producerIncrementEpoch, producerMarkClean, producerNotifyConsumers, producerUpdateValueVersion, producerUpdatesAllowed, resetConsumerBeforeComputation, runPostProducerCreatedFn, runPostSignalSetFn, setActiveConsumer, setPostProducerCreatedFn, setPostSignalSetFn, setThrowInvalidWriteToSignalError, signalGetFn, signalSetFn, signalUpdateFn };\n","function _arrayLikeToArray(r, a) {\n  (null == a || a > r.length) && (a = r.length);\n  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];\n  return n;\n}\nexport { _arrayLikeToArray as default };","function _arrayWithHoles(r) {\n  if (Array.isArray(r)) return r;\n}\nexport { _arrayWithHoles as default };","import getPrototypeOf from \"./getPrototypeOf.js\";\nimport isNativeReflectConstruct from \"./isNativeReflectConstruct.js\";\nimport possibleConstructorReturn from \"./possibleConstructorReturn.js\";\nfunction _callSuper(t, o, e) {\n  return o = getPrototypeOf(o), possibleConstructorReturn(t, isNativeReflectConstruct() ? Reflect.construct(o, e || [], getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nexport { _callSuper as default };","import _typeof from \"./typeof.js\";\nimport assertThisInitialized from \"./assertThisInitialized.js\";\nfunction _possibleConstructorReturn(t, e) {\n  if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e;\n  if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\");\n  return assertThisInitialized(t);\n}\nexport { _possibleConstructorReturn as default };","function _assertThisInitialized(e) {\n  if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return e;\n}\nexport { _assertThisInitialized as default };","function _classCallCheck(a, n) {\n  if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n}\nexport { _classCallCheck as default };","import isNativeReflectConstruct from \"./isNativeReflectConstruct.js\";\nimport setPrototypeOf from \"./setPrototypeOf.js\";\nfunction _construct(t, e, r) {\n  if (isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);\n  var o = [null];\n  o.push.apply(o, e);\n  var p = new (t.bind.apply(t, o))();\n  return r && setPrototypeOf(p, r.prototype), p;\n}\nexport { _construct as default };","import toPropertyKey from \"./toPropertyKey.js\";\nfunction _defineProperties(e, r) {\n  for (var t = 0; t < r.length; t++) {\n    var o = r[t];\n    o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, toPropertyKey(o.key), o);\n  }\n}\nfunction _createClass(e, r, t) {\n  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n    writable: !1\n  }), e;\n}\nexport { _createClass as default };","import unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nfunction _createForOfIteratorHelper(r, e) {\n  var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (!t) {\n    if (Array.isArray(r) || (t = unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) {\n      t && (r = t);\n      var _n = 0,\n        F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          return _n >= r.length ? {\n            done: !0\n          } : {\n            done: !1,\n            value: r[_n++]\n          };\n        },\n        e: function e(r) {\n          throw r;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var o,\n    a = !0,\n    u = !1;\n  return {\n    s: function s() {\n      t = t.call(r);\n    },\n    n: function n() {\n      var r = t.next();\n      return a = r.done, r;\n    },\n    e: function e(r) {\n      u = !0, o = r;\n    },\n    f: function f() {\n      try {\n        a || null == t[\"return\"] || t[\"return\"]();\n      } finally {\n        if (u) throw o;\n      }\n    }\n  };\n}\nexport { _createForOfIteratorHelper as default };","import toPropertyKey from \"./toPropertyKey.js\";\nfunction _defineProperty(e, r, t) {\n  return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nexport { _defineProperty as default };","function _getPrototypeOf(t) {\n  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {\n    return t.__proto__ || Object.getPrototypeOf(t);\n  }, _getPrototypeOf(t);\n}\nexport { _getPrototypeOf as default };","import setPrototypeOf from \"./setPrototypeOf.js\";\nfunction _inherits(t, e) {\n  if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n  t.prototype = Object.create(e && e.prototype, {\n    constructor: {\n      value: t,\n      writable: !0,\n      configurable: !0\n    }\n  }), Object.defineProperty(t, \"prototype\", {\n    writable: !1\n  }), e && setPrototypeOf(t, e);\n}\nexport { _inherits as default };","function _isNativeReflectConstruct() {\n  try {\n    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n  } catch (t) {}\n  return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n    return !!t;\n  })();\n}\nexport { _isNativeReflectConstruct as default };","function _iterableToArray(r) {\n  if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r);\n}\nexport { _iterableToArray as default };","function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nexport { _nonIterableRest as default };","import defineProperty from \"./defineProperty.js\";\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nexport { _objectSpread2 as default };","function _regeneratorDefine(e, r, n, t) {\n  var i = Object.defineProperty;\n  try {\n    i({}, \"\", {});\n  } catch (e) {\n    i = 0;\n  }\n  _regeneratorDefine = function regeneratorDefine(e, r, n, t) {\n    function o(r, n) {\n      _regeneratorDefine(e, r, function (e) {\n        return this._invoke(r, n, e);\n      });\n    }\n    r ? i ? i(e, r, {\n      value: n,\n      enumerable: !t,\n      configurable: !t,\n      writable: !t\n    }) : e[r] = n : (o(\"next\", 0), o(\"throw\", 1), o(\"return\", 2));\n  }, _regeneratorDefine(e, r, n, t);\n}\nexport { _regeneratorDefine as default };","import regeneratorDefine from \"./regeneratorDefine.js\";\nfunction _regenerator() {\n  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */\n  var e,\n    t,\n    r = \"function\" == typeof Symbol ? Symbol : {},\n    n = r.iterator || \"@@iterator\",\n    o = r.toStringTag || \"@@toStringTag\";\n  function i(r, n, o, i) {\n    var c = n && n.prototype instanceof Generator ? n : Generator,\n      u = Object.create(c.prototype);\n    return regeneratorDefine(u, \"_invoke\", function (r, n, o) {\n      var i,\n        c,\n        u,\n        f = 0,\n        p = o || [],\n        y = !1,\n        G = {\n          p: 0,\n          n: 0,\n          v: e,\n          a: d,\n          f: d.bind(e, 4),\n          d: function d(t, r) {\n            return i = t, c = 0, u = e, G.n = r, a;\n          }\n        };\n      function d(r, n) {\n        for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) {\n          var o,\n            i = p[t],\n            d = G.p,\n            l = i[2];\n          r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0));\n        }\n        if (o || r > 1) return a;\n        throw y = !0, n;\n      }\n      return function (o, p, l) {\n        if (f > 1) throw TypeError(\"Generator is already running\");\n        for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) {\n          i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u);\n          try {\n            if (f = 2, i) {\n              if (c || (o = \"next\"), t = i[o]) {\n                if (!(t = t.call(i, u))) throw TypeError(\"iterator result is not an object\");\n                if (!t.done) return t;\n                u = t.value, c < 2 && (c = 0);\n              } else 1 === c && (t = i[\"return\"]) && t.call(i), c < 2 && (u = TypeError(\"The iterator does not provide a '\" + o + \"' method\"), c = 1);\n              i = e;\n            } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break;\n          } catch (t) {\n            i = e, c = 1, u = t;\n          } finally {\n            f = 1;\n          }\n        }\n        return {\n          value: t,\n          done: y\n        };\n      };\n    }(r, o, i), !0), u;\n  }\n  var a = {};\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n  t = Object.getPrototypeOf;\n  var c = [][n] ? t(t([][n]())) : (regeneratorDefine(t = {}, n, function () {\n      return this;\n    }), t),\n    u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c);\n  function f(e) {\n    return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, regeneratorDefine(e, o, \"GeneratorFunction\")), e.prototype = Object.create(u), e;\n  }\n  return GeneratorFunction.prototype = GeneratorFunctionPrototype, regeneratorDefine(u, \"constructor\", GeneratorFunctionPrototype), regeneratorDefine(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = \"GeneratorFunction\", regeneratorDefine(GeneratorFunctionPrototype, o, \"GeneratorFunction\"), regeneratorDefine(u), regeneratorDefine(u, o, \"Generator\"), regeneratorDefine(u, n, function () {\n    return this;\n  }), regeneratorDefine(u, \"toString\", function () {\n    return \"[object Generator]\";\n  }), (_regenerator = function _regenerator() {\n    return {\n      w: i,\n      m: f\n    };\n  })();\n}\nexport { _regenerator as default };","function _setPrototypeOf(t, e) {\n  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {\n    return t.__proto__ = e, t;\n  }, _setPrototypeOf(t, e);\n}\nexport { _setPrototypeOf as default };","import arrayWithHoles from \"./arrayWithHoles.js\";\nimport iterableToArrayLimit from \"./iterableToArrayLimit.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableRest from \"./nonIterableRest.js\";\nfunction _slicedToArray(r, e) {\n  return arrayWithHoles(r) || iterableToArrayLimit(r, e) || unsupportedIterableToArray(r, e) || nonIterableRest();\n}\nexport { _slicedToArray as default };","function _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = !0,\n      o = !1;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) {\n        if (Object(t) !== t) return;\n        f = !1;\n      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = !0, n = r;\n    } finally {\n      try {\n        if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}\nexport { _iterableToArrayLimit as default };","import superPropBase from \"./superPropBase.js\";\nfunction _get() {\n  return _get = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) {\n    var p = superPropBase(e, t);\n    if (p) {\n      var n = Object.getOwnPropertyDescriptor(p, t);\n      return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value;\n    }\n  }, _get.apply(null, arguments);\n}\nexport { _get as default };","import getPrototypeOf from \"./getPrototypeOf.js\";\nfunction _superPropBase(t, o) {\n  for (; !{}.hasOwnProperty.call(t, o) && null !== (t = getPrototypeOf(t)););\n  return t;\n}\nexport { _superPropBase as default };","import get from \"./get.js\";\nimport getPrototypeOf from \"./getPrototypeOf.js\";\nfunction _superPropGet(t, o, e, r) {\n  var p = get(getPrototypeOf(1 & r ? t.prototype : t), o, e);\n  return 2 & r && \"function\" == typeof p ? function (t) {\n    return p.apply(e, t);\n  } : p;\n}\nexport { _superPropGet as default };","import arrayWithoutHoles from \"./arrayWithoutHoles.js\";\nimport iterableToArray from \"./iterableToArray.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableSpread from \"./nonIterableSpread.js\";\nfunction _toConsumableArray(r) {\n  return arrayWithoutHoles(r) || iterableToArray(r) || unsupportedIterableToArray(r) || nonIterableSpread();\n}\nexport { _toConsumableArray as default };","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nfunction _arrayWithoutHoles(r) {\n  if (Array.isArray(r)) return arrayLikeToArray(r);\n}\nexport { _arrayWithoutHoles as default };","function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nexport { _nonIterableSpread as default };","import _typeof from \"./typeof.js\";\nimport toPrimitive from \"./toPrimitive.js\";\nfunction toPropertyKey(t) {\n  var i = toPrimitive(t, \"string\");\n  return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nexport { toPropertyKey as default };","import _typeof from \"./typeof.js\";\nfunction toPrimitive(t, r) {\n  if (\"object\" != _typeof(t) || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != _typeof(i)) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nexport { toPrimitive as default };","function _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\nexport { _typeof as default };","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nfunction _unsupportedIterableToArray(r, a) {\n  if (r) {\n    if (\"string\" == typeof r) return arrayLikeToArray(r, a);\n    var t = {}.toString.call(r).slice(8, -1);\n    return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? arrayLikeToArray(r, a) : void 0;\n  }\n}\nexport { _unsupportedIterableToArray as default };","import getPrototypeOf from \"./getPrototypeOf.js\";\nimport setPrototypeOf from \"./setPrototypeOf.js\";\nimport isNativeFunction from \"./isNativeFunction.js\";\nimport construct from \"./construct.js\";\nfunction _wrapNativeSuper(t) {\n  var r = \"function\" == typeof Map ? new Map() : void 0;\n  return _wrapNativeSuper = function _wrapNativeSuper(t) {\n    if (null === t || !isNativeFunction(t)) return t;\n    if (\"function\" != typeof t) throw new TypeError(\"Super expression must either be null or a function\");\n    if (void 0 !== r) {\n      if (r.has(t)) return r.get(t);\n      r.set(t, Wrapper);\n    }\n    function Wrapper() {\n      return construct(t, arguments, getPrototypeOf(this).constructor);\n    }\n    return Wrapper.prototype = Object.create(t.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: !1,\n        writable: !0,\n        configurable: !0\n      }\n    }), setPrototypeOf(Wrapper, t);\n  }, _wrapNativeSuper(t);\n}\nexport { _wrapNativeSuper as default };","function _isNativeFunction(t) {\n  try {\n    return -1 !== Function.toString.call(t).indexOf(\"[native code]\");\n  } catch (n) {\n    return \"function\" == typeof t;\n  }\n}\nexport { _isNativeFunction as default };"],"x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56]}