{"version":3,"file":"9469.2bf6d2fa8dac739e.js","mappings":"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","names":["ConnectableObservable","_Observable","source","subjectFactory","_this","_classCallCheck","this","_callSuper","_subject","_refCount","_connection","hasLift","lift","_inherits","_createClass","key","value","subscriber","getSubject","subscribe","subject","isStopped","unsubscribe","_this2","connection","Subscription","add","createOperatorSubscriber","undefined","_teardown","complete","err","error","closed","EMPTY","higherOrderRefCount","Observable","finalize","callback","operate","refCount","refCounter","sharedConnection","conn","connect","isObservable","obj","isFunction","takeLast","count","buffer","push","length","shift","_step","_iterator","_createForOfIteratorHelper","s","n","done","next","e","f","PRIMARY_OUTLET","RouteTitleKey","Symbol","ParamsAsMap","params","_defineProperty","name","Object","prototype","hasOwnProperty","call","has","v","Array","isArray","get","keys","convertToParamMap","defaultUrlMatcher","segments","segmentGroup","route","parts","path","split","pathMatch","hasChildren","posParams","index","part","segment","substring","consumed","slice","shallowEqual","a","b","k1","getDataKeys","k2","i","equalArraysOrString","concat","_toConsumableArray","getOwnPropertySymbols","aSorted","sort","bSorted","every","val","last","wrapIntoObservable","_isPromise","from","Promise","resolve","of","pathCompareMap","exact","equalSegmentGroups","container","containee","matrixParams","equalPath","matrixParamsMatch","numberOfChildren","c","children","subset","containsSegmentGroup","paramCompareMap","equalParams","containsParams","ignored","containsTree","options","paths","root","queryParams","fragment","containsSegmentGroupHelper","containeePaths","current","containerPaths","containeeSegment","parameters","UrlTree","arguments","UrlSegmentGroup","_this$_queryParamMap","_queryParamMap","DEFAULT_SERIALIZER","serialize","values","forEach","parent","serializePaths","UrlSegment","_this$_parameterMap","_parameterMap","serializePath","as","bs","UrlSerializer","_UrlSerializer","__ngFactoryType__","i0","token","factory","DefaultUrlSerializer","providedIn","url","p","UrlParser","parseRootSegment","parseQueryParams","parseFragment","tree","serializeSegment","query","serializeQueryParams","strParams","entries","map","_ref9","_ref0","_slicedToArray","encodeUriQuery","join","filter","encodeUriFragment","encodeURI","primary","_ref5","_ref6","k","mapChildrenIntoArray","fn","res","_ref","_ref2","childOutlet","_ref3","_ref4","encodeUriString","encodeURIComponent","replace","encodeUriSegment","decode","decodeURIComponent","decodeQuery","serializeMatrixParams","_ref7","_ref8","SEGMENT_RE","matchSegments","str","match","MATRIX_PARAM_SEGMENT_RE","QUERY_PARAM_RE","QUERY_PARAM_VALUE_RE","remaining","consumeOptional","peekStartsWith","parseChildren","parseQueryParam","parseSegment","capture","parseParens","_RuntimeError","ngDevMode","parseMatrixParams","parseParam","matchMatrixKeySegments","valueMatch","matchQueryParams","matchUrlQueryParamValue","decodedKey","decodedVal","currentVal","allowPrimary","outletName","indexOf","startsWith","createRoot","rootCandidate","squashSegmentGroup","newChildren","_i","_Object$entries","_Object$entries$_i","childCandidate","_i2","_Object$entries2","_Object$entries2$_i","mergeTrivialChildren","isUrlTree","createUrlTreeFromSnapshot","relativeTo","commands","createUrlTreeFromSegmentGroup","createSegmentGroupFromRoute","targetGroup","rootSegmentGroup","createSegmentGroupFromRouteRecursive","currentRoute","childOutlets","childSnapshot","outlet","nav","computeNavigation","Navigation","numberOfDoubleDots","isAbsolute","reduce","cmd","cmdIdx","outlets","_ref13","_ref14","segmentPath","urlPart","partIndex","toRoot","position","findStartingPositionForTargetGroup","target","Position","NaN","modifier","isMatrixParams","createPositionApplyingDoubleDots","group","g","ci","dd","newSegmentGroup","processChildren","updateSegmentGroupChildren","updateSegmentGroup","command","isCommandWithOutlets","oldRoot","oldSegmentGroup","qp","_ref1","_ref10","newRoot","replaceSegment","oldSegment","newSegment","_ref11","_ref12","cmdWithOutlet","find","startIndex","m","prefixedWith","currentCommandIndex","currentPathIndex","noMatch","pathIndex","commandIndex","curr","compare","slicedCommands","createNewSegmentGroup","getOutlets","some","o","childrenOfEmptyChild","_ref16","_ref17","_ref18","_ref19","createNewSegmentChildren","stringify","_ref20","_ref21","_ref22","_ref23","IMPERATIVE_NAVIGATION","EventType","NavigationStart","NavigationEnd","NavigationCancel","NavigationError","RoutesRecognized","ResolveStart","ResolveEnd","GuardsCheckStart","GuardsCheckEnd","RouteConfigLoadStart","RouteConfigLoadEnd","ChildActivationStart","ChildActivationEnd","ActivationStart","ActivationEnd","Scroll","NavigationSkipped","RouterEvent","id","_RouterEvent2","navigationTrigger","restoredState","_RouterEvent3","urlAfterRedirects","_this3","NavigationCancellationCode","Redirect","SupersededByNewNavigation","NoDataFromResolver","GuardRejected","Aborted","NavigationSkippedCode","IgnoredSameUrlNavigation","IgnoredByUrlHandlingStrategy","_RouterEvent4","reason","code","_this4","_RouterEvent5","_this5","_RouterEvent6","_this6","_RouterEvent7","state","_this7","_RouterEvent8","_this8","_RouterEvent9","shouldActivate","_this9","_RouterEvent0","_this0","_RouterEvent1","_this1","snapshot","routeConfig","routerEvent","anchor","pos","BeforeActivateRoutes","RedirectRequest","navigationBehaviorOptions","getOutlet","getClosestRouteInjector","_snapshot$routeConfig","_injector","_loadedInjector","OutletContext","rootInjector","ChildrenOutletContexts","_getClosestRouteInjec","_this$route","_ChildrenOutletContexts","Map","childName","context","getOrCreateContext","contexts","set","getContext","attachRef","fac","Tree","_root","t","pathFromRoot","findNode","findPath","cc","node","_step2","_iterator2","_step3","_iterator3","unshift","TreeNode","nodeChildrenAsMap","child","RouterState","_Tree2","_this10","setRouterState","toString","createEmptyState","rootComponent","createEmptyStateSnapshot","activated","ActivatedRouteSnapshot","RouterStateSnapshot","emptyUrl","BehaviorSubject","emptyParams","emptyData","emptyQueryParams","ActivatedRoute","urlSubject","paramsSubject","queryParamsSubject","fragmentSubject","dataSubject","component","futureSnapshot","_this$dataSubject$pip","_this$dataSubject","_futureSnapshot","title","pipe","d","data","_routerState","firstChild","_this$_paramMap","_paramMap","_this$_queryParamMap2","getInherited","_parent$routeConfig","inherited","_route$_resolvedData","loadComponent","_objectSpread","_resolvedData","hasStaticTitle","_resolve","_this$data","_this$_paramMap2","_this$_queryParamMap3","matched","_Tree3","_this11","serializeNode","advanceActivatedRoute","currentSnapshot","nextSnapshot","shallowEqualArrays","equalParamsAndUrlSegments","equalUrlParams","equalSegments","config","ROUTER_OUTLET_DATA","InjectionToken","RouterOutlet","_RouterOutlet","EventEmitter","input","apply","inject","ViewContainerRef","ChangeDetectorRef","INPUT_BINDER","optional","changes","_changes$name","previousValue","firstChange","isTrackedInParentContexts","deactivate","parentContexts","onChildOutletDestroyed","initializeOutletWithName","_this$inputBinder","inputBinder","unsubscribeFromRouteData","_this$parentContexts$","onChildOutletCreated","attach","activateWith","injector","instance","_activatedRoute","location","detach","cmp","detachEvents","emit","ref","activatedRoute","_this$inputBinder2","insert","hostView","bindActivatedRouteToOutletComponent","attachEvents","destroy","deactivateEvents","environmentInjector","_this$inputBinder3","isActivated","childContexts","OutletInjector","routerOutletData","createComponent","changeDetector","markForCheck","activateEvents","type","selectors","inputs","outputs","exportAs","features","outletData","notFoundValue","RoutedComponentInputBinder","_RoutedComponentInputBinder","subscribeToRouteData","_this$outletDataSubsc","outletDataSubscriptions","delete","_this12","dataSubscription","combineLatest","switchMap","_ref24","_ref25","activatedComponentRef","mirror","reflectComponentType","_step4","_iterator4","templateName","setInput","EmptyOutletComponent","_EmptyOutletComponent","decls","vars","template","rf","ctx","dependencies","encapsulation","standardizeConfig","r","loadChildren","createNode","routeReuseStrategy","prevState","shouldReuseRoute","createOrReuseChildren","_step5","_iterator5","shouldAttach","detachedRouteHandle","retrieve","createActivatedRoute","RedirectCommand","redirectTo","NAVIGATION_CANCELING_ERROR","redirectingNavigationError","urlSerializer","redirect","_ref26","navigationCancelingError","message","Error","cancellationCode","isNavigationCancelingError","ActivateRoutes","futureState","currState","forwardEvent","inputBindingEnabled","futureRoot","currRoot","deactivateChildRoutes","activateChildRoutes","futureNode","currNode","_this13","futureChild","childOutletName","deactivateRoutes","deactivateRouteAndItsChildren","parentContext","future","shouldDetach","detachAndStoreRouteSubtree","deactivateRouteAndOutlet","_i3","_Object$values","componentRef","onOutletDeactivated","store","_i4","_Object$values2","_this14","activateRoutes","stored","onOutletReAttached","CanActivate","CanDeactivate","getAllRouteGuards","getChildRouteGuards","getTokenOrFunctionIdentity","tokenOrFunction","NOT_FOUND","result","_isInjectable","futurePath","checks","canDeactivateChecks","canActivateChecks","prevChildren","getRouteGuards","shouldRun","shouldRunGuardsAndResolvers","mode","runGuardsAndResolvers","_ref27","_ref28","_ref29","_ref30","isEmptyError","EmptyError","INITIAL_VALUE","prioritizedGuardValue","obs","take","startWith","results","_step6","_iterator6","isRedirect","item","redirectIfUrlTree","tap","NoMatch","AbsoluteRedirect","_Error","urlTree","_this15","_wrapNativeSuper","noMatch$1","throwError","namedOutletsRedirect","ApplyRedirects","_this16","getRedirectResult","redirectToFn","runInInjectionContext","newTree","applyRedirectCreateUrlTree","parse","createSegmentGroup","createQueryParams","redirectToParams","actualParams","_ref31","_ref32","sourceName","_this17","updatedSegments","createSegments","_ref33","_ref34","redirectToSegments","actualSegments","_this18","findPosParam","findOrReturn","redirectToUrlSegment","_step7","idx","_iterator7","splice","consumedSegments","remainingSegments","positionalParamSegments","matchWithChecks","getOrCreateRouteInjectorIfNeeded","currentInjector","_route$_injector","providers","createEnvironmentInjector","runCanMatchGuards","canMatch","canMatchObservables","injectionToken","guard","isCanMatch","_res$posParams","_res$posParams2","createWildcardMatchResult","matcher","_ref35","_ref36","slicedSegments","containsEmptyPathMatchesWithNamedOutlets","routes","emptyPathMatch","createChildrenForEmptyPaths","primarySegment","_step9","_iterator9","containsEmptyPathMatches","addEmptyPathsToChildrenIfNeeded","_step8","_iterator8","NoLeftoversInUrl","Recognizer","configLoader","rootComponentType","paramsInheritanceStrategy","applyRedirects","_this19","_ref37","rootSnapshot","rootNode","routeState","_this20","freeze","processSegmentGroup","catchError","noMatchError","parentRoute","processSegment","_this21","_i5","_Object$keys","concatMap","sortedConfig","sortByMatchingOutlets","scan","outletChildren","defaultIfEmpty","predicate","defaultValue","hasDefaultValue","identity","throwIfEmpty","last$1","mergeMap","mergedChildren","mergeEmptyPathMatches","sortActivatedRouteSnapshots","nodes","localeCompare","allowRedirects","_this22","_r$_injector","processSegmentAgainstRoute","first","x","noLeftoversInUrl","rawSegment","matchSegmentAgainstRoute","expandSegmentAgainstRouteUsingRedirect","_ref38","_route$component","_this23","_match","absoluteRedirectCount","getData","_loadedComponent","getResolve","applyRedirectCommands","lineralizeSegments","newSegments","_this24","matchResult","_route$_injector2","getChildConfig","_ref39","_route$_loadedInjecto","_ref40","_route$component2","childConfig","childInjector","_split","matchedOnOutlet","_this25","_loadedRoutes","runCanLoadGuards","canLoad","canLoadObservables","isCanLoad","shouldLoadResult","cfg","canLoadFails","_step0","mergedNodes","Set","_iterator0","_loop","hasEmptyPathConfig","_duplicateEmptyPathNo","duplicateEmptyPathNode","resultNode","_step1","_iterator1","mergedNode","flattenRouteTree","descendants","flat","switchTap","nextResult","TitleStrategy","_TitleStrategy","pageTitle","_this$getResolvedTitl","getResolvedTitleForRoute","DefaultTitleStrategy","_DefaultTitleStrategy","_TitleStrategy2","_this26","buildTitle","setTitle","i1","ROUTER_CONFIGURATION","ROUTES","RouterConfigLoader","_RouterConfigLoader","WeakMap","Compiler","_this27","componentLoaders","onLoadStartListener","loadRunner","maybeUnwrapDefaultExport","maybeResolveResources","onLoadEndListener","loader","Subject","parentInjector","_this28","childrenLoaders","compiler","NgModuleFactory","compileModuleAsync","factoryOrRoutes","create","self","isWrappedDefaultExport","default","UrlHandlingStrategy","_UrlHandlingStrategy","DefaultUrlHandlingStrategy","_DefaultUrlHandlingStrategy","newUrlPart","wholeUrl","CREATE_VIEW_TRANSITION","VIEW_TRANSITION_OPTIONS","createViewTransition","to","transitionOptions","document","DOCUMENT","startViewTransition","skipNextTransition","setTimeout","resolveViewTransitionStarted","viewTransitionStarted","transition","createRenderPromise","afterNextRender","read","ready","catch","onViewTransitionCreated","NAVIGATION_ERROR_HANDLER","NavigationTransitions","_NavigationTransitions","_this29","signal","equal","EnvironmentInjector","DestroyRef","Location","events","destroyRef","onDestroy","destroyed","navigationId","_this$transitions","transitions","request","_this30","untracked","_this30$transitions","extractedUrl","urlHandlingStrategy","extract","rawUrl","targetSnapshot","targetRouterState","guards","guardsResult","abortController","AbortController","router","_this31","overallTransitionState","completedOrAborted","_t$extras$onSameUrlNa","cancelNavigationTransition","currentTransition","currentNavigation","initialUrl","targetBrowserUrl","extras","browserUrl","trigger","previousNavigation","lastSuccessfulNavigation","abort","urlTransition","navigated","isUpdatingInternalState","isUpdatedBrowserUrl","onSameUrlNavigation","shouldProcessUrl","recognize","serializer","recognize$1","_ref41","update","finalUrl","routesRecognized","currentRawUrl","navStart","skipLocationChange","replaceUrl","guardsStart","rootContexts","checkGuards","_t$guards","runCanDeactivateChecks","futureRSS","currRSS","check","runCanDeactivate","currARS","canDeactivate","canDeactivateObservables","_getClosestRouteInjec4","closestInjector","isCanDeactivate","isBoolean","runCanActivateChecks","fireChildActivationStart","fireActivationStart","runCanActivateChild","futureARS","canActivateChildGuards","reverse","getCanActivateChild","canActivateChild","_","canActivateChildGuardsMapped","defer","guardsMapped","_getClosestRouteInjec3","isCanActivateChild","runCanActivate","canActivate","canActivateObservables","_getClosestRouteInjec2","isCanActivate","evt","guardsEnd","resolveStart","dataResolved","resolveData","_step10","routesWithResolversToRun","routesNeedingDataUpdates","_iterator10","_step11","_iterator11","routesProcessed","runResolve","resolveNode","getResolver","_getClosestRouteInjec5","resolver","resolvedData","size","resolveEnd","loadComponents","_route$routeConfig","loaders","_getClosestRouteInjec6","loadedComponent","_step12","_iterator12","afterPreactivation","_this31$createViewTra","createRouterState","currentRouterState","activate","takeUntil","abortSignal","handler","addEventListener","removeEventListener","_this31$titleStrategy","titleStrategy","updateTitle","transitionAbortWithErrorSubject","_this31$currentTransi","isRedirectingNavigationCancelingError","_overallTransitionSta2","navigationError","navigationErrorHandlerResult","_this31$navigationErr","navigationErrorHandler","_redirectingNavigatio","ee","resolveNavigationPromiseOnError","reject","navCancel","_this$currentTransiti","_this$currentTransiti2","currentUrlTree","_currentNavigation$ta","currentBrowserUrl","isBrowserTriggeredNavigation","RouteReuseStrategy","_RouteReuseStrategy","DefaultRouteReuseStrategy","BaseRouteReuseStrategy","detachedTree","_DefaultRouteReuseStrategy","_BaseRouteReuseStrate","_DefaultRouteReuseStrategy_BaseFactory","StateManager","_StateManager","canceledNavigationResolution","urlUpdateStrategy","createStateMemento","rawUrlTree","_ref42","merge","_ref43","routerState","stateMemento","_ref44","HistoryStateManager","_HistoryStateManager","_StateManager2","_this32","_len","args","_key","getState","_this$restoredState$","_this$restoredState","currentPageId","routerPageId","listener","event","updateStateMemento","commitTransition","setBrowserUrl","createBrowserPath","restoreHistory","lastSuccessfulId","browserPageId","_ref45","isCurrentPathEqualTo","currentBrowserPageId","newState","generateNgRouterState","replaceState","go","navigation","restoringFromCaughtError","targetPagePosition","historyGo","getCurrentUrlTree","resetInternalState","resetUrlToCurrentUrlTree","getRawUrlTree","routerPageId","_HistoryStateManager_BaseFactory","afterNextNavigation","action","exactMatchOptions","subsetMatchOptions","Router","_Router","_inject$flat","_inject","_this33","_Console","_PendingTasksInternal","navigationTransitions","asReadonly","resetConfig","setupNavigations","console","warn","subscribeToNavigationEvents","stateManager","_events","getRouterState","_this34","subscription","handleRouterEvent","opts","mergedTree","info","scheduleNavigation","promise","isPublicRouterEvent","eventsSubscription","setUpLocationChangeListener","hasRequestedNavigation","navigateToSyncWithBrowser","_this$nonRouterCurren","_this35","nonRouterCurrentEntryChangeSubscription","registerNonRouterCurrentEntryChangeListener","_this36","stateCopy","parseUrl","disposed","_INTERNAL_APPLICATION_ERROR_HANDLER","serializeUrl","dispose","relativeToUrlSegmentGroup","navigationExtras","preserveFragment","q","queryParamsHandling","defaultQueryParamsHandling","removeEmptyProps","validateCommands","navigateByUrl","createUrlTree","matchOptions","_ref46","_ref47","priorPromise","_this37","rej","taskId","pendingTasks","queueMicrotask","remove","handleNavigationRequest","RouterLink","_RouterLink","tabIndexAttribute","renderer","el","locationStrategy","_el$nativeElement$tag","_customElements$get","_customElements$get$i","reactiveHref","HostAttributeToken","tagName","nativeElement","toLowerCase","isAnchorElement","customElements","observedAttributes","includes","setTabIndexIfNotOnNativeEl","subscribeToNavigationEventsIfNecessary","_this$options","createSubcription","dependsOnRouterState","handling","updateHref","newTabIndex","applyAttributeValue","onChanges","commandsOrUrlTree","routerLinkInput","button","ctrlKey","shiftKey","altKey","metaKey","_this$router$navigate","applicationErrorHandler","_this$subscription","_this$locationStrateg","_this$locationStrateg2","prepareExternalUrl","attrName","attrValue","setAttribute","removeAttribute","i3","hostVars","hostBindings","$event","onClick","booleanAttribute","routerLink","RouterLinkActive","_RouterLinkActive","element","cdr","link","routerEventsSubscription","_isActive","links","mergeAll","subscribeToEachLinkOnChanges","_this$linkInputChange","linkInputChangesSubscription","allLinkChanges","toArray","isLinkActive","classes","_this$linkInputChange2","hasActiveLinks","addClass","removeClass","ariaCurrentWhenActive","isActiveChange","isActiveMatchOptions","routerLinkActiveOptions","isActive","isActiveCheckFn","contentQueries","dirIndex","_t","routerLinkActive","PreloadingStrategy","PreloadAllModules","_PreloadAllModules","NoPreloading","_NoPreloading","RouterPreloader","_RouterPreloader","preloadingStrategy","preload","processRoutes","_route$children","injectorForCurrentRoute","injectorForChildren","preloadConfig","recursiveLoadChildren$","loadedChildren$","_config$injector","loadComponent$","ROUTER_SCROLLER","RouterScroller","_RouterScroller","viewportScroller","zone","scrollPositionRestoration","anchorScrolling","setHistoryScrollRestoration","createScrollEvents","scrollEventsSubscription","consumeScrollEvents","lastId","getScrollPosition","lastSource","restoredId","scheduleScrollEvent","instantScroll","behavior","scrollToPosition","scrollToAnchor","runOutsideAngular","_asyncToGenerator","_regenerator","_callee","w","_context","requestAnimationFrame","run","_this$routerEventsSub","_this$scrollEventsSub","provideRouter","makeEnvironmentProviders","provide","multi","useValue","useFactory","rootRoute","deps","APP_BOOTSTRAP_LISTENER","getBootstrapListener","feature","providers","routerFeature","kind","kind","provideRoutes","withInMemoryScrolling","ViewportScroller","NgZone","Injector","bootstrappedComponentRef","_injector$get","_injector$get2","ApplicationRef","components","bootstrapDone","BOOTSTRAP_DONE","INITIAL_NAVIGATION","initialNavigation","ROUTER_PRELOADER","setUpPreloading","init","resetRootComponentType","componentTypes","withEnabledBlockingInitialNavigation","_IS_ENABLED_BLOCKING_INITIAL_NAVIGATION","provideAppInitializer","LOCATION_INITIALIZED","then","withDisabledInitialNavigation","withDebugTracing","withPreloading","useExisting","withRouterConfig","withHashLocation","LocationStrategy","useClass","HashLocationStrategy","withNavigationErrorHandler","withComponentInputBinding","withViewTransitions","_performanceMarkFeature","skipInitialTransition","ROUTER_PROVIDERS","RouterModule","_RouterModule","ngModule","errorHandler","useHash","PathLocationStrategy","scrollOffset","setOffset","provideInitialNavigation","bindToComponentInputs","enableViewTransitions","ROUTER_INITIALIZER","mapToCanMatch","provider","mapToCanActivate","_inject2","mapToCanActivateChild","_inject3","mapToCanDeactivate","_inject4","mapToResolve","_inject5","VERSION","Version"],"ignoreList":[],"sourceRoot":"webpack:///","sources":["./node_modules/rxjs/dist/esm/internal/observable/ConnectableObservable.js","./node_modules/rxjs/dist/esm/internal/operators/finalize.js","./node_modules/rxjs/dist/esm/internal/operators/refCount.js","./node_modules/rxjs/dist/esm/internal/util/isObservable.js","./node_modules/rxjs/dist/esm/internal/operators/takeLast.js","./node_modules/@angular/router/fesm2022/router2.mjs","./node_modules/rxjs/dist/esm/internal/operators/last.js","./node_modules/@angular/router/fesm2022/router_module.mjs","./node_modules/@angular/router/fesm2022/router.mjs"],"sourcesContent":["import { Observable } from '../Observable';\nimport { Subscription } from '../Subscription';\nimport { refCount as higherOrderRefCount } from '../operators/refCount';\nimport { createOperatorSubscriber } from '../operators/OperatorSubscriber';\nimport { hasLift } from '../util/lift';\nexport class ConnectableObservable extends Observable {\n    constructor(source, subjectFactory) {\n        super();\n        this.source = source;\n        this.subjectFactory = subjectFactory;\n        this._subject = null;\n        this._refCount = 0;\n        this._connection = null;\n        if (hasLift(source)) {\n            this.lift = source.lift;\n        }\n    }\n    _subscribe(subscriber) {\n        return this.getSubject().subscribe(subscriber);\n    }\n    getSubject() {\n        const subject = this._subject;\n        if (!subject || subject.isStopped) {\n            this._subject = this.subjectFactory();\n        }\n        return this._subject;\n    }\n    _teardown() {\n        this._refCount = 0;\n        const { _connection } = this;\n        this._subject = this._connection = null;\n        _connection === null || _connection === void 0 ? void 0 : _connection.unsubscribe();\n    }\n    connect() {\n        let connection = this._connection;\n        if (!connection) {\n            connection = this._connection = new Subscription();\n            const subject = this.getSubject();\n            connection.add(this.source.subscribe(createOperatorSubscriber(subject, undefined, () => {\n                this._teardown();\n                subject.complete();\n            }, (err) => {\n                this._teardown();\n                subject.error(err);\n            }, () => this._teardown())));\n            if (connection.closed) {\n                this._connection = null;\n                connection = Subscription.EMPTY;\n            }\n        }\n        return connection;\n    }\n    refCount() {\n        return higherOrderRefCount()(this);\n    }\n}\n","import { operate } from '../util/lift';\nexport function finalize(callback) {\n    return operate((source, subscriber) => {\n        try {\n            source.subscribe(subscriber);\n        }\n        finally {\n            subscriber.add(callback);\n        }\n    });\n}\n","import { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function refCount() {\n    return operate((source, subscriber) => {\n        let connection = null;\n        source._refCount++;\n        const refCounter = createOperatorSubscriber(subscriber, undefined, undefined, undefined, () => {\n            if (!source || source._refCount <= 0 || 0 < --source._refCount) {\n                connection = null;\n                return;\n            }\n            const sharedConnection = source._connection;\n            const conn = connection;\n            connection = null;\n            if (sharedConnection && (!conn || sharedConnection === conn)) {\n                sharedConnection.unsubscribe();\n            }\n            subscriber.unsubscribe();\n        });\n        source.subscribe(refCounter);\n        if (!refCounter.closed) {\n            connection = source.connect();\n        }\n    });\n}\n","import { Observable } from '../Observable';\nimport { isFunction } from './isFunction';\nexport function isObservable(obj) {\n    return !!obj && (obj instanceof Observable || (isFunction(obj.lift) && isFunction(obj.subscribe)));\n}\n","import { EMPTY } from '../observable/empty';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function takeLast(count) {\n    return count <= 0\n        ? () => EMPTY\n        : operate((source, subscriber) => {\n            let buffer = [];\n            source.subscribe(createOperatorSubscriber(subscriber, (value) => {\n                buffer.push(value);\n                count < buffer.length && buffer.shift();\n            }, () => {\n                for (const value of buffer) {\n                    subscriber.next(value);\n                }\n                subscriber.complete();\n            }, undefined, () => {\n                buffer = null;\n            }));\n        });\n}\n","/**\n * @license Angular v20.3.6\n * (c) 2010-2025 Google LLC. https://angular.dev/\n * License: MIT\n */\n\nimport { DOCUMENT, Location } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { isPromise as _isPromise, RuntimeError as _RuntimeError, Injectable, isNgModule as _isNgModule, isStandalone, createEnvironmentInjector, InjectionToken, EventEmitter, input, inject, ViewContainerRef, ChangeDetectorRef, Directive, Input, Output, reflectComponentType, Component, isInjectable as _isInjectable, runInInjectionContext, Compiler, NgModuleFactory, resolveComponentResources as _resolveComponentResources, afterNextRender, signal, EnvironmentInjector, DestroyRef, untracked, Console as _Console, PendingTasksInternal as _PendingTasksInternal, INTERNAL_APPLICATION_ERROR_HANDLER as _INTERNAL_APPLICATION_ERROR_HANDLER } from '@angular/core';\nimport { isObservable, from, of, BehaviorSubject, combineLatest, EmptyError, concat, defer, pipe, throwError, EMPTY, ConnectableObservable, Subject, Observable, Subscription } from 'rxjs';\nimport { map, switchMap, take, startWith, filter, mergeMap, first, concatMap, tap, catchError, scan, defaultIfEmpty, last as last$1, takeLast, finalize, refCount, takeUntil } from 'rxjs/operators';\nimport * as i1 from '@angular/platform-browser';\n\n/**\n * The primary routing outlet.\n *\n * @publicApi\n */\nconst PRIMARY_OUTLET = 'primary';\n/**\n * A private symbol used to store the value of `Route.title` inside the `Route.data` if it is a\n * static string or `Route.resolve` if anything else. This allows us to reuse the existing route\n * data/resolvers to support the title feature without new instrumentation in the `Router` pipeline.\n */\nconst RouteTitleKey = /* @__PURE__ */ Symbol('RouteTitle');\nclass ParamsAsMap {\n    params;\n    constructor(params) {\n        this.params = params || {};\n    }\n    has(name) {\n        return Object.prototype.hasOwnProperty.call(this.params, name);\n    }\n    get(name) {\n        if (this.has(name)) {\n            const v = this.params[name];\n            return Array.isArray(v) ? v[0] : v;\n        }\n        return null;\n    }\n    getAll(name) {\n        if (this.has(name)) {\n            const v = this.params[name];\n            return Array.isArray(v) ? v : [v];\n        }\n        return [];\n    }\n    get keys() {\n        return Object.keys(this.params);\n    }\n}\n/**\n * Converts a `Params` instance to a `ParamMap`.\n * @param params The instance to convert.\n * @returns The new map instance.\n *\n * @publicApi\n */\nfunction convertToParamMap(params) {\n    return new ParamsAsMap(params);\n}\n/**\n * Matches the route configuration (`route`) against the actual URL (`segments`).\n *\n * When no matcher is defined on a `Route`, this is the matcher used by the Router by default.\n *\n * @param segments The remaining unmatched segments in the current navigation\n * @param segmentGroup The current segment group being matched\n * @param route The `Route` to match against.\n *\n * @see {@link UrlMatchResult}\n * @see {@link Route}\n *\n * @returns The resulting match information or `null` if the `route` should not match.\n * @publicApi\n */\nfunction defaultUrlMatcher(segments, segmentGroup, route) {\n    const parts = route.path.split('/');\n    if (parts.length > segments.length) {\n        // The actual URL is shorter than the config, no match\n        return null;\n    }\n    if (route.pathMatch === 'full' &&\n        (segmentGroup.hasChildren() || parts.length < segments.length)) {\n        // The config is longer than the actual URL but we are looking for a full match, return null\n        return null;\n    }\n    const posParams = {};\n    // Check each config part against the actual URL\n    for (let index = 0; index < parts.length; index++) {\n        const part = parts[index];\n        const segment = segments[index];\n        const isParameter = part[0] === ':';\n        if (isParameter) {\n            posParams[part.substring(1)] = segment;\n        }\n        else if (part !== segment.path) {\n            // The actual URL part does not match the config, no match\n            return null;\n        }\n    }\n    return { consumed: segments.slice(0, parts.length), posParams };\n}\n\nfunction shallowEqualArrays(a, b) {\n    if (a.length !== b.length)\n        return false;\n    for (let i = 0; i < a.length; ++i) {\n        if (!shallowEqual(a[i], b[i]))\n            return false;\n    }\n    return true;\n}\nfunction shallowEqual(a, b) {\n    // While `undefined` should never be possible, it would sometimes be the case in IE 11\n    // and pre-chromium Edge. The check below accounts for this edge case.\n    const k1 = a ? getDataKeys(a) : undefined;\n    const k2 = b ? getDataKeys(b) : undefined;\n    if (!k1 || !k2 || k1.length != k2.length) {\n        return false;\n    }\n    let key;\n    for (let i = 0; i < k1.length; i++) {\n        key = k1[i];\n        if (!equalArraysOrString(a[key], b[key])) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Gets the keys of an object, including `symbol` keys.\n */\nfunction getDataKeys(obj) {\n    return [...Object.keys(obj), ...Object.getOwnPropertySymbols(obj)];\n}\n/**\n * Test equality for arrays of strings or a string.\n */\nfunction equalArraysOrString(a, b) {\n    if (Array.isArray(a) && Array.isArray(b)) {\n        if (a.length !== b.length)\n            return false;\n        const aSorted = [...a].sort();\n        const bSorted = [...b].sort();\n        return aSorted.every((val, index) => bSorted[index] === val);\n    }\n    else {\n        return a === b;\n    }\n}\n/**\n * Return the last element of an array.\n */\nfunction last(a) {\n    return a.length > 0 ? a[a.length - 1] : null;\n}\nfunction wrapIntoObservable(value) {\n    if (isObservable(value)) {\n        return value;\n    }\n    if (_isPromise(value)) {\n        // Use `Promise.resolve()` to wrap promise-like instances.\n        // Required ie when a Resolver returns a AngularJS `$q` promise to correctly trigger the\n        // change detection.\n        return from(Promise.resolve(value));\n    }\n    return of(value);\n}\n\nconst pathCompareMap = {\n    'exact': equalSegmentGroups,\n    'subset': containsSegmentGroup,\n};\nconst paramCompareMap = {\n    'exact': equalParams,\n    'subset': containsParams,\n    'ignored': () => true,\n};\nfunction containsTree(container, containee, options) {\n    return (pathCompareMap[options.paths](container.root, containee.root, options.matrixParams) &&\n        paramCompareMap[options.queryParams](container.queryParams, containee.queryParams) &&\n        !(options.fragment === 'exact' && container.fragment !== containee.fragment));\n}\nfunction equalParams(container, containee) {\n    // TODO: This does not handle array params correctly.\n    return shallowEqual(container, containee);\n}\nfunction equalSegmentGroups(container, containee, matrixParams) {\n    if (!equalPath(container.segments, containee.segments))\n        return false;\n    if (!matrixParamsMatch(container.segments, containee.segments, matrixParams)) {\n        return false;\n    }\n    if (container.numberOfChildren !== containee.numberOfChildren)\n        return false;\n    for (const c in containee.children) {\n        if (!container.children[c])\n            return false;\n        if (!equalSegmentGroups(container.children[c], containee.children[c], matrixParams))\n            return false;\n    }\n    return true;\n}\nfunction containsParams(container, containee) {\n    return (Object.keys(containee).length <= Object.keys(container).length &&\n        Object.keys(containee).every((key) => equalArraysOrString(container[key], containee[key])));\n}\nfunction containsSegmentGroup(container, containee, matrixParams) {\n    return containsSegmentGroupHelper(container, containee, containee.segments, matrixParams);\n}\nfunction containsSegmentGroupHelper(container, containee, containeePaths, matrixParams) {\n    if (container.segments.length > containeePaths.length) {\n        const current = container.segments.slice(0, containeePaths.length);\n        if (!equalPath(current, containeePaths))\n            return false;\n        if (containee.hasChildren())\n            return false;\n        if (!matrixParamsMatch(current, containeePaths, matrixParams))\n            return false;\n        return true;\n    }\n    else if (container.segments.length === containeePaths.length) {\n        if (!equalPath(container.segments, containeePaths))\n            return false;\n        if (!matrixParamsMatch(container.segments, containeePaths, matrixParams))\n            return false;\n        for (const c in containee.children) {\n            if (!container.children[c])\n                return false;\n            if (!containsSegmentGroup(container.children[c], containee.children[c], matrixParams)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    else {\n        const current = containeePaths.slice(0, container.segments.length);\n        const next = containeePaths.slice(container.segments.length);\n        if (!equalPath(container.segments, current))\n            return false;\n        if (!matrixParamsMatch(container.segments, current, matrixParams))\n            return false;\n        if (!container.children[PRIMARY_OUTLET])\n            return false;\n        return containsSegmentGroupHelper(container.children[PRIMARY_OUTLET], containee, next, matrixParams);\n    }\n}\nfunction matrixParamsMatch(containerPaths, containeePaths, options) {\n    return containeePaths.every((containeeSegment, i) => {\n        return paramCompareMap[options](containerPaths[i].parameters, containeeSegment.parameters);\n    });\n}\n/**\n * @description\n *\n * Represents the parsed URL.\n *\n * Since a router state is a tree, and the URL is nothing but a serialized state, the URL is a\n * serialized tree.\n * UrlTree is a data structure that provides a lot of affordances in dealing with URLs\n *\n * @usageNotes\n * ### Example\n *\n * ```ts\n * @Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const tree: UrlTree =\n *       router.parseUrl('/team/33/(user/victor//support:help)?debug=true#fragment');\n *     const f = tree.fragment; // return 'fragment'\n *     const q = tree.queryParams; // returns {debug: 'true'}\n *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];\n *     const s: UrlSegment[] = g.segments; // returns 2 segments 'team' and '33'\n *     g.children[PRIMARY_OUTLET].segments; // returns 2 segments 'user' and 'victor'\n *     g.children['support'].segments; // return 1 segment 'help'\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nclass UrlTree {\n    root;\n    queryParams;\n    fragment;\n    /** @internal */\n    _queryParamMap;\n    constructor(\n    /** The root segment group of the URL tree */\n    root = new UrlSegmentGroup([], {}), \n    /** The query params of the URL */\n    queryParams = {}, \n    /** The fragment of the URL */\n    fragment = null) {\n        this.root = root;\n        this.queryParams = queryParams;\n        this.fragment = fragment;\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            if (root.segments.length > 0) {\n                throw new _RuntimeError(4015 /* RuntimeErrorCode.INVALID_ROOT_URL_SEGMENT */, 'The root `UrlSegmentGroup` should not contain `segments`. ' +\n                    'Instead, these segments belong in the `children` so they can be associated with a named outlet.');\n            }\n        }\n    }\n    get queryParamMap() {\n        this._queryParamMap ??= convertToParamMap(this.queryParams);\n        return this._queryParamMap;\n    }\n    /** @docsNotRequired */\n    toString() {\n        return DEFAULT_SERIALIZER.serialize(this);\n    }\n}\n/**\n * @description\n *\n * Represents the parsed URL segment group.\n *\n * See `UrlTree` for more information.\n *\n * @publicApi\n */\nclass UrlSegmentGroup {\n    segments;\n    children;\n    /** The parent node in the url tree */\n    parent = null;\n    constructor(\n    /** The URL segments of this group. See `UrlSegment` for more information */\n    segments, \n    /** The list of children of this group */\n    children) {\n        this.segments = segments;\n        this.children = children;\n        Object.values(children).forEach((v) => (v.parent = this));\n    }\n    /** Whether the segment has child segments */\n    hasChildren() {\n        return this.numberOfChildren > 0;\n    }\n    /** Number of child segments */\n    get numberOfChildren() {\n        return Object.keys(this.children).length;\n    }\n    /** @docsNotRequired */\n    toString() {\n        return serializePaths(this);\n    }\n}\n/**\n * @description\n *\n * Represents a single URL segment.\n *\n * A UrlSegment is a part of a URL between the two slashes. It contains a path and the matrix\n * parameters associated with the segment.\n *\n * @usageNotes\n *### Example\n *\n * ```ts\n * @Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const tree: UrlTree = router.parseUrl('/team;id=33');\n *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];\n *     const s: UrlSegment[] = g.segments;\n *     s[0].path; // returns 'team'\n *     s[0].parameters; // returns {id: 33}\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nclass UrlSegment {\n    path;\n    parameters;\n    /** @internal */\n    _parameterMap;\n    constructor(\n    /** The path part of a URL segment */\n    path, \n    /** The matrix parameters associated with a segment */\n    parameters) {\n        this.path = path;\n        this.parameters = parameters;\n    }\n    get parameterMap() {\n        this._parameterMap ??= convertToParamMap(this.parameters);\n        return this._parameterMap;\n    }\n    /** @docsNotRequired */\n    toString() {\n        return serializePath(this);\n    }\n}\nfunction equalSegments(as, bs) {\n    return equalPath(as, bs) && as.every((a, i) => shallowEqual(a.parameters, bs[i].parameters));\n}\nfunction equalPath(as, bs) {\n    if (as.length !== bs.length)\n        return false;\n    return as.every((a, i) => a.path === bs[i].path);\n}\nfunction mapChildrenIntoArray(segment, fn) {\n    let res = [];\n    Object.entries(segment.children).forEach(([childOutlet, child]) => {\n        if (childOutlet === PRIMARY_OUTLET) {\n            res = res.concat(fn(child, childOutlet));\n        }\n    });\n    Object.entries(segment.children).forEach(([childOutlet, child]) => {\n        if (childOutlet !== PRIMARY_OUTLET) {\n            res = res.concat(fn(child, childOutlet));\n        }\n    });\n    return res;\n}\n/**\n * @description\n *\n * Serializes and deserializes a URL string into a URL tree.\n *\n * The url serialization strategy is customizable. You can\n * make all URLs case insensitive by providing a custom UrlSerializer.\n *\n * See `DefaultUrlSerializer` for an example of a URL serializer.\n *\n * @publicApi\n */\nclass UrlSerializer {\n    static fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: UrlSerializer, deps: [], target: i0.FactoryTarget.Injectable });\n    static prov = i0.ngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: UrlSerializer, providedIn: 'root', useFactory: () => new DefaultUrlSerializer() });\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: UrlSerializer, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root', useFactory: () => new DefaultUrlSerializer() }]\n        }] });\n/**\n * @description\n *\n * A default implementation of the `UrlSerializer`.\n *\n * Example URLs:\n *\n * ```\n * /inbox/33(popup:compose)\n * /inbox/33;open=true/messages/44\n * ```\n *\n * DefaultUrlSerializer uses parentheses to serialize secondary segments (e.g., popup:compose), the\n * colon syntax to specify the outlet, and the ';parameter=value' syntax (e.g., open=true) to\n * specify route specific parameters.\n *\n * @publicApi\n */\nclass DefaultUrlSerializer {\n    /** Parses a url into a `UrlTree` */\n    parse(url) {\n        const p = new UrlParser(url);\n        return new UrlTree(p.parseRootSegment(), p.parseQueryParams(), p.parseFragment());\n    }\n    /** Converts a `UrlTree` into a url */\n    serialize(tree) {\n        const segment = `/${serializeSegment(tree.root, true)}`;\n        const query = serializeQueryParams(tree.queryParams);\n        const fragment = typeof tree.fragment === `string` ? `#${encodeUriFragment(tree.fragment)}` : '';\n        return `${segment}${query}${fragment}`;\n    }\n}\nconst DEFAULT_SERIALIZER = new DefaultUrlSerializer();\nfunction serializePaths(segment) {\n    return segment.segments.map((p) => serializePath(p)).join('/');\n}\nfunction serializeSegment(segment, root) {\n    if (!segment.hasChildren()) {\n        return serializePaths(segment);\n    }\n    if (root) {\n        const primary = segment.children[PRIMARY_OUTLET]\n            ? serializeSegment(segment.children[PRIMARY_OUTLET], false)\n            : '';\n        const children = [];\n        Object.entries(segment.children).forEach(([k, v]) => {\n            if (k !== PRIMARY_OUTLET) {\n                children.push(`${k}:${serializeSegment(v, false)}`);\n            }\n        });\n        return children.length > 0 ? `${primary}(${children.join('//')})` : primary;\n    }\n    else {\n        const children = mapChildrenIntoArray(segment, (v, k) => {\n            if (k === PRIMARY_OUTLET) {\n                return [serializeSegment(segment.children[PRIMARY_OUTLET], false)];\n            }\n            return [`${k}:${serializeSegment(v, false)}`];\n        });\n        // use no parenthesis if the only child is a primary outlet route\n        if (Object.keys(segment.children).length === 1 && segment.children[PRIMARY_OUTLET] != null) {\n            return `${serializePaths(segment)}/${children[0]}`;\n        }\n        return `${serializePaths(segment)}/(${children.join('//')})`;\n    }\n}\n/**\n * Encodes a URI string with the default encoding. This function will only ever be called from\n * `encodeUriQuery` or `encodeUriSegment` as it's the base set of encodings to be used. We need\n * a custom encoding because encodeURIComponent is too aggressive and encodes stuff that doesn't\n * have to be encoded per https://url.spec.whatwg.org.\n */\nfunction encodeUriString(s) {\n    return encodeURIComponent(s)\n        .replace(/%40/g, '@')\n        .replace(/%3A/gi, ':')\n        .replace(/%24/g, '$')\n        .replace(/%2C/gi, ',');\n}\n/**\n * This function should be used to encode both keys and values in a query string key/value. In\n * the following URL, you need to call encodeUriQuery on \"k\" and \"v\":\n *\n * http://www.site.org/html;mk=mv?k=v#f\n */\nfunction encodeUriQuery(s) {\n    return encodeUriString(s).replace(/%3B/gi, ';');\n}\n/**\n * This function should be used to encode a URL fragment. In the following URL, you need to call\n * encodeUriFragment on \"f\":\n *\n * http://www.site.org/html;mk=mv?k=v#f\n */\nfunction encodeUriFragment(s) {\n    return encodeURI(s);\n}\n/**\n * This function should be run on any URI segment as well as the key and value in a key/value\n * pair for matrix params. In the following URL, you need to call encodeUriSegment on \"html\",\n * \"mk\", and \"mv\":\n *\n * http://www.site.org/html;mk=mv?k=v#f\n */\nfunction encodeUriSegment(s) {\n    return encodeUriString(s).replace(/\\(/g, '%28').replace(/\\)/g, '%29').replace(/%26/gi, '&');\n}\nfunction decode(s) {\n    return decodeURIComponent(s);\n}\n// Query keys/values should have the \"+\" replaced first, as \"+\" in a query string is \" \".\n// decodeURIComponent function will not decode \"+\" as a space.\nfunction decodeQuery(s) {\n    return decode(s.replace(/\\+/g, '%20'));\n}\nfunction serializePath(path) {\n    return `${encodeUriSegment(path.path)}${serializeMatrixParams(path.parameters)}`;\n}\nfunction serializeMatrixParams(params) {\n    return Object.entries(params)\n        .map(([key, value]) => `;${encodeUriSegment(key)}=${encodeUriSegment(value)}`)\n        .join('');\n}\nfunction serializeQueryParams(params) {\n    const strParams = Object.entries(params)\n        .map(([name, value]) => {\n        return Array.isArray(value)\n            ? value.map((v) => `${encodeUriQuery(name)}=${encodeUriQuery(v)}`).join('&')\n            : `${encodeUriQuery(name)}=${encodeUriQuery(value)}`;\n    })\n        .filter((s) => s);\n    return strParams.length ? `?${strParams.join('&')}` : '';\n}\nconst SEGMENT_RE = /^[^\\/()?;#]+/;\nfunction matchSegments(str) {\n    const match = str.match(SEGMENT_RE);\n    return match ? match[0] : '';\n}\nconst MATRIX_PARAM_SEGMENT_RE = /^[^\\/()?;=#]+/;\nfunction matchMatrixKeySegments(str) {\n    const match = str.match(MATRIX_PARAM_SEGMENT_RE);\n    return match ? match[0] : '';\n}\nconst QUERY_PARAM_RE = /^[^=?&#]+/;\n// Return the name of the query param at the start of the string or an empty string\nfunction matchQueryParams(str) {\n    const match = str.match(QUERY_PARAM_RE);\n    return match ? match[0] : '';\n}\nconst QUERY_PARAM_VALUE_RE = /^[^&#]+/;\n// Return the value of the query param at the start of the string or an empty string\nfunction matchUrlQueryParamValue(str) {\n    const match = str.match(QUERY_PARAM_VALUE_RE);\n    return match ? match[0] : '';\n}\nclass UrlParser {\n    url;\n    remaining;\n    constructor(url) {\n        this.url = url;\n        this.remaining = url;\n    }\n    parseRootSegment() {\n        this.consumeOptional('/');\n        if (this.remaining === '' || this.peekStartsWith('?') || this.peekStartsWith('#')) {\n            return new UrlSegmentGroup([], {});\n        }\n        // The root segment group never has segments\n        return new UrlSegmentGroup([], this.parseChildren());\n    }\n    parseQueryParams() {\n        const params = {};\n        if (this.consumeOptional('?')) {\n            do {\n                this.parseQueryParam(params);\n            } while (this.consumeOptional('&'));\n        }\n        return params;\n    }\n    parseFragment() {\n        return this.consumeOptional('#') ? decodeURIComponent(this.remaining) : null;\n    }\n    parseChildren() {\n        if (this.remaining === '') {\n            return {};\n        }\n        this.consumeOptional('/');\n        const segments = [];\n        if (!this.peekStartsWith('(')) {\n            segments.push(this.parseSegment());\n        }\n        while (this.peekStartsWith('/') && !this.peekStartsWith('//') && !this.peekStartsWith('/(')) {\n            this.capture('/');\n            segments.push(this.parseSegment());\n        }\n        let children = {};\n        if (this.peekStartsWith('/(')) {\n            this.capture('/');\n            children = this.parseParens(true);\n        }\n        let res = {};\n        if (this.peekStartsWith('(')) {\n            res = this.parseParens(false);\n        }\n        if (segments.length > 0 || Object.keys(children).length > 0) {\n            res[PRIMARY_OUTLET] = new UrlSegmentGroup(segments, children);\n        }\n        return res;\n    }\n    // parse a segment with its matrix parameters\n    // ie `name;k1=v1;k2`\n    parseSegment() {\n        const path = matchSegments(this.remaining);\n        if (path === '' && this.peekStartsWith(';')) {\n            throw new _RuntimeError(4009 /* RuntimeErrorCode.EMPTY_PATH_WITH_PARAMS */, (typeof ngDevMode === 'undefined' || ngDevMode) &&\n                `Empty path url segment cannot have parameters: '${this.remaining}'.`);\n        }\n        this.capture(path);\n        return new UrlSegment(decode(path), this.parseMatrixParams());\n    }\n    parseMatrixParams() {\n        const params = {};\n        while (this.consumeOptional(';')) {\n            this.parseParam(params);\n        }\n        return params;\n    }\n    parseParam(params) {\n        const key = matchMatrixKeySegments(this.remaining);\n        if (!key) {\n            return;\n        }\n        this.capture(key);\n        let value = '';\n        if (this.consumeOptional('=')) {\n            const valueMatch = matchSegments(this.remaining);\n            if (valueMatch) {\n                value = valueMatch;\n                this.capture(value);\n            }\n        }\n        params[decode(key)] = decode(value);\n    }\n    // Parse a single query parameter `name[=value]`\n    parseQueryParam(params) {\n        const key = matchQueryParams(this.remaining);\n        if (!key) {\n            return;\n        }\n        this.capture(key);\n        let value = '';\n        if (this.consumeOptional('=')) {\n            const valueMatch = matchUrlQueryParamValue(this.remaining);\n            if (valueMatch) {\n                value = valueMatch;\n                this.capture(value);\n            }\n        }\n        const decodedKey = decodeQuery(key);\n        const decodedVal = decodeQuery(value);\n        if (params.hasOwnProperty(decodedKey)) {\n            // Append to existing values\n            let currentVal = params[decodedKey];\n            if (!Array.isArray(currentVal)) {\n                currentVal = [currentVal];\n                params[decodedKey] = currentVal;\n            }\n            currentVal.push(decodedVal);\n        }\n        else {\n            // Create a new value\n            params[decodedKey] = decodedVal;\n        }\n    }\n    // parse `(a/b//outlet_name:c/d)`\n    parseParens(allowPrimary) {\n        const segments = {};\n        this.capture('(');\n        while (!this.consumeOptional(')') && this.remaining.length > 0) {\n            const path = matchSegments(this.remaining);\n            const next = this.remaining[path.length];\n            // if is is not one of these characters, then the segment was unescaped\n            // or the group was not closed\n            if (next !== '/' && next !== ')' && next !== ';') {\n                throw new _RuntimeError(4010 /* RuntimeErrorCode.UNPARSABLE_URL */, (typeof ngDevMode === 'undefined' || ngDevMode) && `Cannot parse url '${this.url}'`);\n            }\n            let outletName = undefined;\n            if (path.indexOf(':') > -1) {\n                outletName = path.slice(0, path.indexOf(':'));\n                this.capture(outletName);\n                this.capture(':');\n            }\n            else if (allowPrimary) {\n                outletName = PRIMARY_OUTLET;\n            }\n            const children = this.parseChildren();\n            segments[outletName] =\n                Object.keys(children).length === 1\n                    ? children[PRIMARY_OUTLET]\n                    : new UrlSegmentGroup([], children);\n            this.consumeOptional('//');\n        }\n        return segments;\n    }\n    peekStartsWith(str) {\n        return this.remaining.startsWith(str);\n    }\n    // Consumes the prefix when it is present and returns whether it has been consumed\n    consumeOptional(str) {\n        if (this.peekStartsWith(str)) {\n            this.remaining = this.remaining.substring(str.length);\n            return true;\n        }\n        return false;\n    }\n    capture(str) {\n        if (!this.consumeOptional(str)) {\n            throw new _RuntimeError(4011 /* RuntimeErrorCode.UNEXPECTED_VALUE_IN_URL */, (typeof ngDevMode === 'undefined' || ngDevMode) && `Expected \"${str}\".`);\n        }\n    }\n}\nfunction createRoot(rootCandidate) {\n    return rootCandidate.segments.length > 0\n        ? new UrlSegmentGroup([], { [PRIMARY_OUTLET]: rootCandidate })\n        : rootCandidate;\n}\n/**\n * Recursively\n * - merges primary segment children into their parents\n * - drops empty children (those which have no segments and no children themselves). This latter\n * prevents serializing a group into something like `/a(aux:)`, where `aux` is an empty child\n * segment.\n * - merges named outlets without a primary segment sibling into the children. This prevents\n * serializing a URL like `//(a:a)(b:b) instead of `/(a:a//b:b)` when the aux b route lives on the\n * root but the `a` route lives under an empty path primary route.\n */\nfunction squashSegmentGroup(segmentGroup) {\n    const newChildren = {};\n    for (const [childOutlet, child] of Object.entries(segmentGroup.children)) {\n        const childCandidate = squashSegmentGroup(child);\n        // moves named children in an empty path primary child into this group\n        if (childOutlet === PRIMARY_OUTLET &&\n            childCandidate.segments.length === 0 &&\n            childCandidate.hasChildren()) {\n            for (const [grandChildOutlet, grandChild] of Object.entries(childCandidate.children)) {\n                newChildren[grandChildOutlet] = grandChild;\n            }\n        } // don't add empty children\n        else if (childCandidate.segments.length > 0 || childCandidate.hasChildren()) {\n            newChildren[childOutlet] = childCandidate;\n        }\n    }\n    const s = new UrlSegmentGroup(segmentGroup.segments, newChildren);\n    return mergeTrivialChildren(s);\n}\n/**\n * When possible, merges the primary outlet child into the parent `UrlSegmentGroup`.\n *\n * When a segment group has only one child which is a primary outlet, merges that child into the\n * parent. That is, the child segment group's segments are merged into the `s` and the child's\n * children become the children of `s`. Think of this like a 'squash', merging the child segment\n * group into the parent.\n */\nfunction mergeTrivialChildren(s) {\n    if (s.numberOfChildren === 1 && s.children[PRIMARY_OUTLET]) {\n        const c = s.children[PRIMARY_OUTLET];\n        return new UrlSegmentGroup(s.segments.concat(c.segments), c.children);\n    }\n    return s;\n}\nfunction isUrlTree(v) {\n    return v instanceof UrlTree;\n}\n\n/**\n * Creates a `UrlTree` relative to an `ActivatedRouteSnapshot`.\n *\n * @publicApi\n *\n *\n * @param relativeTo The `ActivatedRouteSnapshot` to apply the commands to\n * @param commands An array of URL fragments with which to construct the new URL tree.\n * If the path is static, can be the literal URL string. For a dynamic path, pass an array of path\n * segments, followed by the parameters for each segment.\n * The fragments are applied to the one provided in the `relativeTo` parameter.\n * @param queryParams The query parameters for the `UrlTree`. `null` if the `UrlTree` does not have\n *     any query parameters.\n * @param fragment The fragment for the `UrlTree`. `null` if the `UrlTree` does not have a fragment.\n *\n * @usageNotes\n *\n * ```ts\n * // create /team/33/user/11\n * createUrlTreeFromSnapshot(snapshot, ['/team', 33, 'user', 11]);\n *\n * // create /team/33;expand=true/user/11\n * createUrlTreeFromSnapshot(snapshot, ['/team', 33, {expand: true}, 'user', 11]);\n *\n * // you can collapse static segments like this (this works only with the first passed-in value):\n * createUrlTreeFromSnapshot(snapshot, ['/team/33/user', userId]);\n *\n * // If the first segment can contain slashes, and you do not want the router to split it,\n * // you can do the following:\n * createUrlTreeFromSnapshot(snapshot, [{segmentPath: '/one/two'}]);\n *\n * // create /team/33/(user/11//right:chat)\n * createUrlTreeFromSnapshot(snapshot, ['/team', 33, {outlets: {primary: 'user/11', right:\n * 'chat'}}], null, null);\n *\n * // remove the right secondary node\n * createUrlTreeFromSnapshot(snapshot, ['/team', 33, {outlets: {primary: 'user/11', right: null}}]);\n *\n * // For the examples below, assume the current URL is for the `/team/33/user/11` and the\n * `ActivatedRouteSnapshot` points to `user/11`:\n *\n * // navigate to /team/33/user/11/details\n * createUrlTreeFromSnapshot(snapshot, ['details']);\n *\n * // navigate to /team/33/user/22\n * createUrlTreeFromSnapshot(snapshot, ['../22']);\n *\n * // navigate to /team/44/user/22\n * createUrlTreeFromSnapshot(snapshot, ['../../team/44/user/22']);\n * ```\n */\nfunction createUrlTreeFromSnapshot(relativeTo, commands, queryParams = null, fragment = null) {\n    const relativeToUrlSegmentGroup = createSegmentGroupFromRoute(relativeTo);\n    return createUrlTreeFromSegmentGroup(relativeToUrlSegmentGroup, commands, queryParams, fragment);\n}\nfunction createSegmentGroupFromRoute(route) {\n    let targetGroup;\n    function createSegmentGroupFromRouteRecursive(currentRoute) {\n        const childOutlets = {};\n        for (const childSnapshot of currentRoute.children) {\n            const root = createSegmentGroupFromRouteRecursive(childSnapshot);\n            childOutlets[childSnapshot.outlet] = root;\n        }\n        const segmentGroup = new UrlSegmentGroup(currentRoute.url, childOutlets);\n        if (currentRoute === route) {\n            targetGroup = segmentGroup;\n        }\n        return segmentGroup;\n    }\n    const rootCandidate = createSegmentGroupFromRouteRecursive(route.root);\n    const rootSegmentGroup = createRoot(rootCandidate);\n    return targetGroup ?? rootSegmentGroup;\n}\nfunction createUrlTreeFromSegmentGroup(relativeTo, commands, queryParams, fragment) {\n    let root = relativeTo;\n    while (root.parent) {\n        root = root.parent;\n    }\n    // There are no commands so the `UrlTree` goes to the same path as the one created from the\n    // `UrlSegmentGroup`. All we need to do is update the `queryParams` and `fragment` without\n    // applying any other logic.\n    if (commands.length === 0) {\n        return tree(root, root, root, queryParams, fragment);\n    }\n    const nav = computeNavigation(commands);\n    if (nav.toRoot()) {\n        return tree(root, root, new UrlSegmentGroup([], {}), queryParams, fragment);\n    }\n    const position = findStartingPositionForTargetGroup(nav, root, relativeTo);\n    const newSegmentGroup = position.processChildren\n        ? updateSegmentGroupChildren(position.segmentGroup, position.index, nav.commands)\n        : updateSegmentGroup(position.segmentGroup, position.index, nav.commands);\n    return tree(root, position.segmentGroup, newSegmentGroup, queryParams, fragment);\n}\nfunction isMatrixParams(command) {\n    return typeof command === 'object' && command != null && !command.outlets && !command.segmentPath;\n}\n/**\n * Determines if a given command has an `outlets` map. When we encounter a command\n * with an outlets k/v map, we need to apply each outlet individually to the existing segment.\n */\nfunction isCommandWithOutlets(command) {\n    return typeof command === 'object' && command != null && command.outlets;\n}\nfunction tree(oldRoot, oldSegmentGroup, newSegmentGroup, queryParams, fragment) {\n    let qp = {};\n    if (queryParams) {\n        Object.entries(queryParams).forEach(([name, value]) => {\n            qp[name] = Array.isArray(value) ? value.map((v) => `${v}`) : `${value}`;\n        });\n    }\n    let rootCandidate;\n    if (oldRoot === oldSegmentGroup) {\n        rootCandidate = newSegmentGroup;\n    }\n    else {\n        rootCandidate = replaceSegment(oldRoot, oldSegmentGroup, newSegmentGroup);\n    }\n    const newRoot = createRoot(squashSegmentGroup(rootCandidate));\n    return new UrlTree(newRoot, qp, fragment);\n}\n/**\n * Replaces the `oldSegment` which is located in some child of the `current` with the `newSegment`.\n * This also has the effect of creating new `UrlSegmentGroup` copies to update references. This\n * shouldn't be necessary but the fallback logic for an invalid ActivatedRoute in the creation uses\n * the Router's current url tree. If we don't create new segment groups, we end up modifying that\n * value.\n */\nfunction replaceSegment(current, oldSegment, newSegment) {\n    const children = {};\n    Object.entries(current.children).forEach(([outletName, c]) => {\n        if (c === oldSegment) {\n            children[outletName] = newSegment;\n        }\n        else {\n            children[outletName] = replaceSegment(c, oldSegment, newSegment);\n        }\n    });\n    return new UrlSegmentGroup(current.segments, children);\n}\nclass Navigation {\n    isAbsolute;\n    numberOfDoubleDots;\n    commands;\n    constructor(isAbsolute, numberOfDoubleDots, commands) {\n        this.isAbsolute = isAbsolute;\n        this.numberOfDoubleDots = numberOfDoubleDots;\n        this.commands = commands;\n        if (isAbsolute && commands.length > 0 && isMatrixParams(commands[0])) {\n            throw new _RuntimeError(4003 /* RuntimeErrorCode.ROOT_SEGMENT_MATRIX_PARAMS */, (typeof ngDevMode === 'undefined' || ngDevMode) &&\n                'Root segment cannot have matrix parameters');\n        }\n        const cmdWithOutlet = commands.find(isCommandWithOutlets);\n        if (cmdWithOutlet && cmdWithOutlet !== last(commands)) {\n            throw new _RuntimeError(4004 /* RuntimeErrorCode.MISPLACED_OUTLETS_COMMAND */, (typeof ngDevMode === 'undefined' || ngDevMode) &&\n                '{outlets:{}} has to be the last command');\n        }\n    }\n    toRoot() {\n        return this.isAbsolute && this.commands.length === 1 && this.commands[0] == '/';\n    }\n}\n/** Transforms commands to a normalized `Navigation` */\nfunction computeNavigation(commands) {\n    if (typeof commands[0] === 'string' && commands.length === 1 && commands[0] === '/') {\n        return new Navigation(true, 0, commands);\n    }\n    let numberOfDoubleDots = 0;\n    let isAbsolute = false;\n    const res = commands.reduce((res, cmd, cmdIdx) => {\n        if (typeof cmd === 'object' && cmd != null) {\n            if (cmd.outlets) {\n                const outlets = {};\n                Object.entries(cmd.outlets).forEach(([name, commands]) => {\n                    outlets[name] = typeof commands === 'string' ? commands.split('/') : commands;\n                });\n                return [...res, { outlets }];\n            }\n            if (cmd.segmentPath) {\n                return [...res, cmd.segmentPath];\n            }\n        }\n        if (!(typeof cmd === 'string')) {\n            return [...res, cmd];\n        }\n        if (cmdIdx === 0) {\n            cmd.split('/').forEach((urlPart, partIndex) => {\n                if (partIndex == 0 && urlPart === '.') ;\n                else if (partIndex == 0 && urlPart === '') {\n                    //  '/a'\n                    isAbsolute = true;\n                }\n                else if (urlPart === '..') {\n                    //  '../a'\n                    numberOfDoubleDots++;\n                }\n                else if (urlPart != '') {\n                    res.push(urlPart);\n                }\n            });\n            return res;\n        }\n        return [...res, cmd];\n    }, []);\n    return new Navigation(isAbsolute, numberOfDoubleDots, res);\n}\nclass Position {\n    segmentGroup;\n    processChildren;\n    index;\n    constructor(segmentGroup, processChildren, index) {\n        this.segmentGroup = segmentGroup;\n        this.processChildren = processChildren;\n        this.index = index;\n    }\n}\nfunction findStartingPositionForTargetGroup(nav, root, target) {\n    if (nav.isAbsolute) {\n        return new Position(root, true, 0);\n    }\n    if (!target) {\n        // `NaN` is used only to maintain backwards compatibility with incorrectly mocked\n        // `ActivatedRouteSnapshot` in tests. In prior versions of this code, the position here was\n        // determined based on an internal property that was rarely mocked, resulting in `NaN`. In\n        // reality, this code path should _never_ be touched since `target` is not allowed to be falsey.\n        return new Position(root, false, NaN);\n    }\n    if (target.parent === null) {\n        return new Position(target, true, 0);\n    }\n    const modifier = isMatrixParams(nav.commands[0]) ? 0 : 1;\n    const index = target.segments.length - 1 + modifier;\n    return createPositionApplyingDoubleDots(target, index, nav.numberOfDoubleDots);\n}\nfunction createPositionApplyingDoubleDots(group, index, numberOfDoubleDots) {\n    let g = group;\n    let ci = index;\n    let dd = numberOfDoubleDots;\n    while (dd > ci) {\n        dd -= ci;\n        g = g.parent;\n        if (!g) {\n            throw new _RuntimeError(4005 /* RuntimeErrorCode.INVALID_DOUBLE_DOTS */, (typeof ngDevMode === 'undefined' || ngDevMode) && \"Invalid number of '../'\");\n        }\n        ci = g.segments.length;\n    }\n    return new Position(g, false, ci - dd);\n}\nfunction getOutlets(commands) {\n    if (isCommandWithOutlets(commands[0])) {\n        return commands[0].outlets;\n    }\n    return { [PRIMARY_OUTLET]: commands };\n}\nfunction updateSegmentGroup(segmentGroup, startIndex, commands) {\n    segmentGroup ??= new UrlSegmentGroup([], {});\n    if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n        return updateSegmentGroupChildren(segmentGroup, startIndex, commands);\n    }\n    const m = prefixedWith(segmentGroup, startIndex, commands);\n    const slicedCommands = commands.slice(m.commandIndex);\n    if (m.match && m.pathIndex < segmentGroup.segments.length) {\n        const g = new UrlSegmentGroup(segmentGroup.segments.slice(0, m.pathIndex), {});\n        g.children[PRIMARY_OUTLET] = new UrlSegmentGroup(segmentGroup.segments.slice(m.pathIndex), segmentGroup.children);\n        return updateSegmentGroupChildren(g, 0, slicedCommands);\n    }\n    else if (m.match && slicedCommands.length === 0) {\n        return new UrlSegmentGroup(segmentGroup.segments, {});\n    }\n    else if (m.match && !segmentGroup.hasChildren()) {\n        return createNewSegmentGroup(segmentGroup, startIndex, commands);\n    }\n    else if (m.match) {\n        return updateSegmentGroupChildren(segmentGroup, 0, slicedCommands);\n    }\n    else {\n        return createNewSegmentGroup(segmentGroup, startIndex, commands);\n    }\n}\nfunction updateSegmentGroupChildren(segmentGroup, startIndex, commands) {\n    if (commands.length === 0) {\n        return new UrlSegmentGroup(segmentGroup.segments, {});\n    }\n    else {\n        const outlets = getOutlets(commands);\n        const children = {};\n        // If the set of commands applies to anything other than the primary outlet and the child\n        // segment is an empty path primary segment on its own, we want to apply the commands to the\n        // empty child path rather than here. The outcome is that the empty primary child is effectively\n        // removed from the final output UrlTree. Imagine the following config:\n        //\n        // {path: '', children: [{path: '**', outlet: 'popup'}]}.\n        //\n        // Navigation to /(popup:a) will activate the child outlet correctly Given a follow-up\n        // navigation with commands\n        // ['/', {outlets: {'popup': 'b'}}], we _would not_ want to apply the outlet commands to the\n        // root segment because that would result in\n        // //(popup:a)(popup:b) since the outlet command got applied one level above where it appears in\n        // the `ActivatedRoute` rather than updating the existing one.\n        //\n        // Because empty paths do not appear in the URL segments and the fact that the segments used in\n        // the output `UrlTree` are squashed to eliminate these empty paths where possible\n        // https://github.com/angular/angular/blob/13f10de40e25c6900ca55bd83b36bd533dacfa9e/packages/router/src/url_tree.ts#L755\n        // it can be hard to determine what is the right thing to do when applying commands to a\n        // `UrlSegmentGroup` that is created from an \"unsquashed\"/expanded `ActivatedRoute` tree.\n        // This code effectively \"squashes\" empty path primary routes when they have no siblings on\n        // the same level of the tree.\n        if (Object.keys(outlets).some((o) => o !== PRIMARY_OUTLET) &&\n            segmentGroup.children[PRIMARY_OUTLET] &&\n            segmentGroup.numberOfChildren === 1 &&\n            segmentGroup.children[PRIMARY_OUTLET].segments.length === 0) {\n            const childrenOfEmptyChild = updateSegmentGroupChildren(segmentGroup.children[PRIMARY_OUTLET], startIndex, commands);\n            return new UrlSegmentGroup(segmentGroup.segments, childrenOfEmptyChild.children);\n        }\n        Object.entries(outlets).forEach(([outlet, commands]) => {\n            if (typeof commands === 'string') {\n                commands = [commands];\n            }\n            if (commands !== null) {\n                children[outlet] = updateSegmentGroup(segmentGroup.children[outlet], startIndex, commands);\n            }\n        });\n        Object.entries(segmentGroup.children).forEach(([childOutlet, child]) => {\n            if (outlets[childOutlet] === undefined) {\n                children[childOutlet] = child;\n            }\n        });\n        return new UrlSegmentGroup(segmentGroup.segments, children);\n    }\n}\nfunction prefixedWith(segmentGroup, startIndex, commands) {\n    let currentCommandIndex = 0;\n    let currentPathIndex = startIndex;\n    const noMatch = { match: false, pathIndex: 0, commandIndex: 0 };\n    while (currentPathIndex < segmentGroup.segments.length) {\n        if (currentCommandIndex >= commands.length)\n            return noMatch;\n        const path = segmentGroup.segments[currentPathIndex];\n        const command = commands[currentCommandIndex];\n        // Do not try to consume command as part of the prefixing if it has outlets because it can\n        // contain outlets other than the one being processed. Consuming the outlets command would\n        // result in other outlets being ignored.\n        if (isCommandWithOutlets(command)) {\n            break;\n        }\n        const curr = `${command}`;\n        const next = currentCommandIndex < commands.length - 1 ? commands[currentCommandIndex + 1] : null;\n        if (currentPathIndex > 0 && curr === undefined)\n            break;\n        if (curr && next && typeof next === 'object' && next.outlets === undefined) {\n            if (!compare(curr, next, path))\n                return noMatch;\n            currentCommandIndex += 2;\n        }\n        else {\n            if (!compare(curr, {}, path))\n                return noMatch;\n            currentCommandIndex++;\n        }\n        currentPathIndex++;\n    }\n    return { match: true, pathIndex: currentPathIndex, commandIndex: currentCommandIndex };\n}\nfunction createNewSegmentGroup(segmentGroup, startIndex, commands) {\n    const paths = segmentGroup.segments.slice(0, startIndex);\n    let i = 0;\n    while (i < commands.length) {\n        const command = commands[i];\n        if (isCommandWithOutlets(command)) {\n            const children = createNewSegmentChildren(command.outlets);\n            return new UrlSegmentGroup(paths, children);\n        }\n        // if we start with an object literal, we need to reuse the path part from the segment\n        if (i === 0 && isMatrixParams(commands[0])) {\n            const p = segmentGroup.segments[startIndex];\n            paths.push(new UrlSegment(p.path, stringify(commands[0])));\n            i++;\n            continue;\n        }\n        const curr = isCommandWithOutlets(command) ? command.outlets[PRIMARY_OUTLET] : `${command}`;\n        const next = i < commands.length - 1 ? commands[i + 1] : null;\n        if (curr && next && isMatrixParams(next)) {\n            paths.push(new UrlSegment(curr, stringify(next)));\n            i += 2;\n        }\n        else {\n            paths.push(new UrlSegment(curr, {}));\n            i++;\n        }\n    }\n    return new UrlSegmentGroup(paths, {});\n}\nfunction createNewSegmentChildren(outlets) {\n    const children = {};\n    Object.entries(outlets).forEach(([outlet, commands]) => {\n        if (typeof commands === 'string') {\n            commands = [commands];\n        }\n        if (commands !== null) {\n            children[outlet] = createNewSegmentGroup(new UrlSegmentGroup([], {}), 0, commands);\n        }\n    });\n    return children;\n}\nfunction stringify(params) {\n    const res = {};\n    Object.entries(params).forEach(([k, v]) => (res[k] = `${v}`));\n    return res;\n}\nfunction compare(path, params, segment) {\n    return path == segment.path && shallowEqual(params, segment.parameters);\n}\n\nconst IMPERATIVE_NAVIGATION = 'imperative';\n/**\n * Identifies the type of a router event.\n *\n * @publicApi\n */\nvar EventType;\n(function (EventType) {\n    EventType[EventType[\"NavigationStart\"] = 0] = \"NavigationStart\";\n    EventType[EventType[\"NavigationEnd\"] = 1] = \"NavigationEnd\";\n    EventType[EventType[\"NavigationCancel\"] = 2] = \"NavigationCancel\";\n    EventType[EventType[\"NavigationError\"] = 3] = \"NavigationError\";\n    EventType[EventType[\"RoutesRecognized\"] = 4] = \"RoutesRecognized\";\n    EventType[EventType[\"ResolveStart\"] = 5] = \"ResolveStart\";\n    EventType[EventType[\"ResolveEnd\"] = 6] = \"ResolveEnd\";\n    EventType[EventType[\"GuardsCheckStart\"] = 7] = \"GuardsCheckStart\";\n    EventType[EventType[\"GuardsCheckEnd\"] = 8] = \"GuardsCheckEnd\";\n    EventType[EventType[\"RouteConfigLoadStart\"] = 9] = \"RouteConfigLoadStart\";\n    EventType[EventType[\"RouteConfigLoadEnd\"] = 10] = \"RouteConfigLoadEnd\";\n    EventType[EventType[\"ChildActivationStart\"] = 11] = \"ChildActivationStart\";\n    EventType[EventType[\"ChildActivationEnd\"] = 12] = \"ChildActivationEnd\";\n    EventType[EventType[\"ActivationStart\"] = 13] = \"ActivationStart\";\n    EventType[EventType[\"ActivationEnd\"] = 14] = \"ActivationEnd\";\n    EventType[EventType[\"Scroll\"] = 15] = \"Scroll\";\n    EventType[EventType[\"NavigationSkipped\"] = 16] = \"NavigationSkipped\";\n})(EventType || (EventType = {}));\n/**\n * Base for events the router goes through, as opposed to events tied to a specific\n * route. Fired one time for any given navigation.\n *\n * The following code shows how a class subscribes to router events.\n *\n * ```ts\n * import {Event, RouterEvent, Router} from '@angular/router';\n *\n * class MyService {\n *   constructor(public router: Router) {\n *     router.events.pipe(\n *        filter((e: Event | RouterEvent): e is RouterEvent => e instanceof RouterEvent)\n *     ).subscribe((e: RouterEvent) => {\n *       // Do something\n *     });\n *   }\n * }\n * ```\n *\n * @see {@link Event}\n * @see [Router events summary](guide/routing/router-reference#router-events)\n * @publicApi\n */\nclass RouterEvent {\n    id;\n    url;\n    constructor(\n    /** A unique ID that the router assigns to every router navigation. */\n    id, \n    /** The URL that is the destination for this navigation. */\n    url) {\n        this.id = id;\n        this.url = url;\n    }\n}\n/**\n * An event triggered when a navigation starts.\n *\n * @publicApi\n */\nclass NavigationStart extends RouterEvent {\n    type = EventType.NavigationStart;\n    /**\n     * Identifies the call or event that triggered the navigation.\n     * An `imperative` trigger is a call to `router.navigateByUrl()` or `router.navigate()`.\n     *\n     * @see {@link NavigationEnd}\n     * @see {@link NavigationCancel}\n     * @see {@link NavigationError}\n     */\n    navigationTrigger;\n    /**\n     * The navigation state that was previously supplied to the `pushState` call,\n     * when the navigation is triggered by a `popstate` event. Otherwise null.\n     *\n     * The state object is defined by `NavigationExtras`, and contains any\n     * developer-defined state value, as well as a unique ID that\n     * the router assigns to every router transition/navigation.\n     *\n     * From the perspective of the router, the router never \"goes back\".\n     * When the user clicks on the back button in the browser,\n     * a new navigation ID is created.\n     *\n     * Use the ID in this previous-state object to differentiate between a newly created\n     * state and one returned to by a `popstate` event, so that you can restore some\n     * remembered state, such as scroll position.\n     *\n     */\n    restoredState;\n    constructor(\n    /** @docsNotRequired */\n    id, \n    /** @docsNotRequired */\n    url, \n    /** @docsNotRequired */\n    navigationTrigger = 'imperative', \n    /** @docsNotRequired */\n    restoredState = null) {\n        super(id, url);\n        this.navigationTrigger = navigationTrigger;\n        this.restoredState = restoredState;\n    }\n    /** @docsNotRequired */\n    toString() {\n        return `NavigationStart(id: ${this.id}, url: '${this.url}')`;\n    }\n}\n/**\n * An event triggered when a navigation ends successfully.\n *\n * @see {@link NavigationStart}\n * @see {@link NavigationCancel}\n * @see {@link NavigationError}\n *\n * @publicApi\n */\nclass NavigationEnd extends RouterEvent {\n    urlAfterRedirects;\n    type = EventType.NavigationEnd;\n    constructor(\n    /** @docsNotRequired */\n    id, \n    /** @docsNotRequired */\n    url, \n    /** @docsNotRequired */\n    urlAfterRedirects) {\n        super(id, url);\n        this.urlAfterRedirects = urlAfterRedirects;\n    }\n    /** @docsNotRequired */\n    toString() {\n        return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`;\n    }\n}\n/**\n * A code for the `NavigationCancel` event of the `Router` to indicate the\n * reason a navigation failed.\n *\n * @publicApi\n */\nvar NavigationCancellationCode;\n(function (NavigationCancellationCode) {\n    /**\n     * A navigation failed because a guard returned a `UrlTree` to redirect.\n     */\n    NavigationCancellationCode[NavigationCancellationCode[\"Redirect\"] = 0] = \"Redirect\";\n    /**\n     * A navigation failed because a more recent navigation started.\n     */\n    NavigationCancellationCode[NavigationCancellationCode[\"SupersededByNewNavigation\"] = 1] = \"SupersededByNewNavigation\";\n    /**\n     * A navigation failed because one of the resolvers completed without emitting a value.\n     */\n    NavigationCancellationCode[NavigationCancellationCode[\"NoDataFromResolver\"] = 2] = \"NoDataFromResolver\";\n    /**\n     * A navigation failed because a guard returned `false`.\n     */\n    NavigationCancellationCode[NavigationCancellationCode[\"GuardRejected\"] = 3] = \"GuardRejected\";\n    /**\n     * A navigation was aborted by the `Navigation.abort` function.\n     *\n     * @see {@link Navigation}\n     */\n    NavigationCancellationCode[NavigationCancellationCode[\"Aborted\"] = 4] = \"Aborted\";\n})(NavigationCancellationCode || (NavigationCancellationCode = {}));\n/**\n * A code for the `NavigationSkipped` event of the `Router` to indicate the\n * reason a navigation was skipped.\n *\n * @publicApi\n */\nvar NavigationSkippedCode;\n(function (NavigationSkippedCode) {\n    /**\n     * A navigation was skipped because the navigation URL was the same as the current Router URL.\n     */\n    NavigationSkippedCode[NavigationSkippedCode[\"IgnoredSameUrlNavigation\"] = 0] = \"IgnoredSameUrlNavigation\";\n    /**\n     * A navigation was skipped because the configured `UrlHandlingStrategy` return `false` for both\n     * the current Router URL and the target of the navigation.\n     *\n     * @see {@link UrlHandlingStrategy}\n     */\n    NavigationSkippedCode[NavigationSkippedCode[\"IgnoredByUrlHandlingStrategy\"] = 1] = \"IgnoredByUrlHandlingStrategy\";\n})(NavigationSkippedCode || (NavigationSkippedCode = {}));\n/**\n * An event triggered when a navigation is canceled, directly or indirectly.\n * This can happen for several reasons including when a route guard\n * returns `false` or initiates a redirect by returning a `UrlTree`.\n *\n * @see {@link NavigationStart}\n * @see {@link NavigationEnd}\n * @see {@link NavigationError}\n *\n * @publicApi\n */\nclass NavigationCancel extends RouterEvent {\n    reason;\n    code;\n    type = EventType.NavigationCancel;\n    constructor(\n    /** @docsNotRequired */\n    id, \n    /** @docsNotRequired */\n    url, \n    /**\n     * A description of why the navigation was cancelled. For debug purposes only. Use `code`\n     * instead for a stable cancellation reason that can be used in production.\n     */\n    reason, \n    /**\n     * A code to indicate why the navigation was canceled. This cancellation code is stable for\n     * the reason and can be relied on whereas the `reason` string could change and should not be\n     * used in production.\n     */\n    code) {\n        super(id, url);\n        this.reason = reason;\n        this.code = code;\n    }\n    /** @docsNotRequired */\n    toString() {\n        return `NavigationCancel(id: ${this.id}, url: '${this.url}')`;\n    }\n}\n/**\n * An event triggered when a navigation is skipped.\n * This can happen for a couple reasons including onSameUrlHandling\n * is set to `ignore` and the navigation URL is not different than the\n * current state.\n *\n * @publicApi\n */\nclass NavigationSkipped extends RouterEvent {\n    reason;\n    code;\n    type = EventType.NavigationSkipped;\n    constructor(\n    /** @docsNotRequired */\n    id, \n    /** @docsNotRequired */\n    url, \n    /**\n     * A description of why the navigation was skipped. For debug purposes only. Use `code`\n     * instead for a stable skipped reason that can be used in production.\n     */\n    reason, \n    /**\n     * A code to indicate why the navigation was skipped. This code is stable for\n     * the reason and can be relied on whereas the `reason` string could change and should not be\n     * used in production.\n     */\n    code) {\n        super(id, url);\n        this.reason = reason;\n        this.code = code;\n    }\n}\n/**\n * An event triggered when a navigation fails due to an unexpected error.\n *\n * @see {@link NavigationStart}\n * @see {@link NavigationEnd}\n * @see {@link NavigationCancel}\n *\n * @publicApi\n */\nclass NavigationError extends RouterEvent {\n    error;\n    target;\n    type = EventType.NavigationError;\n    constructor(\n    /** @docsNotRequired */\n    id, \n    /** @docsNotRequired */\n    url, \n    /** @docsNotRequired */\n    error, \n    /**\n     * The target of the navigation when the error occurred.\n     *\n     * Note that this can be `undefined` because an error could have occurred before the\n     * `RouterStateSnapshot` was created for the navigation.\n     */\n    target) {\n        super(id, url);\n        this.error = error;\n        this.target = target;\n    }\n    /** @docsNotRequired */\n    toString() {\n        return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`;\n    }\n}\n/**\n * An event triggered when routes are recognized.\n *\n * @publicApi\n */\nclass RoutesRecognized extends RouterEvent {\n    urlAfterRedirects;\n    state;\n    type = EventType.RoutesRecognized;\n    constructor(\n    /** @docsNotRequired */\n    id, \n    /** @docsNotRequired */\n    url, \n    /** @docsNotRequired */\n    urlAfterRedirects, \n    /** @docsNotRequired */\n    state) {\n        super(id, url);\n        this.urlAfterRedirects = urlAfterRedirects;\n        this.state = state;\n    }\n    /** @docsNotRequired */\n    toString() {\n        return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;\n    }\n}\n/**\n * An event triggered at the start of the Guard phase of routing.\n *\n * @see {@link GuardsCheckEnd}\n *\n * @publicApi\n */\nclass GuardsCheckStart extends RouterEvent {\n    urlAfterRedirects;\n    state;\n    type = EventType.GuardsCheckStart;\n    constructor(\n    /** @docsNotRequired */\n    id, \n    /** @docsNotRequired */\n    url, \n    /** @docsNotRequired */\n    urlAfterRedirects, \n    /** @docsNotRequired */\n    state) {\n        super(id, url);\n        this.urlAfterRedirects = urlAfterRedirects;\n        this.state = state;\n    }\n    toString() {\n        return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;\n    }\n}\n/**\n * An event triggered at the end of the Guard phase of routing.\n *\n * @see {@link GuardsCheckStart}\n *\n * @publicApi\n */\nclass GuardsCheckEnd extends RouterEvent {\n    urlAfterRedirects;\n    state;\n    shouldActivate;\n    type = EventType.GuardsCheckEnd;\n    constructor(\n    /** @docsNotRequired */\n    id, \n    /** @docsNotRequired */\n    url, \n    /** @docsNotRequired */\n    urlAfterRedirects, \n    /** @docsNotRequired */\n    state, \n    /** @docsNotRequired */\n    shouldActivate) {\n        super(id, url);\n        this.urlAfterRedirects = urlAfterRedirects;\n        this.state = state;\n        this.shouldActivate = shouldActivate;\n    }\n    toString() {\n        return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`;\n    }\n}\n/**\n * An event triggered at the start of the Resolve phase of routing.\n *\n * Runs in the \"resolve\" phase whether or not there is anything to resolve.\n * In future, may change to only run when there are things to be resolved.\n *\n * @see {@link ResolveEnd}\n *\n * @publicApi\n */\nclass ResolveStart extends RouterEvent {\n    urlAfterRedirects;\n    state;\n    type = EventType.ResolveStart;\n    constructor(\n    /** @docsNotRequired */\n    id, \n    /** @docsNotRequired */\n    url, \n    /** @docsNotRequired */\n    urlAfterRedirects, \n    /** @docsNotRequired */\n    state) {\n        super(id, url);\n        this.urlAfterRedirects = urlAfterRedirects;\n        this.state = state;\n    }\n    toString() {\n        return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;\n    }\n}\n/**\n * An event triggered at the end of the Resolve phase of routing.\n * @see {@link ResolveStart}\n *\n * @publicApi\n */\nclass ResolveEnd extends RouterEvent {\n    urlAfterRedirects;\n    state;\n    type = EventType.ResolveEnd;\n    constructor(\n    /** @docsNotRequired */\n    id, \n    /** @docsNotRequired */\n    url, \n    /** @docsNotRequired */\n    urlAfterRedirects, \n    /** @docsNotRequired */\n    state) {\n        super(id, url);\n        this.urlAfterRedirects = urlAfterRedirects;\n        this.state = state;\n    }\n    toString() {\n        return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;\n    }\n}\n/**\n * An event triggered before lazy loading a route configuration.\n *\n * @see {@link RouteConfigLoadEnd}\n *\n * @publicApi\n */\nclass RouteConfigLoadStart {\n    route;\n    type = EventType.RouteConfigLoadStart;\n    constructor(\n    /** @docsNotRequired */\n    route) {\n        this.route = route;\n    }\n    toString() {\n        return `RouteConfigLoadStart(path: ${this.route.path})`;\n    }\n}\n/**\n * An event triggered when a route has been lazy loaded.\n *\n * @see {@link RouteConfigLoadStart}\n *\n * @publicApi\n */\nclass RouteConfigLoadEnd {\n    route;\n    type = EventType.RouteConfigLoadEnd;\n    constructor(\n    /** @docsNotRequired */\n    route) {\n        this.route = route;\n    }\n    toString() {\n        return `RouteConfigLoadEnd(path: ${this.route.path})`;\n    }\n}\n/**\n * An event triggered at the start of the child-activation\n * part of the Resolve phase of routing.\n * @see {@link ChildActivationEnd}\n * @see {@link ResolveStart}\n *\n * @publicApi\n */\nclass ChildActivationStart {\n    snapshot;\n    type = EventType.ChildActivationStart;\n    constructor(\n    /** @docsNotRequired */\n    snapshot) {\n        this.snapshot = snapshot;\n    }\n    toString() {\n        const path = (this.snapshot.routeConfig && this.snapshot.routeConfig.path) || '';\n        return `ChildActivationStart(path: '${path}')`;\n    }\n}\n/**\n * An event triggered at the end of the child-activation part\n * of the Resolve phase of routing.\n * @see {@link ChildActivationStart}\n * @see {@link ResolveStart}\n * @publicApi\n */\nclass ChildActivationEnd {\n    snapshot;\n    type = EventType.ChildActivationEnd;\n    constructor(\n    /** @docsNotRequired */\n    snapshot) {\n        this.snapshot = snapshot;\n    }\n    toString() {\n        const path = (this.snapshot.routeConfig && this.snapshot.routeConfig.path) || '';\n        return `ChildActivationEnd(path: '${path}')`;\n    }\n}\n/**\n * An event triggered at the start of the activation part\n * of the Resolve phase of routing.\n * @see {@link ActivationEnd}\n * @see {@link ResolveStart}\n *\n * @publicApi\n */\nclass ActivationStart {\n    snapshot;\n    type = EventType.ActivationStart;\n    constructor(\n    /** @docsNotRequired */\n    snapshot) {\n        this.snapshot = snapshot;\n    }\n    toString() {\n        const path = (this.snapshot.routeConfig && this.snapshot.routeConfig.path) || '';\n        return `ActivationStart(path: '${path}')`;\n    }\n}\n/**\n * An event triggered at the end of the activation part\n * of the Resolve phase of routing.\n * @see {@link ActivationStart}\n * @see {@link ResolveStart}\n *\n * @publicApi\n */\nclass ActivationEnd {\n    snapshot;\n    type = EventType.ActivationEnd;\n    constructor(\n    /** @docsNotRequired */\n    snapshot) {\n        this.snapshot = snapshot;\n    }\n    toString() {\n        const path = (this.snapshot.routeConfig && this.snapshot.routeConfig.path) || '';\n        return `ActivationEnd(path: '${path}')`;\n    }\n}\n/**\n * An event triggered by scrolling.\n *\n * @publicApi\n */\nclass Scroll {\n    routerEvent;\n    position;\n    anchor;\n    type = EventType.Scroll;\n    constructor(\n    /** @docsNotRequired */\n    routerEvent, \n    /** @docsNotRequired */\n    position, \n    /** @docsNotRequired */\n    anchor) {\n        this.routerEvent = routerEvent;\n        this.position = position;\n        this.anchor = anchor;\n    }\n    toString() {\n        const pos = this.position ? `${this.position[0]}, ${this.position[1]}` : null;\n        return `Scroll(anchor: '${this.anchor}', position: '${pos}')`;\n    }\n}\nclass BeforeActivateRoutes {\n}\nclass RedirectRequest {\n    url;\n    navigationBehaviorOptions;\n    constructor(url, navigationBehaviorOptions) {\n        this.url = url;\n        this.navigationBehaviorOptions = navigationBehaviorOptions;\n    }\n}\nfunction isPublicRouterEvent(e) {\n    return !(e instanceof BeforeActivateRoutes) && !(e instanceof RedirectRequest);\n}\nfunction stringifyEvent(routerEvent) {\n    switch (routerEvent.type) {\n        case EventType.ActivationEnd:\n            return `ActivationEnd(path: '${routerEvent.snapshot.routeConfig?.path || ''}')`;\n        case EventType.ActivationStart:\n            return `ActivationStart(path: '${routerEvent.snapshot.routeConfig?.path || ''}')`;\n        case EventType.ChildActivationEnd:\n            return `ChildActivationEnd(path: '${routerEvent.snapshot.routeConfig?.path || ''}')`;\n        case EventType.ChildActivationStart:\n            return `ChildActivationStart(path: '${routerEvent.snapshot.routeConfig?.path || ''}')`;\n        case EventType.GuardsCheckEnd:\n            return `GuardsCheckEnd(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state}, shouldActivate: ${routerEvent.shouldActivate})`;\n        case EventType.GuardsCheckStart:\n            return `GuardsCheckStart(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;\n        case EventType.NavigationCancel:\n            return `NavigationCancel(id: ${routerEvent.id}, url: '${routerEvent.url}')`;\n        case EventType.NavigationSkipped:\n            return `NavigationSkipped(id: ${routerEvent.id}, url: '${routerEvent.url}')`;\n        case EventType.NavigationEnd:\n            return `NavigationEnd(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}')`;\n        case EventType.NavigationError:\n            return `NavigationError(id: ${routerEvent.id}, url: '${routerEvent.url}', error: ${routerEvent.error})`;\n        case EventType.NavigationStart:\n            return `NavigationStart(id: ${routerEvent.id}, url: '${routerEvent.url}')`;\n        case EventType.ResolveEnd:\n            return `ResolveEnd(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;\n        case EventType.ResolveStart:\n            return `ResolveStart(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;\n        case EventType.RouteConfigLoadEnd:\n            return `RouteConfigLoadEnd(path: ${routerEvent.route.path})`;\n        case EventType.RouteConfigLoadStart:\n            return `RouteConfigLoadStart(path: ${routerEvent.route.path})`;\n        case EventType.RoutesRecognized:\n            return `RoutesRecognized(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;\n        case EventType.Scroll:\n            const pos = routerEvent.position\n                ? `${routerEvent.position[0]}, ${routerEvent.position[1]}`\n                : null;\n            return `Scroll(anchor: '${routerEvent.anchor}', position: '${pos}')`;\n    }\n}\n\n/**\n * Creates an `EnvironmentInjector` if the `Route` has providers and one does not already exist\n * and returns the injector. Otherwise, if the `Route` does not have `providers`, returns the\n * `currentInjector`.\n *\n * @param route The route that might have providers\n * @param currentInjector The parent injector of the `Route`\n */\nfunction getOrCreateRouteInjectorIfNeeded(route, currentInjector) {\n    if (route.providers && !route._injector) {\n        route._injector = createEnvironmentInjector(route.providers, currentInjector, `Route: ${route.path}`);\n    }\n    return route._injector ?? currentInjector;\n}\nfunction validateConfig(config, parentPath = '', requireStandaloneComponents = false) {\n    // forEach doesn't iterate undefined values\n    for (let i = 0; i < config.length; i++) {\n        const route = config[i];\n        const fullPath = getFullPath(parentPath, route);\n        validateNode(route, fullPath, requireStandaloneComponents);\n    }\n}\nfunction assertStandalone(fullPath, component) {\n    if (component && _isNgModule(component)) {\n        throw new _RuntimeError(4014 /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */, `Invalid configuration of route '${fullPath}'. You are using 'loadComponent' with a module, ` +\n            `but it must be used with standalone components. Use 'loadChildren' instead.`);\n    }\n    else if (component && !isStandalone(component)) {\n        throw new _RuntimeError(4014 /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */, `Invalid configuration of route '${fullPath}'. The component must be standalone.`);\n    }\n}\nfunction validateNode(route, fullPath, requireStandaloneComponents) {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        if (!route) {\n            throw new _RuntimeError(4014 /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */, `\n      Invalid configuration of route '${fullPath}': Encountered undefined route.\n      The reason might be an extra comma.\n\n      Example:\n      const routes: Routes = [\n        { path: '', redirectTo: '/dashboard', pathMatch: 'full' },\n        { path: 'dashboard',  component: DashboardComponent },, << two commas\n        { path: 'detail/:id', component: HeroDetailComponent }\n      ];\n    `);\n        }\n        if (Array.isArray(route)) {\n            throw new _RuntimeError(4014 /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */, `Invalid configuration of route '${fullPath}': Array cannot be specified`);\n        }\n        if (!route.redirectTo &&\n            !route.component &&\n            !route.loadComponent &&\n            !route.children &&\n            !route.loadChildren &&\n            route.outlet &&\n            route.outlet !== PRIMARY_OUTLET) {\n            throw new _RuntimeError(4014 /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */, `Invalid configuration of route '${fullPath}': a componentless route without children or loadChildren cannot have a named outlet set`);\n        }\n        if (route.redirectTo && route.children) {\n            throw new _RuntimeError(4014 /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */, `Invalid configuration of route '${fullPath}': redirectTo and children cannot be used together`);\n        }\n        if (route.redirectTo && route.loadChildren) {\n            throw new _RuntimeError(4014 /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */, `Invalid configuration of route '${fullPath}': redirectTo and loadChildren cannot be used together`);\n        }\n        if (route.children && route.loadChildren) {\n            throw new _RuntimeError(4014 /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */, `Invalid configuration of route '${fullPath}': children and loadChildren cannot be used together`);\n        }\n        if (route.component && route.loadComponent) {\n            throw new _RuntimeError(4014 /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */, `Invalid configuration of route '${fullPath}': component and loadComponent cannot be used together`);\n        }\n        if (route.redirectTo) {\n            if (route.component || route.loadComponent) {\n                throw new _RuntimeError(4014 /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */, `Invalid configuration of route '${fullPath}': redirectTo and component/loadComponent cannot be used together`);\n            }\n            if (route.canMatch || route.canActivate) {\n                throw new _RuntimeError(4014 /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */, `Invalid configuration of route '${fullPath}': redirectTo and ${route.canMatch ? 'canMatch' : 'canActivate'} cannot be used together.` +\n                    `Redirects happen before guards are executed.`);\n            }\n        }\n        if (route.path && route.matcher) {\n            throw new _RuntimeError(4014 /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */, `Invalid configuration of route '${fullPath}': path and matcher cannot be used together`);\n        }\n        if (route.redirectTo === void 0 &&\n            !route.component &&\n            !route.loadComponent &&\n            !route.children &&\n            !route.loadChildren) {\n            throw new _RuntimeError(4014 /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */, `Invalid configuration of route '${fullPath}'. One of the following must be provided: component, loadComponent, redirectTo, children or loadChildren`);\n        }\n        if (route.path === void 0 && route.matcher === void 0) {\n            throw new _RuntimeError(4014 /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */, `Invalid configuration of route '${fullPath}': routes must have either a path or a matcher specified`);\n        }\n        if (typeof route.path === 'string' && route.path.charAt(0) === '/') {\n            throw new _RuntimeError(4014 /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */, `Invalid configuration of route '${fullPath}': path cannot start with a slash`);\n        }\n        if (route.path === '' && route.redirectTo !== void 0 && route.pathMatch === void 0) {\n            const exp = `The default value of 'pathMatch' is 'prefix', but often the intent is to use 'full'.`;\n            throw new _RuntimeError(4014 /* RuntimeErrorCode.INVALID_ROUTE_CONFIG */, `Invalid configuration of route '{path: \"${fullPath}\", redirectTo: \"${route.redirectTo}\"}': please provide 'pathMatch'. ${exp}`);\n        }\n        if (requireStandaloneComponents) {\n            assertStandalone(fullPath, route.component);\n        }\n    }\n    if (route.children) {\n        validateConfig(route.children, fullPath, requireStandaloneComponents);\n    }\n}\nfunction getFullPath(parentPath, currentRoute) {\n    if (!currentRoute) {\n        return parentPath;\n    }\n    if (!parentPath && !currentRoute.path) {\n        return '';\n    }\n    else if (parentPath && !currentRoute.path) {\n        return `${parentPath}/`;\n    }\n    else if (!parentPath && currentRoute.path) {\n        return currentRoute.path;\n    }\n    else {\n        return `${parentPath}/${currentRoute.path}`;\n    }\n}\n/** Returns the `route.outlet` or PRIMARY_OUTLET if none exists. */\nfunction getOutlet(route) {\n    return route.outlet || PRIMARY_OUTLET;\n}\n/**\n * Sorts the `routes` such that the ones with an outlet matching `outletName` come first.\n * The order of the configs is otherwise preserved.\n */\nfunction sortByMatchingOutlets(routes, outletName) {\n    const sortedConfig = routes.filter((r) => getOutlet(r) === outletName);\n    sortedConfig.push(...routes.filter((r) => getOutlet(r) !== outletName));\n    return sortedConfig;\n}\n/**\n * Gets the first injector in the snapshot's parent tree.\n *\n * If the `Route` has a static list of providers, the returned injector will be the one created from\n * those. If it does not exist, the returned injector may come from the parents, which may be from a\n * loaded config or their static providers.\n *\n * Returns `null` if there is neither this nor any parents have a stored injector.\n *\n * Generally used for retrieving the injector to use for getting tokens for guards/resolvers and\n * also used for getting the correct injector to use for creating components.\n */\nfunction getClosestRouteInjector(snapshot) {\n    if (!snapshot)\n        return null;\n    // If the current route has its own injector, which is created from the static providers on the\n    // route itself, we should use that. Otherwise, we start at the parent since we do not want to\n    // include the lazy loaded injector from this route.\n    if (snapshot.routeConfig?._injector) {\n        return snapshot.routeConfig._injector;\n    }\n    for (let s = snapshot.parent; s; s = s.parent) {\n        const route = s.routeConfig;\n        // Note that the order here is important. `_loadedInjector` stored on the route with\n        // `loadChildren: () => NgModule` so it applies to child routes with priority. The `_injector`\n        // is created from the static providers on that parent route, so it applies to the children as\n        // well, but only if there is no lazy loaded NgModuleRef injector.\n        if (route?._loadedInjector)\n            return route._loadedInjector;\n        if (route?._injector)\n            return route._injector;\n    }\n    return null;\n}\n\n/**\n * Store contextual information about a `RouterOutlet`\n *\n * @publicApi\n */\nclass OutletContext {\n    rootInjector;\n    outlet = null;\n    route = null;\n    children;\n    attachRef = null;\n    get injector() {\n        return getClosestRouteInjector(this.route?.snapshot) ?? this.rootInjector;\n    }\n    constructor(rootInjector) {\n        this.rootInjector = rootInjector;\n        this.children = new ChildrenOutletContexts(this.rootInjector);\n    }\n}\n/**\n * Store contextual information about the children (= nested) `RouterOutlet`\n *\n * @publicApi\n */\nclass ChildrenOutletContexts {\n    rootInjector;\n    // contexts for child outlets, by name.\n    contexts = new Map();\n    /** @docs-private */\n    constructor(rootInjector) {\n        this.rootInjector = rootInjector;\n    }\n    /** Called when a `RouterOutlet` directive is instantiated */\n    onChildOutletCreated(childName, outlet) {\n        const context = this.getOrCreateContext(childName);\n        context.outlet = outlet;\n        this.contexts.set(childName, context);\n    }\n    /**\n     * Called when a `RouterOutlet` directive is destroyed.\n     * We need to keep the context as the outlet could be destroyed inside a NgIf and might be\n     * re-created later.\n     */\n    onChildOutletDestroyed(childName) {\n        const context = this.getContext(childName);\n        if (context) {\n            context.outlet = null;\n            context.attachRef = null;\n        }\n    }\n    /**\n     * Called when the corresponding route is deactivated during navigation.\n     * Because the component get destroyed, all children outlet are destroyed.\n     */\n    onOutletDeactivated() {\n        const contexts = this.contexts;\n        this.contexts = new Map();\n        return contexts;\n    }\n    onOutletReAttached(contexts) {\n        this.contexts = contexts;\n    }\n    getOrCreateContext(childName) {\n        let context = this.getContext(childName);\n        if (!context) {\n            context = new OutletContext(this.rootInjector);\n            this.contexts.set(childName, context);\n        }\n        return context;\n    }\n    getContext(childName) {\n        return this.contexts.get(childName) || null;\n    }\n    static fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: ChildrenOutletContexts, deps: [{ token: i0.EnvironmentInjector }], target: i0.FactoryTarget.Injectable });\n    static prov = i0.ngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: ChildrenOutletContexts, providedIn: 'root' });\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: ChildrenOutletContexts, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [{ type: i0.EnvironmentInjector }] });\n\nclass Tree {\n    /** @internal */\n    _root;\n    constructor(root) {\n        this._root = root;\n    }\n    get root() {\n        return this._root.value;\n    }\n    /**\n     * @internal\n     */\n    parent(t) {\n        const p = this.pathFromRoot(t);\n        return p.length > 1 ? p[p.length - 2] : null;\n    }\n    /**\n     * @internal\n     */\n    children(t) {\n        const n = findNode(t, this._root);\n        return n ? n.children.map((t) => t.value) : [];\n    }\n    /**\n     * @internal\n     */\n    firstChild(t) {\n        const n = findNode(t, this._root);\n        return n && n.children.length > 0 ? n.children[0].value : null;\n    }\n    /**\n     * @internal\n     */\n    siblings(t) {\n        const p = findPath(t, this._root);\n        if (p.length < 2)\n            return [];\n        const c = p[p.length - 2].children.map((c) => c.value);\n        return c.filter((cc) => cc !== t);\n    }\n    /**\n     * @internal\n     */\n    pathFromRoot(t) {\n        return findPath(t, this._root).map((s) => s.value);\n    }\n}\n// DFS for the node matching the value\nfunction findNode(value, node) {\n    if (value === node.value)\n        return node;\n    for (const child of node.children) {\n        const node = findNode(value, child);\n        if (node)\n            return node;\n    }\n    return null;\n}\n// Return the path to the node with the given value using DFS\nfunction findPath(value, node) {\n    if (value === node.value)\n        return [node];\n    for (const child of node.children) {\n        const path = findPath(value, child);\n        if (path.length) {\n            path.unshift(node);\n            return path;\n        }\n    }\n    return [];\n}\nclass TreeNode {\n    value;\n    children;\n    constructor(value, children) {\n        this.value = value;\n        this.children = children;\n    }\n    toString() {\n        return `TreeNode(${this.value})`;\n    }\n}\n// Return the list of T indexed by outlet name\nfunction nodeChildrenAsMap(node) {\n    const map = {};\n    if (node) {\n        node.children.forEach((child) => (map[child.value.outlet] = child));\n    }\n    return map;\n}\n\n/**\n * Represents the state of the router as a tree of activated routes.\n *\n * @usageNotes\n *\n * Every node in the route tree is an `ActivatedRoute` instance\n * that knows about the \"consumed\" URL segments, the extracted parameters,\n * and the resolved data.\n * Use the `ActivatedRoute` properties to traverse the tree from any node.\n *\n * The following fragment shows how a component gets the root node\n * of the current state to establish its own route tree:\n *\n * ```ts\n * @Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const state: RouterState = router.routerState;\n *     const root: ActivatedRoute = state.root;\n *     const child = root.firstChild;\n *     const id: Observable<string> = child.params.map(p => p.id);\n *     //...\n *   }\n * }\n * ```\n *\n * @see {@link ActivatedRoute}\n * @see [Getting route information](guide/routing/common-router-tasks#getting-route-information)\n *\n * @publicApi\n */\nclass RouterState extends Tree {\n    snapshot;\n    /** @internal */\n    constructor(root, \n    /** The current snapshot of the router state */\n    snapshot) {\n        super(root);\n        this.snapshot = snapshot;\n        setRouterState(this, root);\n    }\n    toString() {\n        return this.snapshot.toString();\n    }\n}\nfunction createEmptyState(rootComponent) {\n    const snapshot = createEmptyStateSnapshot(rootComponent);\n    const emptyUrl = new BehaviorSubject([new UrlSegment('', {})]);\n    const emptyParams = new BehaviorSubject({});\n    const emptyData = new BehaviorSubject({});\n    const emptyQueryParams = new BehaviorSubject({});\n    const fragment = new BehaviorSubject('');\n    const activated = new ActivatedRoute(emptyUrl, emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, snapshot.root);\n    activated.snapshot = snapshot.root;\n    return new RouterState(new TreeNode(activated, []), snapshot);\n}\nfunction createEmptyStateSnapshot(rootComponent) {\n    const emptyParams = {};\n    const emptyData = {};\n    const emptyQueryParams = {};\n    const fragment = '';\n    const activated = new ActivatedRouteSnapshot([], emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, null, {});\n    return new RouterStateSnapshot('', new TreeNode(activated, []));\n}\n/**\n * Provides access to information about a route associated with a component\n * that is loaded in an outlet.\n * Use to traverse the `RouterState` tree and extract information from nodes.\n *\n * The following example shows how to construct a component using information from a\n * currently activated route.\n *\n * Note: the observables in this class only emit when the current and previous values differ based\n * on shallow equality. For example, changing deeply nested properties in resolved `data` will not\n * cause the `ActivatedRoute.data` `Observable` to emit a new value.\n *\n * {@example router/activated-route/module.ts region=\"activated-route\"}\n *\n * @see [Getting route information](guide/routing/common-router-tasks#getting-route-information)\n *\n * @publicApi\n */\nclass ActivatedRoute {\n    urlSubject;\n    paramsSubject;\n    queryParamsSubject;\n    fragmentSubject;\n    dataSubject;\n    outlet;\n    component;\n    /** The current snapshot of this route */\n    snapshot;\n    /** @internal */\n    _futureSnapshot;\n    /** @internal */\n    _routerState;\n    /** @internal */\n    _paramMap;\n    /** @internal */\n    _queryParamMap;\n    /** An Observable of the resolved route title */\n    title;\n    /** An observable of the URL segments matched by this route. */\n    url;\n    /** An observable of the matrix parameters scoped to this route. */\n    params;\n    /** An observable of the query parameters shared by all the routes. */\n    queryParams;\n    /** An observable of the URL fragment shared by all the routes. */\n    fragment;\n    /** An observable of the static and resolved data of this route. */\n    data;\n    /** @internal */\n    constructor(\n    /** @internal */\n    urlSubject, \n    /** @internal */\n    paramsSubject, \n    /** @internal */\n    queryParamsSubject, \n    /** @internal */\n    fragmentSubject, \n    /** @internal */\n    dataSubject, \n    /** The outlet name of the route, a constant. */\n    outlet, \n    /** The component of the route, a constant. */\n    component, futureSnapshot) {\n        this.urlSubject = urlSubject;\n        this.paramsSubject = paramsSubject;\n        this.queryParamsSubject = queryParamsSubject;\n        this.fragmentSubject = fragmentSubject;\n        this.dataSubject = dataSubject;\n        this.outlet = outlet;\n        this.component = component;\n        this._futureSnapshot = futureSnapshot;\n        this.title = this.dataSubject?.pipe(map((d) => d[RouteTitleKey])) ?? of(undefined);\n        // TODO(atscott): Verify that these can be changed to `.asObservable()` with TGP.\n        this.url = urlSubject;\n        this.params = paramsSubject;\n        this.queryParams = queryParamsSubject;\n        this.fragment = fragmentSubject;\n        this.data = dataSubject;\n    }\n    /** The configuration used to match this route. */\n    get routeConfig() {\n        return this._futureSnapshot.routeConfig;\n    }\n    /** The root of the router state. */\n    get root() {\n        return this._routerState.root;\n    }\n    /** The parent of this route in the router state tree. */\n    get parent() {\n        return this._routerState.parent(this);\n    }\n    /** The first child of this route in the router state tree. */\n    get firstChild() {\n        return this._routerState.firstChild(this);\n    }\n    /** The children of this route in the router state tree. */\n    get children() {\n        return this._routerState.children(this);\n    }\n    /** The path from the root of the router state tree to this route. */\n    get pathFromRoot() {\n        return this._routerState.pathFromRoot(this);\n    }\n    /**\n     * An Observable that contains a map of the required and optional parameters\n     * specific to the route.\n     * The map supports retrieving single and multiple values from the same parameter.\n     */\n    get paramMap() {\n        this._paramMap ??= this.params.pipe(map((p) => convertToParamMap(p)));\n        return this._paramMap;\n    }\n    /**\n     * An Observable that contains a map of the query parameters available to all routes.\n     * The map supports retrieving single and multiple values from the query parameter.\n     */\n    get queryParamMap() {\n        this._queryParamMap ??= this.queryParams.pipe(map((p) => convertToParamMap(p)));\n        return this._queryParamMap;\n    }\n    toString() {\n        return this.snapshot ? this.snapshot.toString() : `Future(${this._futureSnapshot})`;\n    }\n}\n/**\n * Returns the inherited params, data, and resolve for a given route.\n *\n * By default, we do not inherit parent data unless the current route is path-less or the parent\n * route is component-less.\n */\nfunction getInherited(route, parent, paramsInheritanceStrategy = 'emptyOnly') {\n    let inherited;\n    const { routeConfig } = route;\n    if (parent !== null &&\n        (paramsInheritanceStrategy === 'always' ||\n            // inherit parent data if route is empty path\n            routeConfig?.path === '' ||\n            // inherit parent data if parent was componentless\n            (!parent.component && !parent.routeConfig?.loadComponent))) {\n        inherited = {\n            params: { ...parent.params, ...route.params },\n            data: { ...parent.data, ...route.data },\n            resolve: {\n                // Snapshots are created with data inherited from parent and guards (i.e. canActivate) can\n                // change data because it's not frozen...\n                // This first line could be deleted chose to break/disallow mutating the `data` object in\n                // guards.\n                // Note that data from parents still override this mutated data so anyone relying on this\n                // might be surprised that it doesn't work if parent data is inherited but otherwise does.\n                ...route.data,\n                // Ensure inherited resolved data overrides inherited static data\n                ...parent.data,\n                // static data from the current route overrides any inherited data\n                ...routeConfig?.data,\n                // resolved data from current route overrides everything\n                ...route._resolvedData,\n            },\n        };\n    }\n    else {\n        inherited = {\n            params: { ...route.params },\n            data: { ...route.data },\n            resolve: { ...route.data, ...(route._resolvedData ?? {}) },\n        };\n    }\n    if (routeConfig && hasStaticTitle(routeConfig)) {\n        inherited.resolve[RouteTitleKey] = routeConfig.title;\n    }\n    return inherited;\n}\n/**\n * @description\n *\n * Contains the information about a route associated with a component loaded in an\n * outlet at a particular moment in time. ActivatedRouteSnapshot can also be used to\n * traverse the router state tree.\n *\n * The following example initializes a component with route information extracted\n * from the snapshot of the root node at the time of creation.\n *\n * ```ts\n * @Component({templateUrl:'./my-component.html'})\n * class MyComponent {\n *   constructor(route: ActivatedRoute) {\n *     const id: string = route.snapshot.params.id;\n *     const url: string = route.snapshot.url.join('');\n *     const user = route.snapshot.data.user;\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nclass ActivatedRouteSnapshot {\n    url;\n    params;\n    queryParams;\n    fragment;\n    data;\n    outlet;\n    component;\n    /** The configuration used to match this route **/\n    routeConfig;\n    /** @internal */\n    _resolve;\n    /** @internal */\n    _resolvedData;\n    /** @internal */\n    _routerState;\n    /** @internal */\n    _paramMap;\n    /** @internal */\n    _queryParamMap;\n    /** The resolved route title */\n    get title() {\n        // Note: This _must_ be a getter because the data is mutated in the resolvers. Title will not be\n        // available at the time of class instantiation.\n        return this.data?.[RouteTitleKey];\n    }\n    /** @internal */\n    constructor(\n    /** The URL segments matched by this route */\n    url, \n    /**\n     *  The matrix parameters scoped to this route.\n     *\n     *  You can compute all params (or data) in the router state or to get params outside\n     *  of an activated component by traversing the `RouterState` tree as in the following\n     *  example:\n     *  ```ts\n     *  collectRouteParams(router: Router) {\n     *    let params = {};\n     *    let stack: ActivatedRouteSnapshot[] = [router.routerState.snapshot.root];\n     *    while (stack.length > 0) {\n     *      const route = stack.pop()!;\n     *      params = {...params, ...route.params};\n     *      stack.push(...route.children);\n     *    }\n     *    return params;\n     *  }\n     *  ```\n     */\n    params, \n    /** The query parameters shared by all the routes */\n    queryParams, \n    /** The URL fragment shared by all the routes */\n    fragment, \n    /** The static and resolved data of this route */\n    data, \n    /** The outlet name of the route */\n    outlet, \n    /** The component of the route */\n    component, routeConfig, resolve) {\n        this.url = url;\n        this.params = params;\n        this.queryParams = queryParams;\n        this.fragment = fragment;\n        this.data = data;\n        this.outlet = outlet;\n        this.component = component;\n        this.routeConfig = routeConfig;\n        this._resolve = resolve;\n    }\n    /** The root of the router state */\n    get root() {\n        return this._routerState.root;\n    }\n    /** The parent of this route in the router state tree */\n    get parent() {\n        return this._routerState.parent(this);\n    }\n    /** The first child of this route in the router state tree */\n    get firstChild() {\n        return this._routerState.firstChild(this);\n    }\n    /** The children of this route in the router state tree */\n    get children() {\n        return this._routerState.children(this);\n    }\n    /** The path from the root of the router state tree to this route */\n    get pathFromRoot() {\n        return this._routerState.pathFromRoot(this);\n    }\n    get paramMap() {\n        this._paramMap ??= convertToParamMap(this.params);\n        return this._paramMap;\n    }\n    get queryParamMap() {\n        this._queryParamMap ??= convertToParamMap(this.queryParams);\n        return this._queryParamMap;\n    }\n    toString() {\n        const url = this.url.map((segment) => segment.toString()).join('/');\n        const matched = this.routeConfig ? this.routeConfig.path : '';\n        return `Route(url:'${url}', path:'${matched}')`;\n    }\n}\n/**\n * @description\n *\n * Represents the state of the router at a moment in time.\n *\n * This is a tree of activated route snapshots. Every node in this tree knows about\n * the \"consumed\" URL segments, the extracted parameters, and the resolved data.\n *\n * The following example shows how a component is initialized with information\n * from the snapshot of the root node's state at the time of creation.\n *\n * ```ts\n * @Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const state: RouterState = router.routerState;\n *     const snapshot: RouterStateSnapshot = state.snapshot;\n *     const root: ActivatedRouteSnapshot = snapshot.root;\n *     const child = root.firstChild;\n *     const id: Observable<string> = child.params.map(p => p.id);\n *     //...\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nclass RouterStateSnapshot extends Tree {\n    url;\n    /** @internal */\n    constructor(\n    /** The url from which this snapshot was created */\n    url, root) {\n        super(root);\n        this.url = url;\n        setRouterState(this, root);\n    }\n    toString() {\n        return serializeNode(this._root);\n    }\n}\nfunction setRouterState(state, node) {\n    node.value._routerState = state;\n    node.children.forEach((c) => setRouterState(state, c));\n}\nfunction serializeNode(node) {\n    const c = node.children.length > 0 ? ` { ${node.children.map(serializeNode).join(', ')} } ` : '';\n    return `${node.value}${c}`;\n}\n/**\n * The expectation is that the activate route is created with the right set of parameters.\n * So we push new values into the observables only when they are not the initial values.\n * And we detect that by checking if the snapshot field is set.\n */\nfunction advanceActivatedRoute(route) {\n    if (route.snapshot) {\n        const currentSnapshot = route.snapshot;\n        const nextSnapshot = route._futureSnapshot;\n        route.snapshot = nextSnapshot;\n        if (!shallowEqual(currentSnapshot.queryParams, nextSnapshot.queryParams)) {\n            route.queryParamsSubject.next(nextSnapshot.queryParams);\n        }\n        if (currentSnapshot.fragment !== nextSnapshot.fragment) {\n            route.fragmentSubject.next(nextSnapshot.fragment);\n        }\n        if (!shallowEqual(currentSnapshot.params, nextSnapshot.params)) {\n            route.paramsSubject.next(nextSnapshot.params);\n        }\n        if (!shallowEqualArrays(currentSnapshot.url, nextSnapshot.url)) {\n            route.urlSubject.next(nextSnapshot.url);\n        }\n        if (!shallowEqual(currentSnapshot.data, nextSnapshot.data)) {\n            route.dataSubject.next(nextSnapshot.data);\n        }\n    }\n    else {\n        route.snapshot = route._futureSnapshot;\n        // this is for resolved data\n        route.dataSubject.next(route._futureSnapshot.data);\n    }\n}\nfunction equalParamsAndUrlSegments(a, b) {\n    const equalUrlParams = shallowEqual(a.params, b.params) && equalSegments(a.url, b.url);\n    const parentsMismatch = !a.parent !== !b.parent;\n    return (equalUrlParams &&\n        !parentsMismatch &&\n        (!a.parent || equalParamsAndUrlSegments(a.parent, b.parent)));\n}\nfunction hasStaticTitle(config) {\n    return typeof config.title === 'string' || config.title === null;\n}\n\n/**\n * An `InjectionToken` provided by the `RouterOutlet` and can be set using the `routerOutletData`\n * input.\n *\n * When unset, this value is `null` by default.\n *\n * @usageNotes\n *\n * To set the data from the template of the component with `router-outlet`:\n * ```html\n * <router-outlet [routerOutletData]=\"{name: 'Angular'}\" />\n * ```\n *\n * To read the data in the routed component:\n * ```ts\n * data = inject(ROUTER_OUTLET_DATA) as Signal<{name: string}>;\n * ```\n *\n * @publicApi\n * @see [Page routerOutletData](guide/routing/show-routes-with-outlets#passing-contextual-data-to-routed-components)\n */\nconst ROUTER_OUTLET_DATA = new InjectionToken(ngDevMode ? 'RouterOutlet data' : '');\n/**\n * @description\n *\n * Acts as a placeholder that Angular dynamically fills based on the current router state.\n *\n * Each outlet can have a unique name, determined by the optional `name` attribute.\n * The name cannot be set or changed dynamically. If not set, default value is \"primary\".\n *\n * ```html\n * <router-outlet></router-outlet>\n * <router-outlet name='left'></router-outlet>\n * <router-outlet name='right'></router-outlet>\n * ```\n *\n * Named outlets can be the targets of secondary routes.\n * The `Route` object for a secondary route has an `outlet` property to identify the target outlet:\n *\n * `{path: <base-path>, component: <component>, outlet: <target_outlet_name>}`\n *\n * Using named outlets and secondary routes, you can target multiple outlets in\n * the same `RouterLink` directive.\n *\n * The router keeps track of separate branches in a navigation tree for each named outlet and\n * generates a representation of that tree in the URL.\n * The URL for a secondary route uses the following syntax to specify both the primary and secondary\n * routes at the same time:\n *\n * `http://base-path/primary-route-path(outlet-name:route-path)`\n *\n * A router outlet emits an activate event when a new component is instantiated,\n * deactivate event when a component is destroyed.\n * An attached event emits when the `RouteReuseStrategy` instructs the outlet to reattach the\n * subtree, and the detached event emits when the `RouteReuseStrategy` instructs the outlet to\n * detach the subtree.\n *\n * ```html\n * <router-outlet\n *   (activate)='onActivate($event)'\n *   (deactivate)='onDeactivate($event)'\n *   (attach)='onAttach($event)'\n *   (detach)='onDetach($event)'></router-outlet>\n * ```\n *\n * @see {@link RouterLink}\n * @see {@link Route}\n * @ngModule RouterModule\n *\n * @publicApi\n */\nclass RouterOutlet {\n    activated = null;\n    /** @internal */\n    get activatedComponentRef() {\n        return this.activated;\n    }\n    _activatedRoute = null;\n    /**\n     * The name of the outlet\n     *\n     */\n    name = PRIMARY_OUTLET;\n    activateEvents = new EventEmitter();\n    deactivateEvents = new EventEmitter();\n    /**\n     * Emits an attached component instance when the `RouteReuseStrategy` instructs to re-attach a\n     * previously detached subtree.\n     **/\n    attachEvents = new EventEmitter();\n    /**\n     * Emits a detached component instance when the `RouteReuseStrategy` instructs to detach the\n     * subtree.\n     */\n    detachEvents = new EventEmitter();\n    /**\n     * Data that will be provided to the child injector through the `ROUTER_OUTLET_DATA` token.\n     *\n     * When unset, the value of the token is `undefined` by default.\n     */\n    routerOutletData = input(undefined, ...(ngDevMode ? [{ debugName: \"routerOutletData\" }] : []));\n    parentContexts = inject(ChildrenOutletContexts);\n    location = inject(ViewContainerRef);\n    changeDetector = inject(ChangeDetectorRef);\n    inputBinder = inject(INPUT_BINDER, { optional: true });\n    /** @docs-private */\n    supportsBindingToComponentInputs = true;\n    /** @docs-private */\n    ngOnChanges(changes) {\n        if (changes['name']) {\n            const { firstChange, previousValue } = changes['name'];\n            if (firstChange) {\n                // The first change is handled by ngOnInit. Because ngOnChanges doesn't get called when no\n                // input is set at all, we need to centrally handle the first change there.\n                return;\n            }\n            // unregister with the old name\n            if (this.isTrackedInParentContexts(previousValue)) {\n                this.deactivate();\n                this.parentContexts.onChildOutletDestroyed(previousValue);\n            }\n            // register the new name\n            this.initializeOutletWithName();\n        }\n    }\n    /** @docs-private */\n    ngOnDestroy() {\n        // Ensure that the registered outlet is this one before removing it on the context.\n        if (this.isTrackedInParentContexts(this.name)) {\n            this.parentContexts.onChildOutletDestroyed(this.name);\n        }\n        this.inputBinder?.unsubscribeFromRouteData(this);\n    }\n    isTrackedInParentContexts(outletName) {\n        return this.parentContexts.getContext(outletName)?.outlet === this;\n    }\n    /** @docs-private */\n    ngOnInit() {\n        this.initializeOutletWithName();\n    }\n    initializeOutletWithName() {\n        this.parentContexts.onChildOutletCreated(this.name, this);\n        if (this.activated) {\n            return;\n        }\n        // If the outlet was not instantiated at the time the route got activated we need to populate\n        // the outlet when it is initialized (ie inside a NgIf)\n        const context = this.parentContexts.getContext(this.name);\n        if (context?.route) {\n            if (context.attachRef) {\n                // `attachRef` is populated when there is an existing component to mount\n                this.attach(context.attachRef, context.route);\n            }\n            else {\n                // otherwise the component defined in the configuration is created\n                this.activateWith(context.route, context.injector);\n            }\n        }\n    }\n    get isActivated() {\n        return !!this.activated;\n    }\n    /**\n     * @returns The currently activated component instance.\n     * @throws An error if the outlet is not activated.\n     */\n    get component() {\n        if (!this.activated)\n            throw new _RuntimeError(4012 /* RuntimeErrorCode.OUTLET_NOT_ACTIVATED */, (typeof ngDevMode === 'undefined' || ngDevMode) && 'Outlet is not activated');\n        return this.activated.instance;\n    }\n    get activatedRoute() {\n        if (!this.activated)\n            throw new _RuntimeError(4012 /* RuntimeErrorCode.OUTLET_NOT_ACTIVATED */, (typeof ngDevMode === 'undefined' || ngDevMode) && 'Outlet is not activated');\n        return this._activatedRoute;\n    }\n    get activatedRouteData() {\n        if (this._activatedRoute) {\n            return this._activatedRoute.snapshot.data;\n        }\n        return {};\n    }\n    /**\n     * Called when the `RouteReuseStrategy` instructs to detach the subtree\n     */\n    detach() {\n        if (!this.activated)\n            throw new _RuntimeError(4012 /* RuntimeErrorCode.OUTLET_NOT_ACTIVATED */, (typeof ngDevMode === 'undefined' || ngDevMode) && 'Outlet is not activated');\n        this.location.detach();\n        const cmp = this.activated;\n        this.activated = null;\n        this._activatedRoute = null;\n        this.detachEvents.emit(cmp.instance);\n        return cmp;\n    }\n    /**\n     * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree\n     */\n    attach(ref, activatedRoute) {\n        this.activated = ref;\n        this._activatedRoute = activatedRoute;\n        this.location.insert(ref.hostView);\n        this.inputBinder?.bindActivatedRouteToOutletComponent(this);\n        this.attachEvents.emit(ref.instance);\n    }\n    deactivate() {\n        if (this.activated) {\n            const c = this.component;\n            this.activated.destroy();\n            this.activated = null;\n            this._activatedRoute = null;\n            this.deactivateEvents.emit(c);\n        }\n    }\n    activateWith(activatedRoute, environmentInjector) {\n        if (this.isActivated) {\n            throw new _RuntimeError(4013 /* RuntimeErrorCode.OUTLET_ALREADY_ACTIVATED */, (typeof ngDevMode === 'undefined' || ngDevMode) &&\n                'Cannot activate an already activated outlet');\n        }\n        this._activatedRoute = activatedRoute;\n        const location = this.location;\n        const snapshot = activatedRoute.snapshot;\n        const component = snapshot.component;\n        const childContexts = this.parentContexts.getOrCreateContext(this.name).children;\n        const injector = new OutletInjector(activatedRoute, childContexts, location.injector, this.routerOutletData);\n        this.activated = location.createComponent(component, {\n            index: location.length,\n            injector,\n            environmentInjector: environmentInjector,\n        });\n        // Calling `markForCheck` to make sure we will run the change detection when the\n        // `RouterOutlet` is inside a `ChangeDetectionStrategy.OnPush` component.\n        this.changeDetector.markForCheck();\n        this.inputBinder?.bindActivatedRouteToOutletComponent(this);\n        this.activateEvents.emit(this.activated.instance);\n    }\n    static fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: RouterOutlet, deps: [], target: i0.FactoryTarget.Directive });\n    static dir = i0.ngDeclareDirective({ minVersion: \"17.1.0\", version: \"20.3.6\", type: RouterOutlet, isStandalone: true, selector: \"router-outlet\", inputs: { name: { classPropertyName: \"name\", publicName: \"name\", isSignal: false, isRequired: false, transformFunction: null }, routerOutletData: { classPropertyName: \"routerOutletData\", publicName: \"routerOutletData\", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { activateEvents: \"activate\", deactivateEvents: \"deactivate\", attachEvents: \"attach\", detachEvents: \"detach\" }, exportAs: [\"outlet\"], usesOnChanges: true, ngImport: i0 });\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: RouterOutlet, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: 'router-outlet',\n                    exportAs: 'outlet',\n                }]\n        }], propDecorators: { name: [{\n                type: Input\n            }], activateEvents: [{\n                type: Output,\n                args: ['activate']\n            }], deactivateEvents: [{\n                type: Output,\n                args: ['deactivate']\n            }], attachEvents: [{\n                type: Output,\n                args: ['attach']\n            }], detachEvents: [{\n                type: Output,\n                args: ['detach']\n            }], routerOutletData: [{ type: i0.Input, args: [{ isSignal: true, alias: \"routerOutletData\", required: false }] }] } });\nclass OutletInjector {\n    route;\n    childContexts;\n    parent;\n    outletData;\n    constructor(route, childContexts, parent, outletData) {\n        this.route = route;\n        this.childContexts = childContexts;\n        this.parent = parent;\n        this.outletData = outletData;\n    }\n    get(token, notFoundValue) {\n        if (token === ActivatedRoute) {\n            return this.route;\n        }\n        if (token === ChildrenOutletContexts) {\n            return this.childContexts;\n        }\n        if (token === ROUTER_OUTLET_DATA) {\n            return this.outletData;\n        }\n        return this.parent.get(token, notFoundValue);\n    }\n}\nconst INPUT_BINDER = new InjectionToken('');\n/**\n * Injectable used as a tree-shakable provider for opting in to binding router data to component\n * inputs.\n *\n * The RouterOutlet registers itself with this service when an `ActivatedRoute` is attached or\n * activated. When this happens, the service subscribes to the `ActivatedRoute` observables (params,\n * queryParams, data) and sets the inputs of the component using `ComponentRef.setInput`.\n * Importantly, when an input does not have an item in the route data with a matching key, this\n * input is set to `undefined`. If it were not done this way, the previous information would be\n * retained if the data got removed from the route (i.e. if a query parameter is removed).\n *\n * The `RouterOutlet` should unregister itself when destroyed via `unsubscribeFromRouteData` so that\n * the subscriptions are cleaned up.\n */\nclass RoutedComponentInputBinder {\n    outletDataSubscriptions = new Map();\n    bindActivatedRouteToOutletComponent(outlet) {\n        this.unsubscribeFromRouteData(outlet);\n        this.subscribeToRouteData(outlet);\n    }\n    unsubscribeFromRouteData(outlet) {\n        this.outletDataSubscriptions.get(outlet)?.unsubscribe();\n        this.outletDataSubscriptions.delete(outlet);\n    }\n    subscribeToRouteData(outlet) {\n        const { activatedRoute } = outlet;\n        const dataSubscription = combineLatest([\n            activatedRoute.queryParams,\n            activatedRoute.params,\n            activatedRoute.data,\n        ])\n            .pipe(switchMap(([queryParams, params, data], index) => {\n            data = { ...queryParams, ...params, ...data };\n            // Get the first result from the data subscription synchronously so it's available to\n            // the component as soon as possible (and doesn't require a second change detection).\n            if (index === 0) {\n                return of(data);\n            }\n            // Promise.resolve is used to avoid synchronously writing the wrong data when\n            // two of the Observables in the `combineLatest` stream emit one after\n            // another.\n            return Promise.resolve(data);\n        }))\n            .subscribe((data) => {\n            // Outlet may have been deactivated or changed names to be associated with a different\n            // route\n            if (!outlet.isActivated ||\n                !outlet.activatedComponentRef ||\n                outlet.activatedRoute !== activatedRoute ||\n                activatedRoute.component === null) {\n                this.unsubscribeFromRouteData(outlet);\n                return;\n            }\n            const mirror = reflectComponentType(activatedRoute.component);\n            if (!mirror) {\n                this.unsubscribeFromRouteData(outlet);\n                return;\n            }\n            for (const { templateName } of mirror.inputs) {\n                outlet.activatedComponentRef.setInput(templateName, data[templateName]);\n            }\n        });\n        this.outletDataSubscriptions.set(outlet, dataSubscription);\n    }\n    static fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: RoutedComponentInputBinder, deps: [], target: i0.FactoryTarget.Injectable });\n    static prov = i0.ngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: RoutedComponentInputBinder });\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: RoutedComponentInputBinder, decorators: [{\n            type: Injectable\n        }] });\n\n/**\n * This component is used internally within the router to be a placeholder when an empty\n * router-outlet is needed. For example, with a config such as:\n *\n * `{path: 'parent', outlet: 'nav', children: [...]}`\n *\n * In order to render, there needs to be a component on this config, which will default\n * to this `EmptyOutletComponent`.\n */\nclass EmptyOutletComponent {\n    static fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: EmptyOutletComponent, deps: [], target: i0.FactoryTarget.Component });\n    static cmp = i0.ngDeclareComponent({ minVersion: \"14.0.0\", version: \"20.3.6\", type: EmptyOutletComponent, isStandalone: true, selector: \"ng-component\", exportAs: [\"emptyRouterOutlet\"], ngImport: i0, template: `<router-outlet/>`, isInline: true, dependencies: [{ kind: \"directive\", type: RouterOutlet, selector: \"router-outlet\", inputs: [\"name\", \"routerOutletData\"], outputs: [\"activate\", \"deactivate\", \"attach\", \"detach\"], exportAs: [\"outlet\"] }] });\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: EmptyOutletComponent, decorators: [{\n            type: Component,\n            args: [{\n                    template: `<router-outlet/>`,\n                    imports: [RouterOutlet],\n                    // Used to avoid component ID collisions with user code.\n                    exportAs: 'emptyRouterOutlet',\n                }]\n        }] });\n/**\n * Makes a copy of the config and adds any default required properties.\n */\nfunction standardizeConfig(r) {\n    const children = r.children && r.children.map(standardizeConfig);\n    const c = children ? { ...r, children } : { ...r };\n    if (!c.component &&\n        !c.loadComponent &&\n        (children || c.loadChildren) &&\n        c.outlet &&\n        c.outlet !== PRIMARY_OUTLET) {\n        c.component = EmptyOutletComponent;\n    }\n    return c;\n}\n\nfunction createRouterState(routeReuseStrategy, curr, prevState) {\n    const root = createNode(routeReuseStrategy, curr._root, prevState ? prevState._root : undefined);\n    return new RouterState(root, curr);\n}\nfunction createNode(routeReuseStrategy, curr, prevState) {\n    // reuse an activated route that is currently displayed on the screen\n    if (prevState && routeReuseStrategy.shouldReuseRoute(curr.value, prevState.value.snapshot)) {\n        const value = prevState.value;\n        value._futureSnapshot = curr.value;\n        const children = createOrReuseChildren(routeReuseStrategy, curr, prevState);\n        return new TreeNode(value, children);\n    }\n    else {\n        if (routeReuseStrategy.shouldAttach(curr.value)) {\n            // retrieve an activated route that is used to be displayed, but is not currently displayed\n            const detachedRouteHandle = routeReuseStrategy.retrieve(curr.value);\n            if (detachedRouteHandle !== null) {\n                const tree = detachedRouteHandle.route;\n                tree.value._futureSnapshot = curr.value;\n                tree.children = curr.children.map((c) => createNode(routeReuseStrategy, c));\n                return tree;\n            }\n        }\n        const value = createActivatedRoute(curr.value);\n        const children = curr.children.map((c) => createNode(routeReuseStrategy, c));\n        return new TreeNode(value, children);\n    }\n}\nfunction createOrReuseChildren(routeReuseStrategy, curr, prevState) {\n    return curr.children.map((child) => {\n        for (const p of prevState.children) {\n            if (routeReuseStrategy.shouldReuseRoute(child.value, p.value.snapshot)) {\n                return createNode(routeReuseStrategy, child, p);\n            }\n        }\n        return createNode(routeReuseStrategy, child);\n    });\n}\nfunction createActivatedRoute(c) {\n    return new ActivatedRoute(new BehaviorSubject(c.url), new BehaviorSubject(c.params), new BehaviorSubject(c.queryParams), new BehaviorSubject(c.fragment), new BehaviorSubject(c.data), c.outlet, c.component, c);\n}\n\n/**\n * Can be returned by a `Router` guard to instruct the `Router` to redirect rather than continue\n * processing the path of the in-flight navigation. The `redirectTo` indicates _where_ the new\n * navigation should go to and the optional `navigationBehaviorOptions` can provide more information\n * about _how_ to perform the navigation.\n *\n * ```ts\n * const route: Route = {\n *   path: \"user/:userId\",\n *   component: User,\n *   canActivate: [\n *     () => {\n *       const router = inject(Router);\n *       const authService = inject(AuthenticationService);\n *\n *       if (!authService.isLoggedIn()) {\n *         const loginPath = router.parseUrl(\"/login\");\n *         return new RedirectCommand(loginPath, {\n *           skipLocationChange: true,\n *         });\n *       }\n *\n *       return true;\n *     },\n *   ],\n * };\n * ```\n * @see [Routing guide](guide/routing/common-router-tasks#preventing-unauthorized-access)\n *\n * @publicApi\n */\nclass RedirectCommand {\n    redirectTo;\n    navigationBehaviorOptions;\n    constructor(redirectTo, navigationBehaviorOptions) {\n        this.redirectTo = redirectTo;\n        this.navigationBehaviorOptions = navigationBehaviorOptions;\n    }\n}\n\nconst NAVIGATION_CANCELING_ERROR = 'ngNavigationCancelingError';\nfunction redirectingNavigationError(urlSerializer, redirect) {\n    const { redirectTo, navigationBehaviorOptions } = isUrlTree(redirect)\n        ? { redirectTo: redirect, navigationBehaviorOptions: undefined }\n        : redirect;\n    const error = navigationCancelingError(ngDevMode && `Redirecting to \"${urlSerializer.serialize(redirectTo)}\"`, NavigationCancellationCode.Redirect);\n    error.url = redirectTo;\n    error.navigationBehaviorOptions = navigationBehaviorOptions;\n    return error;\n}\nfunction navigationCancelingError(message, code) {\n    const error = new Error(`NavigationCancelingError: ${message || ''}`);\n    error[NAVIGATION_CANCELING_ERROR] = true;\n    error.cancellationCode = code;\n    return error;\n}\nfunction isRedirectingNavigationCancelingError(error) {\n    return (isNavigationCancelingError(error) &&\n        isUrlTree(error.url));\n}\nfunction isNavigationCancelingError(error) {\n    return !!error && error[NAVIGATION_CANCELING_ERROR];\n}\n\nlet warnedAboutUnsupportedInputBinding = false;\nconst activateRoutes = (rootContexts, routeReuseStrategy, forwardEvent, inputBindingEnabled) => map((t) => {\n    new ActivateRoutes(routeReuseStrategy, t.targetRouterState, t.currentRouterState, forwardEvent, inputBindingEnabled).activate(rootContexts);\n    return t;\n});\nclass ActivateRoutes {\n    routeReuseStrategy;\n    futureState;\n    currState;\n    forwardEvent;\n    inputBindingEnabled;\n    constructor(routeReuseStrategy, futureState, currState, forwardEvent, inputBindingEnabled) {\n        this.routeReuseStrategy = routeReuseStrategy;\n        this.futureState = futureState;\n        this.currState = currState;\n        this.forwardEvent = forwardEvent;\n        this.inputBindingEnabled = inputBindingEnabled;\n    }\n    activate(parentContexts) {\n        const futureRoot = this.futureState._root;\n        const currRoot = this.currState ? this.currState._root : null;\n        this.deactivateChildRoutes(futureRoot, currRoot, parentContexts);\n        advanceActivatedRoute(this.futureState.root);\n        this.activateChildRoutes(futureRoot, currRoot, parentContexts);\n    }\n    // De-activate the child route that are not re-used for the future state\n    deactivateChildRoutes(futureNode, currNode, contexts) {\n        const children = nodeChildrenAsMap(currNode);\n        // Recurse on the routes active in the future state to de-activate deeper children\n        futureNode.children.forEach((futureChild) => {\n            const childOutletName = futureChild.value.outlet;\n            this.deactivateRoutes(futureChild, children[childOutletName], contexts);\n            delete children[childOutletName];\n        });\n        // De-activate the routes that will not be re-used\n        Object.values(children).forEach((v) => {\n            this.deactivateRouteAndItsChildren(v, contexts);\n        });\n    }\n    deactivateRoutes(futureNode, currNode, parentContext) {\n        const future = futureNode.value;\n        const curr = currNode ? currNode.value : null;\n        if (future === curr) {\n            // Reusing the node, check to see if the children need to be de-activated\n            if (future.component) {\n                // If we have a normal route, we need to go through an outlet.\n                const context = parentContext.getContext(future.outlet);\n                if (context) {\n                    this.deactivateChildRoutes(futureNode, currNode, context.children);\n                }\n            }\n            else {\n                // if we have a componentless route, we recurse but keep the same outlet map.\n                this.deactivateChildRoutes(futureNode, currNode, parentContext);\n            }\n        }\n        else {\n            if (curr) {\n                // Deactivate the current route which will not be re-used\n                this.deactivateRouteAndItsChildren(currNode, parentContext);\n            }\n        }\n    }\n    deactivateRouteAndItsChildren(route, parentContexts) {\n        // If there is no component, the Route is never attached to an outlet (because there is no\n        // component to attach).\n        if (route.value.component && this.routeReuseStrategy.shouldDetach(route.value.snapshot)) {\n            this.detachAndStoreRouteSubtree(route, parentContexts);\n        }\n        else {\n            this.deactivateRouteAndOutlet(route, parentContexts);\n        }\n    }\n    detachAndStoreRouteSubtree(route, parentContexts) {\n        const context = parentContexts.getContext(route.value.outlet);\n        const contexts = context && route.value.component ? context.children : parentContexts;\n        const children = nodeChildrenAsMap(route);\n        for (const treeNode of Object.values(children)) {\n            this.deactivateRouteAndItsChildren(treeNode, contexts);\n        }\n        if (context && context.outlet) {\n            const componentRef = context.outlet.detach();\n            const contexts = context.children.onOutletDeactivated();\n            this.routeReuseStrategy.store(route.value.snapshot, { componentRef, route, contexts });\n        }\n    }\n    deactivateRouteAndOutlet(route, parentContexts) {\n        const context = parentContexts.getContext(route.value.outlet);\n        // The context could be `null` if we are on a componentless route but there may still be\n        // children that need deactivating.\n        const contexts = context && route.value.component ? context.children : parentContexts;\n        const children = nodeChildrenAsMap(route);\n        for (const treeNode of Object.values(children)) {\n            this.deactivateRouteAndItsChildren(treeNode, contexts);\n        }\n        if (context) {\n            if (context.outlet) {\n                // Destroy the component\n                context.outlet.deactivate();\n                // Destroy the contexts for all the outlets that were in the component\n                context.children.onOutletDeactivated();\n            }\n            // Clear the information about the attached component on the context but keep the reference to\n            // the outlet. Clear even if outlet was not yet activated to avoid activating later with old\n            // info\n            context.attachRef = null;\n            context.route = null;\n        }\n    }\n    activateChildRoutes(futureNode, currNode, contexts) {\n        const children = nodeChildrenAsMap(currNode);\n        futureNode.children.forEach((c) => {\n            this.activateRoutes(c, children[c.value.outlet], contexts);\n            this.forwardEvent(new ActivationEnd(c.value.snapshot));\n        });\n        if (futureNode.children.length) {\n            this.forwardEvent(new ChildActivationEnd(futureNode.value.snapshot));\n        }\n    }\n    activateRoutes(futureNode, currNode, parentContexts) {\n        const future = futureNode.value;\n        const curr = currNode ? currNode.value : null;\n        advanceActivatedRoute(future);\n        // reusing the node\n        if (future === curr) {\n            if (future.component) {\n                // If we have a normal route, we need to go through an outlet.\n                const context = parentContexts.getOrCreateContext(future.outlet);\n                this.activateChildRoutes(futureNode, currNode, context.children);\n            }\n            else {\n                // if we have a componentless route, we recurse but keep the same outlet map.\n                this.activateChildRoutes(futureNode, currNode, parentContexts);\n            }\n        }\n        else {\n            if (future.component) {\n                // if we have a normal route, we need to place the component into the outlet and recurse.\n                const context = parentContexts.getOrCreateContext(future.outlet);\n                if (this.routeReuseStrategy.shouldAttach(future.snapshot)) {\n                    const stored = (this.routeReuseStrategy.retrieve(future.snapshot));\n                    this.routeReuseStrategy.store(future.snapshot, null);\n                    context.children.onOutletReAttached(stored.contexts);\n                    context.attachRef = stored.componentRef;\n                    context.route = stored.route.value;\n                    if (context.outlet) {\n                        // Attach right away when the outlet has already been instantiated\n                        // Otherwise attach from `RouterOutlet.ngOnInit` when it is instantiated\n                        context.outlet.attach(stored.componentRef, stored.route.value);\n                    }\n                    advanceActivatedRoute(stored.route.value);\n                    this.activateChildRoutes(futureNode, null, context.children);\n                }\n                else {\n                    context.attachRef = null;\n                    context.route = future;\n                    if (context.outlet) {\n                        // Activate the outlet when it has already been instantiated\n                        // Otherwise it will get activated from its `ngOnInit` when instantiated\n                        context.outlet.activateWith(future, context.injector);\n                    }\n                    this.activateChildRoutes(futureNode, null, context.children);\n                }\n            }\n            else {\n                // if we have a componentless route, we recurse but keep the same outlet map.\n                this.activateChildRoutes(futureNode, null, parentContexts);\n            }\n        }\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            const context = parentContexts.getOrCreateContext(future.outlet);\n            const outlet = context.outlet;\n            if (outlet &&\n                this.inputBindingEnabled &&\n                !outlet.supportsBindingToComponentInputs &&\n                !warnedAboutUnsupportedInputBinding) {\n                console.warn(`'withComponentInputBinding' feature is enabled but ` +\n                    `this application is using an outlet that may not support binding to component inputs.`);\n                warnedAboutUnsupportedInputBinding = true;\n            }\n        }\n    }\n}\n\nclass CanActivate {\n    path;\n    route;\n    constructor(path) {\n        this.path = path;\n        this.route = this.path[this.path.length - 1];\n    }\n}\nclass CanDeactivate {\n    component;\n    route;\n    constructor(component, route) {\n        this.component = component;\n        this.route = route;\n    }\n}\nfunction getAllRouteGuards(future, curr, parentContexts) {\n    const futureRoot = future._root;\n    const currRoot = curr ? curr._root : null;\n    return getChildRouteGuards(futureRoot, currRoot, parentContexts, [futureRoot.value]);\n}\nfunction getCanActivateChild(p) {\n    const canActivateChild = p.routeConfig ? p.routeConfig.canActivateChild : null;\n    if (!canActivateChild || canActivateChild.length === 0)\n        return null;\n    return { node: p, guards: canActivateChild };\n}\nfunction getTokenOrFunctionIdentity(tokenOrFunction, injector) {\n    const NOT_FOUND = Symbol();\n    const result = injector.get(tokenOrFunction, NOT_FOUND);\n    if (result === NOT_FOUND) {\n        if (typeof tokenOrFunction === 'function' && !_isInjectable(tokenOrFunction)) {\n            // We think the token is just a function so return it as-is\n            return tokenOrFunction;\n        }\n        else {\n            // This will throw the not found error\n            return injector.get(tokenOrFunction);\n        }\n    }\n    return result;\n}\nfunction getChildRouteGuards(futureNode, currNode, contexts, futurePath, checks = {\n    canDeactivateChecks: [],\n    canActivateChecks: [],\n}) {\n    const prevChildren = nodeChildrenAsMap(currNode);\n    // Process the children of the future route\n    futureNode.children.forEach((c) => {\n        getRouteGuards(c, prevChildren[c.value.outlet], contexts, futurePath.concat([c.value]), checks);\n        delete prevChildren[c.value.outlet];\n    });\n    // Process any children left from the current route (not active for the future route)\n    Object.entries(prevChildren).forEach(([k, v]) => deactivateRouteAndItsChildren(v, contexts.getContext(k), checks));\n    return checks;\n}\nfunction getRouteGuards(futureNode, currNode, parentContexts, futurePath, checks = {\n    canDeactivateChecks: [],\n    canActivateChecks: [],\n}) {\n    const future = futureNode.value;\n    const curr = currNode ? currNode.value : null;\n    const context = parentContexts ? parentContexts.getContext(futureNode.value.outlet) : null;\n    // reusing the node\n    if (curr && future.routeConfig === curr.routeConfig) {\n        const shouldRun = shouldRunGuardsAndResolvers(curr, future, future.routeConfig.runGuardsAndResolvers);\n        if (shouldRun) {\n            checks.canActivateChecks.push(new CanActivate(futurePath));\n        }\n        else {\n            // we need to set the data\n            future.data = curr.data;\n            future._resolvedData = curr._resolvedData;\n        }\n        // If we have a component, we need to go through an outlet.\n        if (future.component) {\n            getChildRouteGuards(futureNode, currNode, context ? context.children : null, futurePath, checks);\n            // if we have a componentless route, we recurse but keep the same outlet map.\n        }\n        else {\n            getChildRouteGuards(futureNode, currNode, parentContexts, futurePath, checks);\n        }\n        if (shouldRun && context && context.outlet && context.outlet.isActivated) {\n            checks.canDeactivateChecks.push(new CanDeactivate(context.outlet.component, curr));\n        }\n    }\n    else {\n        if (curr) {\n            deactivateRouteAndItsChildren(currNode, context, checks);\n        }\n        checks.canActivateChecks.push(new CanActivate(futurePath));\n        // If we have a component, we need to go through an outlet.\n        if (future.component) {\n            getChildRouteGuards(futureNode, null, context ? context.children : null, futurePath, checks);\n            // if we have a componentless route, we recurse but keep the same outlet map.\n        }\n        else {\n            getChildRouteGuards(futureNode, null, parentContexts, futurePath, checks);\n        }\n    }\n    return checks;\n}\nfunction shouldRunGuardsAndResolvers(curr, future, mode) {\n    if (typeof mode === 'function') {\n        return mode(curr, future);\n    }\n    switch (mode) {\n        case 'pathParamsChange':\n            return !equalPath(curr.url, future.url);\n        case 'pathParamsOrQueryParamsChange':\n            return (!equalPath(curr.url, future.url) || !shallowEqual(curr.queryParams, future.queryParams));\n        case 'always':\n            return true;\n        case 'paramsOrQueryParamsChange':\n            return (!equalParamsAndUrlSegments(curr, future) ||\n                !shallowEqual(curr.queryParams, future.queryParams));\n        case 'paramsChange':\n        default:\n            return !equalParamsAndUrlSegments(curr, future);\n    }\n}\nfunction deactivateRouteAndItsChildren(route, context, checks) {\n    const children = nodeChildrenAsMap(route);\n    const r = route.value;\n    Object.entries(children).forEach(([childName, node]) => {\n        if (!r.component) {\n            deactivateRouteAndItsChildren(node, context, checks);\n        }\n        else if (context) {\n            deactivateRouteAndItsChildren(node, context.children.getContext(childName), checks);\n        }\n        else {\n            deactivateRouteAndItsChildren(node, null, checks);\n        }\n    });\n    if (!r.component) {\n        checks.canDeactivateChecks.push(new CanDeactivate(null, r));\n    }\n    else if (context && context.outlet && context.outlet.isActivated) {\n        checks.canDeactivateChecks.push(new CanDeactivate(context.outlet.component, r));\n    }\n    else {\n        checks.canDeactivateChecks.push(new CanDeactivate(null, r));\n    }\n}\n\n/**\n * Simple function check, but generic so type inference will flow. Example:\n *\n * function product(a: number, b: number) {\n *   return a * b;\n * }\n *\n * if (isFunction<product>(fn)) {\n *   return fn(1, 2);\n * } else {\n *   throw \"Must provide the `product` function\";\n * }\n */\nfunction isFunction(v) {\n    return typeof v === 'function';\n}\nfunction isBoolean(v) {\n    return typeof v === 'boolean';\n}\nfunction isCanLoad(guard) {\n    return guard && isFunction(guard.canLoad);\n}\nfunction isCanActivate(guard) {\n    return guard && isFunction(guard.canActivate);\n}\nfunction isCanActivateChild(guard) {\n    return guard && isFunction(guard.canActivateChild);\n}\nfunction isCanDeactivate(guard) {\n    return guard && isFunction(guard.canDeactivate);\n}\nfunction isCanMatch(guard) {\n    return guard && isFunction(guard.canMatch);\n}\nfunction isEmptyError(e) {\n    return e instanceof EmptyError || e?.name === 'EmptyError';\n}\n\nconst INITIAL_VALUE = /* @__PURE__ */ Symbol('INITIAL_VALUE');\nfunction prioritizedGuardValue() {\n    return switchMap((obs) => {\n        return combineLatest(obs.map((o) => o.pipe(take(1), startWith(INITIAL_VALUE)))).pipe(map((results) => {\n            for (const result of results) {\n                if (result === true) {\n                    // If result is true, check the next one\n                    continue;\n                }\n                else if (result === INITIAL_VALUE) {\n                    // If guard has not finished, we need to stop processing.\n                    return INITIAL_VALUE;\n                }\n                else if (result === false || isRedirect(result)) {\n                    // Result finished and was not true. Return the result.\n                    // Note that we only allow false/UrlTree/RedirectCommand. Other values are considered invalid and\n                    // ignored.\n                    return result;\n                }\n            }\n            // Everything resolved to true. Return true.\n            return true;\n        }), filter((item) => item !== INITIAL_VALUE), take(1));\n    });\n}\nfunction isRedirect(val) {\n    return isUrlTree(val) || val instanceof RedirectCommand;\n}\n\nfunction checkGuards(injector, forwardEvent) {\n    return mergeMap((t) => {\n        const { targetSnapshot, currentSnapshot, guards: { canActivateChecks, canDeactivateChecks }, } = t;\n        if (canDeactivateChecks.length === 0 && canActivateChecks.length === 0) {\n            return of({ ...t, guardsResult: true });\n        }\n        return runCanDeactivateChecks(canDeactivateChecks, targetSnapshot, currentSnapshot, injector).pipe(mergeMap((canDeactivate) => {\n            return canDeactivate && isBoolean(canDeactivate)\n                ? runCanActivateChecks(targetSnapshot, canActivateChecks, injector, forwardEvent)\n                : of(canDeactivate);\n        }), map((guardsResult) => ({ ...t, guardsResult })));\n    });\n}\nfunction runCanDeactivateChecks(checks, futureRSS, currRSS, injector) {\n    return from(checks).pipe(mergeMap((check) => runCanDeactivate(check.component, check.route, currRSS, futureRSS, injector)), first((result) => {\n        return result !== true;\n    }, true));\n}\nfunction runCanActivateChecks(futureSnapshot, checks, injector, forwardEvent) {\n    return from(checks).pipe(concatMap((check) => {\n        return concat(fireChildActivationStart(check.route.parent, forwardEvent), fireActivationStart(check.route, forwardEvent), runCanActivateChild(futureSnapshot, check.path, injector), runCanActivate(futureSnapshot, check.route, injector));\n    }), first((result) => {\n        return result !== true;\n    }, true));\n}\n/**\n * This should fire off `ActivationStart` events for each route being activated at this\n * level.\n * In other words, if you're activating `a` and `b` below, `path` will contain the\n * `ActivatedRouteSnapshot`s for both and we will fire `ActivationStart` for both. Always\n * return\n * `true` so checks continue to run.\n */\nfunction fireActivationStart(snapshot, forwardEvent) {\n    if (snapshot !== null && forwardEvent) {\n        forwardEvent(new ActivationStart(snapshot));\n    }\n    return of(true);\n}\n/**\n * This should fire off `ChildActivationStart` events for each route being activated at this\n * level.\n * In other words, if you're activating `a` and `b` below, `path` will contain the\n * `ActivatedRouteSnapshot`s for both and we will fire `ChildActivationStart` for both. Always\n * return\n * `true` so checks continue to run.\n */\nfunction fireChildActivationStart(snapshot, forwardEvent) {\n    if (snapshot !== null && forwardEvent) {\n        forwardEvent(new ChildActivationStart(snapshot));\n    }\n    return of(true);\n}\nfunction runCanActivate(futureRSS, futureARS, injector) {\n    const canActivate = futureARS.routeConfig ? futureARS.routeConfig.canActivate : null;\n    if (!canActivate || canActivate.length === 0)\n        return of(true);\n    const canActivateObservables = canActivate.map((canActivate) => {\n        return defer(() => {\n            const closestInjector = getClosestRouteInjector(futureARS) ?? injector;\n            const guard = getTokenOrFunctionIdentity(canActivate, closestInjector);\n            const guardVal = isCanActivate(guard)\n                ? guard.canActivate(futureARS, futureRSS)\n                : runInInjectionContext(closestInjector, () => guard(futureARS, futureRSS));\n            return wrapIntoObservable(guardVal).pipe(first());\n        });\n    });\n    return of(canActivateObservables).pipe(prioritizedGuardValue());\n}\nfunction runCanActivateChild(futureRSS, path, injector) {\n    const futureARS = path[path.length - 1];\n    const canActivateChildGuards = path\n        .slice(0, path.length - 1)\n        .reverse()\n        .map((p) => getCanActivateChild(p))\n        .filter((_) => _ !== null);\n    const canActivateChildGuardsMapped = canActivateChildGuards.map((d) => {\n        return defer(() => {\n            const guardsMapped = d.guards.map((canActivateChild) => {\n                const closestInjector = getClosestRouteInjector(d.node) ?? injector;\n                const guard = getTokenOrFunctionIdentity(canActivateChild, closestInjector);\n                const guardVal = isCanActivateChild(guard)\n                    ? guard.canActivateChild(futureARS, futureRSS)\n                    : runInInjectionContext(closestInjector, () => guard(futureARS, futureRSS));\n                return wrapIntoObservable(guardVal).pipe(first());\n            });\n            return of(guardsMapped).pipe(prioritizedGuardValue());\n        });\n    });\n    return of(canActivateChildGuardsMapped).pipe(prioritizedGuardValue());\n}\nfunction runCanDeactivate(component, currARS, currRSS, futureRSS, injector) {\n    const canDeactivate = currARS && currARS.routeConfig ? currARS.routeConfig.canDeactivate : null;\n    if (!canDeactivate || canDeactivate.length === 0)\n        return of(true);\n    const canDeactivateObservables = canDeactivate.map((c) => {\n        const closestInjector = getClosestRouteInjector(currARS) ?? injector;\n        const guard = getTokenOrFunctionIdentity(c, closestInjector);\n        const guardVal = isCanDeactivate(guard)\n            ? guard.canDeactivate(component, currARS, currRSS, futureRSS)\n            : runInInjectionContext(closestInjector, () => guard(component, currARS, currRSS, futureRSS));\n        return wrapIntoObservable(guardVal).pipe(first());\n    });\n    return of(canDeactivateObservables).pipe(prioritizedGuardValue());\n}\nfunction runCanLoadGuards(injector, route, segments, urlSerializer) {\n    const canLoad = route.canLoad;\n    if (canLoad === undefined || canLoad.length === 0) {\n        return of(true);\n    }\n    const canLoadObservables = canLoad.map((injectionToken) => {\n        const guard = getTokenOrFunctionIdentity(injectionToken, injector);\n        const guardVal = isCanLoad(guard)\n            ? guard.canLoad(route, segments)\n            : runInInjectionContext(injector, () => guard(route, segments));\n        return wrapIntoObservable(guardVal);\n    });\n    return of(canLoadObservables).pipe(prioritizedGuardValue(), redirectIfUrlTree(urlSerializer));\n}\nfunction redirectIfUrlTree(urlSerializer) {\n    return pipe(tap((result) => {\n        if (typeof result === 'boolean')\n            return;\n        throw redirectingNavigationError(urlSerializer, result);\n    }), map((result) => result === true));\n}\nfunction runCanMatchGuards(injector, route, segments, urlSerializer) {\n    const canMatch = route.canMatch;\n    if (!canMatch || canMatch.length === 0)\n        return of(true);\n    const canMatchObservables = canMatch.map((injectionToken) => {\n        const guard = getTokenOrFunctionIdentity(injectionToken, injector);\n        const guardVal = isCanMatch(guard)\n            ? guard.canMatch(route, segments)\n            : runInInjectionContext(injector, () => guard(route, segments));\n        return wrapIntoObservable(guardVal);\n    });\n    return of(canMatchObservables).pipe(prioritizedGuardValue(), redirectIfUrlTree(urlSerializer));\n}\n\nclass NoMatch {\n    segmentGroup;\n    constructor(segmentGroup) {\n        this.segmentGroup = segmentGroup || null;\n    }\n}\nclass AbsoluteRedirect extends Error {\n    urlTree;\n    constructor(urlTree) {\n        super();\n        this.urlTree = urlTree;\n    }\n}\nfunction noMatch$1(segmentGroup) {\n    return throwError(new NoMatch(segmentGroup));\n}\nfunction namedOutletsRedirect(redirectTo) {\n    return throwError(new _RuntimeError(4000 /* RuntimeErrorCode.NAMED_OUTLET_REDIRECT */, (typeof ngDevMode === 'undefined' || ngDevMode) &&\n        `Only absolute redirects can have named outlets. redirectTo: '${redirectTo}'`));\n}\nfunction canLoadFails(route) {\n    return throwError(navigationCancelingError((typeof ngDevMode === 'undefined' || ngDevMode) &&\n        `Cannot load children because the guard of the route \"path: '${route.path}'\" returned false`, NavigationCancellationCode.GuardRejected));\n}\nclass ApplyRedirects {\n    urlSerializer;\n    urlTree;\n    constructor(urlSerializer, urlTree) {\n        this.urlSerializer = urlSerializer;\n        this.urlTree = urlTree;\n    }\n    lineralizeSegments(route, urlTree) {\n        let res = [];\n        let c = urlTree.root;\n        while (true) {\n            res = res.concat(c.segments);\n            if (c.numberOfChildren === 0) {\n                return of(res);\n            }\n            if (c.numberOfChildren > 1 || !c.children[PRIMARY_OUTLET]) {\n                return namedOutletsRedirect(`${route.redirectTo}`);\n            }\n            c = c.children[PRIMARY_OUTLET];\n        }\n    }\n    applyRedirectCommands(segments, redirectTo, posParams, currentSnapshot, injector) {\n        return getRedirectResult(redirectTo, currentSnapshot, injector).pipe(map((redirect) => {\n            if (redirect instanceof UrlTree) {\n                throw new AbsoluteRedirect(redirect);\n            }\n            const newTree = this.applyRedirectCreateUrlTree(redirect, this.urlSerializer.parse(redirect), segments, posParams);\n            if (redirect[0] === '/') {\n                throw new AbsoluteRedirect(newTree);\n            }\n            return newTree;\n        }));\n    }\n    applyRedirectCreateUrlTree(redirectTo, urlTree, segments, posParams) {\n        const newRoot = this.createSegmentGroup(redirectTo, urlTree.root, segments, posParams);\n        return new UrlTree(newRoot, this.createQueryParams(urlTree.queryParams, this.urlTree.queryParams), urlTree.fragment);\n    }\n    createQueryParams(redirectToParams, actualParams) {\n        const res = {};\n        Object.entries(redirectToParams).forEach(([k, v]) => {\n            const copySourceValue = typeof v === 'string' && v[0] === ':';\n            if (copySourceValue) {\n                const sourceName = v.substring(1);\n                res[k] = actualParams[sourceName];\n            }\n            else {\n                res[k] = v;\n            }\n        });\n        return res;\n    }\n    createSegmentGroup(redirectTo, group, segments, posParams) {\n        const updatedSegments = this.createSegments(redirectTo, group.segments, segments, posParams);\n        let children = {};\n        Object.entries(group.children).forEach(([name, child]) => {\n            children[name] = this.createSegmentGroup(redirectTo, child, segments, posParams);\n        });\n        return new UrlSegmentGroup(updatedSegments, children);\n    }\n    createSegments(redirectTo, redirectToSegments, actualSegments, posParams) {\n        return redirectToSegments.map((s) => s.path[0] === ':'\n            ? this.findPosParam(redirectTo, s, posParams)\n            : this.findOrReturn(s, actualSegments));\n    }\n    findPosParam(redirectTo, redirectToUrlSegment, posParams) {\n        const pos = posParams[redirectToUrlSegment.path.substring(1)];\n        if (!pos)\n            throw new _RuntimeError(4001 /* RuntimeErrorCode.MISSING_REDIRECT */, (typeof ngDevMode === 'undefined' || ngDevMode) &&\n                `Cannot redirect to '${redirectTo}'. Cannot find '${redirectToUrlSegment.path}'.`);\n        return pos;\n    }\n    findOrReturn(redirectToUrlSegment, actualSegments) {\n        let idx = 0;\n        for (const s of actualSegments) {\n            if (s.path === redirectToUrlSegment.path) {\n                actualSegments.splice(idx);\n                return s;\n            }\n            idx++;\n        }\n        return redirectToUrlSegment;\n    }\n}\nfunction getRedirectResult(redirectTo, currentSnapshot, injector) {\n    if (typeof redirectTo === 'string') {\n        return of(redirectTo);\n    }\n    const redirectToFn = redirectTo;\n    const { queryParams, fragment, routeConfig, url, outlet, params, data, title } = currentSnapshot;\n    return wrapIntoObservable(runInInjectionContext(injector, () => redirectToFn({ params, data, queryParams, fragment, routeConfig, url, outlet, title })));\n}\n\nconst noMatch = {\n    matched: false,\n    consumedSegments: [],\n    remainingSegments: [],\n    parameters: {},\n    positionalParamSegments: {},\n};\nfunction matchWithChecks(segmentGroup, route, segments, injector, urlSerializer) {\n    const result = match(segmentGroup, route, segments);\n    if (!result.matched) {\n        return of(result);\n    }\n    // Only create the Route's `EnvironmentInjector` if it matches the attempted\n    // navigation\n    injector = getOrCreateRouteInjectorIfNeeded(route, injector);\n    return runCanMatchGuards(injector, route, segments, urlSerializer).pipe(map((v) => (v === true ? result : { ...noMatch })));\n}\nfunction match(segmentGroup, route, segments) {\n    if (route.path === '**') {\n        return createWildcardMatchResult(segments);\n    }\n    if (route.path === '') {\n        if (route.pathMatch === 'full' && (segmentGroup.hasChildren() || segments.length > 0)) {\n            return { ...noMatch };\n        }\n        return {\n            matched: true,\n            consumedSegments: [],\n            remainingSegments: segments,\n            parameters: {},\n            positionalParamSegments: {},\n        };\n    }\n    const matcher = route.matcher || defaultUrlMatcher;\n    const res = matcher(segments, segmentGroup, route);\n    if (!res)\n        return { ...noMatch };\n    const posParams = {};\n    Object.entries(res.posParams ?? {}).forEach(([k, v]) => {\n        posParams[k] = v.path;\n    });\n    const parameters = res.consumed.length > 0\n        ? { ...posParams, ...res.consumed[res.consumed.length - 1].parameters }\n        : posParams;\n    return {\n        matched: true,\n        consumedSegments: res.consumed,\n        remainingSegments: segments.slice(res.consumed.length),\n        // TODO(atscott): investigate combining parameters and positionalParamSegments\n        parameters,\n        positionalParamSegments: res.posParams ?? {},\n    };\n}\nfunction createWildcardMatchResult(segments) {\n    return {\n        matched: true,\n        parameters: segments.length > 0 ? last(segments).parameters : {},\n        consumedSegments: segments,\n        remainingSegments: [],\n        positionalParamSegments: {},\n    };\n}\nfunction split(segmentGroup, consumedSegments, slicedSegments, config) {\n    if (slicedSegments.length > 0 &&\n        containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, config)) {\n        const s = new UrlSegmentGroup(consumedSegments, createChildrenForEmptyPaths(config, new UrlSegmentGroup(slicedSegments, segmentGroup.children)));\n        return { segmentGroup: s, slicedSegments: [] };\n    }\n    if (slicedSegments.length === 0 &&\n        containsEmptyPathMatches(segmentGroup, slicedSegments, config)) {\n        const s = new UrlSegmentGroup(segmentGroup.segments, addEmptyPathsToChildrenIfNeeded(segmentGroup, slicedSegments, config, segmentGroup.children));\n        return { segmentGroup: s, slicedSegments };\n    }\n    const s = new UrlSegmentGroup(segmentGroup.segments, segmentGroup.children);\n    return { segmentGroup: s, slicedSegments };\n}\nfunction addEmptyPathsToChildrenIfNeeded(segmentGroup, slicedSegments, routes, children) {\n    const res = {};\n    for (const r of routes) {\n        if (emptyPathMatch(segmentGroup, slicedSegments, r) && !children[getOutlet(r)]) {\n            const s = new UrlSegmentGroup([], {});\n            res[getOutlet(r)] = s;\n        }\n    }\n    return { ...children, ...res };\n}\nfunction createChildrenForEmptyPaths(routes, primarySegment) {\n    const res = {};\n    res[PRIMARY_OUTLET] = primarySegment;\n    for (const r of routes) {\n        if (r.path === '' && getOutlet(r) !== PRIMARY_OUTLET) {\n            const s = new UrlSegmentGroup([], {});\n            res[getOutlet(r)] = s;\n        }\n    }\n    return res;\n}\nfunction containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, routes) {\n    return routes.some((r) => emptyPathMatch(segmentGroup, slicedSegments, r) && getOutlet(r) !== PRIMARY_OUTLET);\n}\nfunction containsEmptyPathMatches(segmentGroup, slicedSegments, routes) {\n    return routes.some((r) => emptyPathMatch(segmentGroup, slicedSegments, r));\n}\nfunction emptyPathMatch(segmentGroup, slicedSegments, r) {\n    if ((segmentGroup.hasChildren() || slicedSegments.length > 0) && r.pathMatch === 'full') {\n        return false;\n    }\n    return r.path === '';\n}\nfunction noLeftoversInUrl(segmentGroup, segments, outlet) {\n    return segments.length === 0 && !segmentGroup.children[outlet];\n}\n\n/**\n * Class used to indicate there were no additional route config matches but that all segments of\n * the URL were consumed during matching so the route was URL matched. When this happens, we still\n * try to match child configs in case there are empty path children.\n */\nclass NoLeftoversInUrl {\n}\nfunction recognize$1(injector, configLoader, rootComponentType, config, urlTree, urlSerializer, paramsInheritanceStrategy = 'emptyOnly') {\n    return new Recognizer(injector, configLoader, rootComponentType, config, urlTree, paramsInheritanceStrategy, urlSerializer).recognize();\n}\nconst MAX_ALLOWED_REDIRECTS = 31;\nclass Recognizer {\n    injector;\n    configLoader;\n    rootComponentType;\n    config;\n    urlTree;\n    paramsInheritanceStrategy;\n    urlSerializer;\n    applyRedirects;\n    absoluteRedirectCount = 0;\n    allowRedirects = true;\n    constructor(injector, configLoader, rootComponentType, config, urlTree, paramsInheritanceStrategy, urlSerializer) {\n        this.injector = injector;\n        this.configLoader = configLoader;\n        this.rootComponentType = rootComponentType;\n        this.config = config;\n        this.urlTree = urlTree;\n        this.paramsInheritanceStrategy = paramsInheritanceStrategy;\n        this.urlSerializer = urlSerializer;\n        this.applyRedirects = new ApplyRedirects(this.urlSerializer, this.urlTree);\n    }\n    noMatchError(e) {\n        return new _RuntimeError(4002 /* RuntimeErrorCode.NO_MATCH */, typeof ngDevMode === 'undefined' || ngDevMode\n            ? `Cannot match any routes. URL Segment: '${e.segmentGroup}'`\n            : `'${e.segmentGroup}'`);\n    }\n    recognize() {\n        const rootSegmentGroup = split(this.urlTree.root, [], [], this.config).segmentGroup;\n        return this.match(rootSegmentGroup).pipe(map(({ children, rootSnapshot }) => {\n            const rootNode = new TreeNode(rootSnapshot, children);\n            const routeState = new RouterStateSnapshot('', rootNode);\n            const tree = createUrlTreeFromSnapshot(rootSnapshot, [], this.urlTree.queryParams, this.urlTree.fragment);\n            // https://github.com/angular/angular/issues/47307\n            // Creating the tree stringifies the query params\n            // We don't want to do this here so reassign them to the original.\n            tree.queryParams = this.urlTree.queryParams;\n            routeState.url = this.urlSerializer.serialize(tree);\n            return { state: routeState, tree };\n        }));\n    }\n    match(rootSegmentGroup) {\n        // Use Object.freeze to prevent readers of the Router state from modifying it outside\n        // of a navigation, resulting in the router being out of sync with the browser.\n        const rootSnapshot = new ActivatedRouteSnapshot([], Object.freeze({}), Object.freeze({ ...this.urlTree.queryParams }), this.urlTree.fragment, Object.freeze({}), PRIMARY_OUTLET, this.rootComponentType, null, {});\n        return this.processSegmentGroup(this.injector, this.config, rootSegmentGroup, PRIMARY_OUTLET, rootSnapshot).pipe(map((children) => {\n            return { children, rootSnapshot };\n        }), catchError((e) => {\n            if (e instanceof AbsoluteRedirect) {\n                this.urlTree = e.urlTree;\n                return this.match(e.urlTree.root);\n            }\n            if (e instanceof NoMatch) {\n                throw this.noMatchError(e);\n            }\n            throw e;\n        }));\n    }\n    processSegmentGroup(injector, config, segmentGroup, outlet, parentRoute) {\n        if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n            return this.processChildren(injector, config, segmentGroup, parentRoute);\n        }\n        return this.processSegment(injector, config, segmentGroup, segmentGroup.segments, outlet, true, parentRoute).pipe(map((child) => (child instanceof TreeNode ? [child] : [])));\n    }\n    /**\n     * Matches every child outlet in the `segmentGroup` to a `Route` in the config. Returns `null` if\n     * we cannot find a match for _any_ of the children.\n     *\n     * @param config - The `Routes` to match against\n     * @param segmentGroup - The `UrlSegmentGroup` whose children need to be matched against the\n     *     config.\n     */\n    processChildren(injector, config, segmentGroup, parentRoute) {\n        // Expand outlets one at a time, starting with the primary outlet. We need to do it this way\n        // because an absolute redirect from the primary outlet takes precedence.\n        const childOutlets = [];\n        for (const child of Object.keys(segmentGroup.children)) {\n            if (child === 'primary') {\n                childOutlets.unshift(child);\n            }\n            else {\n                childOutlets.push(child);\n            }\n        }\n        return from(childOutlets).pipe(concatMap((childOutlet) => {\n            const child = segmentGroup.children[childOutlet];\n            // Sort the config so that routes with outlets that match the one being activated\n            // appear first, followed by routes for other outlets, which might match if they have\n            // an empty path.\n            const sortedConfig = sortByMatchingOutlets(config, childOutlet);\n            return this.processSegmentGroup(injector, sortedConfig, child, childOutlet, parentRoute);\n        }), scan((children, outletChildren) => {\n            children.push(...outletChildren);\n            return children;\n        }), defaultIfEmpty(null), last$1(), mergeMap((children) => {\n            if (children === null)\n                return noMatch$1(segmentGroup);\n            // Because we may have matched two outlets to the same empty path segment, we can have\n            // multiple activated results for the same outlet. We should merge the children of\n            // these results so the final return value is only one `TreeNode` per outlet.\n            const mergedChildren = mergeEmptyPathMatches(children);\n            if (typeof ngDevMode === 'undefined' || ngDevMode) {\n                // This should really never happen - we are only taking the first match for each\n                // outlet and merge the empty path matches.\n                checkOutletNameUniqueness(mergedChildren);\n            }\n            sortActivatedRouteSnapshots(mergedChildren);\n            return of(mergedChildren);\n        }));\n    }\n    processSegment(injector, routes, segmentGroup, segments, outlet, allowRedirects, parentRoute) {\n        return from(routes).pipe(concatMap((r) => {\n            return this.processSegmentAgainstRoute(r._injector ?? injector, routes, r, segmentGroup, segments, outlet, allowRedirects, parentRoute).pipe(catchError((e) => {\n                if (e instanceof NoMatch) {\n                    return of(null);\n                }\n                throw e;\n            }));\n        }), first((x) => !!x), catchError((e) => {\n            if (isEmptyError(e)) {\n                if (noLeftoversInUrl(segmentGroup, segments, outlet)) {\n                    return of(new NoLeftoversInUrl());\n                }\n                return noMatch$1(segmentGroup);\n            }\n            throw e;\n        }));\n    }\n    processSegmentAgainstRoute(injector, routes, route, rawSegment, segments, outlet, allowRedirects, parentRoute) {\n        // We allow matches to empty paths when the outlets differ so we can match a url like `/(b:b)` to\n        // a config like\n        // * `{path: '', children: [{path: 'b', outlet: 'b'}]}`\n        // or even\n        // * `{path: '', outlet: 'a', children: [{path: 'b', outlet: 'b'}]`\n        //\n        // The exception here is when the segment outlet is for the primary outlet. This would\n        // result in a match inside the named outlet because all children there are written as primary\n        // outlets. So we need to prevent child named outlet matches in a url like `/b` in a config like\n        // * `{path: '', outlet: 'x' children: [{path: 'b'}]}`\n        // This should only match if the url is `/(x:b)`.\n        if (getOutlet(route) !== outlet &&\n            (outlet === PRIMARY_OUTLET || !emptyPathMatch(rawSegment, segments, route))) {\n            return noMatch$1(rawSegment);\n        }\n        if (route.redirectTo === undefined) {\n            return this.matchSegmentAgainstRoute(injector, rawSegment, route, segments, outlet, parentRoute);\n        }\n        if (this.allowRedirects && allowRedirects) {\n            return this.expandSegmentAgainstRouteUsingRedirect(injector, rawSegment, routes, route, segments, outlet, parentRoute);\n        }\n        return noMatch$1(rawSegment);\n    }\n    expandSegmentAgainstRouteUsingRedirect(injector, segmentGroup, routes, route, segments, outlet, parentRoute) {\n        const { matched, parameters, consumedSegments, positionalParamSegments, remainingSegments } = match(segmentGroup, route, segments);\n        if (!matched)\n            return noMatch$1(segmentGroup);\n        // TODO(atscott): Move all of this under an if(ngDevMode) as a breaking change and allow stack\n        // size exceeded in production\n        if (typeof route.redirectTo === 'string' && route.redirectTo[0] === '/') {\n            this.absoluteRedirectCount++;\n            if (this.absoluteRedirectCount > MAX_ALLOWED_REDIRECTS) {\n                if (ngDevMode) {\n                    throw new _RuntimeError(4016 /* RuntimeErrorCode.INFINITE_REDIRECT */, `Detected possible infinite redirect when redirecting from '${this.urlTree}' to '${route.redirectTo}'.\\n` +\n                        `This is currently a dev mode only error but will become a` +\n                        ` call stack size exceeded error in production in a future major version.`);\n                }\n                this.allowRedirects = false;\n            }\n        }\n        const currentSnapshot = new ActivatedRouteSnapshot(segments, parameters, Object.freeze({ ...this.urlTree.queryParams }), this.urlTree.fragment, getData(route), getOutlet(route), route.component ?? route._loadedComponent ?? null, route, getResolve(route));\n        const inherited = getInherited(currentSnapshot, parentRoute, this.paramsInheritanceStrategy);\n        currentSnapshot.params = Object.freeze(inherited.params);\n        currentSnapshot.data = Object.freeze(inherited.data);\n        const newTree$ = this.applyRedirects.applyRedirectCommands(consumedSegments, route.redirectTo, positionalParamSegments, currentSnapshot, injector);\n        return newTree$.pipe(switchMap((newTree) => this.applyRedirects.lineralizeSegments(route, newTree)), mergeMap((newSegments) => {\n            return this.processSegment(injector, routes, segmentGroup, newSegments.concat(remainingSegments), outlet, false, parentRoute);\n        }));\n    }\n    matchSegmentAgainstRoute(injector, rawSegment, route, segments, outlet, parentRoute) {\n        const matchResult = matchWithChecks(rawSegment, route, segments, injector, this.urlSerializer);\n        if (route.path === '**') {\n            // Prior versions of the route matching algorithm would stop matching at the wildcard route.\n            // We should investigate a better strategy for any existing children. Otherwise, these\n            // child segments are silently dropped from the navigation.\n            // https://github.com/angular/angular/issues/40089\n            rawSegment.children = {};\n        }\n        return matchResult.pipe(switchMap((result) => {\n            if (!result.matched) {\n                return noMatch$1(rawSegment);\n            }\n            // If the route has an injector created from providers, we should start using that.\n            injector = route._injector ?? injector;\n            return this.getChildConfig(injector, route, segments).pipe(switchMap(({ routes: childConfig }) => {\n                const childInjector = route._loadedInjector ?? injector;\n                const { parameters, consumedSegments, remainingSegments } = result;\n                const snapshot = new ActivatedRouteSnapshot(consumedSegments, parameters, Object.freeze({ ...this.urlTree.queryParams }), this.urlTree.fragment, getData(route), getOutlet(route), route.component ?? route._loadedComponent ?? null, route, getResolve(route));\n                const inherited = getInherited(snapshot, parentRoute, this.paramsInheritanceStrategy);\n                snapshot.params = Object.freeze(inherited.params);\n                snapshot.data = Object.freeze(inherited.data);\n                const { segmentGroup, slicedSegments } = split(rawSegment, consumedSegments, remainingSegments, childConfig);\n                if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {\n                    return this.processChildren(childInjector, childConfig, segmentGroup, snapshot).pipe(map((children) => {\n                        return new TreeNode(snapshot, children);\n                    }));\n                }\n                if (childConfig.length === 0 && slicedSegments.length === 0) {\n                    return of(new TreeNode(snapshot, []));\n                }\n                const matchedOnOutlet = getOutlet(route) === outlet;\n                // If we matched a config due to empty path match on a different outlet, we need to\n                // continue passing the current outlet for the segment rather than switch to PRIMARY.\n                // Note that we switch to primary when we have a match because outlet configs look like\n                // this: {path: 'a', outlet: 'a', children: [\n                //  {path: 'b', component: B},\n                //  {path: 'c', component: C},\n                // ]}\n                // Notice that the children of the named outlet are configured with the primary outlet\n                return this.processSegment(childInjector, childConfig, segmentGroup, slicedSegments, matchedOnOutlet ? PRIMARY_OUTLET : outlet, true, snapshot).pipe(map((child) => {\n                    return new TreeNode(snapshot, child instanceof TreeNode ? [child] : []);\n                }));\n            }));\n        }));\n    }\n    getChildConfig(injector, route, segments) {\n        if (route.children) {\n            // The children belong to the same module\n            return of({ routes: route.children, injector });\n        }\n        if (route.loadChildren) {\n            // lazy children belong to the loaded module\n            if (route._loadedRoutes !== undefined) {\n                return of({ routes: route._loadedRoutes, injector: route._loadedInjector });\n            }\n            return runCanLoadGuards(injector, route, segments, this.urlSerializer).pipe(mergeMap((shouldLoadResult) => {\n                if (shouldLoadResult) {\n                    return this.configLoader.loadChildren(injector, route).pipe(tap((cfg) => {\n                        route._loadedRoutes = cfg.routes;\n                        route._loadedInjector = cfg.injector;\n                    }));\n                }\n                return canLoadFails(route);\n            }));\n        }\n        return of({ routes: [], injector });\n    }\n}\nfunction sortActivatedRouteSnapshots(nodes) {\n    nodes.sort((a, b) => {\n        if (a.value.outlet === PRIMARY_OUTLET)\n            return -1;\n        if (b.value.outlet === PRIMARY_OUTLET)\n            return 1;\n        return a.value.outlet.localeCompare(b.value.outlet);\n    });\n}\nfunction hasEmptyPathConfig(node) {\n    const config = node.value.routeConfig;\n    return config && config.path === '';\n}\n/**\n * Finds `TreeNode`s with matching empty path route configs and merges them into `TreeNode` with\n * the children from each duplicate. This is necessary because different outlets can match a\n * single empty path route config and the results need to then be merged.\n */\nfunction mergeEmptyPathMatches(nodes) {\n    const result = [];\n    // The set of nodes which contain children that were merged from two duplicate empty path nodes.\n    const mergedNodes = new Set();\n    for (const node of nodes) {\n        if (!hasEmptyPathConfig(node)) {\n            result.push(node);\n            continue;\n        }\n        const duplicateEmptyPathNode = result.find((resultNode) => node.value.routeConfig === resultNode.value.routeConfig);\n        if (duplicateEmptyPathNode !== undefined) {\n            duplicateEmptyPathNode.children.push(...node.children);\n            mergedNodes.add(duplicateEmptyPathNode);\n        }\n        else {\n            result.push(node);\n        }\n    }\n    // For each node which has children from multiple sources, we need to recompute a new `TreeNode`\n    // by also merging those children. This is necessary when there are multiple empty path configs\n    // in a row. Put another way: whenever we combine children of two nodes, we need to also check\n    // if any of those children can be combined into a single node as well.\n    for (const mergedNode of mergedNodes) {\n        const mergedChildren = mergeEmptyPathMatches(mergedNode.children);\n        result.push(new TreeNode(mergedNode.value, mergedChildren));\n    }\n    return result.filter((n) => !mergedNodes.has(n));\n}\nfunction checkOutletNameUniqueness(nodes) {\n    const names = {};\n    nodes.forEach((n) => {\n        const routeWithSameOutletName = names[n.value.outlet];\n        if (routeWithSameOutletName) {\n            const p = routeWithSameOutletName.url.map((s) => s.toString()).join('/');\n            const c = n.value.url.map((s) => s.toString()).join('/');\n            throw new _RuntimeError(4006 /* RuntimeErrorCode.TWO_SEGMENTS_WITH_SAME_OUTLET */, (typeof ngDevMode === 'undefined' || ngDevMode) &&\n                `Two segments cannot have the same outlet name: '${p}' and '${c}'.`);\n        }\n        names[n.value.outlet] = n.value;\n    });\n}\nfunction getData(route) {\n    return route.data || {};\n}\nfunction getResolve(route) {\n    return route.resolve || {};\n}\n\nfunction recognize(injector, configLoader, rootComponentType, config, serializer, paramsInheritanceStrategy) {\n    return mergeMap((t) => recognize$1(injector, configLoader, rootComponentType, config, t.extractedUrl, serializer, paramsInheritanceStrategy).pipe(map(({ state: targetSnapshot, tree: urlAfterRedirects }) => {\n        return { ...t, targetSnapshot, urlAfterRedirects };\n    })));\n}\n\nfunction resolveData(paramsInheritanceStrategy, injector) {\n    return mergeMap((t) => {\n        const { targetSnapshot, guards: { canActivateChecks }, } = t;\n        if (!canActivateChecks.length) {\n            return of(t);\n        }\n        // Iterating a Set in javascript  happens in insertion order so it is safe to use a `Set` to\n        // preserve the correct order that the resolvers should run in.\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set#description\n        const routesWithResolversToRun = new Set(canActivateChecks.map((check) => check.route));\n        const routesNeedingDataUpdates = new Set();\n        for (const route of routesWithResolversToRun) {\n            if (routesNeedingDataUpdates.has(route)) {\n                continue;\n            }\n            // All children under the route with a resolver to run need to recompute inherited data.\n            for (const newRoute of flattenRouteTree(route)) {\n                routesNeedingDataUpdates.add(newRoute);\n            }\n        }\n        let routesProcessed = 0;\n        return from(routesNeedingDataUpdates).pipe(concatMap((route) => {\n            if (routesWithResolversToRun.has(route)) {\n                return runResolve(route, targetSnapshot, paramsInheritanceStrategy, injector);\n            }\n            else {\n                route.data = getInherited(route, route.parent, paramsInheritanceStrategy).resolve;\n                return of(void 0);\n            }\n        }), tap(() => routesProcessed++), takeLast(1), mergeMap((_) => (routesProcessed === routesNeedingDataUpdates.size ? of(t) : EMPTY)));\n    });\n}\n/**\n *  Returns the `ActivatedRouteSnapshot` tree as an array, using DFS to traverse the route tree.\n */\nfunction flattenRouteTree(route) {\n    const descendants = route.children.map((child) => flattenRouteTree(child)).flat();\n    return [route, ...descendants];\n}\nfunction runResolve(futureARS, futureRSS, paramsInheritanceStrategy, injector) {\n    const config = futureARS.routeConfig;\n    const resolve = futureARS._resolve;\n    if (config?.title !== undefined && !hasStaticTitle(config)) {\n        resolve[RouteTitleKey] = config.title;\n    }\n    return defer(() => {\n        futureARS.data = getInherited(futureARS, futureARS.parent, paramsInheritanceStrategy).resolve;\n        return resolveNode(resolve, futureARS, futureRSS, injector).pipe(map((resolvedData) => {\n            futureARS._resolvedData = resolvedData;\n            futureARS.data = { ...futureARS.data, ...resolvedData };\n            return null;\n        }));\n    });\n}\nfunction resolveNode(resolve, futureARS, futureRSS, injector) {\n    const keys = getDataKeys(resolve);\n    if (keys.length === 0) {\n        return of({});\n    }\n    const data = {};\n    return from(keys).pipe(mergeMap((key) => getResolver(resolve[key], futureARS, futureRSS, injector).pipe(first(), tap((value) => {\n        if (value instanceof RedirectCommand) {\n            throw redirectingNavigationError(new DefaultUrlSerializer(), value);\n        }\n        data[key] = value;\n    }))), takeLast(1), map(() => data), catchError((e) => (isEmptyError(e) ? EMPTY : throwError(e))));\n}\nfunction getResolver(injectionToken, futureARS, futureRSS, injector) {\n    const closestInjector = getClosestRouteInjector(futureARS) ?? injector;\n    const resolver = getTokenOrFunctionIdentity(injectionToken, closestInjector);\n    const resolverValue = resolver.resolve\n        ? resolver.resolve(futureARS, futureRSS)\n        : runInInjectionContext(closestInjector, () => resolver(futureARS, futureRSS));\n    return wrapIntoObservable(resolverValue);\n}\n\n/**\n * Perform a side effect through a switchMap for every emission on the source Observable,\n * but return an Observable that is identical to the source. It's essentially the same as\n * the `tap` operator, but if the side effectful `next` function returns an ObservableInput,\n * it will wait before continuing with the original value.\n */\nfunction switchTap(next) {\n    return switchMap((v) => {\n        const nextResult = next(v);\n        if (nextResult) {\n            return from(nextResult).pipe(map(() => v));\n        }\n        return of(v);\n    });\n}\n\n/**\n * Provides a strategy for setting the page title after a router navigation.\n *\n * The built-in implementation traverses the router state snapshot and finds the deepest primary\n * outlet with `title` property. Given the `Routes` below, navigating to\n * `/base/child(popup:aux)` would result in the document title being set to \"child\".\n * ```ts\n * [\n *   {path: 'base', title: 'base', children: [\n *     {path: 'child', title: 'child'},\n *   ],\n *   {path: 'aux', outlet: 'popup', title: 'popupTitle'}\n * ]\n * ```\n *\n * This class can be used as a base class for custom title strategies. That is, you can create your\n * own class that extends the `TitleStrategy`. Note that in the above example, the `title`\n * from the named outlet is never used. However, a custom strategy might be implemented to\n * incorporate titles in named outlets.\n *\n * @publicApi\n * @see [Page title guide](guide/routing/define-routes#using-titlestrategy-for-page-titles)\n */\nclass TitleStrategy {\n    /**\n     * @returns The `title` of the deepest primary route.\n     */\n    buildTitle(snapshot) {\n        let pageTitle;\n        let route = snapshot.root;\n        while (route !== undefined) {\n            pageTitle = this.getResolvedTitleForRoute(route) ?? pageTitle;\n            route = route.children.find((child) => child.outlet === PRIMARY_OUTLET);\n        }\n        return pageTitle;\n    }\n    /**\n     * Given an `ActivatedRouteSnapshot`, returns the final value of the\n     * `Route.title` property, which can either be a static string or a resolved value.\n     */\n    getResolvedTitleForRoute(snapshot) {\n        return snapshot.data[RouteTitleKey];\n    }\n    static fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: TitleStrategy, deps: [], target: i0.FactoryTarget.Injectable });\n    static prov = i0.ngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: TitleStrategy, providedIn: 'root', useFactory: () => inject(DefaultTitleStrategy) });\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: TitleStrategy, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root', useFactory: () => inject(DefaultTitleStrategy) }]\n        }] });\n/**\n * The default `TitleStrategy` used by the router that updates the title using the `Title` service.\n */\nclass DefaultTitleStrategy extends TitleStrategy {\n    title;\n    constructor(title) {\n        super();\n        this.title = title;\n    }\n    /**\n     * Sets the title of the browser to the given value.\n     *\n     * @param title The `pageTitle` from the deepest primary route.\n     */\n    updateTitle(snapshot) {\n        const title = this.buildTitle(snapshot);\n        if (title !== undefined) {\n            this.title.setTitle(title);\n        }\n    }\n    static fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: DefaultTitleStrategy, deps: [{ token: i1.Title }], target: i0.FactoryTarget.Injectable });\n    static prov = i0.ngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: DefaultTitleStrategy, providedIn: 'root' });\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: DefaultTitleStrategy, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [{ type: i1.Title }] });\n\n/**\n * A DI token for the router service.\n *\n * @publicApi\n */\nconst ROUTER_CONFIGURATION = new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'router config' : '', {\n    providedIn: 'root',\n    factory: () => ({}),\n});\n\n/**\n * The DI token for a router configuration.\n *\n * `ROUTES` is a low level API for router configuration via dependency injection.\n *\n * We recommend that in almost all cases to use higher level APIs such as `RouterModule.forRoot()`,\n * `provideRouter`, or `Router.resetConfig()`.\n *\n * @publicApi\n */\nconst ROUTES = new InjectionToken(ngDevMode ? 'ROUTES' : '');\nclass RouterConfigLoader {\n    componentLoaders = new WeakMap();\n    childrenLoaders = new WeakMap();\n    onLoadStartListener;\n    onLoadEndListener;\n    compiler = inject(Compiler);\n    loadComponent(injector, route) {\n        if (this.componentLoaders.get(route)) {\n            return this.componentLoaders.get(route);\n        }\n        else if (route._loadedComponent) {\n            return of(route._loadedComponent);\n        }\n        if (this.onLoadStartListener) {\n            this.onLoadStartListener(route);\n        }\n        const loadRunner = wrapIntoObservable(runInInjectionContext(injector, () => route.loadComponent())).pipe(map(maybeUnwrapDefaultExport), switchMap(maybeResolveResources), tap((component) => {\n            if (this.onLoadEndListener) {\n                this.onLoadEndListener(route);\n            }\n            (typeof ngDevMode === 'undefined' || ngDevMode) &&\n                assertStandalone(route.path ?? '', component);\n            route._loadedComponent = component;\n        }), finalize(() => {\n            this.componentLoaders.delete(route);\n        }));\n        // Use custom ConnectableObservable as share in runners pipe increasing the bundle size too much\n        const loader = new ConnectableObservable(loadRunner, () => new Subject()).pipe(refCount());\n        this.componentLoaders.set(route, loader);\n        return loader;\n    }\n    loadChildren(parentInjector, route) {\n        if (this.childrenLoaders.get(route)) {\n            return this.childrenLoaders.get(route);\n        }\n        else if (route._loadedRoutes) {\n            return of({ routes: route._loadedRoutes, injector: route._loadedInjector });\n        }\n        if (this.onLoadStartListener) {\n            this.onLoadStartListener(route);\n        }\n        const moduleFactoryOrRoutes$ = loadChildren(route, this.compiler, parentInjector, this.onLoadEndListener);\n        const loadRunner = moduleFactoryOrRoutes$.pipe(finalize(() => {\n            this.childrenLoaders.delete(route);\n        }));\n        // Use custom ConnectableObservable as share in runners pipe increasing the bundle size too much\n        const loader = new ConnectableObservable(loadRunner, () => new Subject()).pipe(refCount());\n        this.childrenLoaders.set(route, loader);\n        return loader;\n    }\n    static fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: RouterConfigLoader, deps: [], target: i0.FactoryTarget.Injectable });\n    static prov = i0.ngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: RouterConfigLoader, providedIn: 'root' });\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: RouterConfigLoader, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }] });\n/**\n * Executes a `route.loadChildren` callback and converts the result to an array of child routes and\n * an injector if that callback returned a module.\n *\n * This function is used for the route discovery during prerendering\n * in @angular-devkit/build-angular. If there are any updates to the contract here, it will require\n * an update to the extractor.\n */\nfunction loadChildren(route, compiler, parentInjector, onLoadEndListener) {\n    return wrapIntoObservable(runInInjectionContext(parentInjector, () => route.loadChildren())).pipe(map(maybeUnwrapDefaultExport), switchMap(maybeResolveResources), mergeMap((t) => {\n        if (t instanceof NgModuleFactory || Array.isArray(t)) {\n            return of(t);\n        }\n        else {\n            return from(compiler.compileModuleAsync(t));\n        }\n    }), map((factoryOrRoutes) => {\n        if (onLoadEndListener) {\n            onLoadEndListener(route);\n        }\n        // This injector comes from the `NgModuleRef` when lazy loading an `NgModule`. There is\n        // no injector associated with lazy loading a `Route` array.\n        let injector;\n        let rawRoutes;\n        let requireStandaloneComponents = false;\n        if (Array.isArray(factoryOrRoutes)) {\n            rawRoutes = factoryOrRoutes;\n            requireStandaloneComponents = true;\n        }\n        else {\n            injector = factoryOrRoutes.create(parentInjector).injector;\n            // When loading a module that doesn't provide `RouterModule.forChild()` preloader\n            // will get stuck in an infinite loop. The child module's Injector will look to\n            // its parent `Injector` when it doesn't find any ROUTES so it will return routes\n            // for it's parent module instead.\n            rawRoutes = injector.get(ROUTES, [], { optional: true, self: true }).flat();\n        }\n        const routes = rawRoutes.map(standardizeConfig);\n        (typeof ngDevMode === 'undefined' || ngDevMode) &&\n            validateConfig(routes, route.path, requireStandaloneComponents);\n        return { routes, injector };\n    }));\n}\nfunction isWrappedDefaultExport(value) {\n    // We use `in` here with a string key `'default'`, because we expect `DefaultExport` objects to be\n    // dynamically imported ES modules with a spec-mandated `default` key. Thus we don't expect that\n    // `default` will be a renamed property.\n    return value && typeof value === 'object' && 'default' in value;\n}\nfunction maybeUnwrapDefaultExport(input) {\n    // As per `isWrappedDefaultExport`, the `default` key here is generated by the browser and not\n    // subject to property renaming, so we reference it with bracket access.\n    return isWrappedDefaultExport(input) ? input['default'] : input;\n}\nfunction maybeResolveResources(value) {\n    // In JIT mode we usually resolve the resources of components on bootstrap, however\n    // that won't have happened for lazy-loaded components. Attempt to load any pending\n    // resources again here.\n    if ((typeof ngJitMode === 'undefined' || ngJitMode) && typeof fetch === 'function') {\n        return _resolveComponentResources(fetch)\n            .catch((error) => {\n            console.error(error);\n            return Promise.resolve();\n        })\n            .then(() => value);\n    }\n    return of(value);\n}\n\n/**\n * @description\n *\n * Provides a way to migrate AngularJS applications to Angular.\n *\n * @publicApi\n */\nclass UrlHandlingStrategy {\n    static fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: UrlHandlingStrategy, deps: [], target: i0.FactoryTarget.Injectable });\n    static prov = i0.ngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: UrlHandlingStrategy, providedIn: 'root', useFactory: () => inject(DefaultUrlHandlingStrategy) });\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: UrlHandlingStrategy, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root', useFactory: () => inject(DefaultUrlHandlingStrategy) }]\n        }] });\n/**\n * @publicApi\n */\nclass DefaultUrlHandlingStrategy {\n    shouldProcessUrl(url) {\n        return true;\n    }\n    extract(url) {\n        return url;\n    }\n    merge(newUrlPart, wholeUrl) {\n        return newUrlPart;\n    }\n    static fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: DefaultUrlHandlingStrategy, deps: [], target: i0.FactoryTarget.Injectable });\n    static prov = i0.ngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: DefaultUrlHandlingStrategy, providedIn: 'root' });\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: DefaultUrlHandlingStrategy, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }] });\n\nconst CREATE_VIEW_TRANSITION = new InjectionToken(ngDevMode ? 'view transition helper' : '');\nconst VIEW_TRANSITION_OPTIONS = new InjectionToken(ngDevMode ? 'view transition options' : '');\n/**\n * A helper function for using browser view transitions. This function skips the call to\n * `startViewTransition` if the browser does not support it.\n *\n * @returns A Promise that resolves when the view transition callback begins.\n */\nfunction createViewTransition(injector, from, to) {\n    const transitionOptions = injector.get(VIEW_TRANSITION_OPTIONS);\n    const document = injector.get(DOCUMENT);\n    if (!document.startViewTransition || transitionOptions.skipNextTransition) {\n        transitionOptions.skipNextTransition = false;\n        // The timing of `startViewTransition` is closer to a macrotask. It won't be called\n        // until the current event loop exits so we use a promise resolved in a timeout instead\n        // of Promise.resolve().\n        return new Promise((resolve) => setTimeout(resolve));\n    }\n    let resolveViewTransitionStarted;\n    const viewTransitionStarted = new Promise((resolve) => {\n        resolveViewTransitionStarted = resolve;\n    });\n    const transition = document.startViewTransition(() => {\n        resolveViewTransitionStarted();\n        // We don't actually update dom within the transition callback. The resolving of the above\n        // promise unblocks the Router navigation, which synchronously activates and deactivates\n        // routes (the DOM update). This view transition waits for the next change detection to\n        // complete (below), which includes the update phase of the routed components.\n        return createRenderPromise(injector);\n    });\n    transition.ready.catch((error) => {\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            console.error(error);\n        }\n    });\n    const { onViewTransitionCreated } = transitionOptions;\n    if (onViewTransitionCreated) {\n        runInInjectionContext(injector, () => onViewTransitionCreated({ transition, from, to }));\n    }\n    return viewTransitionStarted;\n}\n/**\n * Creates a promise that resolves after next render.\n */\nfunction createRenderPromise(injector) {\n    return new Promise((resolve) => {\n        // Wait for the microtask queue to empty after the next render happens (by waiting a macrotask).\n        // This ensures any follow-up renders in the microtask queue are completed before the\n        // view transition starts animating.\n        afterNextRender({ read: () => setTimeout(resolve) }, { injector });\n    });\n}\n\nconst NAVIGATION_ERROR_HANDLER = new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'navigation error handler' : '');\nclass NavigationTransitions {\n    // Some G3 targets expect the navigation object to be mutated (and not getting a new reference on changes).\n    currentNavigation = signal(null, ...(ngDevMode ? [{ debugName: \"currentNavigation\", equal: () => false }] : [{ equal: () => false }]));\n    currentTransition = null;\n    lastSuccessfulNavigation = null;\n    /**\n     * These events are used to communicate back to the Router about the state of the transition. The\n     * Router wants to respond to these events in various ways. Because the `NavigationTransition`\n     * class is not public, this event subject is not publicly exposed.\n     */\n    events = new Subject();\n    /**\n     * Used to abort the current transition with an error.\n     */\n    transitionAbortWithErrorSubject = new Subject();\n    configLoader = inject(RouterConfigLoader);\n    environmentInjector = inject(EnvironmentInjector);\n    destroyRef = inject(DestroyRef);\n    urlSerializer = inject(UrlSerializer);\n    rootContexts = inject(ChildrenOutletContexts);\n    location = inject(Location);\n    inputBindingEnabled = inject(INPUT_BINDER, { optional: true }) !== null;\n    titleStrategy = inject(TitleStrategy);\n    options = inject(ROUTER_CONFIGURATION, { optional: true }) || {};\n    paramsInheritanceStrategy = this.options.paramsInheritanceStrategy || 'emptyOnly';\n    urlHandlingStrategy = inject(UrlHandlingStrategy);\n    createViewTransition = inject(CREATE_VIEW_TRANSITION, { optional: true });\n    navigationErrorHandler = inject(NAVIGATION_ERROR_HANDLER, { optional: true });\n    navigationId = 0;\n    get hasRequestedNavigation() {\n        return this.navigationId !== 0;\n    }\n    transitions;\n    /**\n     * Hook that enables you to pause navigation after the preactivation phase.\n     * Used by `RouterModule`.\n     *\n     * @internal\n     */\n    afterPreactivation = () => of(void 0);\n    /** @internal */\n    rootComponentType = null;\n    destroyed = false;\n    constructor() {\n        const onLoadStart = (r) => this.events.next(new RouteConfigLoadStart(r));\n        const onLoadEnd = (r) => this.events.next(new RouteConfigLoadEnd(r));\n        this.configLoader.onLoadEndListener = onLoadEnd;\n        this.configLoader.onLoadStartListener = onLoadStart;\n        this.destroyRef.onDestroy(() => {\n            this.destroyed = true;\n        });\n    }\n    complete() {\n        this.transitions?.complete();\n    }\n    handleNavigationRequest(request) {\n        const id = ++this.navigationId;\n        // Navigation can happen as a side effect of template execution, as such we need to untrack signal updates\n        // (Writing to signals is not allowed while Angular renders the template)\n        // TODO: We might want to reconsider allowing navigation as side effect of template execution.\n        untracked(() => {\n            this.transitions?.next({\n                ...request,\n                extractedUrl: this.urlHandlingStrategy.extract(request.rawUrl),\n                targetSnapshot: null,\n                targetRouterState: null,\n                guards: { canActivateChecks: [], canDeactivateChecks: [] },\n                guardsResult: null,\n                abortController: new AbortController(),\n                id,\n            });\n        });\n    }\n    setupNavigations(router) {\n        this.transitions = new BehaviorSubject(null);\n        return this.transitions.pipe(filter((t) => t !== null), \n        // Using switchMap so we cancel executing navigations when a new one comes in\n        switchMap((overallTransitionState) => {\n            let completedOrAborted = false;\n            return of(overallTransitionState).pipe(switchMap((t) => {\n                // It is possible that `switchMap` fails to cancel previous navigations if a new one happens synchronously while the operator\n                // is processing the `next` notification of that previous navigation. This can happen when a new navigation (say 2) cancels a\n                // previous one (1) and yet another navigation (3) happens synchronously in response to the `NavigationCancel` event for (1).\n                // https://github.com/ReactiveX/rxjs/issues/7455\n                if (this.navigationId > overallTransitionState.id) {\n                    const cancellationReason = typeof ngDevMode === 'undefined' || ngDevMode\n                        ? `Navigation ID ${overallTransitionState.id} is not equal to the current navigation id ${this.navigationId}`\n                        : '';\n                    this.cancelNavigationTransition(overallTransitionState, cancellationReason, NavigationCancellationCode.SupersededByNewNavigation);\n                    return EMPTY;\n                }\n                this.currentTransition = overallTransitionState;\n                // Store the Navigation object\n                this.currentNavigation.set({\n                    id: t.id,\n                    initialUrl: t.rawUrl,\n                    extractedUrl: t.extractedUrl,\n                    targetBrowserUrl: typeof t.extras.browserUrl === 'string'\n                        ? this.urlSerializer.parse(t.extras.browserUrl)\n                        : t.extras.browserUrl,\n                    trigger: t.source,\n                    extras: t.extras,\n                    previousNavigation: !this.lastSuccessfulNavigation\n                        ? null\n                        : {\n                            ...this.lastSuccessfulNavigation,\n                            previousNavigation: null,\n                        },\n                    abort: () => t.abortController.abort(),\n                });\n                const urlTransition = !router.navigated || this.isUpdatingInternalState() || this.isUpdatedBrowserUrl();\n                const onSameUrlNavigation = t.extras.onSameUrlNavigation ?? router.onSameUrlNavigation;\n                if (!urlTransition && onSameUrlNavigation !== 'reload') {\n                    const reason = typeof ngDevMode === 'undefined' || ngDevMode\n                        ? `Navigation to ${t.rawUrl} was ignored because it is the same as the current Router URL.`\n                        : '';\n                    this.events.next(new NavigationSkipped(t.id, this.urlSerializer.serialize(t.rawUrl), reason, NavigationSkippedCode.IgnoredSameUrlNavigation));\n                    t.resolve(false);\n                    return EMPTY;\n                }\n                if (this.urlHandlingStrategy.shouldProcessUrl(t.rawUrl)) {\n                    return of(t).pipe(\n                    // Fire NavigationStart event\n                    switchMap((t) => {\n                        this.events.next(new NavigationStart(t.id, this.urlSerializer.serialize(t.extractedUrl), t.source, t.restoredState));\n                        if (t.id !== this.navigationId) {\n                            return EMPTY;\n                        }\n                        // This delay is required to match old behavior that forced\n                        // navigation to always be async\n                        return Promise.resolve(t);\n                    }), \n                    // Recognize\n                    recognize(this.environmentInjector, this.configLoader, this.rootComponentType, router.config, this.urlSerializer, this.paramsInheritanceStrategy), \n                    // Update URL if in `eager` update mode\n                    tap((t) => {\n                        overallTransitionState.targetSnapshot = t.targetSnapshot;\n                        overallTransitionState.urlAfterRedirects = t.urlAfterRedirects;\n                        this.currentNavigation.update((nav) => {\n                            nav.finalUrl = t.urlAfterRedirects;\n                            return nav;\n                        });\n                        // Fire RoutesRecognized\n                        const routesRecognized = new RoutesRecognized(t.id, this.urlSerializer.serialize(t.extractedUrl), this.urlSerializer.serialize(t.urlAfterRedirects), t.targetSnapshot);\n                        this.events.next(routesRecognized);\n                    }));\n                }\n                else if (urlTransition &&\n                    this.urlHandlingStrategy.shouldProcessUrl(t.currentRawUrl)) {\n                    /* When the current URL shouldn't be processed, but the previous one\n                     * was, we handle this \"error condition\" by navigating to the\n                     * previously successful URL, but leaving the URL intact.*/\n                    const { id, extractedUrl, source, restoredState, extras } = t;\n                    const navStart = new NavigationStart(id, this.urlSerializer.serialize(extractedUrl), source, restoredState);\n                    this.events.next(navStart);\n                    const targetSnapshot = createEmptyState(this.rootComponentType).snapshot;\n                    this.currentTransition = overallTransitionState = {\n                        ...t,\n                        targetSnapshot,\n                        urlAfterRedirects: extractedUrl,\n                        extras: { ...extras, skipLocationChange: false, replaceUrl: false },\n                    };\n                    this.currentNavigation.update((nav) => {\n                        nav.finalUrl = extractedUrl;\n                        return nav;\n                    });\n                    return of(overallTransitionState);\n                }\n                else {\n                    /* When neither the current or previous URL can be processed, do\n                     * nothing other than update router's internal reference to the\n                     * current \"settled\" URL. This way the next navigation will be coming\n                     * from the current URL in the browser.\n                     */\n                    const reason = typeof ngDevMode === 'undefined' || ngDevMode\n                        ? `Navigation was ignored because the UrlHandlingStrategy` +\n                            ` indicated neither the current URL ${t.currentRawUrl} nor target URL ${t.rawUrl} should be processed.`\n                        : '';\n                    this.events.next(new NavigationSkipped(t.id, this.urlSerializer.serialize(t.extractedUrl), reason, NavigationSkippedCode.IgnoredByUrlHandlingStrategy));\n                    t.resolve(false);\n                    return EMPTY;\n                }\n            }), \n            // --- GUARDS ---\n            tap((t) => {\n                const guardsStart = new GuardsCheckStart(t.id, this.urlSerializer.serialize(t.extractedUrl), this.urlSerializer.serialize(t.urlAfterRedirects), t.targetSnapshot);\n                this.events.next(guardsStart);\n            }), map((t) => {\n                this.currentTransition = overallTransitionState = {\n                    ...t,\n                    guards: getAllRouteGuards(t.targetSnapshot, t.currentSnapshot, this.rootContexts),\n                };\n                return overallTransitionState;\n            }), checkGuards(this.environmentInjector, (evt) => this.events.next(evt)), tap((t) => {\n                overallTransitionState.guardsResult = t.guardsResult;\n                if (t.guardsResult && typeof t.guardsResult !== 'boolean') {\n                    throw redirectingNavigationError(this.urlSerializer, t.guardsResult);\n                }\n                const guardsEnd = new GuardsCheckEnd(t.id, this.urlSerializer.serialize(t.extractedUrl), this.urlSerializer.serialize(t.urlAfterRedirects), t.targetSnapshot, !!t.guardsResult);\n                this.events.next(guardsEnd);\n            }), filter((t) => {\n                if (!t.guardsResult) {\n                    this.cancelNavigationTransition(t, '', NavigationCancellationCode.GuardRejected);\n                    return false;\n                }\n                return true;\n            }), \n            // --- RESOLVE ---\n            switchTap((t) => {\n                if (t.guards.canActivateChecks.length === 0) {\n                    return undefined;\n                }\n                return of(t).pipe(tap((t) => {\n                    const resolveStart = new ResolveStart(t.id, this.urlSerializer.serialize(t.extractedUrl), this.urlSerializer.serialize(t.urlAfterRedirects), t.targetSnapshot);\n                    this.events.next(resolveStart);\n                }), switchMap((t) => {\n                    let dataResolved = false;\n                    return of(t).pipe(resolveData(this.paramsInheritanceStrategy, this.environmentInjector), tap({\n                        next: () => (dataResolved = true),\n                        complete: () => {\n                            if (!dataResolved) {\n                                this.cancelNavigationTransition(t, typeof ngDevMode === 'undefined' || ngDevMode\n                                    ? `At least one route resolver didn't emit any value.`\n                                    : '', NavigationCancellationCode.NoDataFromResolver);\n                            }\n                        },\n                    }));\n                }), tap((t) => {\n                    const resolveEnd = new ResolveEnd(t.id, this.urlSerializer.serialize(t.extractedUrl), this.urlSerializer.serialize(t.urlAfterRedirects), t.targetSnapshot);\n                    this.events.next(resolveEnd);\n                }));\n            }), \n            // --- LOAD COMPONENTS ---\n            switchTap((t) => {\n                const loadComponents = (route) => {\n                    const loaders = [];\n                    if (route.routeConfig?.loadComponent) {\n                        const injector = getClosestRouteInjector(route) ?? this.environmentInjector;\n                        loaders.push(this.configLoader.loadComponent(injector, route.routeConfig).pipe(tap((loadedComponent) => {\n                            route.component = loadedComponent;\n                        }), map(() => void 0)));\n                    }\n                    for (const child of route.children) {\n                        loaders.push(...loadComponents(child));\n                    }\n                    return loaders;\n                };\n                return combineLatest(loadComponents(t.targetSnapshot.root)).pipe(defaultIfEmpty(null), take(1));\n            }), switchTap(() => this.afterPreactivation()), switchMap(() => {\n                const { currentSnapshot, targetSnapshot } = overallTransitionState;\n                const viewTransitionStarted = this.createViewTransition?.(this.environmentInjector, currentSnapshot.root, targetSnapshot.root);\n                // If view transitions are enabled, block the navigation until the view\n                // transition callback starts. Otherwise, continue immediately.\n                return viewTransitionStarted\n                    ? from(viewTransitionStarted).pipe(map(() => overallTransitionState))\n                    : of(overallTransitionState);\n            }), map((t) => {\n                const targetRouterState = createRouterState(router.routeReuseStrategy, t.targetSnapshot, t.currentRouterState);\n                this.currentTransition = overallTransitionState = { ...t, targetRouterState };\n                this.currentNavigation.update((nav) => {\n                    nav.targetRouterState = targetRouterState;\n                    return nav;\n                });\n                return overallTransitionState;\n            }), tap(() => {\n                this.events.next(new BeforeActivateRoutes());\n            }), activateRoutes(this.rootContexts, router.routeReuseStrategy, (evt) => this.events.next(evt), this.inputBindingEnabled), \n            // Ensure that if some observable used to drive the transition doesn't\n            // complete, the navigation still finalizes This should never happen, but\n            // this is done as a safety measure to avoid surfacing this error (#49567).\n            take(1), takeUntil(new Observable((subscriber) => {\n                const abortSignal = overallTransitionState.abortController.signal;\n                const handler = () => subscriber.next();\n                abortSignal.addEventListener('abort', handler);\n                return () => abortSignal.removeEventListener('abort', handler);\n            }).pipe(\n            // Ignore aborts if we are already completed, canceled, or are in the activation stage (we have targetRouterState)\n            filter(() => !completedOrAborted && !overallTransitionState.targetRouterState), tap(() => {\n                this.cancelNavigationTransition(overallTransitionState, overallTransitionState.abortController.signal.reason + '', NavigationCancellationCode.Aborted);\n            }))), tap({\n                next: (t) => {\n                    completedOrAborted = true;\n                    this.lastSuccessfulNavigation = untracked(this.currentNavigation);\n                    this.events.next(new NavigationEnd(t.id, this.urlSerializer.serialize(t.extractedUrl), this.urlSerializer.serialize(t.urlAfterRedirects)));\n                    this.titleStrategy?.updateTitle(t.targetRouterState.snapshot);\n                    t.resolve(true);\n                },\n                complete: () => {\n                    completedOrAborted = true;\n                },\n            }), \n            // There used to be a lot more logic happening directly within the\n            // transition Observable. Some of this logic has been refactored out to\n            // other places but there may still be errors that happen there. This gives\n            // us a way to cancel the transition from the outside. This may also be\n            // required in the future to support something like the abort signal of the\n            // Navigation API where the navigation gets aborted from outside the\n            // transition.\n            takeUntil(this.transitionAbortWithErrorSubject.pipe(tap((err) => {\n                throw err;\n            }))), finalize(() => {\n                /* When the navigation stream finishes either through error or success,\n                 * we set the `completed` or `errored` flag. However, there are some\n                 * situations where we could get here without either of those being set.\n                 * For instance, a redirect during NavigationStart. Therefore, this is a\n                 * catch-all to make sure the NavigationCancel event is fired when a\n                 * navigation gets cancelled but not caught by other means. */\n                if (!completedOrAborted) {\n                    const cancelationReason = typeof ngDevMode === 'undefined' || ngDevMode\n                        ? `Navigation ID ${overallTransitionState.id} is not equal to the current navigation id ${this.navigationId}`\n                        : '';\n                    this.cancelNavigationTransition(overallTransitionState, cancelationReason, NavigationCancellationCode.SupersededByNewNavigation);\n                }\n                // Only clear current navigation if it is still set to the one that\n                // finalized.\n                if (this.currentTransition?.id === overallTransitionState.id) {\n                    this.currentNavigation.set(null);\n                    this.currentTransition = null;\n                }\n            }), catchError((e) => {\n                // If the application is already destroyed, the catch block should not\n                // execute anything in practice because other resources have already\n                // been released and destroyed.\n                if (this.destroyed) {\n                    overallTransitionState.resolve(false);\n                    return EMPTY;\n                }\n                completedOrAborted = true;\n                /* This error type is issued during Redirect, and is handled as a\n                 * cancellation rather than an error. */\n                if (isNavigationCancelingError(e)) {\n                    this.events.next(new NavigationCancel(overallTransitionState.id, this.urlSerializer.serialize(overallTransitionState.extractedUrl), e.message, e.cancellationCode));\n                    // When redirecting, we need to delay resolving the navigation\n                    // promise and push it to the redirect navigation\n                    if (!isRedirectingNavigationCancelingError(e)) {\n                        overallTransitionState.resolve(false);\n                    }\n                    else {\n                        this.events.next(new RedirectRequest(e.url, e.navigationBehaviorOptions));\n                    }\n                    /* All other errors should reset to the router's internal URL reference\n                     * to the pre-error state. */\n                }\n                else {\n                    const navigationError = new NavigationError(overallTransitionState.id, this.urlSerializer.serialize(overallTransitionState.extractedUrl), e, overallTransitionState.targetSnapshot ?? undefined);\n                    try {\n                        const navigationErrorHandlerResult = runInInjectionContext(this.environmentInjector, () => this.navigationErrorHandler?.(navigationError));\n                        if (navigationErrorHandlerResult instanceof RedirectCommand) {\n                            const { message, cancellationCode } = redirectingNavigationError(this.urlSerializer, navigationErrorHandlerResult);\n                            this.events.next(new NavigationCancel(overallTransitionState.id, this.urlSerializer.serialize(overallTransitionState.extractedUrl), message, cancellationCode));\n                            this.events.next(new RedirectRequest(navigationErrorHandlerResult.redirectTo, navigationErrorHandlerResult.navigationBehaviorOptions));\n                        }\n                        else {\n                            this.events.next(navigationError);\n                            throw e;\n                        }\n                    }\n                    catch (ee) {\n                        // TODO(atscott): consider flipping the default behavior of\n                        // resolveNavigationPromiseOnError to be `resolve(false)` when\n                        // undefined. This is the most sane thing to do given that\n                        // applications very rarely handle the promise rejection and, as a\n                        // result, would get \"unhandled promise rejection\" console logs.\n                        // The vast majority of applications would not be affected by this\n                        // change so omitting a migration seems reasonable. Instead,\n                        // applications that rely on rejection can specifically opt-in to the\n                        // old behavior.\n                        if (this.options.resolveNavigationPromiseOnError) {\n                            overallTransitionState.resolve(false);\n                        }\n                        else {\n                            overallTransitionState.reject(ee);\n                        }\n                    }\n                }\n                return EMPTY;\n            }));\n            // casting because `pipe` returns observable({}) when called with 8+ arguments\n        }));\n    }\n    cancelNavigationTransition(t, reason, code) {\n        const navCancel = new NavigationCancel(t.id, this.urlSerializer.serialize(t.extractedUrl), reason, code);\n        this.events.next(navCancel);\n        t.resolve(false);\n    }\n    /**\n     * @returns Whether we're navigating to somewhere that is not what the Router is\n     * currently set to.\n     */\n    isUpdatingInternalState() {\n        // TODO(atscott): The serializer should likely be used instead of\n        // `UrlTree.toString()`. Custom serializers are often written to handle\n        // things better than the default one (objects, for example will be\n        // [Object object] with the custom serializer and be \"the same\" when they\n        // aren't).\n        // (Same for isUpdatedBrowserUrl)\n        return (this.currentTransition?.extractedUrl.toString() !==\n            this.currentTransition?.currentUrlTree.toString());\n    }\n    /**\n     * @returns Whether we're updating the browser URL to something new (navigation is going\n     * to somewhere not displayed in the URL bar and we will update the URL\n     * bar if navigation succeeds).\n     */\n    isUpdatedBrowserUrl() {\n        // The extracted URL is the part of the URL that this application cares about. `extract` may\n        // return only part of the browser URL and that part may have not changed even if some other\n        // portion of the URL did.\n        const currentBrowserUrl = this.urlHandlingStrategy.extract(this.urlSerializer.parse(this.location.path(true)));\n        const currentNavigation = untracked(this.currentNavigation);\n        const targetBrowserUrl = currentNavigation?.targetBrowserUrl ?? currentNavigation?.extractedUrl;\n        return (currentBrowserUrl.toString() !== targetBrowserUrl?.toString() &&\n            !currentNavigation?.extras.skipLocationChange);\n    }\n    static fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: NavigationTransitions, deps: [], target: i0.FactoryTarget.Injectable });\n    static prov = i0.ngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: NavigationTransitions, providedIn: 'root' });\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: NavigationTransitions, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [] });\nfunction isBrowserTriggeredNavigation(source) {\n    return source !== IMPERATIVE_NAVIGATION;\n}\n\n/**\n * @description\n *\n * Provides a way to customize when activated routes get reused.\n *\n * @publicApi\n */\nclass RouteReuseStrategy {\n    static fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: RouteReuseStrategy, deps: [], target: i0.FactoryTarget.Injectable });\n    static prov = i0.ngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: RouteReuseStrategy, providedIn: 'root', useFactory: () => inject(DefaultRouteReuseStrategy) });\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: RouteReuseStrategy, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root', useFactory: () => inject(DefaultRouteReuseStrategy) }]\n        }] });\n/**\n * @description\n *\n * This base route reuse strategy only reuses routes when the matched router configs are\n * identical. This prevents components from being destroyed and recreated\n * when just the route parameters, query parameters or fragment change\n * (that is, the existing component is _reused_).\n *\n * This strategy does not store any routes for later reuse.\n *\n * Angular uses this strategy by default.\n *\n *\n * It can be used as a base class for custom route reuse strategies, i.e. you can create your own\n * class that extends the `BaseRouteReuseStrategy` one.\n * @publicApi\n */\nclass BaseRouteReuseStrategy {\n    /**\n     * Whether the given route should detach for later reuse.\n     * Always returns false for `BaseRouteReuseStrategy`.\n     * */\n    shouldDetach(route) {\n        return false;\n    }\n    /**\n     * A no-op; the route is never stored since this strategy never detaches routes for later re-use.\n     */\n    store(route, detachedTree) { }\n    /** Returns `false`, meaning the route (and its subtree) is never reattached */\n    shouldAttach(route) {\n        return false;\n    }\n    /** Returns `null` because this strategy does not store routes for later re-use. */\n    retrieve(route) {\n        return null;\n    }\n    /**\n     * Determines if a route should be reused.\n     * This strategy returns `true` when the future route config and current route config are\n     * identical.\n     */\n    shouldReuseRoute(future, curr) {\n        return future.routeConfig === curr.routeConfig;\n    }\n}\nclass DefaultRouteReuseStrategy extends BaseRouteReuseStrategy {\n    static fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: DefaultRouteReuseStrategy, deps: null, target: i0.FactoryTarget.Injectable });\n    static prov = i0.ngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: DefaultRouteReuseStrategy, providedIn: 'root' });\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: DefaultRouteReuseStrategy, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }] });\n\nclass StateManager {\n    urlSerializer = inject(UrlSerializer);\n    options = inject(ROUTER_CONFIGURATION, { optional: true }) || {};\n    canceledNavigationResolution = this.options.canceledNavigationResolution || 'replace';\n    location = inject(Location);\n    urlHandlingStrategy = inject(UrlHandlingStrategy);\n    urlUpdateStrategy = this.options.urlUpdateStrategy || 'deferred';\n    currentUrlTree = new UrlTree();\n    /**\n     * Returns the currently activated `UrlTree`.\n     *\n     * This `UrlTree` shows only URLs that the `Router` is configured to handle (through\n     * `UrlHandlingStrategy`).\n     *\n     * The value is set after finding the route config tree to activate but before activating the\n     * route.\n     */\n    getCurrentUrlTree() {\n        return this.currentUrlTree;\n    }\n    rawUrlTree = this.currentUrlTree;\n    /**\n     * Returns a `UrlTree` that is represents what the browser is actually showing.\n     *\n     * In the life of a navigation transition:\n     * 1. When a navigation begins, the raw `UrlTree` is updated to the full URL that's being\n     * navigated to.\n     * 2. During a navigation, redirects are applied, which might only apply to _part_ of the URL (due\n     * to `UrlHandlingStrategy`).\n     * 3. Just before activation, the raw `UrlTree` is updated to include the redirects on top of the\n     * original raw URL.\n     *\n     * Note that this is _only_ here to support `UrlHandlingStrategy.extract` and\n     * `UrlHandlingStrategy.shouldProcessUrl`. Without those APIs, the current `UrlTree` would not\n     * deviated from the raw `UrlTree`.\n     *\n     * For `extract`, a raw `UrlTree` is needed because `extract` may only return part\n     * of the navigation URL. Thus, the current `UrlTree` may only represent _part_ of the browser\n     * URL. When a navigation gets cancelled and the router needs to reset the URL or a new navigation\n     * occurs, it needs to know the _whole_ browser URL, not just the part handled by\n     * `UrlHandlingStrategy`.\n     * For `shouldProcessUrl`, when the return is `false`, the router ignores the navigation but\n     * still updates the raw `UrlTree` with the assumption that the navigation was caused by the\n     * location change listener due to a URL update by the AngularJS router. In this case, the router\n     * still need to know what the browser's URL is for future navigations.\n     */\n    getRawUrlTree() {\n        return this.rawUrlTree;\n    }\n    createBrowserPath({ finalUrl, initialUrl, targetBrowserUrl }) {\n        const rawUrl = finalUrl !== undefined ? this.urlHandlingStrategy.merge(finalUrl, initialUrl) : initialUrl;\n        const url = targetBrowserUrl ?? rawUrl;\n        const path = url instanceof UrlTree ? this.urlSerializer.serialize(url) : url;\n        return path;\n    }\n    commitTransition({ targetRouterState, finalUrl, initialUrl }) {\n        // If we are committing the transition after having a final URL and target state, we're updating\n        // all pieces of the state. Otherwise, we likely skipped the transition (due to URL handling strategy)\n        // and only want to update the rawUrlTree, which represents the browser URL (and doesn't necessarily match router state).\n        if (finalUrl && targetRouterState) {\n            this.currentUrlTree = finalUrl;\n            this.rawUrlTree = this.urlHandlingStrategy.merge(finalUrl, initialUrl);\n            this.routerState = targetRouterState;\n        }\n        else {\n            this.rawUrlTree = initialUrl;\n        }\n    }\n    routerState = createEmptyState(null);\n    /** Returns the current RouterState. */\n    getRouterState() {\n        return this.routerState;\n    }\n    stateMemento = this.createStateMemento();\n    updateStateMemento() {\n        this.stateMemento = this.createStateMemento();\n    }\n    createStateMemento() {\n        return {\n            rawUrlTree: this.rawUrlTree,\n            currentUrlTree: this.currentUrlTree,\n            routerState: this.routerState,\n        };\n    }\n    resetInternalState({ finalUrl }) {\n        this.routerState = this.stateMemento.routerState;\n        this.currentUrlTree = this.stateMemento.currentUrlTree;\n        // Note here that we use the urlHandlingStrategy to get the reset `rawUrlTree` because it may be\n        // configured to handle only part of the navigation URL. This means we would only want to reset\n        // the part of the navigation handled by the Angular router rather than the whole URL. In\n        // addition, the URLHandlingStrategy may be configured to specifically preserve parts of the URL\n        // when merging, such as the query params so they are not lost on a refresh.\n        this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, finalUrl ?? this.rawUrlTree);\n    }\n    static fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: StateManager, deps: [], target: i0.FactoryTarget.Injectable });\n    static prov = i0.ngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: StateManager, providedIn: 'root', useFactory: () => inject(HistoryStateManager) });\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: StateManager, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root', useFactory: () => inject(HistoryStateManager) }]\n        }] });\nclass HistoryStateManager extends StateManager {\n    /**\n     * The id of the currently active page in the router.\n     * Updated to the transition's target id on a successful navigation.\n     *\n     * This is used to track what page the router last activated. When an attempted navigation fails,\n     * the router can then use this to compute how to restore the state back to the previously active\n     * page.\n     */\n    currentPageId = 0;\n    lastSuccessfulId = -1;\n    restoredState() {\n        return this.location.getState();\n    }\n    /**\n     * The routerPageId of whatever page is currently active in the browser history. This is\n     * important for computing the target page id for new navigations because we need to ensure each\n     * page id in the browser history is 1 more than the previous entry.\n     */\n    get browserPageId() {\n        if (this.canceledNavigationResolution !== 'computed') {\n            return this.currentPageId;\n        }\n        return this.restoredState()?.routerPageId ?? this.currentPageId;\n    }\n    registerNonRouterCurrentEntryChangeListener(listener) {\n        return this.location.subscribe((event) => {\n            if (event['type'] === 'popstate') {\n                // The `setTimeout` was added in #12160 and is likely to support Angular/AngularJS\n                // hybrid apps.\n                setTimeout(() => {\n                    listener(event['url'], event.state, 'popstate');\n                });\n            }\n        });\n    }\n    handleRouterEvent(e, currentTransition) {\n        if (e instanceof NavigationStart) {\n            this.updateStateMemento();\n        }\n        else if (e instanceof NavigationSkipped) {\n            this.commitTransition(currentTransition);\n        }\n        else if (e instanceof RoutesRecognized) {\n            if (this.urlUpdateStrategy === 'eager') {\n                if (!currentTransition.extras.skipLocationChange) {\n                    this.setBrowserUrl(this.createBrowserPath(currentTransition), currentTransition);\n                }\n            }\n        }\n        else if (e instanceof BeforeActivateRoutes) {\n            this.commitTransition(currentTransition);\n            if (this.urlUpdateStrategy === 'deferred' && !currentTransition.extras.skipLocationChange) {\n                this.setBrowserUrl(this.createBrowserPath(currentTransition), currentTransition);\n            }\n        }\n        else if (e instanceof NavigationCancel &&\n            e.code !== NavigationCancellationCode.SupersededByNewNavigation &&\n            e.code !== NavigationCancellationCode.Redirect) {\n            this.restoreHistory(currentTransition);\n        }\n        else if (e instanceof NavigationError) {\n            this.restoreHistory(currentTransition, true);\n        }\n        else if (e instanceof NavigationEnd) {\n            this.lastSuccessfulId = e.id;\n            this.currentPageId = this.browserPageId;\n        }\n    }\n    setBrowserUrl(path, { extras, id }) {\n        const { replaceUrl, state } = extras;\n        if (this.location.isCurrentPathEqualTo(path) || !!replaceUrl) {\n            // replacements do not update the target page\n            const currentBrowserPageId = this.browserPageId;\n            const newState = {\n                ...state,\n                ...this.generateNgRouterState(id, currentBrowserPageId),\n            };\n            this.location.replaceState(path, '', newState);\n        }\n        else {\n            const newState = {\n                ...state,\n                ...this.generateNgRouterState(id, this.browserPageId + 1),\n            };\n            this.location.go(path, '', newState);\n        }\n    }\n    /**\n     * Performs the necessary rollback action to restore the browser URL to the\n     * state before the transition.\n     */\n    restoreHistory(navigation, restoringFromCaughtError = false) {\n        if (this.canceledNavigationResolution === 'computed') {\n            const currentBrowserPageId = this.browserPageId;\n            const targetPagePosition = this.currentPageId - currentBrowserPageId;\n            if (targetPagePosition !== 0) {\n                this.location.historyGo(targetPagePosition);\n            }\n            else if (this.getCurrentUrlTree() === navigation.finalUrl && targetPagePosition === 0) {\n                // We got to the activation stage (where currentUrlTree is set to the navigation's\n                // finalUrl), but we weren't moving anywhere in history (skipLocationChange or replaceUrl).\n                // We still need to reset the router state back to what it was when the navigation started.\n                this.resetInternalState(navigation);\n                this.resetUrlToCurrentUrlTree();\n            }\n            else ;\n        }\n        else if (this.canceledNavigationResolution === 'replace') {\n            // TODO(atscott): It seems like we should _always_ reset the state here. It would be a no-op\n            // for `deferred` navigations that haven't change the internal state yet because guards\n            // reject. For 'eager' navigations, it seems like we also really should reset the state\n            // because the navigation was cancelled. Investigate if this can be done by running TGP.\n            if (restoringFromCaughtError) {\n                this.resetInternalState(navigation);\n            }\n            this.resetUrlToCurrentUrlTree();\n        }\n    }\n    resetUrlToCurrentUrlTree() {\n        this.location.replaceState(this.urlSerializer.serialize(this.getRawUrlTree()), '', this.generateNgRouterState(this.lastSuccessfulId, this.currentPageId));\n    }\n    generateNgRouterState(navigationId, routerPageId) {\n        if (this.canceledNavigationResolution === 'computed') {\n            return { navigationId, routerPageId: routerPageId };\n        }\n        return { navigationId };\n    }\n    static fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: HistoryStateManager, deps: null, target: i0.FactoryTarget.Injectable });\n    static prov = i0.ngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: HistoryStateManager, providedIn: 'root' });\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: HistoryStateManager, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }] });\n\n/**\n * Performs the given action once the router finishes its next/current navigation.\n *\n * The navigation is considered complete under the following conditions:\n * - `NavigationCancel` event emits and the code is not `NavigationCancellationCode.Redirect` or\n * `NavigationCancellationCode.SupersededByNewNavigation`. In these cases, the\n * redirecting/superseding navigation must finish.\n * - `NavigationError`, `NavigationEnd`, or `NavigationSkipped` event emits\n */\nfunction afterNextNavigation(router, action) {\n    router.events\n        .pipe(filter((e) => e instanceof NavigationEnd ||\n        e instanceof NavigationCancel ||\n        e instanceof NavigationError ||\n        e instanceof NavigationSkipped), map((e) => {\n        if (e instanceof NavigationEnd || e instanceof NavigationSkipped) {\n            return 0 /* NavigationResult.COMPLETE */;\n        }\n        const redirecting = e instanceof NavigationCancel\n            ? e.code === NavigationCancellationCode.Redirect ||\n                e.code === NavigationCancellationCode.SupersededByNewNavigation\n            : false;\n        return redirecting ? 2 /* NavigationResult.REDIRECTING */ : 1 /* NavigationResult.FAILED */;\n    }), filter((result) => result !== 2 /* NavigationResult.REDIRECTING */), take(1))\n        .subscribe(() => {\n        action();\n    });\n}\n\n/**\n * The equivalent `IsActiveMatchOptions` options for `Router.isActive` is called with `true`\n * (exact = true).\n */\nconst exactMatchOptions = {\n    paths: 'exact',\n    fragment: 'ignored',\n    matrixParams: 'ignored',\n    queryParams: 'exact',\n};\n/**\n * The equivalent `IsActiveMatchOptions` options for `Router.isActive` is called with `false`\n * (exact = false).\n */\nconst subsetMatchOptions = {\n    paths: 'subset',\n    fragment: 'ignored',\n    matrixParams: 'ignored',\n    queryParams: 'subset',\n};\n/**\n * @description\n *\n * A service that facilitates navigation among views and URL manipulation capabilities.\n * This service is provided in the root scope and configured with [provideRouter](api/router/provideRouter).\n *\n * @see {@link Route}\n * @see {@link provideRouter}\n * @see [Routing and Navigation Guide](guide/routing/common-router-tasks).\n *\n * @ngModule RouterModule\n *\n * @publicApi\n */\nclass Router {\n    get currentUrlTree() {\n        return this.stateManager.getCurrentUrlTree();\n    }\n    get rawUrlTree() {\n        return this.stateManager.getRawUrlTree();\n    }\n    disposed = false;\n    nonRouterCurrentEntryChangeSubscription;\n    console = inject(_Console);\n    stateManager = inject(StateManager);\n    options = inject(ROUTER_CONFIGURATION, { optional: true }) || {};\n    pendingTasks = inject(_PendingTasksInternal);\n    urlUpdateStrategy = this.options.urlUpdateStrategy || 'deferred';\n    navigationTransitions = inject(NavigationTransitions);\n    urlSerializer = inject(UrlSerializer);\n    location = inject(Location);\n    urlHandlingStrategy = inject(UrlHandlingStrategy);\n    injector = inject(EnvironmentInjector);\n    /**\n     * The private `Subject` type for the public events exposed in the getter. This is used internally\n     * to push events to. The separate field allows us to expose separate types in the public API\n     * (i.e., an Observable rather than the Subject).\n     */\n    _events = new Subject();\n    /**\n     * An event stream for routing events.\n     */\n    get events() {\n        // TODO(atscott): This _should_ be events.asObservable(). However, this change requires internal\n        // cleanup: tests are doing `(route.events as Subject<Event>).next(...)`. This isn't\n        // allowed/supported but we still have to fix these or file bugs against the teams before making\n        // the change.\n        return this._events;\n    }\n    /**\n     * The current state of routing in this NgModule.\n     */\n    get routerState() {\n        return this.stateManager.getRouterState();\n    }\n    /**\n     * True if at least one navigation event has occurred,\n     * false otherwise.\n     */\n    navigated = false;\n    /**\n     * A strategy for re-using routes.\n     *\n     * @deprecated Configure using `providers` instead:\n     *   `{provide: RouteReuseStrategy, useClass: MyStrategy}`.\n     */\n    routeReuseStrategy = inject(RouteReuseStrategy);\n    /**\n     * How to handle a navigation request to the current URL.\n     *\n     *\n     * @deprecated Configure this through `provideRouter` or `RouterModule.forRoot` instead.\n     * @see {@link withRouterConfig}\n     * @see {@link provideRouter}\n     * @see {@link RouterModule}\n     */\n    onSameUrlNavigation = this.options.onSameUrlNavigation || 'ignore';\n    config = inject(ROUTES, { optional: true })?.flat() ?? [];\n    /**\n     * Indicates whether the application has opted in to binding Router data to component inputs.\n     *\n     * This option is enabled by the `withComponentInputBinding` feature of `provideRouter` or\n     * `bindToComponentInputs` in the `ExtraOptions` of `RouterModule.forRoot`.\n     */\n    componentInputBindingEnabled = !!inject(INPUT_BINDER, { optional: true });\n    /**\n     * Signal of the current `Navigation` object when the router is navigating, and `null` when idle.\n     *\n     * Note: The current navigation becomes to null after the NavigationEnd event is emitted.\n     */\n    currentNavigation = this.navigationTransitions.currentNavigation.asReadonly();\n    constructor() {\n        this.resetConfig(this.config);\n        this.navigationTransitions.setupNavigations(this).subscribe({\n            error: (e) => {\n                this.console.warn(ngDevMode ? `Unhandled Navigation Error: ${e}` : e);\n            },\n        });\n        this.subscribeToNavigationEvents();\n    }\n    eventsSubscription = new Subscription();\n    subscribeToNavigationEvents() {\n        const subscription = this.navigationTransitions.events.subscribe((e) => {\n            try {\n                const currentTransition = this.navigationTransitions.currentTransition;\n                const currentNavigation = untracked(this.navigationTransitions.currentNavigation);\n                if (currentTransition !== null && currentNavigation !== null) {\n                    this.stateManager.handleRouterEvent(e, currentNavigation);\n                    if (e instanceof NavigationCancel &&\n                        e.code !== NavigationCancellationCode.Redirect &&\n                        e.code !== NavigationCancellationCode.SupersededByNewNavigation) {\n                        // It seems weird that `navigated` is set to `true` when the navigation is rejected,\n                        // however it's how things were written initially. Investigation would need to be done\n                        // to determine if this can be removed.\n                        this.navigated = true;\n                    }\n                    else if (e instanceof NavigationEnd) {\n                        this.navigated = true;\n                    }\n                    else if (e instanceof RedirectRequest) {\n                        const opts = e.navigationBehaviorOptions;\n                        const mergedTree = this.urlHandlingStrategy.merge(e.url, currentTransition.currentRawUrl);\n                        const extras = {\n                            browserUrl: currentTransition.extras.browserUrl,\n                            info: currentTransition.extras.info,\n                            skipLocationChange: currentTransition.extras.skipLocationChange,\n                            // The URL is already updated at this point if we have 'eager' URL\n                            // updates or if the navigation was triggered by the browser (back\n                            // button, URL bar, etc). We want to replace that item in history\n                            // if the navigation is rejected.\n                            replaceUrl: currentTransition.extras.replaceUrl ||\n                                this.urlUpdateStrategy === 'eager' ||\n                                isBrowserTriggeredNavigation(currentTransition.source),\n                            // allow developer to override default options with RedirectCommand\n                            ...opts,\n                        };\n                        this.scheduleNavigation(mergedTree, IMPERATIVE_NAVIGATION, null, extras, {\n                            resolve: currentTransition.resolve,\n                            reject: currentTransition.reject,\n                            promise: currentTransition.promise,\n                        });\n                    }\n                }\n                // Note that it's important to have the Router process the events _before_ the event is\n                // pushed through the public observable. This ensures the correct router state is in place\n                // before applications observe the events.\n                if (isPublicRouterEvent(e)) {\n                    this._events.next(e);\n                }\n            }\n            catch (e) {\n                this.navigationTransitions.transitionAbortWithErrorSubject.next(e);\n            }\n        });\n        this.eventsSubscription.add(subscription);\n    }\n    /** @internal */\n    resetRootComponentType(rootComponentType) {\n        // TODO: vsavkin router 4.0 should make the root component set to null\n        // this will simplify the lifecycle of the router.\n        this.routerState.root.component = rootComponentType;\n        this.navigationTransitions.rootComponentType = rootComponentType;\n    }\n    /**\n     * Sets up the location change listener and performs the initial navigation.\n     */\n    initialNavigation() {\n        this.setUpLocationChangeListener();\n        if (!this.navigationTransitions.hasRequestedNavigation) {\n            this.navigateToSyncWithBrowser(this.location.path(true), IMPERATIVE_NAVIGATION, this.stateManager.restoredState());\n        }\n    }\n    /**\n     * Sets up the location change listener. This listener detects navigations triggered from outside\n     * the Router (the browser back/forward buttons, for example) and schedules a corresponding Router\n     * navigation so that the correct events, guards, etc. are triggered.\n     */\n    setUpLocationChangeListener() {\n        // Don't need to use Zone.wrap any more, because zone.js\n        // already patch onPopState, so location change callback will\n        // run into ngZone\n        this.nonRouterCurrentEntryChangeSubscription ??=\n            this.stateManager.registerNonRouterCurrentEntryChangeListener((url, state, source) => {\n                this.navigateToSyncWithBrowser(url, source, state);\n            });\n    }\n    /**\n     * Schedules a router navigation to synchronize Router state with the browser state.\n     *\n     * This is done as a response to a popstate event and the initial navigation. These\n     * two scenarios represent times when the browser URL/state has been updated and\n     * the Router needs to respond to ensure its internal state matches.\n     */\n    navigateToSyncWithBrowser(url, source, state) {\n        const extras = { replaceUrl: true };\n        // TODO: restoredState should always include the entire state, regardless\n        // of navigationId. This requires a breaking change to update the type on\n        // NavigationStarts restoredState, which currently requires navigationId\n        // to always be present. The Router used to only restore history state if\n        // a navigationId was present.\n        // The stored navigationId is used by the RouterScroller to retrieve the scroll\n        // position for the page.\n        const restoredState = state?.navigationId ? state : null;\n        // Separate to NavigationStart.restoredState, we must also restore the state to\n        // history.state and generate a new navigationId, since it will be overwritten\n        if (state) {\n            const stateCopy = { ...state };\n            delete stateCopy.navigationId;\n            delete stateCopy.routerPageId;\n            if (Object.keys(stateCopy).length !== 0) {\n                extras.state = stateCopy;\n            }\n        }\n        const urlTree = this.parseUrl(url);\n        this.scheduleNavigation(urlTree, source, restoredState, extras).catch((e) => {\n            if (this.disposed) {\n                return;\n            }\n            this.injector.get(_INTERNAL_APPLICATION_ERROR_HANDLER)(e);\n        });\n    }\n    /** The current URL. */\n    get url() {\n        return this.serializeUrl(this.currentUrlTree);\n    }\n    /**\n     * Returns the current `Navigation` object when the router is navigating,\n     * and `null` when idle.\n     *\n     * @deprecated 20.2 Use the `currentNavigation` signal instead.\n     */\n    getCurrentNavigation() {\n        return untracked(this.navigationTransitions.currentNavigation);\n    }\n    /**\n     * The `Navigation` object of the most recent navigation to succeed and `null` if there\n     *     has not been a successful navigation yet.\n     */\n    get lastSuccessfulNavigation() {\n        return this.navigationTransitions.lastSuccessfulNavigation;\n    }\n    /**\n     * Resets the route configuration used for navigation and generating links.\n     *\n     * @param config The route array for the new configuration.\n     *\n     * @usageNotes\n     *\n     * ```ts\n     * router.resetConfig([\n     *  { path: 'team/:id', component: TeamCmp, children: [\n     *    { path: 'simple', component: SimpleCmp },\n     *    { path: 'user/:name', component: UserCmp }\n     *  ]}\n     * ]);\n     * ```\n     */\n    resetConfig(config) {\n        (typeof ngDevMode === 'undefined' || ngDevMode) && validateConfig(config);\n        this.config = config.map(standardizeConfig);\n        this.navigated = false;\n    }\n    /** @docs-private */\n    ngOnDestroy() {\n        this.dispose();\n    }\n    /** Disposes of the router. */\n    dispose() {\n        // We call `unsubscribe()` to release observers, as users may forget to\n        // unsubscribe manually when subscribing to `router.events`. We do not call\n        // `complete()` because it is unsafe; if someone subscribes using the `first`\n        // operator and the observable completes before emitting a value,\n        // RxJS will throw an error.\n        this._events.unsubscribe();\n        this.navigationTransitions.complete();\n        if (this.nonRouterCurrentEntryChangeSubscription) {\n            this.nonRouterCurrentEntryChangeSubscription.unsubscribe();\n            this.nonRouterCurrentEntryChangeSubscription = undefined;\n        }\n        this.disposed = true;\n        this.eventsSubscription.unsubscribe();\n    }\n    /**\n     * Appends URL segments to the current URL tree to create a new URL tree.\n     *\n     * @param commands An array of URL fragments with which to construct the new URL tree.\n     * If the path is static, can be the literal URL string. For a dynamic path, pass an array of path\n     * segments, followed by the parameters for each segment.\n     * The fragments are applied to the current URL tree or the one provided  in the `relativeTo`\n     * property of the options object, if supplied.\n     * @param navigationExtras Options that control the navigation strategy.\n     * @returns The new URL tree.\n     *\n     * @usageNotes\n     *\n     * ```\n     * // create /team/33/user/11\n     * router.createUrlTree(['/team', 33, 'user', 11]);\n     *\n     * // create /team/33;expand=true/user/11\n     * router.createUrlTree(['/team', 33, {expand: true}, 'user', 11]);\n     *\n     * // you can collapse static segments like this (this works only with the first passed-in value):\n     * router.createUrlTree(['/team/33/user', userId]);\n     *\n     * // If the first segment can contain slashes, and you do not want the router to split it,\n     * // you can do the following:\n     * router.createUrlTree([{segmentPath: '/one/two'}]);\n     *\n     * // create /team/33/(user/11//right:chat)\n     * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: 'chat'}}]);\n     *\n     * // remove the right secondary node\n     * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: null}}]);\n     *\n     * // assuming the current url is `/team/33/user/11` and the route points to `user/11`\n     *\n     * // navigate to /team/33/user/11/details\n     * router.createUrlTree(['details'], {relativeTo: route});\n     *\n     * // navigate to /team/33/user/22\n     * router.createUrlTree(['../22'], {relativeTo: route});\n     *\n     * // navigate to /team/44/user/22\n     * router.createUrlTree(['../../team/44/user/22'], {relativeTo: route});\n     *\n     * Note that a value of `null` or `undefined` for `relativeTo` indicates that the\n     * tree should be created relative to the root.\n     * ```\n     */\n    createUrlTree(commands, navigationExtras = {}) {\n        const { relativeTo, queryParams, fragment, queryParamsHandling, preserveFragment } = navigationExtras;\n        const f = preserveFragment ? this.currentUrlTree.fragment : fragment;\n        let q = null;\n        switch (queryParamsHandling ?? this.options.defaultQueryParamsHandling) {\n            case 'merge':\n                q = { ...this.currentUrlTree.queryParams, ...queryParams };\n                break;\n            case 'preserve':\n                q = this.currentUrlTree.queryParams;\n                break;\n            default:\n                q = queryParams || null;\n        }\n        if (q !== null) {\n            q = this.removeEmptyProps(q);\n        }\n        let relativeToUrlSegmentGroup;\n        try {\n            const relativeToSnapshot = relativeTo ? relativeTo.snapshot : this.routerState.snapshot.root;\n            relativeToUrlSegmentGroup = createSegmentGroupFromRoute(relativeToSnapshot);\n        }\n        catch (e) {\n            // This is strictly for backwards compatibility with tests that create\n            // invalid `ActivatedRoute` mocks.\n            // Note: the difference between having this fallback for invalid `ActivatedRoute` setups and\n            // just throwing is ~500 test failures. Fixing all of those tests by hand is not feasible at\n            // the moment.\n            if (typeof commands[0] !== 'string' || commands[0][0] !== '/') {\n                // Navigations that were absolute in the old way of creating UrlTrees\n                // would still work because they wouldn't attempt to match the\n                // segments in the `ActivatedRoute` to the `currentUrlTree` but\n                // instead just replace the root segment with the navigation result.\n                // Non-absolute navigations would fail to apply the commands because\n                // the logic could not find the segment to replace (so they'd act like there were no\n                // commands).\n                commands = [];\n            }\n            relativeToUrlSegmentGroup = this.currentUrlTree.root;\n        }\n        return createUrlTreeFromSegmentGroup(relativeToUrlSegmentGroup, commands, q, f ?? null);\n    }\n    /**\n     * Navigates to a view using an absolute route path.\n     *\n     * @param url An absolute path for a defined route. The function does not apply any delta to the\n     *     current URL.\n     * @param extras An object containing properties that modify the navigation strategy.\n     *\n     * @returns A Promise that resolves to 'true' when navigation succeeds,\n     * to 'false' when navigation fails, or is rejected on error.\n     *\n     * @usageNotes\n     *\n     * The following calls request navigation to an absolute path.\n     *\n     * ```ts\n     * router.navigateByUrl(\"/team/33/user/11\");\n     *\n     * // Navigate without updating the URL\n     * router.navigateByUrl(\"/team/33/user/11\", { skipLocationChange: true });\n     * ```\n     *\n     * @see [Routing and Navigation guide](guide/routing/common-router-tasks)\n     *\n     */\n    navigateByUrl(url, extras = {\n        skipLocationChange: false,\n    }) {\n        const urlTree = isUrlTree(url) ? url : this.parseUrl(url);\n        const mergedTree = this.urlHandlingStrategy.merge(urlTree, this.rawUrlTree);\n        return this.scheduleNavigation(mergedTree, IMPERATIVE_NAVIGATION, null, extras);\n    }\n    /**\n     * Navigate based on the provided array of commands and a starting point.\n     * If no starting route is provided, the navigation is absolute.\n     *\n     * @param commands An array of URL fragments with which to construct the target URL.\n     * If the path is static, can be the literal URL string. For a dynamic path, pass an array of path\n     * segments, followed by the parameters for each segment.\n     * The fragments are applied to the current URL or the one provided  in the `relativeTo` property\n     * of the options object, if supplied.\n     * @param extras An options object that determines how the URL should be constructed or\n     *     interpreted.\n     *\n     * @returns A Promise that resolves to `true` when navigation succeeds, or `false` when navigation\n     *     fails. The Promise is rejected when an error occurs if `resolveNavigationPromiseOnError` is\n     * not `true`.\n     *\n     * @usageNotes\n     *\n     * The following calls request navigation to a dynamic route path relative to the current URL.\n     *\n     * ```ts\n     * router.navigate(['team', 33, 'user', 11], {relativeTo: route});\n     *\n     * // Navigate without updating the URL, overriding the default behavior\n     * router.navigate(['team', 33, 'user', 11], {relativeTo: route, skipLocationChange: true});\n     * ```\n     *\n     * @see [Routing and Navigation guide](guide/routing/common-router-tasks)\n     *\n     */\n    navigate(commands, extras = { skipLocationChange: false }) {\n        validateCommands(commands);\n        return this.navigateByUrl(this.createUrlTree(commands, extras), extras);\n    }\n    /** Serializes a `UrlTree` into a string */\n    serializeUrl(url) {\n        return this.urlSerializer.serialize(url);\n    }\n    /** Parses a string into a `UrlTree` */\n    parseUrl(url) {\n        try {\n            return this.urlSerializer.parse(url);\n        }\n        catch {\n            return this.urlSerializer.parse('/');\n        }\n    }\n    isActive(url, matchOptions) {\n        let options;\n        if (matchOptions === true) {\n            options = { ...exactMatchOptions };\n        }\n        else if (matchOptions === false) {\n            options = { ...subsetMatchOptions };\n        }\n        else {\n            options = matchOptions;\n        }\n        if (isUrlTree(url)) {\n            return containsTree(this.currentUrlTree, url, options);\n        }\n        const urlTree = this.parseUrl(url);\n        return containsTree(this.currentUrlTree, urlTree, options);\n    }\n    removeEmptyProps(params) {\n        return Object.entries(params).reduce((result, [key, value]) => {\n            if (value !== null && value !== undefined) {\n                result[key] = value;\n            }\n            return result;\n        }, {});\n    }\n    scheduleNavigation(rawUrl, source, restoredState, extras, priorPromise) {\n        if (this.disposed) {\n            return Promise.resolve(false);\n        }\n        let resolve;\n        let reject;\n        let promise;\n        if (priorPromise) {\n            resolve = priorPromise.resolve;\n            reject = priorPromise.reject;\n            promise = priorPromise.promise;\n        }\n        else {\n            promise = new Promise((res, rej) => {\n                resolve = res;\n                reject = rej;\n            });\n        }\n        // Indicate that the navigation is happening.\n        const taskId = this.pendingTasks.add();\n        afterNextNavigation(this, () => {\n            // Remove pending task in a microtask to allow for cancelled\n            // initial navigations and redirects within the same task.\n            queueMicrotask(() => this.pendingTasks.remove(taskId));\n        });\n        this.navigationTransitions.handleNavigationRequest({\n            source,\n            restoredState,\n            currentUrlTree: this.currentUrlTree,\n            currentRawUrl: this.currentUrlTree,\n            rawUrl,\n            extras,\n            resolve: resolve,\n            reject: reject,\n            promise,\n            currentSnapshot: this.routerState.snapshot,\n            currentRouterState: this.routerState,\n        });\n        // Make sure that the error is propagated even though `processNavigations` catch\n        // handler does not rethrow\n        return promise.catch((e) => {\n            return Promise.reject(e);\n        });\n    }\n    static fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: Router, deps: [], target: i0.FactoryTarget.Injectable });\n    static prov = i0.ngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: Router, providedIn: 'root' });\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: Router, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [] });\nfunction validateCommands(commands) {\n    for (let i = 0; i < commands.length; i++) {\n        const cmd = commands[i];\n        if (cmd == null) {\n            throw new _RuntimeError(4008 /* RuntimeErrorCode.NULLISH_COMMAND */, (typeof ngDevMode === 'undefined' || ngDevMode) &&\n                `The requested path contains ${cmd} segment at index ${i}`);\n        }\n    }\n}\n\nexport { ActivatedRoute, ActivatedRouteSnapshot, ActivationEnd, ActivationStart, BaseRouteReuseStrategy, CREATE_VIEW_TRANSITION, ChildActivationEnd, ChildActivationStart, ChildrenOutletContexts, DefaultTitleStrategy, DefaultUrlSerializer, EventType, GuardsCheckEnd, GuardsCheckStart, IMPERATIVE_NAVIGATION, INPUT_BINDER, NAVIGATION_ERROR_HANDLER, NavigationCancel, NavigationCancellationCode, NavigationEnd, NavigationError, NavigationSkipped, NavigationSkippedCode, NavigationStart, NavigationTransitions, OutletContext, PRIMARY_OUTLET, ROUTER_CONFIGURATION, ROUTER_OUTLET_DATA, ROUTES, RedirectCommand, ResolveEnd, ResolveStart, RouteConfigLoadEnd, RouteConfigLoadStart, RouteReuseStrategy, RoutedComponentInputBinder, Router, RouterConfigLoader, RouterEvent, RouterOutlet, RouterState, RouterStateSnapshot, RoutesRecognized, Scroll, TitleStrategy, UrlHandlingStrategy, UrlSegment, UrlSegmentGroup, UrlSerializer, UrlTree, VIEW_TRANSITION_OPTIONS, afterNextNavigation, convertToParamMap, createUrlTreeFromSnapshot, createViewTransition, defaultUrlMatcher, isUrlTree, loadChildren, stringifyEvent, EmptyOutletComponent };\n","import { EmptyError } from '../util/EmptyError';\nimport { filter } from './filter';\nimport { takeLast } from './takeLast';\nimport { throwIfEmpty } from './throwIfEmpty';\nimport { defaultIfEmpty } from './defaultIfEmpty';\nimport { identity } from '../util/identity';\nexport function last(predicate, defaultValue) {\n    const hasDefaultValue = arguments.length >= 2;\n    return (source) => source.pipe(predicate ? filter((v, i) => predicate(v, i, source)) : identity, takeLast(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(() => new EmptyError()));\n}\n","/**\n * @license Angular v20.3.6\n * (c) 2010-2025 Google LLC. https://angular.dev/\n * License: MIT\n */\n\nimport * as i3 from '@angular/common';\nimport { LOCATION_INITIALIZED, ViewportScroller, LocationStrategy, HashLocationStrategy, Location, PathLocationStrategy } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { signal, untracked, inject, INTERNAL_APPLICATION_ERROR_HANDLER as _INTERNAL_APPLICATION_ERROR_HANDLER, HostAttributeToken, RuntimeError as _RuntimeError, booleanAttribute, Directive, Attribute, HostBinding, Input, HostListener, EventEmitter, Optional, ContentChildren, Output, Injectable, createEnvironmentInjector, InjectionToken, publishExternalGlobalUtil as _publishExternalGlobalUtil, makeEnvironmentProviders, APP_BOOTSTRAP_LISTENER, Injector, ApplicationRef, IS_ENABLED_BLOCKING_INITIAL_NAVIGATION as _IS_ENABLED_BLOCKING_INITIAL_NAVIGATION, provideAppInitializer, performanceMarkFeature as _performanceMarkFeature, ENVIRONMENT_INITIALIZER, NgZone, SkipSelf, NgModule } from '@angular/core';\nimport { ROUTER_CONFIGURATION, NavigationEnd, isUrlTree, Router, ActivatedRoute, RouterConfigLoader, IMPERATIVE_NAVIGATION, NavigationStart, NavigationSkipped, NavigationSkippedCode, Scroll, UrlSerializer, NavigationTransitions, ROUTES, afterNextNavigation, stringifyEvent, NAVIGATION_ERROR_HANDLER, RoutedComponentInputBinder, INPUT_BINDER, CREATE_VIEW_TRANSITION, createViewTransition, VIEW_TRANSITION_OPTIONS, DefaultUrlSerializer, ChildrenOutletContexts, RouterOutlet, EmptyOutletComponent as _EmptyOutletComponent } from './router2.mjs';\nimport { Subject, of, from } from 'rxjs';\nimport { mergeAll, catchError, filter, concatMap, mergeMap } from 'rxjs/operators';\n\n/**\n * @description\n *\n * When applied to an element in a template, makes that element a link\n * that initiates navigation to a route. Navigation opens one or more routed components\n * in one or more `<router-outlet>` locations on the page.\n *\n * Given a route configuration `[{ path: 'user/:name', component: UserCmp }]`,\n * the following creates a static link to the route:\n * `<a routerLink=\"/user/bob\">link to user component</a>`\n *\n * You can use dynamic values to generate the link.\n * For a dynamic link, pass an array of path segments,\n * followed by the params for each segment.\n * For example, `['/team', teamId, 'user', userName, {details: true}]`\n * generates a link to `/team/11/user/bob;details=true`.\n *\n * Multiple static segments can be merged into one term and combined with dynamic segments.\n * For example, `['/team/11/user', userName, {details: true}]`\n *\n * The input that you provide to the link is treated as a delta to the current URL.\n * For instance, suppose the current URL is `/user/(box//aux:team)`.\n * The link `<a [routerLink]=\"['/user/jim']\">Jim</a>` creates the URL\n * `/user/(jim//aux:team)`.\n * See {@link Router#createUrlTree} for more information.\n *\n * @usageNotes\n *\n * You can use absolute or relative paths in a link, set query parameters,\n * control how parameters are handled, and keep a history of navigation states.\n *\n * ### Relative link paths\n *\n * The first segment name can be prepended with `/`, `./`, or `../`.\n * * If the first segment begins with `/`, the router looks up the route from the root of the\n *   app.\n * * If the first segment begins with `./`, or doesn't begin with a slash, the router\n *   looks in the children of the current activated route.\n * * If the first segment begins with `../`, the router goes up one level in the route tree.\n *\n * ### Setting and handling query params and fragments\n *\n * The following link adds a query parameter and a fragment to the generated URL:\n *\n * ```html\n * <a [routerLink]=\"['/user/bob']\" [queryParams]=\"{debug: true}\" fragment=\"education\">\n *   link to user component\n * </a>\n * ```\n * By default, the directive constructs the new URL using the given query parameters.\n * The example generates the link: `/user/bob?debug=true#education`.\n *\n * You can instruct the directive to handle query parameters differently\n * by specifying the `queryParamsHandling` option in the link.\n * Allowed values are:\n *\n *  - `'merge'`: Merge the given `queryParams` into the current query params.\n *  - `'preserve'`: Preserve the current query params.\n *\n * For example:\n *\n * ```html\n * <a [routerLink]=\"['/user/bob']\" [queryParams]=\"{debug: true}\" queryParamsHandling=\"merge\">\n *   link to user component\n * </a>\n * ```\n *\n * `queryParams`, `fragment`, `queryParamsHandling`, `preserveFragment`, and `relativeTo`\n * cannot be used when the `routerLink` input is a `UrlTree`.\n *\n * See {@link UrlCreationOptions#queryParamsHandling}.\n *\n * ### Preserving navigation history\n *\n * You can provide a `state` value to be persisted to the browser's\n * [`History.state` property](https://developer.mozilla.org/en-US/docs/Web/API/History#Properties).\n * For example:\n *\n * ```html\n * <a [routerLink]=\"['/user/bob']\" [state]=\"{tracingId: 123}\">\n *   link to user component\n * </a>\n * ```\n *\n * Use {@link Router#getCurrentNavigation} to retrieve a saved\n * navigation-state value. For example, to capture the `tracingId` during the `NavigationStart`\n * event:\n *\n * ```ts\n * // Get NavigationStart events\n * router.events.pipe(filter(e => e instanceof NavigationStart)).subscribe(e => {\n *   const navigation = router.getCurrentNavigation();\n *   tracingService.trace({id: navigation.extras.state.tracingId});\n * });\n * ```\n *\n * ### RouterLink compatible custom elements\n *\n * In order to make a custom element work with routerLink, the corresponding custom\n * element must implement the `href` attribute and must list `href` in the array of\n * the static property/getter `observedAttributes`.\n *\n * @ngModule RouterModule\n *\n * @publicApi\n */\nclass RouterLink {\n    router;\n    route;\n    tabIndexAttribute;\n    renderer;\n    el;\n    locationStrategy;\n    /** @nodoc */\n    reactiveHref = signal(null, ...(ngDevMode ? [{ debugName: \"reactiveHref\" }] : []));\n    /**\n     * Represents an `href` attribute value applied to a host element,\n     * when a host element is an `<a>`/`<area>` tag or a compatible custom element.\n     * For other tags, the value is `null`.\n     */\n    get href() {\n        return untracked(this.reactiveHref);\n    }\n    /** @deprecated */\n    set href(value) {\n        this.reactiveHref.set(value);\n    }\n    /**\n     * Represents the `target` attribute on a host element.\n     * This is only used when the host element is\n     * an `<a>`/`<area>` tag or a compatible custom element.\n     */\n    target;\n    /**\n     * Passed to {@link Router#createUrlTree} as part of the\n     * `UrlCreationOptions`.\n     * @see {@link UrlCreationOptions#queryParams}\n     * @see {@link Router#createUrlTree}\n     */\n    queryParams;\n    /**\n     * Passed to {@link Router#createUrlTree} as part of the\n     * `UrlCreationOptions`.\n     * @see {@link UrlCreationOptions#fragment}\n     * @see {@link Router#createUrlTree}\n     */\n    fragment;\n    /**\n     * Passed to {@link Router#createUrlTree} as part of the\n     * `UrlCreationOptions`.\n     * @see {@link UrlCreationOptions#queryParamsHandling}\n     * @see {@link Router#createUrlTree}\n     */\n    queryParamsHandling;\n    /**\n     * Passed to {@link Router#navigateByUrl} as part of the\n     * `NavigationBehaviorOptions`.\n     * @see {@link NavigationBehaviorOptions#state}\n     * @see {@link Router#navigateByUrl}\n     */\n    state;\n    /**\n     * Passed to {@link Router#navigateByUrl} as part of the\n     * `NavigationBehaviorOptions`.\n     * @see {@link NavigationBehaviorOptions#info}\n     * @see {@link Router#navigateByUrl}\n     */\n    info;\n    /**\n     * Passed to {@link Router#createUrlTree} as part of the\n     * `UrlCreationOptions`.\n     * Specify a value here when you do not want to use the default value\n     * for `routerLink`, which is the current activated route.\n     * Note that a value of `undefined` here will use the `routerLink` default.\n     * @see {@link UrlCreationOptions#relativeTo}\n     * @see {@link Router#createUrlTree}\n     */\n    relativeTo;\n    /** Whether a host element is an `<a>`/`<area>` tag or a compatible custom element. */\n    isAnchorElement;\n    subscription;\n    /** @internal */\n    onChanges = new Subject();\n    applicationErrorHandler = inject(_INTERNAL_APPLICATION_ERROR_HANDLER);\n    options = inject(ROUTER_CONFIGURATION, { optional: true });\n    constructor(router, route, tabIndexAttribute, renderer, el, locationStrategy) {\n        this.router = router;\n        this.route = route;\n        this.tabIndexAttribute = tabIndexAttribute;\n        this.renderer = renderer;\n        this.el = el;\n        this.locationStrategy = locationStrategy;\n        // Set the initial href value to whatever exists on the host element already\n        this.reactiveHref.set(inject(new HostAttributeToken('href'), { optional: true }));\n        const tagName = el.nativeElement.tagName?.toLowerCase();\n        this.isAnchorElement =\n            tagName === 'a' ||\n                tagName === 'area' ||\n                !!(\n                // Avoid breaking in an SSR context where customElements might not be defined.\n                (typeof customElements === 'object' &&\n                    // observedAttributes is an optional static property/getter on a custom element.\n                    // The spec states that this must be an array of strings.\n                    customElements.get(tagName)?.observedAttributes?.includes?.('href')));\n        if (!this.isAnchorElement) {\n            this.subscribeToNavigationEventsIfNecessary();\n        }\n        else {\n            this.setTabIndexIfNotOnNativeEl('0');\n        }\n    }\n    subscribeToNavigationEventsIfNecessary() {\n        if (this.subscription !== undefined || !this.isAnchorElement) {\n            return;\n        }\n        // preserving fragment in router state\n        let createSubcription = this.preserveFragment;\n        // preserving or merging with query params in router state\n        const dependsOnRouterState = (handling) => handling === 'merge' || handling === 'preserve';\n        createSubcription ||= dependsOnRouterState(this.queryParamsHandling);\n        createSubcription ||=\n            !this.queryParamsHandling && !dependsOnRouterState(this.options?.defaultQueryParamsHandling);\n        if (!createSubcription) {\n            return;\n        }\n        this.subscription = this.router.events.subscribe((s) => {\n            if (s instanceof NavigationEnd) {\n                this.updateHref();\n            }\n        });\n    }\n    /**\n     * Passed to {@link Router#createUrlTree} as part of the\n     * `UrlCreationOptions`.\n     * @see {@link UrlCreationOptions#preserveFragment}\n     * @see {@link Router#createUrlTree}\n     */\n    preserveFragment = false;\n    /**\n     * Passed to {@link Router#navigateByUrl} as part of the\n     * `NavigationBehaviorOptions`.\n     * @see {@link NavigationBehaviorOptions#skipLocationChange}\n     * @see {@link Router#navigateByUrl}\n     */\n    skipLocationChange = false;\n    /**\n     * Passed to {@link Router#navigateByUrl} as part of the\n     * `NavigationBehaviorOptions`.\n     * @see {@link NavigationBehaviorOptions#replaceUrl}\n     * @see {@link Router#navigateByUrl}\n     */\n    replaceUrl = false;\n    /**\n     * Modifies the tab index if there was not a tabindex attribute on the element during\n     * instantiation.\n     */\n    setTabIndexIfNotOnNativeEl(newTabIndex) {\n        if (this.tabIndexAttribute != null /* both `null` and `undefined` */ || this.isAnchorElement) {\n            return;\n        }\n        this.applyAttributeValue('tabindex', newTabIndex);\n    }\n    /** @docs-private */\n    // TODO(atscott): Remove changes parameter in major version as a breaking change.\n    ngOnChanges(changes) {\n        if (ngDevMode &&\n            isUrlTree(this.routerLinkInput) &&\n            (this.fragment !== undefined ||\n                this.queryParams ||\n                this.queryParamsHandling ||\n                this.preserveFragment ||\n                this.relativeTo)) {\n            throw new _RuntimeError(4017 /* RuntimeErrorCode.INVALID_ROUTER_LINK_INPUTS */, 'Cannot configure queryParams or fragment when using a UrlTree as the routerLink input value.');\n        }\n        if (this.isAnchorElement) {\n            this.updateHref();\n            this.subscribeToNavigationEventsIfNecessary();\n        }\n        // This is subscribed to by `RouterLinkActive` so that it knows to update when there are changes\n        // to the RouterLinks it's tracking.\n        this.onChanges.next(this);\n    }\n    routerLinkInput = null;\n    /**\n     * Commands to pass to {@link Router#createUrlTree} or a `UrlTree`.\n     *   - **array**: commands to pass to {@link Router#createUrlTree}.\n     *   - **string**: shorthand for array of commands with just the string, i.e. `['/route']`\n     *   - **UrlTree**: a `UrlTree` for this link rather than creating one from the commands\n     *     and other inputs that correspond to properties of `UrlCreationOptions`.\n     *   - **null|undefined**: effectively disables the `routerLink`\n     * @see {@link Router#createUrlTree}\n     */\n    set routerLink(commandsOrUrlTree) {\n        if (commandsOrUrlTree == null) {\n            this.routerLinkInput = null;\n            this.setTabIndexIfNotOnNativeEl(null);\n        }\n        else {\n            if (isUrlTree(commandsOrUrlTree)) {\n                this.routerLinkInput = commandsOrUrlTree;\n            }\n            else {\n                this.routerLinkInput = Array.isArray(commandsOrUrlTree)\n                    ? commandsOrUrlTree\n                    : [commandsOrUrlTree];\n            }\n            this.setTabIndexIfNotOnNativeEl('0');\n        }\n    }\n    /** @docs-private */\n    onClick(button, ctrlKey, shiftKey, altKey, metaKey) {\n        const urlTree = this.urlTree;\n        if (urlTree === null) {\n            return true;\n        }\n        if (this.isAnchorElement) {\n            if (button !== 0 || ctrlKey || shiftKey || altKey || metaKey) {\n                return true;\n            }\n            if (typeof this.target === 'string' && this.target != '_self') {\n                return true;\n            }\n        }\n        const extras = {\n            skipLocationChange: this.skipLocationChange,\n            replaceUrl: this.replaceUrl,\n            state: this.state,\n            info: this.info,\n        };\n        // navigateByUrl is mocked frequently in tests... Reduce breakages when adding `catch`\n        this.router.navigateByUrl(urlTree, extras)?.catch((e) => {\n            this.applicationErrorHandler(e);\n        });\n        // Return `false` for `<a>` elements to prevent default action\n        // and cancel the native behavior, since the navigation is handled\n        // by the Router.\n        return !this.isAnchorElement;\n    }\n    /** @docs-private */\n    ngOnDestroy() {\n        this.subscription?.unsubscribe();\n    }\n    updateHref() {\n        const urlTree = this.urlTree;\n        this.reactiveHref.set(urlTree !== null && this.locationStrategy\n            ? (this.locationStrategy?.prepareExternalUrl(this.router.serializeUrl(urlTree)) ?? '')\n            : null);\n    }\n    applyAttributeValue(attrName, attrValue) {\n        const renderer = this.renderer;\n        const nativeElement = this.el.nativeElement;\n        if (attrValue !== null) {\n            renderer.setAttribute(nativeElement, attrName, attrValue);\n        }\n        else {\n            renderer.removeAttribute(nativeElement, attrName);\n        }\n    }\n    get urlTree() {\n        if (this.routerLinkInput === null) {\n            return null;\n        }\n        else if (isUrlTree(this.routerLinkInput)) {\n            return this.routerLinkInput;\n        }\n        return this.router.createUrlTree(this.routerLinkInput, {\n            // If the `relativeTo` input is not defined, we want to use `this.route` by default.\n            // Otherwise, we should use the value provided by the user in the input.\n            relativeTo: this.relativeTo !== undefined ? this.relativeTo : this.route,\n            queryParams: this.queryParams,\n            fragment: this.fragment,\n            queryParamsHandling: this.queryParamsHandling,\n            preserveFragment: this.preserveFragment,\n        });\n    }\n    static fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: RouterLink, deps: [{ token: Router }, { token: ActivatedRoute }, { token: 'tabindex', attribute: true }, { token: i0.Renderer2 }, { token: i0.ElementRef }, { token: i3.LocationStrategy }], target: i0.FactoryTarget.Directive });\n    static dir = i0.ngDeclareDirective({ minVersion: \"16.1.0\", version: \"20.3.6\", type: RouterLink, isStandalone: true, selector: \"[routerLink]\", inputs: { target: \"target\", queryParams: \"queryParams\", fragment: \"fragment\", queryParamsHandling: \"queryParamsHandling\", state: \"state\", info: \"info\", relativeTo: \"relativeTo\", preserveFragment: [\"preserveFragment\", \"preserveFragment\", booleanAttribute], skipLocationChange: [\"skipLocationChange\", \"skipLocationChange\", booleanAttribute], replaceUrl: [\"replaceUrl\", \"replaceUrl\", booleanAttribute], routerLink: \"routerLink\" }, host: { listeners: { \"click\": \"onClick($event.button,$event.ctrlKey,$event.shiftKey,$event.altKey,$event.metaKey)\" }, properties: { \"attr.href\": \"reactiveHref()\", \"attr.target\": \"this.target\" } }, usesOnChanges: true, ngImport: i0 });\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: RouterLink, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[routerLink]',\n                    host: {\n                        '[attr.href]': 'reactiveHref()',\n                    },\n                }]\n        }], ctorParameters: () => [{ type: Router }, { type: ActivatedRoute }, { type: undefined, decorators: [{\n                    type: Attribute,\n                    args: ['tabindex']\n                }] }, { type: i0.Renderer2 }, { type: i0.ElementRef }, { type: i3.LocationStrategy }], propDecorators: { target: [{\n                type: HostBinding,\n                args: ['attr.target']\n            }, {\n                type: Input\n            }], queryParams: [{\n                type: Input\n            }], fragment: [{\n                type: Input\n            }], queryParamsHandling: [{\n                type: Input\n            }], state: [{\n                type: Input\n            }], info: [{\n                type: Input\n            }], relativeTo: [{\n                type: Input\n            }], preserveFragment: [{\n                type: Input,\n                args: [{ transform: booleanAttribute }]\n            }], skipLocationChange: [{\n                type: Input,\n                args: [{ transform: booleanAttribute }]\n            }], replaceUrl: [{\n                type: Input,\n                args: [{ transform: booleanAttribute }]\n            }], routerLink: [{\n                type: Input\n            }], onClick: [{\n                type: HostListener,\n                args: ['click', [\n                        '$event.button',\n                        '$event.ctrlKey',\n                        '$event.shiftKey',\n                        '$event.altKey',\n                        '$event.metaKey',\n                    ]]\n            }] } });\n\n/**\n *\n * @description\n *\n * Tracks whether the linked route of an element is currently active, and allows you\n * to specify one or more CSS classes to add to the element when the linked route\n * is active.\n *\n * Use this directive to create a visual distinction for elements associated with an active route.\n * For example, the following code highlights the word \"Bob\" when the router\n * activates the associated route:\n *\n * ```html\n * <a routerLink=\"/user/bob\" routerLinkActive=\"active-link\">Bob</a>\n * ```\n *\n * Whenever the URL is either '/user' or '/user/bob', the \"active-link\" class is\n * added to the anchor tag. If the URL changes, the class is removed.\n *\n * You can set more than one class using a space-separated string or an array.\n * For example:\n *\n * ```html\n * <a routerLink=\"/user/bob\" routerLinkActive=\"class1 class2\">Bob</a>\n * <a routerLink=\"/user/bob\" [routerLinkActive]=\"['class1', 'class2']\">Bob</a>\n * ```\n *\n * To add the classes only when the URL matches the link exactly, add the option `exact: true`:\n *\n * ```html\n * <a routerLink=\"/user/bob\" routerLinkActive=\"active-link\" [routerLinkActiveOptions]=\"{exact:\n * true}\">Bob</a>\n * ```\n *\n * To directly check the `isActive` status of the link, assign the `RouterLinkActive`\n * instance to a template variable.\n * For example, the following checks the status without assigning any CSS classes:\n *\n * ```html\n * <a routerLink=\"/user/bob\" routerLinkActive #rla=\"routerLinkActive\">\n *   Bob {{ rla.isActive ? '(already open)' : ''}}\n * </a>\n * ```\n *\n * You can apply the `RouterLinkActive` directive to an ancestor of linked elements.\n * For example, the following sets the active-link class on the `<div>`  parent tag\n * when the URL is either '/user/jim' or '/user/bob'.\n *\n * ```html\n * <div routerLinkActive=\"active-link\" [routerLinkActiveOptions]=\"{exact: true}\">\n *   <a routerLink=\"/user/jim\">Jim</a>\n *   <a routerLink=\"/user/bob\">Bob</a>\n * </div>\n * ```\n *\n * The `RouterLinkActive` directive can also be used to set the aria-current attribute\n * to provide an alternative distinction for active elements to visually impaired users.\n *\n * For example, the following code adds the 'active' class to the Home Page link when it is\n * indeed active and in such case also sets its aria-current attribute to 'page':\n *\n * ```html\n * <a routerLink=\"/\" routerLinkActive=\"active\" ariaCurrentWhenActive=\"page\">Home Page</a>\n * ```\n *\n * NOTE: RouterLinkActive is a `ContentChildren` query.\n * Content children queries do not retrieve elements or directives that are in other components' templates, since a component's template is always a black box to its ancestors.\n *\n * @ngModule RouterModule\n *\n * @publicApi\n */\nclass RouterLinkActive {\n    router;\n    element;\n    renderer;\n    cdr;\n    link;\n    links;\n    classes = [];\n    routerEventsSubscription;\n    linkInputChangesSubscription;\n    _isActive = false;\n    get isActive() {\n        return this._isActive;\n    }\n    /**\n     * Options to configure how to determine if the router link is active.\n     *\n     * These options are passed to the `Router.isActive()` function.\n     *\n     * @see {@link Router#isActive}\n     */\n    routerLinkActiveOptions = { exact: false };\n    /**\n     * Aria-current attribute to apply when the router link is active.\n     *\n     * Possible values: `'page'` | `'step'` | `'location'` | `'date'` | `'time'` | `true` | `false`.\n     *\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-current}\n     */\n    ariaCurrentWhenActive;\n    /**\n     *\n     * You can use the output `isActiveChange` to get notified each time the link becomes\n     * active or inactive.\n     *\n     * Emits:\n     * true  -> Route is active\n     * false -> Route is inactive\n     *\n     * ```html\n     * <a\n     *  routerLink=\"/user/bob\"\n     *  routerLinkActive=\"active-link\"\n     *  (isActiveChange)=\"this.onRouterLinkActive($event)\">Bob</a>\n     * ```\n     */\n    isActiveChange = new EventEmitter();\n    constructor(router, element, renderer, cdr, link) {\n        this.router = router;\n        this.element = element;\n        this.renderer = renderer;\n        this.cdr = cdr;\n        this.link = link;\n        this.routerEventsSubscription = router.events.subscribe((s) => {\n            if (s instanceof NavigationEnd) {\n                this.update();\n            }\n        });\n    }\n    /** @docs-private */\n    ngAfterContentInit() {\n        // `of(null)` is used to force subscribe body to execute once immediately (like `startWith`).\n        of(this.links.changes, of(null))\n            .pipe(mergeAll())\n            .subscribe((_) => {\n            this.update();\n            this.subscribeToEachLinkOnChanges();\n        });\n    }\n    subscribeToEachLinkOnChanges() {\n        this.linkInputChangesSubscription?.unsubscribe();\n        const allLinkChanges = [...this.links.toArray(), this.link]\n            .filter((link) => !!link)\n            .map((link) => link.onChanges);\n        this.linkInputChangesSubscription = from(allLinkChanges)\n            .pipe(mergeAll())\n            .subscribe((link) => {\n            if (this._isActive !== this.isLinkActive(this.router)(link)) {\n                this.update();\n            }\n        });\n    }\n    set routerLinkActive(data) {\n        const classes = Array.isArray(data) ? data : data.split(' ');\n        this.classes = classes.filter((c) => !!c);\n    }\n    /** @docs-private */\n    ngOnChanges(changes) {\n        this.update();\n    }\n    /** @docs-private */\n    ngOnDestroy() {\n        this.routerEventsSubscription.unsubscribe();\n        this.linkInputChangesSubscription?.unsubscribe();\n    }\n    update() {\n        if (!this.links || !this.router.navigated)\n            return;\n        queueMicrotask(() => {\n            const hasActiveLinks = this.hasActiveLinks();\n            this.classes.forEach((c) => {\n                if (hasActiveLinks) {\n                    this.renderer.addClass(this.element.nativeElement, c);\n                }\n                else {\n                    this.renderer.removeClass(this.element.nativeElement, c);\n                }\n            });\n            if (hasActiveLinks && this.ariaCurrentWhenActive !== undefined) {\n                this.renderer.setAttribute(this.element.nativeElement, 'aria-current', this.ariaCurrentWhenActive.toString());\n            }\n            else {\n                this.renderer.removeAttribute(this.element.nativeElement, 'aria-current');\n            }\n            // Only emit change if the active state changed.\n            if (this._isActive !== hasActiveLinks) {\n                this._isActive = hasActiveLinks;\n                this.cdr.markForCheck();\n                // Emit on isActiveChange after classes are updated\n                this.isActiveChange.emit(hasActiveLinks);\n            }\n        });\n    }\n    isLinkActive(router) {\n        const options = isActiveMatchOptions(this.routerLinkActiveOptions)\n            ? this.routerLinkActiveOptions\n            : // While the types should disallow `undefined` here, it's possible without strict inputs\n                this.routerLinkActiveOptions.exact || false;\n        return (link) => {\n            const urlTree = link.urlTree;\n            return urlTree ? router.isActive(urlTree, options) : false;\n        };\n    }\n    hasActiveLinks() {\n        const isActiveCheckFn = this.isLinkActive(this.router);\n        return (this.link && isActiveCheckFn(this.link)) || this.links.some(isActiveCheckFn);\n    }\n    static fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: RouterLinkActive, deps: [{ token: Router }, { token: i0.ElementRef }, { token: i0.Renderer2 }, { token: i0.ChangeDetectorRef }, { token: RouterLink, optional: true }], target: i0.FactoryTarget.Directive });\n    static dir = i0.ngDeclareDirective({ minVersion: \"14.0.0\", version: \"20.3.6\", type: RouterLinkActive, isStandalone: true, selector: \"[routerLinkActive]\", inputs: { routerLinkActiveOptions: \"routerLinkActiveOptions\", ariaCurrentWhenActive: \"ariaCurrentWhenActive\", routerLinkActive: \"routerLinkActive\" }, outputs: { isActiveChange: \"isActiveChange\" }, queries: [{ propertyName: \"links\", predicate: RouterLink, descendants: true }], exportAs: [\"routerLinkActive\"], usesOnChanges: true, ngImport: i0 });\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: RouterLinkActive, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[routerLinkActive]',\n                    exportAs: 'routerLinkActive',\n                }]\n        }], ctorParameters: () => [{ type: Router }, { type: i0.ElementRef }, { type: i0.Renderer2 }, { type: i0.ChangeDetectorRef }, { type: RouterLink, decorators: [{\n                    type: Optional\n                }] }], propDecorators: { links: [{\n                type: ContentChildren,\n                args: [RouterLink, { descendants: true }]\n            }], routerLinkActiveOptions: [{\n                type: Input\n            }], ariaCurrentWhenActive: [{\n                type: Input\n            }], isActiveChange: [{\n                type: Output\n            }], routerLinkActive: [{\n                type: Input\n            }] } });\n/**\n * Use instead of `'paths' in options` to be compatible with property renaming\n */\nfunction isActiveMatchOptions(options) {\n    return !!options.paths;\n}\n\n/**\n * @description\n *\n * Provides a preloading strategy.\n *\n * @publicApi\n */\nclass PreloadingStrategy {\n}\n/**\n * @description\n *\n * Provides a preloading strategy that preloads all modules as quickly as possible.\n *\n * ```ts\n * RouterModule.forRoot(ROUTES, {preloadingStrategy: PreloadAllModules})\n * ```\n *\n * @publicApi\n */\nclass PreloadAllModules {\n    preload(route, fn) {\n        return fn().pipe(catchError(() => of(null)));\n    }\n    static fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: PreloadAllModules, deps: [], target: i0.FactoryTarget.Injectable });\n    static prov = i0.ngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: PreloadAllModules, providedIn: 'root' });\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: PreloadAllModules, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }] });\n/**\n * @description\n *\n * Provides a preloading strategy that does not preload any modules.\n *\n * This strategy is enabled by default.\n *\n * @publicApi\n */\nclass NoPreloading {\n    preload(route, fn) {\n        return of(null);\n    }\n    static fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: NoPreloading, deps: [], target: i0.FactoryTarget.Injectable });\n    static prov = i0.ngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: NoPreloading, providedIn: 'root' });\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: NoPreloading, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }] });\n/**\n * The preloader optimistically loads all router configurations to\n * make navigations into lazily-loaded sections of the application faster.\n *\n * The preloader runs in the background. When the router bootstraps, the preloader\n * starts listening to all navigation events. After every such event, the preloader\n * will check if any configurations can be loaded lazily.\n *\n * If a route is protected by `canLoad` guards, the preloaded will not load it.\n *\n * @publicApi\n */\nclass RouterPreloader {\n    router;\n    injector;\n    preloadingStrategy;\n    loader;\n    subscription;\n    constructor(router, injector, preloadingStrategy, loader) {\n        this.router = router;\n        this.injector = injector;\n        this.preloadingStrategy = preloadingStrategy;\n        this.loader = loader;\n    }\n    setUpPreloading() {\n        this.subscription = this.router.events\n            .pipe(filter((e) => e instanceof NavigationEnd), concatMap(() => this.preload()))\n            .subscribe(() => { });\n    }\n    preload() {\n        return this.processRoutes(this.injector, this.router.config);\n    }\n    /** @docs-private */\n    ngOnDestroy() {\n        if (this.subscription) {\n            this.subscription.unsubscribe();\n        }\n    }\n    processRoutes(injector, routes) {\n        const res = [];\n        for (const route of routes) {\n            if (route.providers && !route._injector) {\n                route._injector = createEnvironmentInjector(route.providers, injector, `Route: ${route.path}`);\n            }\n            const injectorForCurrentRoute = route._injector ?? injector;\n            const injectorForChildren = route._loadedInjector ?? injectorForCurrentRoute;\n            // Note that `canLoad` is only checked as a condition that prevents `loadChildren` and not\n            // `loadComponent`. `canLoad` guards only block loading of child routes by design. This\n            // happens as a consequence of needing to descend into children for route matching immediately\n            // while component loading is deferred until route activation. Because `canLoad` guards can\n            // have side effects, we cannot execute them here so we instead skip preloading altogether\n            // when present. Lastly, it remains to be decided whether `canLoad` should behave this way\n            // at all. Code splitting and lazy loading is separate from client-side authorization checks\n            // and should not be used as a security measure to prevent loading of code.\n            if ((route.loadChildren && !route._loadedRoutes && route.canLoad === undefined) ||\n                (route.loadComponent && !route._loadedComponent)) {\n                res.push(this.preloadConfig(injectorForCurrentRoute, route));\n            }\n            if (route.children || route._loadedRoutes) {\n                res.push(this.processRoutes(injectorForChildren, (route.children ?? route._loadedRoutes)));\n            }\n        }\n        return from(res).pipe(mergeAll());\n    }\n    preloadConfig(injector, route) {\n        return this.preloadingStrategy.preload(route, () => {\n            let loadedChildren$;\n            if (route.loadChildren && route.canLoad === undefined) {\n                loadedChildren$ = this.loader.loadChildren(injector, route);\n            }\n            else {\n                loadedChildren$ = of(null);\n            }\n            const recursiveLoadChildren$ = loadedChildren$.pipe(mergeMap((config) => {\n                if (config === null) {\n                    return of(void 0);\n                }\n                route._loadedRoutes = config.routes;\n                route._loadedInjector = config.injector;\n                // If the loaded config was a module, use that as the module/module injector going\n                // forward. Otherwise, continue using the current module/module injector.\n                return this.processRoutes(config.injector ?? injector, config.routes);\n            }));\n            if (route.loadComponent && !route._loadedComponent) {\n                const loadComponent$ = this.loader.loadComponent(injector, route);\n                return from([recursiveLoadChildren$, loadComponent$]).pipe(mergeAll());\n            }\n            else {\n                return recursiveLoadChildren$;\n            }\n        });\n    }\n    static fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: RouterPreloader, deps: [{ token: Router }, { token: i0.EnvironmentInjector }, { token: PreloadingStrategy }, { token: RouterConfigLoader }], target: i0.FactoryTarget.Injectable });\n    static prov = i0.ngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: RouterPreloader, providedIn: 'root' });\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: RouterPreloader, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [{ type: Router }, { type: i0.EnvironmentInjector }, { type: PreloadingStrategy }, { type: RouterConfigLoader }] });\n\nconst ROUTER_SCROLLER = new InjectionToken('');\nclass RouterScroller {\n    urlSerializer;\n    transitions;\n    viewportScroller;\n    zone;\n    options;\n    routerEventsSubscription;\n    scrollEventsSubscription;\n    lastId = 0;\n    lastSource = IMPERATIVE_NAVIGATION;\n    restoredId = 0;\n    store = {};\n    /** @docs-private */\n    constructor(urlSerializer, transitions, viewportScroller, zone, options = {}) {\n        this.urlSerializer = urlSerializer;\n        this.transitions = transitions;\n        this.viewportScroller = viewportScroller;\n        this.zone = zone;\n        this.options = options;\n        // Default both options to 'disabled'\n        options.scrollPositionRestoration ||= 'disabled';\n        options.anchorScrolling ||= 'disabled';\n    }\n    init() {\n        // we want to disable the automatic scrolling because having two places\n        // responsible for scrolling results race conditions, especially given\n        // that browser don't implement this behavior consistently\n        if (this.options.scrollPositionRestoration !== 'disabled') {\n            this.viewportScroller.setHistoryScrollRestoration('manual');\n        }\n        this.routerEventsSubscription = this.createScrollEvents();\n        this.scrollEventsSubscription = this.consumeScrollEvents();\n    }\n    createScrollEvents() {\n        return this.transitions.events.subscribe((e) => {\n            if (e instanceof NavigationStart) {\n                // store the scroll position of the current stable navigations.\n                this.store[this.lastId] = this.viewportScroller.getScrollPosition();\n                this.lastSource = e.navigationTrigger;\n                this.restoredId = e.restoredState ? e.restoredState.navigationId : 0;\n            }\n            else if (e instanceof NavigationEnd) {\n                this.lastId = e.id;\n                this.scheduleScrollEvent(e, this.urlSerializer.parse(e.urlAfterRedirects).fragment);\n            }\n            else if (e instanceof NavigationSkipped &&\n                e.code === NavigationSkippedCode.IgnoredSameUrlNavigation) {\n                this.lastSource = undefined;\n                this.restoredId = 0;\n                this.scheduleScrollEvent(e, this.urlSerializer.parse(e.url).fragment);\n            }\n        });\n    }\n    consumeScrollEvents() {\n        return this.transitions.events.subscribe((e) => {\n            if (!(e instanceof Scroll))\n                return;\n            const instantScroll = { behavior: 'instant' };\n            // a popstate event. The pop state event will always ignore anchor scrolling.\n            if (e.position) {\n                if (this.options.scrollPositionRestoration === 'top') {\n                    this.viewportScroller.scrollToPosition([0, 0], instantScroll);\n                }\n                else if (this.options.scrollPositionRestoration === 'enabled') {\n                    this.viewportScroller.scrollToPosition(e.position, instantScroll);\n                }\n                // imperative navigation \"forward\"\n            }\n            else {\n                if (e.anchor && this.options.anchorScrolling === 'enabled') {\n                    this.viewportScroller.scrollToAnchor(e.anchor);\n                }\n                else if (this.options.scrollPositionRestoration !== 'disabled') {\n                    this.viewportScroller.scrollToPosition([0, 0]);\n                }\n            }\n        });\n    }\n    scheduleScrollEvent(routerEvent, anchor) {\n        this.zone.runOutsideAngular(async () => {\n            // The scroll event needs to be delayed until after change detection. Otherwise, we may\n            // attempt to restore the scroll position before the router outlet has fully rendered the\n            // component by executing its update block of the template function.\n            //\n            // #57109 (we need to wait at least a macrotask before scrolling. AfterNextRender resolves in microtask event loop with Zones)\n            // We could consider _also_ waiting for a render promise though one should have already happened or been scheduled by this point\n            // and should definitely happen before rAF/setTimeout.\n            // #53985 (cannot rely solely on setTimeout because a frame may paint before the timeout)\n            await new Promise((resolve) => {\n                setTimeout(resolve);\n                if (typeof requestAnimationFrame !== 'undefined') {\n                    requestAnimationFrame(resolve);\n                }\n            });\n            this.zone.run(() => {\n                this.transitions.events.next(new Scroll(routerEvent, this.lastSource === 'popstate' ? this.store[this.restoredId] : null, anchor));\n            });\n        });\n    }\n    /** @docs-private */\n    ngOnDestroy() {\n        this.routerEventsSubscription?.unsubscribe();\n        this.scrollEventsSubscription?.unsubscribe();\n    }\n    static fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: RouterScroller, deps: \"invalid\", target: i0.FactoryTarget.Injectable });\n    static prov = i0.ngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: RouterScroller });\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: RouterScroller, decorators: [{\n            type: Injectable\n        }], ctorParameters: () => [{ type: UrlSerializer }, { type: NavigationTransitions }, { type: i3.ViewportScroller }, { type: i0.NgZone }, { type: undefined }] });\n\n/**\n * Returns the loaded routes for a given route.\n */\nfunction getLoadedRoutes(route) {\n    return route._loadedRoutes;\n}\n/**\n * Returns the Router instance from the given injector, or null if not available.\n */\nfunction getRouterInstance(injector) {\n    return injector.get(Router, null, { optional: true });\n}\n/**\n * Navigates the given router to the specified URL.\n * Throws if the provided router is not an Angular Router.\n */\nfunction navigateByUrl(router, url) {\n    if (!(router instanceof Router)) {\n        throw new Error('The provided router is not an Angular Router.');\n    }\n    return router.navigateByUrl(url);\n}\n\n/**\n * Sets up providers necessary to enable `Router` functionality for the application.\n * Allows to configure a set of routes as well as extra features that should be enabled.\n *\n * @usageNotes\n *\n * Basic example of how you can add a Router to your application:\n * ```ts\n * const appRoutes: Routes = [];\n * bootstrapApplication(AppComponent, {\n *   providers: [provideRouter(appRoutes)]\n * });\n * ```\n *\n * You can also enable optional features in the Router by adding functions from the `RouterFeatures`\n * type:\n * ```ts\n * const appRoutes: Routes = [];\n * bootstrapApplication(AppComponent,\n *   {\n *     providers: [\n *       provideRouter(appRoutes,\n *         withDebugTracing(),\n *         withRouterConfig({paramsInheritanceStrategy: 'always'}))\n *     ]\n *   }\n * );\n * ```\n *\n * @see {@link RouterFeatures}\n *\n * @publicApi\n * @param routes A set of `Route`s to use for the application routing table.\n * @param features Optional features to configure additional router behaviors.\n * @returns A set of providers to setup a Router.\n */\nfunction provideRouter(routes, ...features) {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        // Publish this util when the router is provided so that the devtools can use it.\n        _publishExternalGlobalUtil('getLoadedRoutes', getLoadedRoutes);\n        _publishExternalGlobalUtil('getRouterInstance', getRouterInstance);\n        _publishExternalGlobalUtil('navigateByUrl', navigateByUrl);\n    }\n    return makeEnvironmentProviders([\n        { provide: ROUTES, multi: true, useValue: routes },\n        typeof ngDevMode === 'undefined' || ngDevMode\n            ? { provide: ROUTER_IS_PROVIDED, useValue: true }\n            : [],\n        { provide: ActivatedRoute, useFactory: rootRoute, deps: [Router] },\n        { provide: APP_BOOTSTRAP_LISTENER, multi: true, useFactory: getBootstrapListener },\n        features.map((feature) => feature.providers),\n    ]);\n}\nfunction rootRoute(router) {\n    return router.routerState.root;\n}\n/**\n * Helper function to create an object that represents a Router feature.\n */\nfunction routerFeature(kind, providers) {\n    return { kind: kind, providers: providers };\n}\n/**\n * An Injection token used to indicate whether `provideRouter` or `RouterModule.forRoot` was ever\n * called.\n */\nconst ROUTER_IS_PROVIDED = new InjectionToken('', {\n    providedIn: 'root',\n    factory: () => false,\n});\nconst routerIsProvidedDevModeCheck = {\n    provide: ENVIRONMENT_INITIALIZER,\n    multi: true,\n    useFactory() {\n        return () => {\n            if (!inject(ROUTER_IS_PROVIDED)) {\n                console.warn('`provideRoutes` was called without `provideRouter` or `RouterModule.forRoot`. ' +\n                    'This is likely a mistake.');\n            }\n        };\n    },\n};\n/**\n * Registers a DI provider for a set of routes.\n * @param routes The route configuration to provide.\n *\n * @usageNotes\n *\n * ```ts\n * @NgModule({\n *   providers: [provideRoutes(ROUTES)]\n * })\n * class LazyLoadedChildModule {}\n * ```\n *\n * @deprecated If necessary, provide routes using the `ROUTES` `InjectionToken`.\n * @see {@link ROUTES}\n * @publicApi\n */\nfunction provideRoutes(routes) {\n    return [\n        { provide: ROUTES, multi: true, useValue: routes },\n        typeof ngDevMode === 'undefined' || ngDevMode ? routerIsProvidedDevModeCheck : [],\n    ];\n}\n/**\n * Enables customizable scrolling behavior for router navigations.\n *\n * @usageNotes\n *\n * Basic example of how you can enable scrolling feature:\n * ```ts\n * const appRoutes: Routes = [];\n * bootstrapApplication(AppComponent,\n *   {\n *     providers: [\n *       provideRouter(appRoutes, withInMemoryScrolling())\n *     ]\n *   }\n * );\n * ```\n *\n * @see {@link provideRouter}\n * @see {@link ViewportScroller}\n *\n * @publicApi\n * @param options Set of configuration parameters to customize scrolling behavior, see\n *     `InMemoryScrollingOptions` for additional information.\n * @returns A set of providers for use with `provideRouter`.\n */\nfunction withInMemoryScrolling(options = {}) {\n    const providers = [\n        {\n            provide: ROUTER_SCROLLER,\n            useFactory: () => {\n                const viewportScroller = inject(ViewportScroller);\n                const zone = inject(NgZone);\n                const transitions = inject(NavigationTransitions);\n                const urlSerializer = inject(UrlSerializer);\n                return new RouterScroller(urlSerializer, transitions, viewportScroller, zone, options);\n            },\n        },\n    ];\n    return routerFeature(4 /* RouterFeatureKind.InMemoryScrollingFeature */, providers);\n}\nfunction getBootstrapListener() {\n    const injector = inject(Injector);\n    return (bootstrappedComponentRef) => {\n        const ref = injector.get(ApplicationRef);\n        if (bootstrappedComponentRef !== ref.components[0]) {\n            return;\n        }\n        const router = injector.get(Router);\n        const bootstrapDone = injector.get(BOOTSTRAP_DONE);\n        if (injector.get(INITIAL_NAVIGATION) === 1 /* InitialNavigation.EnabledNonBlocking */) {\n            router.initialNavigation();\n        }\n        injector.get(ROUTER_PRELOADER, null, { optional: true })?.setUpPreloading();\n        injector.get(ROUTER_SCROLLER, null, { optional: true })?.init();\n        router.resetRootComponentType(ref.componentTypes[0]);\n        if (!bootstrapDone.closed) {\n            bootstrapDone.next();\n            bootstrapDone.complete();\n            bootstrapDone.unsubscribe();\n        }\n    };\n}\n/**\n * A subject used to indicate that the bootstrapping phase is done. When initial navigation is\n * `enabledBlocking`, the first navigation waits until bootstrapping is finished before continuing\n * to the activation phase.\n */\nconst BOOTSTRAP_DONE = new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'bootstrap done indicator' : '', {\n    factory: () => {\n        return new Subject();\n    },\n});\nconst INITIAL_NAVIGATION = new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'initial navigation' : '', { providedIn: 'root', factory: () => 1 /* InitialNavigation.EnabledNonBlocking */ });\n/**\n * Configures initial navigation to start before the root component is created.\n *\n * The bootstrap is blocked until the initial navigation is complete. This should be set in case\n * you use [server-side rendering](guide/ssr), but do not enable [hydration](guide/hydration) for\n * your application.\n *\n * @usageNotes\n *\n * Basic example of how you can enable this navigation behavior:\n * ```ts\n * const appRoutes: Routes = [];\n * bootstrapApplication(AppComponent,\n *   {\n *     providers: [\n *       provideRouter(appRoutes, withEnabledBlockingInitialNavigation())\n *     ]\n *   }\n * );\n * ```\n *\n * @see {@link provideRouter}\n *\n * @publicApi\n * @returns A set of providers for use with `provideRouter`.\n */\nfunction withEnabledBlockingInitialNavigation() {\n    const providers = [\n        { provide: _IS_ENABLED_BLOCKING_INITIAL_NAVIGATION, useValue: true },\n        { provide: INITIAL_NAVIGATION, useValue: 0 /* InitialNavigation.EnabledBlocking */ },\n        provideAppInitializer(() => {\n            const injector = inject(Injector);\n            const locationInitialized = injector.get(LOCATION_INITIALIZED, Promise.resolve());\n            return locationInitialized.then(() => {\n                return new Promise((resolve) => {\n                    const router = injector.get(Router);\n                    const bootstrapDone = injector.get(BOOTSTRAP_DONE);\n                    afterNextNavigation(router, () => {\n                        // Unblock APP_INITIALIZER in case the initial navigation was canceled or errored\n                        // without a redirect.\n                        resolve(true);\n                    });\n                    injector.get(NavigationTransitions).afterPreactivation = () => {\n                        // Unblock APP_INITIALIZER once we get to `afterPreactivation`. At this point, we\n                        // assume activation will complete successfully (even though this is not\n                        // guaranteed).\n                        resolve(true);\n                        return bootstrapDone.closed ? of(void 0) : bootstrapDone;\n                    };\n                    router.initialNavigation();\n                });\n            });\n        }),\n    ];\n    return routerFeature(2 /* RouterFeatureKind.EnabledBlockingInitialNavigationFeature */, providers);\n}\n/**\n * Disables initial navigation.\n *\n * Use if there is a reason to have more control over when the router starts its initial navigation\n * due to some complex initialization logic.\n *\n * @usageNotes\n *\n * Basic example of how you can disable initial navigation:\n * ```ts\n * const appRoutes: Routes = [];\n * bootstrapApplication(AppComponent,\n *   {\n *     providers: [\n *       provideRouter(appRoutes, withDisabledInitialNavigation())\n *     ]\n *   }\n * );\n * ```\n *\n * @see {@link provideRouter}\n *\n * @returns A set of providers for use with `provideRouter`.\n *\n * @publicApi\n */\nfunction withDisabledInitialNavigation() {\n    const providers = [\n        provideAppInitializer(() => {\n            inject(Router).setUpLocationChangeListener();\n        }),\n        { provide: INITIAL_NAVIGATION, useValue: 2 /* InitialNavigation.Disabled */ },\n    ];\n    return routerFeature(3 /* RouterFeatureKind.DisabledInitialNavigationFeature */, providers);\n}\n/**\n * Enables logging of all internal navigation events to the console.\n * Extra logging might be useful for debugging purposes to inspect Router event sequence.\n *\n * @usageNotes\n *\n * Basic example of how you can enable debug tracing:\n * ```ts\n * const appRoutes: Routes = [];\n * bootstrapApplication(AppComponent,\n *   {\n *     providers: [\n *       provideRouter(appRoutes, withDebugTracing())\n *     ]\n *   }\n * );\n * ```\n *\n * @see {@link provideRouter}\n *\n * @returns A set of providers for use with `provideRouter`.\n *\n * @publicApi\n */\nfunction withDebugTracing() {\n    let providers = [];\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        providers = [\n            {\n                provide: ENVIRONMENT_INITIALIZER,\n                multi: true,\n                useFactory: () => {\n                    const router = inject(Router);\n                    return () => router.events.subscribe((e) => {\n                        // tslint:disable:no-console\n                        console.group?.(`Router Event: ${e.constructor.name}`);\n                        console.log(stringifyEvent(e));\n                        console.log(e);\n                        console.groupEnd?.();\n                        // tslint:enable:no-console\n                    });\n                },\n            },\n        ];\n    }\n    else {\n        providers = [];\n    }\n    return routerFeature(1 /* RouterFeatureKind.DebugTracingFeature */, providers);\n}\nconst ROUTER_PRELOADER = new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'router preloader' : '');\n/**\n * Allows to configure a preloading strategy to use. The strategy is configured by providing a\n * reference to a class that implements a `PreloadingStrategy`.\n *\n * @usageNotes\n *\n * Basic example of how you can configure preloading:\n * ```ts\n * const appRoutes: Routes = [];\n * bootstrapApplication(AppComponent,\n *   {\n *     providers: [\n *       provideRouter(appRoutes, withPreloading(PreloadAllModules))\n *     ]\n *   }\n * );\n * ```\n *\n * @see {@link provideRouter}\n *\n * @param preloadingStrategy A reference to a class that implements a `PreloadingStrategy` that\n *     should be used.\n * @returns A set of providers for use with `provideRouter`.\n *\n * @publicApi\n */\nfunction withPreloading(preloadingStrategy) {\n    const providers = [\n        { provide: ROUTER_PRELOADER, useExisting: RouterPreloader },\n        { provide: PreloadingStrategy, useExisting: preloadingStrategy },\n    ];\n    return routerFeature(0 /* RouterFeatureKind.PreloadingFeature */, providers);\n}\n/**\n * Allows to provide extra parameters to configure Router.\n *\n * @usageNotes\n *\n * Basic example of how you can provide extra configuration options:\n * ```ts\n * const appRoutes: Routes = [];\n * bootstrapApplication(AppComponent,\n *   {\n *     providers: [\n *       provideRouter(appRoutes, withRouterConfig({\n *          onSameUrlNavigation: 'reload'\n *       }))\n *     ]\n *   }\n * );\n * ```\n *\n * @see {@link provideRouter}\n *\n * @param options A set of parameters to configure Router, see `RouterConfigOptions` for\n *     additional information.\n * @returns A set of providers for use with `provideRouter`.\n *\n * @publicApi\n */\nfunction withRouterConfig(options) {\n    const providers = [{ provide: ROUTER_CONFIGURATION, useValue: options }];\n    return routerFeature(5 /* RouterFeatureKind.RouterConfigurationFeature */, providers);\n}\n/**\n * Provides the location strategy that uses the URL fragment instead of the history API.\n *\n * @usageNotes\n *\n * Basic example of how you can use the hash location option:\n * ```ts\n * const appRoutes: Routes = [];\n * bootstrapApplication(AppComponent,\n *   {\n *     providers: [\n *       provideRouter(appRoutes, withHashLocation())\n *     ]\n *   }\n * );\n * ```\n *\n * @see {@link provideRouter}\n * @see {@link /api/common/HashLocationStrategy HashLocationStrategy}\n *\n * @returns A set of providers for use with `provideRouter`.\n *\n * @publicApi\n */\nfunction withHashLocation() {\n    const providers = [{ provide: LocationStrategy, useClass: HashLocationStrategy }];\n    return routerFeature(6 /* RouterFeatureKind.RouterHashLocationFeature */, providers);\n}\n/**\n * Provides a function which is called when a navigation error occurs.\n *\n * This function is run inside application's [injection context](guide/di/dependency-injection-context)\n * so you can use the [`inject`](api/core/inject) function.\n *\n * This function can return a `RedirectCommand` to convert the error to a redirect, similar to returning\n * a `UrlTree` or `RedirectCommand` from a guard. This will also prevent the `Router` from emitting\n * `NavigationError`; it will instead emit `NavigationCancel` with code NavigationCancellationCode.Redirect.\n * Return values other than `RedirectCommand` are ignored and do not change any behavior with respect to\n * how the `Router` handles the error.\n *\n * @usageNotes\n *\n * Basic example of how you can use the error handler option:\n * ```ts\n * const appRoutes: Routes = [];\n * bootstrapApplication(AppComponent,\n *   {\n *     providers: [\n *       provideRouter(appRoutes, withNavigationErrorHandler((e: NavigationError) =>\n * inject(MyErrorTracker).trackError(e)))\n *     ]\n *   }\n * );\n * ```\n *\n * @see {@link NavigationError}\n * @see {@link /api/core/inject inject}\n * @see {@link runInInjectionContext}\n *\n * @returns A set of providers for use with `provideRouter`.\n *\n * @publicApi\n */\nfunction withNavigationErrorHandler(handler) {\n    const providers = [\n        {\n            provide: NAVIGATION_ERROR_HANDLER,\n            useValue: handler,\n        },\n    ];\n    return routerFeature(7 /* RouterFeatureKind.NavigationErrorHandlerFeature */, providers);\n}\n/**\n * Enables binding information from the `Router` state directly to the inputs of the component in\n * `Route` configurations.\n *\n * @usageNotes\n *\n * Basic example of how you can enable the feature:\n * ```ts\n * const appRoutes: Routes = [];\n * bootstrapApplication(AppComponent,\n *   {\n *     providers: [\n *       provideRouter(appRoutes, withComponentInputBinding())\n *     ]\n *   }\n * );\n * ```\n *\n * The router bindings information from any of the following sources:\n *\n *  - query parameters\n *  - path and matrix parameters\n *  - static route data\n *  - data from resolvers\n *\n * Duplicate keys are resolved in the same order from above, from least to greatest,\n * meaning that resolvers have the highest precedence and override any of the other information\n * from the route.\n *\n * Importantly, when an input does not have an item in the route data with a matching key, this\n * input is set to `undefined`. This prevents previous information from being\n * retained if the data got removed from the route (i.e. if a query parameter is removed).\n * Default values can be provided with a resolver on the route to ensure the value is always present\n * or an input and use an input transform in the component.\n *\n * @see {@link /guide/components/inputs#input-transforms Input Transforms}\n * @returns A set of providers for use with `provideRouter`.\n */\nfunction withComponentInputBinding() {\n    const providers = [\n        RoutedComponentInputBinder,\n        { provide: INPUT_BINDER, useExisting: RoutedComponentInputBinder },\n    ];\n    return routerFeature(8 /* RouterFeatureKind.ComponentInputBindingFeature */, providers);\n}\n/**\n * Enables view transitions in the Router by running the route activation and deactivation inside of\n * `document.startViewTransition`.\n *\n * Note: The View Transitions API is not available in all browsers. If the browser does not support\n * view transitions, the Router will not attempt to start a view transition and continue processing\n * the navigation as usual.\n *\n * @usageNotes\n *\n * Basic example of how you can enable the feature:\n * ```ts\n * const appRoutes: Routes = [];\n * bootstrapApplication(AppComponent,\n *   {\n *     providers: [\n *       provideRouter(appRoutes, withViewTransitions())\n *     ]\n *   }\n * );\n * ```\n *\n * @returns A set of providers for use with `provideRouter`.\n * @see https://developer.chrome.com/docs/web-platform/view-transitions/\n * @see https://developer.mozilla.org/en-US/docs/Web/API/View_Transitions_API\n * @developerPreview 19.0\n */\nfunction withViewTransitions(options) {\n    _performanceMarkFeature('NgRouterViewTransitions');\n    const providers = [\n        { provide: CREATE_VIEW_TRANSITION, useValue: createViewTransition },\n        {\n            provide: VIEW_TRANSITION_OPTIONS,\n            useValue: { skipNextTransition: !!options?.skipInitialTransition, ...options },\n        },\n    ];\n    return routerFeature(9 /* RouterFeatureKind.ViewTransitionsFeature */, providers);\n}\n\n/**\n * The directives defined in the `RouterModule`.\n */\nconst ROUTER_DIRECTIVES = [RouterOutlet, RouterLink, RouterLinkActive, _EmptyOutletComponent];\n/**\n * @docsNotRequired\n */\nconst ROUTER_FORROOT_GUARD = new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'router duplicate forRoot guard' : '');\n// TODO(atscott): All of these except `ActivatedRoute` are `providedIn: 'root'`. They are only kept\n// here to avoid a breaking change whereby the provider order matters based on where the\n// `RouterModule`/`RouterTestingModule` is imported. These can/should be removed as a \"breaking\"\n// change in a major version.\nconst ROUTER_PROVIDERS = [\n    Location,\n    { provide: UrlSerializer, useClass: DefaultUrlSerializer },\n    Router,\n    ChildrenOutletContexts,\n    { provide: ActivatedRoute, useFactory: rootRoute, deps: [Router] },\n    RouterConfigLoader,\n    // Only used to warn when `provideRoutes` is used without `RouterModule` or `provideRouter`. Can\n    // be removed when `provideRoutes` is removed.\n    typeof ngDevMode === 'undefined' || ngDevMode\n        ? { provide: ROUTER_IS_PROVIDED, useValue: true }\n        : [],\n];\n/**\n * @description\n *\n * Adds directives and providers for in-app navigation among views defined in an application.\n * Use the Angular `Router` service to declaratively specify application states and manage state\n * transitions.\n *\n * You can import this NgModule multiple times, once for each lazy-loaded bundle.\n * However, only one `Router` service can be active.\n * To ensure this, there are two ways to register routes when importing this module:\n *\n * * The `forRoot()` method creates an `NgModule` that contains all the directives, the given\n * routes, and the `Router` service itself.\n * * The `forChild()` method creates an `NgModule` that contains all the directives and the given\n * routes, but does not include the `Router` service.\n *\n * @see [Routing and Navigation guide](guide/routing/common-router-tasks) for an\n * overview of how the `Router` service should be used.\n *\n * @publicApi\n */\nclass RouterModule {\n    constructor() {\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            inject(ROUTER_FORROOT_GUARD, { optional: true });\n        }\n    }\n    /**\n     * Creates and configures a module with all the router providers and directives.\n     * Optionally sets up an application listener to perform an initial navigation.\n     *\n     * When registering the NgModule at the root, import as follows:\n     *\n     * ```ts\n     * @NgModule({\n     *   imports: [RouterModule.forRoot(ROUTES)]\n     * })\n     * class MyNgModule {}\n     * ```\n     *\n     * @param routes An array of `Route` objects that define the navigation paths for the application.\n     * @param config An `ExtraOptions` configuration object that controls how navigation is performed.\n     * @return The new `NgModule`.\n     *\n     */\n    static forRoot(routes, config) {\n        return {\n            ngModule: RouterModule,\n            providers: [\n                ROUTER_PROVIDERS,\n                typeof ngDevMode === 'undefined' || ngDevMode\n                    ? config?.enableTracing\n                        ? withDebugTracing().providers\n                        : []\n                    : [],\n                { provide: ROUTES, multi: true, useValue: routes },\n                typeof ngDevMode === 'undefined' || ngDevMode\n                    ? {\n                        provide: ROUTER_FORROOT_GUARD,\n                        useFactory: provideForRootGuard,\n                        deps: [[Router, new Optional(), new SkipSelf()]],\n                    }\n                    : [],\n                config?.errorHandler\n                    ? {\n                        provide: NAVIGATION_ERROR_HANDLER,\n                        useValue: config.errorHandler,\n                    }\n                    : [],\n                { provide: ROUTER_CONFIGURATION, useValue: config ? config : {} },\n                config?.useHash ? provideHashLocationStrategy() : providePathLocationStrategy(),\n                provideRouterScroller(),\n                config?.preloadingStrategy ? withPreloading(config.preloadingStrategy).providers : [],\n                config?.initialNavigation ? provideInitialNavigation(config) : [],\n                config?.bindToComponentInputs ? withComponentInputBinding().providers : [],\n                config?.enableViewTransitions ? withViewTransitions().providers : [],\n                provideRouterInitializer(),\n            ],\n        };\n    }\n    /**\n     * Creates a module with all the router directives and a provider registering routes,\n     * without creating a new Router service.\n     * When registering for submodules and lazy-loaded submodules, create the NgModule as follows:\n     *\n     * ```ts\n     * @NgModule({\n     *   imports: [RouterModule.forChild(ROUTES)]\n     * })\n     * class MyNgModule {}\n     * ```\n     *\n     * @param routes An array of `Route` objects that define the navigation paths for the submodule.\n     * @return The new NgModule.\n     *\n     */\n    static forChild(routes) {\n        return {\n            ngModule: RouterModule,\n            providers: [{ provide: ROUTES, multi: true, useValue: routes }],\n        };\n    }\n    static fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: RouterModule, deps: [], target: i0.FactoryTarget.NgModule });\n    static mod = i0.ngDeclareNgModule({ minVersion: \"14.0.0\", version: \"20.3.6\", ngImport: i0, type: RouterModule, imports: [RouterOutlet, RouterLink, RouterLinkActive, _EmptyOutletComponent], exports: [RouterOutlet, RouterLink, RouterLinkActive, _EmptyOutletComponent] });\n    static inj = i0.ngDeclareInjector({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: RouterModule });\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: RouterModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: ROUTER_DIRECTIVES,\n                    exports: ROUTER_DIRECTIVES,\n                }]\n        }], ctorParameters: () => [] });\n/**\n * For internal use by `RouterModule` only. Note that this differs from `withInMemoryRouterScroller`\n * because it reads from the `ExtraOptions` which should not be used in the standalone world.\n */\nfunction provideRouterScroller() {\n    return {\n        provide: ROUTER_SCROLLER,\n        useFactory: () => {\n            const viewportScroller = inject(ViewportScroller);\n            const zone = inject(NgZone);\n            const config = inject(ROUTER_CONFIGURATION);\n            const transitions = inject(NavigationTransitions);\n            const urlSerializer = inject(UrlSerializer);\n            if (config.scrollOffset) {\n                viewportScroller.setOffset(config.scrollOffset);\n            }\n            return new RouterScroller(urlSerializer, transitions, viewportScroller, zone, config);\n        },\n    };\n}\n// Note: For internal use only with `RouterModule`. Standalone setup via `provideRouter` should\n// provide hash location directly via `{provide: LocationStrategy, useClass: HashLocationStrategy}`.\nfunction provideHashLocationStrategy() {\n    return { provide: LocationStrategy, useClass: HashLocationStrategy };\n}\n// Note: For internal use only with `RouterModule`. Standalone setup via `provideRouter` does not\n// need this at all because `PathLocationStrategy` is the default factory for `LocationStrategy`.\nfunction providePathLocationStrategy() {\n    return { provide: LocationStrategy, useClass: PathLocationStrategy };\n}\nfunction provideForRootGuard(router) {\n    if (router) {\n        throw new _RuntimeError(4007 /* RuntimeErrorCode.FOR_ROOT_CALLED_TWICE */, `The Router was provided more than once. This can happen if 'forRoot' is used outside of the root injector.` +\n            ` Lazy loaded modules should use RouterModule.forChild() instead.`);\n    }\n    return 'guarded';\n}\n// Note: For internal use only with `RouterModule`. Standalone router setup with `provideRouter`\n// users call `withXInitialNavigation` directly.\nfunction provideInitialNavigation(config) {\n    return [\n        config.initialNavigation === 'disabled' ? withDisabledInitialNavigation().providers : [],\n        config.initialNavigation === 'enabledBlocking'\n            ? withEnabledBlockingInitialNavigation().providers\n            : [],\n    ];\n}\n// TODO(atscott): This should not be in the public API\n/**\n * A DI token for the router initializer that\n * is called after the app is bootstrapped.\n *\n * @publicApi\n */\nconst ROUTER_INITIALIZER = new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'Router Initializer' : '');\nfunction provideRouterInitializer() {\n    return [\n        // ROUTER_INITIALIZER token should be removed. It's public API but shouldn't be. We can just\n        // have `getBootstrapListener` directly attached to APP_BOOTSTRAP_LISTENER.\n        { provide: ROUTER_INITIALIZER, useFactory: getBootstrapListener },\n        { provide: APP_BOOTSTRAP_LISTENER, multi: true, useExisting: ROUTER_INITIALIZER },\n    ];\n}\n\nexport { NoPreloading, PreloadAllModules, PreloadingStrategy, ROUTER_INITIALIZER, ROUTER_PROVIDERS, RouterLink, RouterLinkActive, RouterModule, RouterPreloader, provideRouter, provideRoutes, withComponentInputBinding, withDebugTracing, withDisabledInitialNavigation, withEnabledBlockingInitialNavigation, withHashLocation, withInMemoryScrolling, withNavigationErrorHandler, withPreloading, withRouterConfig, withViewTransitions };\n","/**\n * @license Angular v20.3.6\n * (c) 2010-2025 Google LLC. https://angular.dev/\n * License: MIT\n */\n\nexport { ActivatedRoute, ActivatedRouteSnapshot, ActivationEnd, ActivationStart, BaseRouteReuseStrategy, ChildActivationEnd, ChildActivationStart, ChildrenOutletContexts, DefaultTitleStrategy, DefaultUrlSerializer, EventType, GuardsCheckEnd, GuardsCheckStart, NavigationCancel, NavigationCancellationCode, NavigationEnd, NavigationError, NavigationSkipped, NavigationSkippedCode, NavigationStart, OutletContext, PRIMARY_OUTLET, ROUTER_CONFIGURATION, ROUTER_OUTLET_DATA, ROUTES, RedirectCommand, ResolveEnd, ResolveStart, RouteConfigLoadEnd, RouteConfigLoadStart, RouteReuseStrategy, Router, RouterEvent, RouterOutlet, RouterState, RouterStateSnapshot, RoutesRecognized, Scroll, TitleStrategy, UrlHandlingStrategy, UrlSegment, UrlSegmentGroup, UrlSerializer, UrlTree, convertToParamMap, createUrlTreeFromSnapshot, defaultUrlMatcher, EmptyOutletComponent, afterNextNavigation as afterNextNavigation, loadChildren as loadChildren } from './router2.mjs';\nexport { NoPreloading, PreloadAllModules, PreloadingStrategy, ROUTER_INITIALIZER, RouterLink, RouterLinkActive, RouterLink as RouterLinkWithHref, RouterModule, RouterPreloader, provideRouter, provideRoutes, withComponentInputBinding, withDebugTracing, withDisabledInitialNavigation, withEnabledBlockingInitialNavigation, withHashLocation, withInMemoryScrolling, withNavigationErrorHandler, withPreloading, withRouterConfig, withViewTransitions, ROUTER_PROVIDERS as ROUTER_PROVIDERS } from './router_module.mjs';\nimport { inject, Version } from '@angular/core';\nimport '@angular/common';\nimport 'rxjs';\nimport 'rxjs/operators';\nimport '@angular/platform-browser';\n\n/**\n * Maps an array of injectable classes with canMatch functions to an array of equivalent\n * `CanMatchFn` for use in a `Route` definition.\n *\n * Usage {@example router/utils/functional_guards.ts region='CanActivate'}\n *\n * @publicApi\n * @see {@link Route}\n */\nfunction mapToCanMatch(providers) {\n    return providers.map((provider) => (...params) => inject(provider).canMatch(...params));\n}\n/**\n * Maps an array of injectable classes with canActivate functions to an array of equivalent\n * `CanActivateFn` for use in a `Route` definition.\n *\n * Usage {@example router/utils/functional_guards.ts region='CanActivate'}\n *\n * @publicApi\n * @see {@link Route}\n */\nfunction mapToCanActivate(providers) {\n    return providers.map((provider) => (...params) => inject(provider).canActivate(...params));\n}\n/**\n * Maps an array of injectable classes with canActivateChild functions to an array of equivalent\n * `CanActivateChildFn` for use in a `Route` definition.\n *\n * Usage {@example router/utils/functional_guards.ts region='CanActivate'}\n *\n * @publicApi\n * @see {@link Route}\n */\nfunction mapToCanActivateChild(providers) {\n    return providers.map((provider) => (...params) => inject(provider).canActivateChild(...params));\n}\n/**\n * Maps an array of injectable classes with canDeactivate functions to an array of equivalent\n * `CanDeactivateFn` for use in a `Route` definition.\n *\n * Usage {@example router/utils/functional_guards.ts region='CanActivate'}\n *\n * @publicApi\n * @see {@link Route}\n */\nfunction mapToCanDeactivate(providers) {\n    return providers.map((provider) => (...params) => inject(provider).canDeactivate(...params));\n}\n/**\n * Maps an injectable class with a resolve function to an equivalent `ResolveFn`\n * for use in a `Route` definition.\n *\n * Usage {@example router/utils/functional_guards.ts region='Resolve'}\n *\n * @publicApi\n * @see {@link Route}\n */\nfunction mapToResolve(provider) {\n    return (...params) => inject(provider).resolve(...params);\n}\n\n/**\n * @module\n * @description\n * Entry point for all public APIs of the router package.\n */\n/**\n * @publicApi\n */\nconst VERSION = new Version('20.3.6');\n\nexport { VERSION, mapToCanActivate, mapToCanActivateChild, mapToCanDeactivate, mapToCanMatch, mapToResolve };\n"],"x_google_ignoreList":[0,1,2,3,4,5,6,7,8]}