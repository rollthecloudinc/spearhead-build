{"version":3,"file":"4870.74960fe4a4c5c487.js","mappings":"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","names":["FocusKeyManager","_ListKeyManager","_this","_classCallCheck","this","_len","arguments","length","args","Array","_key","_callSuper","concat","_defineProperty","_inherits","_createClass","key","value","origin","_origin","item","_superPropGet","activeItem","focus","ListKeyManager","counters","_IdGenerator","_IdGenerator2","inject","APP_ID","prefix","_appId","hasOwnProperty","__ngFactoryType__","i0","token","factory","ɵfac","providedIn","hasModifierKey","event","modifiers","some","modifier","altKey","shiftKey","ctrlKey","metaKey","_items","injector","signal","apply","_toConsumableArray","Subscription","EMPTY","enabled","delta","disabled","Subject","QueryList","_itemChangesSubscription","changes","subscribe","newItems","_itemsChanged","toArray","isSignal","_effectRef","effect","predicate","_skipPredicateFn","_wrap","undefined","_vertical","direction","_horizontal","keys","_allowedModifierKeys","_this2","debounceInterval","_typeaheadSubscription","unsubscribe","items","_getItemsArray","_typeahead","Typeahead","skipPredicate","selectedItem","setActiveItem","_this$_typeahead","reset","_homeAndEnd","_pageUpAndDown","previousActiveItem","_activeItem","updateActiveItem","change","next","_activeItemIndex","_this$_typeahead3","_this3","keyCode","isModifierAllowed","every","indexOf","TAB","tabOut","DOWN_ARROW","setNextItemActive","UP_ARROW","setPreviousItemActive","RIGHT_ARROW","LEFT_ARROW","HOME","setFirstItemActive","END","setLastItemActive","PAGE_UP","targetIndex","_setActiveItemByIndex","PAGE_DOWN","itemsLength","_this$_typeahead2","handleKey","preventDefault","get","isTyping","_setActiveItemByDelta","_this$_typeahead4","itemArray","index","set","setCurrentSelectedItemIndex","_this$_itemChangesSub","_this$_effectRef","_this$_typeahead5","destroy","complete","_setActiveInWrapMode","_setActiveInDefaultMode","i","fallbackDelta","_this$_typeahead6","setItems","_this$_typeahead7","newIndex","shadowDomIsSupported","_supportsShadowDom","head","document","createShadowRoot","attachShadow","_getShadowRoot","element","rootNode","getRootNode","ShadowRoot","_getFocusedElementPierceShadowDom","activeElement","shadowRoot","newActiveElement","_getEventTarget","composedPath","target"],"ignoreList":[],"sourceRoot":"webpack:///","sources":["./node_modules/@angular/cdk/fesm2022/focus-key-manager.mjs","./node_modules/@angular/cdk/fesm2022/id-generator.mjs","./node_modules/@angular/cdk/fesm2022/keycodes.mjs","./node_modules/@angular/cdk/fesm2022/list-key-manager.mjs","./node_modules/@angular/cdk/fesm2022/shadow-dom.mjs"],"sourcesContent":["import { ListKeyManager } from './list-key-manager.mjs';\n\nclass FocusKeyManager extends ListKeyManager {\n    _origin = 'program';\n    /**\n     * Sets the focus origin that will be passed in to the items for any subsequent `focus` calls.\n     * @param origin Focus origin to be used when focusing items.\n     */\n    setFocusOrigin(origin) {\n        this._origin = origin;\n        return this;\n    }\n    setActiveItem(item) {\n        super.setActiveItem(item);\n        if (this.activeItem) {\n            this.activeItem.focus(this._origin);\n        }\n    }\n}\n\nexport { FocusKeyManager };\n","import * as i0 from '@angular/core';\nimport { inject, APP_ID, Injectable } from '@angular/core';\n\n/**\n * Keeps track of the ID count per prefix. This helps us make the IDs a bit more deterministic\n * like they were before the service was introduced. Note that ideally we wouldn't have to do\n * this, but there are some internal tests that rely on the IDs.\n */\nconst counters = {};\n/** Service that generates unique IDs for DOM nodes. */\nclass _IdGenerator {\n    _appId = inject(APP_ID);\n    /**\n     * Generates a unique ID with a specific prefix.\n     * @param prefix Prefix to add to the ID.\n     */\n    getId(prefix) {\n        // Omit the app ID if it's the default `ng`. Since the vast majority of pages have one\n        // Angular app on them, we can reduce the amount of breakages by not adding it.\n        if (this._appId !== 'ng') {\n            prefix += this._appId;\n        }\n        if (!counters.hasOwnProperty(prefix)) {\n            counters[prefix] = 0;\n        }\n        return `${prefix}${counters[prefix]++}`;\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: _IdGenerator, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: _IdGenerator, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: _IdGenerator, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }] });\n\nexport { _IdGenerator };\n","export { A, ALT, APOSTROPHE, AT_SIGN, B, BACKSLASH, BACKSPACE, C, CAPS_LOCK, CLOSE_SQUARE_BRACKET, COMMA, CONTEXT_MENU, CONTROL, D, DASH, DELETE, DOWN_ARROW, E, EIGHT, END, ENTER, EQUALS, ESCAPE, F, F1, F10, F11, F12, F2, F3, F4, F5, F6, F7, F8, F9, FF_EQUALS, FF_MINUS, FF_MUTE, FF_SEMICOLON, FF_VOLUME_DOWN, FF_VOLUME_UP, FIRST_MEDIA, FIVE, FOUR, G, H, HOME, I, INSERT, J, K, L, LAST_MEDIA, LEFT_ARROW, M, MAC_ENTER, MAC_META, MAC_WK_CMD_LEFT, MAC_WK_CMD_RIGHT, META, MUTE, N, NINE, NUMPAD_DIVIDE, NUMPAD_EIGHT, NUMPAD_FIVE, NUMPAD_FOUR, NUMPAD_MINUS, NUMPAD_MULTIPLY, NUMPAD_NINE, NUMPAD_ONE, NUMPAD_PERIOD, NUMPAD_PLUS, NUMPAD_SEVEN, NUMPAD_SIX, NUMPAD_THREE, NUMPAD_TWO, NUMPAD_ZERO, NUM_CENTER, NUM_LOCK, O, ONE, OPEN_SQUARE_BRACKET, P, PAGE_DOWN, PAGE_UP, PAUSE, PERIOD, PLUS_SIGN, PRINT_SCREEN, Q, QUESTION_MARK, R, RIGHT_ARROW, S, SCROLL_LOCK, SEMICOLON, SEVEN, SHIFT, SINGLE_QUOTE, SIX, SLASH, SPACE, T, TAB, THREE, TILDE, TWO, U, UP_ARROW, V, VOLUME_DOWN, VOLUME_UP, W, X, Y, Z, ZERO } from './keycodes2.mjs';\n\n/**\n * Checks whether a modifier key is pressed.\n * @param event Event to be checked.\n */\nfunction hasModifierKey(event, ...modifiers) {\n    if (modifiers.length) {\n        return modifiers.some(modifier => event[modifier]);\n    }\n    return event.altKey || event.shiftKey || event.ctrlKey || event.metaKey;\n}\n\nexport { hasModifierKey };\n","import { signal, QueryList, isSignal, effect } from '@angular/core';\nimport { Subscription, Subject } from 'rxjs';\nimport { Typeahead } from './typeahead.mjs';\nimport { hasModifierKey } from './keycodes.mjs';\nimport { PAGE_DOWN, PAGE_UP, END, HOME, LEFT_ARROW, RIGHT_ARROW, UP_ARROW, DOWN_ARROW, TAB } from './keycodes2.mjs';\n\n/**\n * This class manages keyboard events for selectable lists. If you pass it a query list\n * of items, it will set the active item correctly when arrow events occur.\n */\nclass ListKeyManager {\n    _items;\n    _activeItemIndex = signal(-1, ...(ngDevMode ? [{ debugName: \"_activeItemIndex\" }] : []));\n    _activeItem = signal(null, ...(ngDevMode ? [{ debugName: \"_activeItem\" }] : []));\n    _wrap = false;\n    _typeaheadSubscription = Subscription.EMPTY;\n    _itemChangesSubscription;\n    _vertical = true;\n    _horizontal;\n    _allowedModifierKeys = [];\n    _homeAndEnd = false;\n    _pageUpAndDown = { enabled: false, delta: 10 };\n    _effectRef;\n    _typeahead;\n    /**\n     * Predicate function that can be used to check whether an item should be skipped\n     * by the key manager. By default, disabled items are skipped.\n     */\n    _skipPredicateFn = (item) => item.disabled;\n    constructor(_items, injector) {\n        this._items = _items;\n        // We allow for the items to be an array because, in some cases, the consumer may\n        // not have access to a QueryList of the items they want to manage (e.g. when the\n        // items aren't being collected via `ViewChildren` or `ContentChildren`).\n        if (_items instanceof QueryList) {\n            this._itemChangesSubscription = _items.changes.subscribe((newItems) => this._itemsChanged(newItems.toArray()));\n        }\n        else if (isSignal(_items)) {\n            if (!injector && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                throw new Error('ListKeyManager constructed with a signal must receive an injector');\n            }\n            this._effectRef = effect(() => this._itemsChanged(_items()), ...(ngDevMode ? [{ debugName: \"_effectRef\", injector }] : [{ injector }]));\n        }\n    }\n    /**\n     * Stream that emits any time the TAB key is pressed, so components can react\n     * when focus is shifted off of the list.\n     */\n    tabOut = new Subject();\n    /** Stream that emits whenever the active item of the list manager changes. */\n    change = new Subject();\n    /**\n     * Sets the predicate function that determines which items should be skipped by the\n     * list key manager.\n     * @param predicate Function that determines whether the given item should be skipped.\n     */\n    skipPredicate(predicate) {\n        this._skipPredicateFn = predicate;\n        return this;\n    }\n    /**\n     * Configures wrapping mode, which determines whether the active item will wrap to\n     * the other end of list when there are no more items in the given direction.\n     * @param shouldWrap Whether the list should wrap when reaching the end.\n     */\n    withWrap(shouldWrap = true) {\n        this._wrap = shouldWrap;\n        return this;\n    }\n    /**\n     * Configures whether the key manager should be able to move the selection vertically.\n     * @param enabled Whether vertical selection should be enabled.\n     */\n    withVerticalOrientation(enabled = true) {\n        this._vertical = enabled;\n        return this;\n    }\n    /**\n     * Configures the key manager to move the selection horizontally.\n     * Passing in `null` will disable horizontal movement.\n     * @param direction Direction in which the selection can be moved.\n     */\n    withHorizontalOrientation(direction) {\n        this._horizontal = direction;\n        return this;\n    }\n    /**\n     * Modifier keys which are allowed to be held down and whose default actions will be prevented\n     * as the user is pressing the arrow keys. Defaults to not allowing any modifier keys.\n     */\n    withAllowedModifierKeys(keys) {\n        this._allowedModifierKeys = keys;\n        return this;\n    }\n    /**\n     * Turns on typeahead mode which allows users to set the active item by typing.\n     * @param debounceInterval Time to wait after the last keystroke before setting the active item.\n     */\n    withTypeAhead(debounceInterval = 200) {\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            const items = this._getItemsArray();\n            if (items.length > 0 && items.some(item => typeof item.getLabel !== 'function')) {\n                throw Error('ListKeyManager items in typeahead mode must implement the `getLabel` method.');\n            }\n        }\n        this._typeaheadSubscription.unsubscribe();\n        const items = this._getItemsArray();\n        this._typeahead = new Typeahead(items, {\n            debounceInterval: typeof debounceInterval === 'number' ? debounceInterval : undefined,\n            skipPredicate: item => this._skipPredicateFn(item),\n        });\n        this._typeaheadSubscription = this._typeahead.selectedItem.subscribe(item => {\n            this.setActiveItem(item);\n        });\n        return this;\n    }\n    /** Cancels the current typeahead sequence. */\n    cancelTypeahead() {\n        this._typeahead?.reset();\n        return this;\n    }\n    /**\n     * Configures the key manager to activate the first and last items\n     * respectively when the Home or End key is pressed.\n     * @param enabled Whether pressing the Home or End key activates the first/last item.\n     */\n    withHomeAndEnd(enabled = true) {\n        this._homeAndEnd = enabled;\n        return this;\n    }\n    /**\n     * Configures the key manager to activate every 10th, configured or first/last element in up/down direction\n     * respectively when the Page-Up or Page-Down key is pressed.\n     * @param enabled Whether pressing the Page-Up or Page-Down key activates the first/last item.\n     * @param delta Whether pressing the Home or End key activates the first/last item.\n     */\n    withPageUpDown(enabled = true, delta = 10) {\n        this._pageUpAndDown = { enabled, delta };\n        return this;\n    }\n    setActiveItem(item) {\n        const previousActiveItem = this._activeItem();\n        this.updateActiveItem(item);\n        if (this._activeItem() !== previousActiveItem) {\n            this.change.next(this._activeItemIndex());\n        }\n    }\n    /**\n     * Sets the active item depending on the key event passed in.\n     * @param event Keyboard event to be used for determining which element should be active.\n     */\n    onKeydown(event) {\n        const keyCode = event.keyCode;\n        const modifiers = ['altKey', 'ctrlKey', 'metaKey', 'shiftKey'];\n        const isModifierAllowed = modifiers.every(modifier => {\n            return !event[modifier] || this._allowedModifierKeys.indexOf(modifier) > -1;\n        });\n        switch (keyCode) {\n            case TAB:\n                this.tabOut.next();\n                return;\n            case DOWN_ARROW:\n                if (this._vertical && isModifierAllowed) {\n                    this.setNextItemActive();\n                    break;\n                }\n                else {\n                    return;\n                }\n            case UP_ARROW:\n                if (this._vertical && isModifierAllowed) {\n                    this.setPreviousItemActive();\n                    break;\n                }\n                else {\n                    return;\n                }\n            case RIGHT_ARROW:\n                if (this._horizontal && isModifierAllowed) {\n                    this._horizontal === 'rtl' ? this.setPreviousItemActive() : this.setNextItemActive();\n                    break;\n                }\n                else {\n                    return;\n                }\n            case LEFT_ARROW:\n                if (this._horizontal && isModifierAllowed) {\n                    this._horizontal === 'rtl' ? this.setNextItemActive() : this.setPreviousItemActive();\n                    break;\n                }\n                else {\n                    return;\n                }\n            case HOME:\n                if (this._homeAndEnd && isModifierAllowed) {\n                    this.setFirstItemActive();\n                    break;\n                }\n                else {\n                    return;\n                }\n            case END:\n                if (this._homeAndEnd && isModifierAllowed) {\n                    this.setLastItemActive();\n                    break;\n                }\n                else {\n                    return;\n                }\n            case PAGE_UP:\n                if (this._pageUpAndDown.enabled && isModifierAllowed) {\n                    const targetIndex = this._activeItemIndex() - this._pageUpAndDown.delta;\n                    this._setActiveItemByIndex(targetIndex > 0 ? targetIndex : 0, 1);\n                    break;\n                }\n                else {\n                    return;\n                }\n            case PAGE_DOWN:\n                if (this._pageUpAndDown.enabled && isModifierAllowed) {\n                    const targetIndex = this._activeItemIndex() + this._pageUpAndDown.delta;\n                    const itemsLength = this._getItemsArray().length;\n                    this._setActiveItemByIndex(targetIndex < itemsLength ? targetIndex : itemsLength - 1, -1);\n                    break;\n                }\n                else {\n                    return;\n                }\n            default:\n                if (isModifierAllowed || hasModifierKey(event, 'shiftKey')) {\n                    this._typeahead?.handleKey(event);\n                }\n                // Note that we return here, in order to avoid preventing\n                // the default action of non-navigational keys.\n                return;\n        }\n        this._typeahead?.reset();\n        event.preventDefault();\n    }\n    /** Index of the currently active item. */\n    get activeItemIndex() {\n        return this._activeItemIndex();\n    }\n    /** The active item. */\n    get activeItem() {\n        return this._activeItem();\n    }\n    /** Gets whether the user is currently typing into the manager using the typeahead feature. */\n    isTyping() {\n        return !!this._typeahead && this._typeahead.isTyping();\n    }\n    /** Sets the active item to the first enabled item in the list. */\n    setFirstItemActive() {\n        this._setActiveItemByIndex(0, 1);\n    }\n    /** Sets the active item to the last enabled item in the list. */\n    setLastItemActive() {\n        this._setActiveItemByIndex(this._getItemsArray().length - 1, -1);\n    }\n    /** Sets the active item to the next enabled item in the list. */\n    setNextItemActive() {\n        this._activeItemIndex() < 0 ? this.setFirstItemActive() : this._setActiveItemByDelta(1);\n    }\n    /** Sets the active item to a previous enabled item in the list. */\n    setPreviousItemActive() {\n        this._activeItemIndex() < 0 && this._wrap\n            ? this.setLastItemActive()\n            : this._setActiveItemByDelta(-1);\n    }\n    updateActiveItem(item) {\n        const itemArray = this._getItemsArray();\n        const index = typeof item === 'number' ? item : itemArray.indexOf(item);\n        const activeItem = itemArray[index];\n        // Explicitly check for `null` and `undefined` because other falsy values are valid.\n        this._activeItem.set(activeItem == null ? null : activeItem);\n        this._activeItemIndex.set(index);\n        this._typeahead?.setCurrentSelectedItemIndex(index);\n    }\n    /** Cleans up the key manager. */\n    destroy() {\n        this._typeaheadSubscription.unsubscribe();\n        this._itemChangesSubscription?.unsubscribe();\n        this._effectRef?.destroy();\n        this._typeahead?.destroy();\n        this.tabOut.complete();\n        this.change.complete();\n    }\n    /**\n     * This method sets the active item, given a list of items and the delta between the\n     * currently active item and the new active item. It will calculate differently\n     * depending on whether wrap mode is turned on.\n     */\n    _setActiveItemByDelta(delta) {\n        this._wrap ? this._setActiveInWrapMode(delta) : this._setActiveInDefaultMode(delta);\n    }\n    /**\n     * Sets the active item properly given \"wrap\" mode. In other words, it will continue to move\n     * down the list until it finds an item that is not disabled, and it will wrap if it\n     * encounters either end of the list.\n     */\n    _setActiveInWrapMode(delta) {\n        const items = this._getItemsArray();\n        for (let i = 1; i <= items.length; i++) {\n            const index = (this._activeItemIndex() + delta * i + items.length) % items.length;\n            const item = items[index];\n            if (!this._skipPredicateFn(item)) {\n                this.setActiveItem(index);\n                return;\n            }\n        }\n    }\n    /**\n     * Sets the active item properly given the default mode. In other words, it will\n     * continue to move down the list until it finds an item that is not disabled. If\n     * it encounters either end of the list, it will stop and not wrap.\n     */\n    _setActiveInDefaultMode(delta) {\n        this._setActiveItemByIndex(this._activeItemIndex() + delta, delta);\n    }\n    /**\n     * Sets the active item to the first enabled item starting at the index specified. If the\n     * item is disabled, it will move in the fallbackDelta direction until it either\n     * finds an enabled item or encounters the end of the list.\n     */\n    _setActiveItemByIndex(index, fallbackDelta) {\n        const items = this._getItemsArray();\n        if (!items[index]) {\n            return;\n        }\n        while (this._skipPredicateFn(items[index])) {\n            index += fallbackDelta;\n            if (!items[index]) {\n                return;\n            }\n        }\n        this.setActiveItem(index);\n    }\n    /** Returns the items as an array. */\n    _getItemsArray() {\n        if (isSignal(this._items)) {\n            return this._items();\n        }\n        return this._items instanceof QueryList ? this._items.toArray() : this._items;\n    }\n    /** Callback for when the items have changed. */\n    _itemsChanged(newItems) {\n        this._typeahead?.setItems(newItems);\n        const activeItem = this._activeItem();\n        if (activeItem) {\n            const newIndex = newItems.indexOf(activeItem);\n            if (newIndex > -1 && newIndex !== this._activeItemIndex()) {\n                this._activeItemIndex.set(newIndex);\n                this._typeahead?.setCurrentSelectedItemIndex(newIndex);\n            }\n        }\n    }\n}\n\nexport { ListKeyManager };\n","let shadowDomIsSupported;\n/** Checks whether the user's browser support Shadow DOM. */\nfunction _supportsShadowDom() {\n    if (shadowDomIsSupported == null) {\n        const head = typeof document !== 'undefined' ? document.head : null;\n        shadowDomIsSupported = !!(head && (head.createShadowRoot || head.attachShadow));\n    }\n    return shadowDomIsSupported;\n}\n/** Gets the shadow root of an element, if supported and the element is inside the Shadow DOM. */\nfunction _getShadowRoot(element) {\n    if (_supportsShadowDom()) {\n        const rootNode = element.getRootNode ? element.getRootNode() : null;\n        // Note that this should be caught by `_supportsShadowDom`, but some\n        // teams have been able to hit this code path on unsupported browsers.\n        if (typeof ShadowRoot !== 'undefined' && ShadowRoot && rootNode instanceof ShadowRoot) {\n            return rootNode;\n        }\n    }\n    return null;\n}\n/**\n * Gets the currently-focused element on the page while\n * also piercing through Shadow DOM boundaries.\n */\nfunction _getFocusedElementPierceShadowDom() {\n    let activeElement = typeof document !== 'undefined' && document\n        ? document.activeElement\n        : null;\n    while (activeElement && activeElement.shadowRoot) {\n        const newActiveElement = activeElement.shadowRoot.activeElement;\n        if (newActiveElement === activeElement) {\n            break;\n        }\n        else {\n            activeElement = newActiveElement;\n        }\n    }\n    return activeElement;\n}\n/** Gets the target of an event while accounting for Shadow DOM. */\nfunction _getEventTarget(event) {\n    // If an event is bound outside the Shadow DOM, the `event.target` will\n    // point to the shadow root so we have to use `composedPath` instead.\n    return (event.composedPath ? event.composedPath()[0] : event.target);\n}\n\nexport { _getEventTarget, _getFocusedElementPierceShadowDom, _getShadowRoot, _supportsShadowDom };\n"],"x_google_ignoreList":[0,1,2,3,4]}