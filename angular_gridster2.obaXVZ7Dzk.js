import { a as k, b as B } from "@nf-internal/chunk-GL2BOVXA";
import { NgStyle as yt } from "@angular/common";
import * as r from "@angular/core";
import { EventEmitter as W, ElementRef as st, Renderer2 as rt, ChangeDetectorRef as wt, NgZone as ot } from "@angular/core";
import { Subject as X, debounceTime as It, takeUntil as K, switchMap as $t, timer as Ct } from "rxjs";
var nt = ["*"];
function xt(n, e) { if (n & 1 && r.\u0275\u0275element(0, "div", 0), n & 2) {
    let t = e.$index, i = r.\u0275\u0275nextContext();
    r.\u0275\u0275property("ngStyle", i.gridRenderer.getGridColumnStyle(t));
} }
function vt(n, e) { if (n & 1 && r.\u0275\u0275element(0, "div", 1), n & 2) {
    let t = e.$index, i = r.\u0275\u0275nextContext();
    r.\u0275\u0275property("ngStyle", i.gridRenderer.getGridRowStyle(t));
} }
function Tt(n, e) { if (n & 1) {
    let t = r.\u0275\u0275getCurrentView();
    r.\u0275\u0275domElementStart(0, "div", 8), r.\u0275\u0275domListener("mousedown", function (s) { r.\u0275\u0275restoreView(t); let o = r.\u0275\u0275nextContext(); return r.\u0275\u0275resetView(o.resize.dragStartDelay(s)); })("touchstart", function (s) { r.\u0275\u0275restoreView(t); let o = r.\u0275\u0275nextContext(); return r.\u0275\u0275resetView(o.resize.dragStartDelay(s)); }), r.\u0275\u0275domElementEnd();
} }
function bt(n, e) { if (n & 1) {
    let t = r.\u0275\u0275getCurrentView();
    r.\u0275\u0275domElementStart(0, "div", 9), r.\u0275\u0275domListener("mousedown", function (s) { r.\u0275\u0275restoreView(t); let o = r.\u0275\u0275nextContext(); return r.\u0275\u0275resetView(o.resize.dragStartDelay(s)); })("touchstart", function (s) { r.\u0275\u0275restoreView(t); let o = r.\u0275\u0275nextContext(); return r.\u0275\u0275resetView(o.resize.dragStartDelay(s)); }), r.\u0275\u0275domElementEnd();
} }
function zt(n, e) { if (n & 1) {
    let t = r.\u0275\u0275getCurrentView();
    r.\u0275\u0275domElementStart(0, "div", 10), r.\u0275\u0275domListener("mousedown", function (s) { r.\u0275\u0275restoreView(t); let o = r.\u0275\u0275nextContext(); return r.\u0275\u0275resetView(o.resize.dragStartDelay(s)); })("touchstart", function (s) { r.\u0275\u0275restoreView(t); let o = r.\u0275\u0275nextContext(); return r.\u0275\u0275resetView(o.resize.dragStartDelay(s)); }), r.\u0275\u0275domElementEnd();
} }
function St(n, e) { if (n & 1) {
    let t = r.\u0275\u0275getCurrentView();
    r.\u0275\u0275domElementStart(0, "div", 11), r.\u0275\u0275domListener("mousedown", function (s) { r.\u0275\u0275restoreView(t); let o = r.\u0275\u0275nextContext(); return r.\u0275\u0275resetView(o.resize.dragStartDelay(s)); })("touchstart", function (s) { r.\u0275\u0275restoreView(t); let o = r.\u0275\u0275nextContext(); return r.\u0275\u0275resetView(o.resize.dragStartDelay(s)); }), r.\u0275\u0275domElementEnd();
} }
function Rt(n, e) { if (n & 1) {
    let t = r.\u0275\u0275getCurrentView();
    r.\u0275\u0275domElementStart(0, "div", 12), r.\u0275\u0275domListener("mousedown", function (s) { r.\u0275\u0275restoreView(t); let o = r.\u0275\u0275nextContext(); return r.\u0275\u0275resetView(o.resize.dragStartDelay(s)); })("touchstart", function (s) { r.\u0275\u0275restoreView(t); let o = r.\u0275\u0275nextContext(); return r.\u0275\u0275resetView(o.resize.dragStartDelay(s)); }), r.\u0275\u0275domElementEnd();
} }
function kt(n, e) { if (n & 1) {
    let t = r.\u0275\u0275getCurrentView();
    r.\u0275\u0275domElementStart(0, "div", 13), r.\u0275\u0275domListener("mousedown", function (s) { r.\u0275\u0275restoreView(t); let o = r.\u0275\u0275nextContext(); return r.\u0275\u0275resetView(o.resize.dragStartDelay(s)); })("touchstart", function (s) { r.\u0275\u0275restoreView(t); let o = r.\u0275\u0275nextContext(); return r.\u0275\u0275resetView(o.resize.dragStartDelay(s)); }), r.\u0275\u0275domElementEnd();
} }
function Pt(n, e) { if (n & 1) {
    let t = r.\u0275\u0275getCurrentView();
    r.\u0275\u0275domElementStart(0, "div", 14), r.\u0275\u0275domListener("mousedown", function (s) { r.\u0275\u0275restoreView(t); let o = r.\u0275\u0275nextContext(); return r.\u0275\u0275resetView(o.resize.dragStartDelay(s)); })("touchstart", function (s) { r.\u0275\u0275restoreView(t); let o = r.\u0275\u0275nextContext(); return r.\u0275\u0275resetView(o.resize.dragStartDelay(s)); }), r.\u0275\u0275domElementEnd();
} }
function Mt(n, e) { if (n & 1) {
    let t = r.\u0275\u0275getCurrentView();
    r.\u0275\u0275domElementStart(0, "div", 15), r.\u0275\u0275domListener("mousedown", function (s) { r.\u0275\u0275restoreView(t); let o = r.\u0275\u0275nextContext(); return r.\u0275\u0275resetView(o.resize.dragStartDelay(s)); })("touchstart", function (s) { r.\u0275\u0275restoreView(t); let o = r.\u0275\u0275nextContext(); return r.\u0275\u0275resetView(o.resize.dragStartDelay(s)); }), r.\u0275\u0275domElementEnd();
} }
var c = (function (n) { return n.Fit = "fit", n.ScrollVertical = "scrollVertical", n.ScrollHorizontal = "scrollHorizontal", n.Fixed = "fixed", n.VerticalFixed = "verticalFixed", n.HorizontalFixed = "horizontalFixed", n; })(c || {}), ht = (function (n) { return n.Always = "always", n.OnDragAndResize = "onDrag&Resize", n.None = "none", n; })(ht || {}), p = (function (n) { return n.None = "none", n.CompactUp = "compactUp", n.CompactLeft = "compactLeft", n.CompactUpAndLeft = "compactUp&Left", n.CompactLeftAndUp = "compactLeft&Up", n.CompactRight = "compactRight", n.CompactUpAndRight = "compactUp&Right", n.CompactRightAndUp = "compactRight&Up", n.CompactDown = "compactDown", n.CompactDownAndLeft = "compactDown&Left", n.CompactLeftAndDown = "compactLeft&Down", n.CompactDownAndRight = "compactDown&Right", n.CompactRightAndDown = "compactRight&Down", n.CompactGrid = "compactGrid", n; })(p || {}), f = (function (n) { return n.LTR = "ltr", n.RTL = "rtl", n; })(f || {}), Y = class {
    gridster;
    constructor(e) { this.gridster = e; }
    destroy() { this.gridster = null; }
    checkCompact() { this.gridster.$options.compactType !== p.None && (this.gridster.$options.compactType === p.CompactUp ? this.checkCompactMovement("y", -1) : this.gridster.$options.compactType === p.CompactLeft ? this.checkCompactMovement("x", -1) : this.gridster.$options.compactType === p.CompactUpAndLeft ? (this.checkCompactMovement("y", -1), this.checkCompactMovement("x", -1)) : this.gridster.$options.compactType === p.CompactLeftAndUp ? (this.checkCompactMovement("x", -1), this.checkCompactMovement("y", -1)) : this.gridster.$options.compactType === p.CompactRight ? this.checkCompactMovement("x", 1) : this.gridster.$options.compactType === p.CompactUpAndRight ? (this.checkCompactMovement("y", -1), this.checkCompactMovement("x", 1)) : this.gridster.$options.compactType === p.CompactRightAndUp ? (this.checkCompactMovement("x", 1), this.checkCompactMovement("y", -1)) : this.gridster.$options.compactType === p.CompactDown ? this.checkCompactMovement("y", 1) : this.gridster.$options.compactType === p.CompactDownAndLeft ? (this.checkCompactMovement("y", 1), this.checkCompactMovement("x", -1)) : this.gridster.$options.compactType === p.CompactDownAndRight ? (this.checkCompactMovement("y", 1), this.checkCompactMovement("x", 1)) : this.gridster.$options.compactType === p.CompactLeftAndDown ? (this.checkCompactMovement("x", -1), this.checkCompactMovement("y", 1)) : this.gridster.$options.compactType === p.CompactRightAndDown ? (this.checkCompactMovement("x", 1), this.checkCompactMovement("y", 1)) : this.gridster.$options.compactType === p.CompactGrid && this.checkCompactGrid()); }
    checkCompactItem(e) { this.gridster.$options.compactType !== p.None && (this.gridster.$options.compactType === p.CompactUp ? this.moveTillCollision(e, "y", -1) : this.gridster.$options.compactType === p.CompactLeft ? this.moveTillCollision(e, "x", -1) : this.gridster.$options.compactType === p.CompactUpAndLeft ? (this.moveTillCollision(e, "y", -1), this.moveTillCollision(e, "x", -1)) : this.gridster.$options.compactType === p.CompactLeftAndUp ? (this.moveTillCollision(e, "x", -1), this.moveTillCollision(e, "y", -1)) : this.gridster.$options.compactType === p.CompactUpAndRight ? (this.moveTillCollision(e, "y", -1), this.moveTillCollision(e, "x", 1)) : this.gridster.$options.compactType === p.CompactDown ? this.moveTillCollision(e, "y", 1) : this.gridster.$options.compactType === p.CompactDownAndLeft ? (this.moveTillCollision(e, "y", 1), this.moveTillCollision(e, "x", -1)) : this.gridster.$options.compactType === p.CompactLeftAndDown ? (this.moveTillCollision(e, "x", -1), this.moveTillCollision(e, "y", 1)) : this.gridster.$options.compactType === p.CompactDownAndRight ? (this.moveTillCollision(e, "y", 1), this.moveTillCollision(e, "x", 1)) : this.gridster.$options.compactType === p.CompactRightAndDown ? (this.moveTillCollision(e, "x", 1), this.moveTillCollision(e, "y", 1)) : this.gridster.$options.compactType === p.CompactGrid && this.moveToGridPosition(e)); }
    checkCompactMovement(e, t) { let i = !1; this.gridster.grid.forEach(s => { s.$item.compactEnabled !== !1 && this.moveTillCollision(s.$item, e, t) && (i = !0, s.item[e] = s.$item[e], s.itemChanged()); }), i && this.checkCompact(); }
    moveTillCollision(e, t, i) { return e[t] += i, this.gridster.checkCollision(e) ? (e[t] -= i, !1) : (this.moveTillCollision(e, t, i), !0); }
    checkCompactGrid() { let e = this.gridster.grid.filter(o => o.$item.compactEnabled !== !1).sort((o, h) => o.$item.y !== h.$item.y ? o.$item.y - h.$item.y : o.$item.x - h.$item.x), t = 0, i = 0, s = 0; e.forEach(o => { let h = o.$item; i + h.cols > this.gridster.columns && (t = s, i = 0, s = t); let l = h.x, a = h.y; h.x = i, h.y = t, (l !== h.x || a !== h.y) && (o.item.x = h.x, o.item.y = h.y, o.itemChanged()), i += h.cols, s = Math.max(s, t + h.rows); }); }
    moveToGridPosition(e) { let t = 0, i = 0, s = 0, o = this.gridster.grid.filter(h => h.$item !== e).sort((h, l) => h.$item.y !== l.$item.y ? h.$item.y - l.$item.y : h.$item.x - l.$item.x); for (let h of o) {
        let l = h.$item;
        i + l.cols > this.gridster.columns && (t = s, i = 0, s = t), t < l.y + l.rows && t + e.rows > l.y && i < l.x + l.cols && i + e.cols > l.x ? (i = l.x + l.cols, t = l.y, s = Math.max(s, t + l.rows)) : (i += l.cols, s = Math.max(s, t + l.rows));
    } i + e.cols > this.gridster.columns && (t = s, i = 0), e.x = i, e.y = t; }
}, Et = { gridType: c.Fit, scale: 1, fixedColWidth: 250, fixedRowHeight: 250, keepFixedHeightInMobile: !1, keepFixedWidthInMobile: !1, setGridSize: !1, compactType: p.None, mobileBreakpoint: 640, useBodyForBreakpoint: !1, allowMultiLayer: !1, defaultLayerIndex: 0, maxLayerIndex: 2, baseLayerIndex: 1, minCols: 1, maxCols: 100, minRows: 1, maxRows: 100, defaultItemCols: 1, defaultItemRows: 1, itemAspectRatio: void 0, maxItemCols: 50, maxItemRows: 50, minItemCols: 1, minItemRows: 1, minItemArea: 1, maxItemArea: 2500, addEmptyRowsCount: 0, rowHeightRatio: 1, margin: 10, outerMargin: !0, outerMarginTop: null, outerMarginRight: null, outerMarginBottom: null, outerMarginLeft: null, useTransformPositioning: !0, scrollSensitivity: 10, scrollSpeed: 20, initCallback: void 0, destroyCallback: void 0, gridSizeChangedCallback: void 0, itemChangeCallback: void 0, itemResizeCallback: void 0, itemInitCallback: void 0, itemRemovedCallback: void 0, itemValidateCallback: void 0, enableEmptyCellClick: !1, enableEmptyCellContextMenu: !1, enableEmptyCellDrop: !1, enableEmptyCellDrag: !1, enableOccupiedCellDrop: !1, emptyCellClickCallback: void 0, emptyCellContextMenuCallback: void 0, emptyCellDropCallback: void 0, emptyCellDragCallback: void 0, emptyCellDragMaxCols: 50, emptyCellDragMaxRows: 50, ignoreMarginInRow: !1, draggable: { delayStart: 0, enabled: !1, ignoreContentClass: "gridster-item-content", ignoreContent: !1, dragHandleClass: "drag-handler", stop: void 0, start: void 0, dropOverItems: !1, dropOverItemsCallback: void 0 }, resizable: { delayStart: 0, enabled: !1, handles: { s: !0, e: !0, n: !0, w: !0, se: !0, ne: !0, sw: !0, nw: !0 }, stop: void 0, start: void 0 }, swap: !0, swapWhileDragging: !1, pushItems: !1, disablePushOnDrag: !1, disablePushOnResize: !1, pushDirections: { north: !0, east: !0, south: !0, west: !0 }, pushResizeItems: !1, displayGrid: ht.OnDragAndResize, disableWindowResize: !1, disableWarnings: !1, scrollToNewItems: !1, disableScrollHorizontal: !1, disableScrollVertical: !1, enableBoundaryControl: !1, disableAutoPositionOnConflict: !1, dirType: f.LTR }, y = class n {
    static merge(e, t, i) { for (let s in t)
        t[s] !== void 0 && i.hasOwnProperty(s) && (typeof t[s] == "object" ? (s in e || (e[s] = {}), e[s] = n.merge(e[s], t[s], i[s])) : e[s] = t[s]); return e; }
    static checkTouchEvent(e) { e.clientX === void 0 && e.touches && (e.touches && e.touches.length ? (e.clientX = e.touches[0].clientX, e.clientY = e.touches[0].clientY) : e.changedTouches && e.changedTouches.length && (e.clientX = e.changedTouches[0].clientX, e.clientY = e.changedTouches[0].clientY)); }
    static checkContentClassForEvent(e, t) { if (e.$options.draggable.ignoreContent) {
        if (!n.checkDragHandleClass(t.target, t.currentTarget, e.$options.draggable.dragHandleClass, e.$options.draggable.ignoreContentClass))
            return !0;
    }
    else if (n.checkContentClass(t.target, t.currentTarget, e.$options.draggable.ignoreContentClass))
        return !0; return !1; }
    static checkContentClassForEmptyCellClickEvent(e, t) { return n.checkContentClass(t.target, t.currentTarget, e.$options.draggable.ignoreContentClass) || n.checkContentClass(t.target, t.currentTarget, e.$options.draggable.dragHandleClass); }
    static checkDragHandleClass(e, t, i, s) { if (!e || e === t)
        return !1; if (e.hasAttribute("class")) {
        let o = e.getAttribute("class").split(" ");
        if (o.indexOf(i) > -1)
            return !0;
        if (o.indexOf(s) > -1)
            return !1;
    } return n.checkDragHandleClass(e.parentNode, t, i, s); }
    static checkContentClass(e, t, i) { return !e || e === t ? !1 : e.hasAttribute("class") && e.getAttribute("class").split(" ").indexOf(i) > -1 ? !0 : n.checkContentClass(e.parentNode, t, i); }
    static compareItems(e, t) { return e.y > t.y ? -1 : e.y < t.y ? 1 : e.x > t.x ? -1 : 1; }
}, N = class {
    gridster;
    initialItem;
    removeEmptyCellClickListenerFn;
    removeEmptyCellTouchendListenerFn;
    removeEmptyCellContextMenuListenerFn;
    removeEmptyCellDropListenerFn;
    removeEmptyCellMousedownListenerFn;
    removeEmptyCellTouchstartListenerFn;
    removeWindowMousemoveListenerFn;
    removeWindowTouchmoveListenerFn;
    removeWindowMouseupListenerFn;
    removeWindowTouchendListenerFn;
    removeEmptyCellDragoverListenerFn;
    removeDocumentDragendListenerFn;
    constructor(e) { this.gridster = e; }
    destroy() { this.gridster.previewStyle && this.gridster.previewStyle(), this.gridster.movingItem = null, this.initialItem = this.gridster = null, this.removeDocumentDragendListenerFn && (this.removeDocumentDragendListenerFn(), this.removeDocumentDragendListenerFn = null); }
    updateOptions() { this.gridster.$options.enableEmptyCellClick && !this.removeEmptyCellClickListenerFn && this.gridster.options.emptyCellClickCallback ? (this.removeEmptyCellClickListenerFn = this.gridster.renderer.listen(this.gridster.el, "click", this.emptyCellClickCb), this.removeEmptyCellTouchendListenerFn = this.gridster.renderer.listen(this.gridster.el, "touchend", this.emptyCellClickCb)) : !this.gridster.$options.enableEmptyCellClick && this.removeEmptyCellClickListenerFn && this.removeEmptyCellTouchendListenerFn && (this.removeEmptyCellClickListenerFn(), this.removeEmptyCellTouchendListenerFn(), this.removeEmptyCellClickListenerFn = null, this.removeEmptyCellTouchendListenerFn = null), this.gridster.$options.enableEmptyCellContextMenu && !this.removeEmptyCellContextMenuListenerFn && this.gridster.options.emptyCellContextMenuCallback ? this.removeEmptyCellContextMenuListenerFn = this.gridster.renderer.listen(this.gridster.el, "contextmenu", this.emptyCellContextMenuCb) : !this.gridster.$options.enableEmptyCellContextMenu && this.removeEmptyCellContextMenuListenerFn && (this.removeEmptyCellContextMenuListenerFn(), this.removeEmptyCellContextMenuListenerFn = null), this.gridster.$options.enableEmptyCellDrop && !this.removeEmptyCellDropListenerFn && this.gridster.options.emptyCellDropCallback ? (this.removeEmptyCellDropListenerFn = this.gridster.renderer.listen(this.gridster.el, "drop", this.emptyCellDragDrop), this.gridster.zone.runOutsideAngular(() => { this.removeEmptyCellDragoverListenerFn = this.gridster.renderer.listen(this.gridster.el, "dragover", this.emptyCellDragOver); }), this.removeDocumentDragendListenerFn = this.gridster.renderer.listen("document", "dragend", () => { this.gridster.movingItem = null, this.gridster.previewStyle(); })) : !this.gridster.$options.enableEmptyCellDrop && this.removeEmptyCellDropListenerFn && this.removeEmptyCellDragoverListenerFn && this.removeDocumentDragendListenerFn && (this.removeEmptyCellDropListenerFn(), this.removeEmptyCellDragoverListenerFn(), this.removeDocumentDragendListenerFn(), this.removeEmptyCellDragoverListenerFn = null, this.removeEmptyCellDropListenerFn = null, this.removeDocumentDragendListenerFn = null), this.gridster.$options.enableEmptyCellDrag && !this.removeEmptyCellMousedownListenerFn && this.gridster.options.emptyCellDragCallback ? (this.removeEmptyCellMousedownListenerFn = this.gridster.renderer.listen(this.gridster.el, "mousedown", this.emptyCellMouseDown), this.removeEmptyCellTouchstartListenerFn = this.gridster.renderer.listen(this.gridster.el, "touchstart", this.emptyCellMouseDown)) : !this.gridster.$options.enableEmptyCellDrag && this.removeEmptyCellMousedownListenerFn && this.removeEmptyCellTouchstartListenerFn && (this.removeEmptyCellMousedownListenerFn(), this.removeEmptyCellTouchstartListenerFn(), this.removeEmptyCellMousedownListenerFn = null, this.removeEmptyCellTouchstartListenerFn = null); }
    emptyCellClickCb = e => { if (!this.gridster || this.gridster.movingItem || y.checkContentClassForEmptyCellClickEvent(this.gridster, e))
        return; let t = this.getValidItemFromEvent(e); t && (this.gridster.options.emptyCellClickCallback && this.gridster.options.emptyCellClickCallback(e, t), this.gridster.cdRef.markForCheck()); };
    emptyCellContextMenuCb = e => { if (this.gridster.movingItem || y.checkContentClassForEmptyCellClickEvent(this.gridster, e))
        return; e.preventDefault(), e.stopPropagation(); let t = this.getValidItemFromEvent(e); t && (this.gridster.options.emptyCellContextMenuCallback && this.gridster.options.emptyCellContextMenuCallback(e, t), this.gridster.cdRef.markForCheck()); };
    emptyCellDragDrop = e => { let t = this.getValidItemFromEvent(e); t && (this.gridster.options.emptyCellDropCallback && this.gridster.options.emptyCellDropCallback(e, t), this.gridster.cdRef.markForCheck()); };
    emptyCellDragOver = e => { e.preventDefault(), e.stopPropagation(); let t = this.getValidItemFromEvent(e); t ? (e.dataTransfer && (e.dataTransfer.dropEffect = "move"), this.gridster.movingItem = t) : (e.dataTransfer && (e.dataTransfer.dropEffect = "none"), this.gridster.movingItem = null), this.gridster.previewStyle(); };
    emptyCellMouseDown = e => { if (y.checkContentClassForEmptyCellClickEvent(this.gridster, e))
        return; e.preventDefault(), e.stopPropagation(); let t = this.getValidItemFromEvent(e); !t || e.buttons !== 1 && !(e instanceof TouchEvent) || (this.initialItem = t, this.gridster.movingItem = t, this.gridster.previewStyle(), this.gridster.zone.runOutsideAngular(() => { this.removeWindowMousemoveListenerFn = this.gridster.renderer.listen("window", "mousemove", this.emptyCellMouseMove), this.removeWindowTouchmoveListenerFn = this.gridster.renderer.listen("window", "touchmove", this.emptyCellMouseMove); }), this.removeWindowMouseupListenerFn = this.gridster.renderer.listen("window", "mouseup", this.emptyCellMouseUp), this.removeWindowTouchendListenerFn = this.gridster.renderer.listen("window", "touchend", this.emptyCellMouseUp)); };
    emptyCellMouseMove = e => { e.preventDefault(), e.stopPropagation(); let t = this.getValidItemFromEvent(e, this.initialItem); t && (this.gridster.movingItem = t, this.gridster.previewStyle()); };
    emptyCellMouseUp = e => { this.removeWindowMousemoveListenerFn(), this.removeWindowTouchmoveListenerFn(), this.removeWindowMouseupListenerFn(), this.removeWindowTouchendListenerFn(); let t = this.getValidItemFromEvent(e, this.initialItem); t && (this.gridster.movingItem = t), this.gridster.options.emptyCellDragCallback && this.gridster.movingItem && this.gridster.options.emptyCellDragCallback(e, this.gridster.movingItem), setTimeout(() => { this.initialItem = null, this.gridster && (this.gridster.movingItem = null, this.gridster.previewStyle()); }), this.gridster.cdRef.markForCheck(); };
    getPixelsX(e, t) { let i = this.gridster.options.scale; return i ? (e.clientX - t.left) / i + this.gridster.el.scrollLeft - this.gridster.gridRenderer.getLeftMargin() : e.clientX + this.gridster.el.scrollLeft - t.left - this.gridster.gridRenderer.getLeftMargin(); }
    getPixelsY(e, t) { let i = this.gridster.options.scale; return i ? (e.clientY - t.top) / i + this.gridster.el.scrollTop - this.gridster.gridRenderer.getTopMargin() : e.clientY + this.gridster.el.scrollTop - t.top - this.gridster.gridRenderer.getTopMargin(); }
    getValidItemFromEvent(e, t) { e.preventDefault(), e.stopPropagation(), y.checkTouchEvent(e); let i = this.gridster.el.getBoundingClientRect(), s = this.getPixelsX(e, i), o = this.getPixelsY(e, i), h = { x: this.gridster.pixelsToPositionX(s, Math.floor, !0), y: this.gridster.pixelsToPositionY(o, Math.floor, !0), cols: this.gridster.$options.defaultItemCols, rows: this.gridster.$options.defaultItemRows }; if (t && (h.cols = Math.min(Math.abs(t.x - h.x) + 1, this.gridster.$options.emptyCellDragMaxCols), h.rows = Math.min(Math.abs(t.y - h.y) + 1, this.gridster.$options.emptyCellDragMaxRows), t.x < h.x ? h.x = t.x : t.x - h.x > this.gridster.$options.emptyCellDragMaxCols - 1 && (h.x = this.gridster.movingItem ? this.gridster.movingItem.x : 0), t.y < h.y ? h.y = t.y : t.y - h.y > this.gridster.$options.emptyCellDragMaxRows - 1 && (h.y = this.gridster.movingItem ? this.gridster.movingItem.y : 0)), !(!this.gridster.$options.enableOccupiedCellDrop && this.gridster.checkCollision(h)))
        return h; }
}, O = class {
    gridster;
    lastGridColumnStyles = {};
    lastGridRowStyles = {};
    constructor(e) { this.gridster = e; }
    destroy() { this.gridster = null; }
    updateItem(e, t, i) { if (this.gridster.mobile)
        this.clearCellPosition(i, e), this.gridster.$options.keepFixedHeightInMobile ? i.setStyle(e, "height", (t.rows - 1) * this.gridster.$options.margin + t.rows * this.gridster.$options.fixedRowHeight + "px") : i.setStyle(e, "height", t.rows * this.gridster.curWidth / t.cols + "px"), this.gridster.$options.keepFixedWidthInMobile ? i.setStyle(e, "width", this.gridster.$options.fixedColWidth + "px") : i.setStyle(e, "width", ""), i.setStyle(e, "margin-bottom", this.gridster.$options.margin + "px"), i.setStyle(e, f.LTR ? "margin-right" : "margin-left", "");
    else {
        let s = Math.round(this.gridster.curColWidth * t.x), o = Math.round(this.gridster.curRowHeight * t.y), h = this.gridster.curColWidth * t.cols - this.gridster.$options.margin, l = this.gridster.curRowHeight * t.rows - this.gridster.$options.margin;
        this.setCellPosition(i, e, s, o), i.setStyle(e, "width", h + "px"), i.setStyle(e, "height", l + "px");
        let a = null, d = null;
        this.gridster.$options.outerMargin && (this.gridster.rows === t.rows + t.y && (this.gridster.$options.outerMarginBottom !== null ? a = this.gridster.$options.outerMarginBottom + "px" : a = this.gridster.$options.margin + "px"), this.gridster.columns === t.cols + t.x && (this.gridster.$options.outerMarginBottom !== null ? d = this.gridster.$options.outerMarginRight + "px" : d = this.gridster.$options.margin + "px")), i.setStyle(e, "margin-bottom", a), i.setStyle(e, this.gridster.$options.dirType === f.LTR ? "margin-right" : "margin-left", d);
    } }
    updateGridster() { let e = "", t = "", i = "", s = ""; if (this.gridster.$options.gridType === c.Fit)
        e = c.Fit, t = c.ScrollVertical, i = c.ScrollHorizontal, s = c.Fixed;
    else if (this.gridster.$options.gridType === c.ScrollVertical)
        this.gridster.curRowHeight = this.gridster.curColWidth * this.gridster.$options.rowHeightRatio, e = c.ScrollVertical, t = c.Fit, i = c.ScrollHorizontal, s = c.Fixed;
    else if (this.gridster.$options.gridType === c.ScrollHorizontal) {
        let o = this.gridster.$options.rowHeightRatio, h = o >= 1 ? o : o + 1;
        this.gridster.curColWidth = this.gridster.curRowHeight * h, e = c.ScrollHorizontal, t = c.Fit, i = c.ScrollVertical, s = c.Fixed;
    }
    else
        this.gridster.$options.gridType === c.Fixed ? (this.gridster.curColWidth = this.gridster.$options.fixedColWidth + (this.gridster.$options.ignoreMarginInRow ? 0 : this.gridster.$options.margin), this.gridster.curRowHeight = this.gridster.$options.fixedRowHeight + (this.gridster.$options.ignoreMarginInRow ? 0 : this.gridster.$options.margin), e = c.Fixed, t = c.Fit, i = c.ScrollVertical, s = c.ScrollHorizontal) : this.gridster.$options.gridType === c.VerticalFixed ? (this.gridster.curRowHeight = this.gridster.$options.fixedRowHeight + (this.gridster.$options.ignoreMarginInRow ? 0 : this.gridster.$options.margin), e = c.ScrollVertical, t = c.Fit, i = c.ScrollHorizontal, s = c.Fixed) : this.gridster.$options.gridType === c.HorizontalFixed && (this.gridster.curColWidth = this.gridster.$options.fixedColWidth + (this.gridster.$options.ignoreMarginInRow ? 0 : this.gridster.$options.margin), e = c.ScrollHorizontal, t = c.Fit, i = c.ScrollVertical, s = c.Fixed); this.gridster.mobile || this.gridster.$options.setGridSize && this.gridster.$options.gridType !== c.Fit ? this.gridster.renderer.removeClass(this.gridster.el, e) : this.gridster.renderer.addClass(this.gridster.el, e), this.gridster.renderer.removeClass(this.gridster.el, t), this.gridster.renderer.removeClass(this.gridster.el, i), this.gridster.renderer.removeClass(this.gridster.el, s); }
    getGridColumnStyle(e) { let t = { left: this.gridster.curColWidth * e, width: this.gridster.curColWidth - this.gridster.$options.margin, height: this.gridster.gridRows.length * this.gridster.curRowHeight - this.gridster.$options.margin, style: {} }; t.style = B(k({}, this.getLeftPosition(t.left)), { width: t.width + "px", height: t.height + "px" }); let i = this.lastGridColumnStyles[e]; return i && i.left === t.left && i.width === t.width && i.height === t.height ? i.style : (this.lastGridColumnStyles[e] = t, t.style); }
    getGridRowStyle(e) { let t = { top: this.gridster.curRowHeight * e, width: this.gridster.gridColumns.length * this.gridster.curColWidth + this.gridster.$options.margin, height: this.gridster.curRowHeight - this.gridster.$options.margin, style: {} }; t.style = B(k({}, this.getTopPosition(t.top)), { width: t.width + "px", height: t.height + "px" }); let i = this.lastGridRowStyles[e]; return i && i.top === t.top && i.width === t.width && i.height === t.height ? i.style : (this.lastGridRowStyles[e] = t, t.style); }
    getLeftPosition(e) { let t = this.gridster.$options.dirType === f.RTL ? -e : e; return this.gridster.$options.useTransformPositioning ? { transform: "translateX(" + t + "px)" } : { left: this.getLeftMargin() + t + "px" }; }
    getTopPosition(e) { return this.gridster.$options.useTransformPositioning ? { transform: "translateY(" + e + "px)" } : { top: this.getTopMargin() + e + "px" }; }
    clearCellPosition(e, t) { this.gridster.$options.useTransformPositioning ? e.setStyle(t, "transform", "") : (e.setStyle(t, "top", ""), e.setStyle(t, "left", "")); }
    setCellPosition(e, t, i, s) { let o = this.gridster.$options.dirType === f.RTL ? -i : i; if (this.gridster.$options.useTransformPositioning) {
        let h = "translate3d(" + o + "px, " + s + "px, 0)";
        e.setStyle(t, "transform", h);
    }
    else
        e.setStyle(t, "left", this.getLeftMargin() + o + "px"), e.setStyle(t, "top", this.getTopMargin() + s + "px"); }
    getLeftMargin() { return this.gridster.$options.outerMargin ? this.gridster.$options.outerMarginLeft !== null ? this.gridster.$options.outerMarginLeft : this.gridster.$options.margin : 0; }
    getTopMargin() { return this.gridster.$options.outerMargin ? this.gridster.$options.outerMarginTop !== null ? this.gridster.$options.outerMarginTop : this.gridster.$options.margin : 0; }
}, Lt = (() => {
    class n {
        renderer;
        previewStyle$;
        gridRenderer;
        el;
        sub;
        constructor(t, i) { this.renderer = i, this.el = t.nativeElement; }
        ngOnInit() { this.sub = this.previewStyle$.subscribe(t => this.previewStyle(t)); }
        ngOnDestroy() { this.sub && this.sub.unsubscribe(); }
        previewStyle(t) { t ? (this.renderer.setStyle(this.el, "display", "block"), this.gridRenderer.updateItem(this.el, t, this.renderer)) : this.renderer.setStyle(this.el, "display", ""); }
        static \u0275fac = function (i) { return new (i || n)(r.\u0275\u0275directiveInject(r.ElementRef), r.\u0275\u0275directiveInject(r.Renderer2)); };
        static \u0275cmp = r.\u0275\u0275defineComponent({ type: n, selectors: [["gridster-preview"]], inputs: { previewStyle$: "previewStyle$", gridRenderer: "gridRenderer" }, decls: 0, vars: 0, template: function (i, s) { }, styles: [`gridster-preview{position:absolute;display:none;background:#00000026}
`], encapsulation: 2 });
    }
    return n;
})(), Ft = (() => {
    class n {
        renderer;
        cdRef;
        zone;
        options;
        movingItem;
        el;
        $options;
        mobile;
        curWidth;
        curHeight;
        grid;
        columns = 0;
        rows = 0;
        curColWidth;
        curRowHeight;
        gridColumns = [];
        gridRows = [];
        windowResize;
        dragInProgress;
        emptyCell;
        compact;
        gridRenderer;
        previewStyle$ = new W;
        calculateLayout$ = new X;
        resize$ = new X;
        destroy$ = new X;
        constructor(t, i, s, o) { this.renderer = i, this.cdRef = s, this.zone = o, this.el = t.nativeElement, this.$options = JSON.parse(JSON.stringify(Et)), this.mobile = !1, this.curWidth = 0, this.curHeight = 0, this.grid = [], this.curColWidth = 0, this.curRowHeight = 0, this.dragInProgress = !1, this.emptyCell = new N(this), this.compact = new Y(this), this.gridRenderer = new O(this); }
        static checkCollisionTwoItemsForSwaping(t, i) { let s = t.cols === 1 ? 0 : 1, o = i.cols === 1 ? 0 : 1, h = t.rows === 1 ? 0 : 1, l = i.rows === 1 ? 0 : 1; return t.x + s < i.x + i.cols && t.x + t.cols > i.x + o && t.y + h < i.y + i.rows && t.y + t.rows > i.y + l; }
        checkCollisionTwoItems(t, i) { if (!(t.x < i.x + i.cols && t.x + t.cols > i.x && t.y < i.y + i.rows && t.y + t.rows > i.y))
            return !1; if (!this.$options.allowMultiLayer)
            return !0; let o = this.$options.defaultLayerIndex, h = t.layerIndex === void 0 ? o : t.layerIndex, l = i.layerIndex === void 0 ? o : i.layerIndex; return h === l; }
        ngOnInit() { this.options.initCallback && this.options.initCallback(this), this.calculateLayout$.pipe(It(0), K(this.destroy$)).subscribe(() => this.calculateLayout()), this.resize$.pipe($t(() => Ct(100)), K(this.destroy$)).subscribe(() => this.resize()); }
        ngOnChanges(t) { t.options && (this.setOptions(), this.options.api = { optionsChanged: this.optionsChanged, resize: this.onResize, getNextPossiblePosition: this.getNextPossiblePosition, getFirstPossiblePosition: this.getFirstPossiblePosition, getLastPossiblePosition: this.getLastPossiblePosition, getItemComponent: i => this.getItemComponent(i) }, this.columns = this.$options.minCols, this.rows = this.$options.minRows + this.$options.addEmptyRowsCount, this.setGridSize(), this.calculateLayout()); }
        resize() { let t, i; this.$options.gridType === "fit" && !this.mobile ? (i = this.el.offsetWidth, t = this.el.offsetHeight) : (i = this.el.clientWidth, t = this.el.clientHeight), (i !== this.curWidth || t !== this.curHeight) && this.checkIfToResize() && this.onResize(); }
        setOptions() { this.$options = y.merge(this.$options, this.options, this.$options), !this.$options.disableWindowResize && !this.windowResize ? this.windowResize = this.renderer.listen("window", "resize", this.onResize) : this.$options.disableWindowResize && this.windowResize && (this.windowResize(), this.windowResize = null), this.emptyCell.updateOptions(); }
        optionsChanged = () => { this.setOptions(); let t = this.grid.length - 1, i; for (; t >= 0; t--)
            i = this.grid[t], i.updateOptions(); this.calculateLayout(); };
        ngOnDestroy() { this.destroy$.next(), this.previewStyle$.complete(), this.windowResize && this.windowResize(), this.options && this.options.destroyCallback && this.options.destroyCallback(this), this.options && this.options.api && (this.options.api.resize = void 0, this.options.api.optionsChanged = void 0, this.options.api.getNextPossiblePosition = void 0, this.options.api = void 0), this.emptyCell.destroy(), this.emptyCell = null, this.compact.destroy(), this.compact = null; }
        onResize = () => { this.el.clientWidth && (this.options.setGridSize && (this.renderer.setStyle(this.el, "width", ""), this.renderer.setStyle(this.el, "height", "")), this.setGridSize(), this.calculateLayout()); };
        checkIfToResize() { let t = this.el.clientWidth, i = this.el.offsetWidth, s = this.el.scrollWidth, o = this.el.clientHeight, h = this.el.offsetHeight, l = this.el.scrollHeight, a = t < i && l > h && l - h < i - t, d = o < h && s > i && s - i < h - o; return a ? !1 : !d; }
        checkIfMobile() { return this.$options.useBodyForBreakpoint ? this.$options.mobileBreakpoint > document.body.clientWidth : this.$options.mobileBreakpoint > this.curWidth; }
        setGridSize() { let t = this.el, i, s; this.$options.setGridSize || this.$options.gridType === c.Fit && !this.mobile ? (i = t.offsetWidth, s = t.offsetHeight) : (i = t.clientWidth, s = t.clientHeight), this.curWidth = i, this.curHeight = s; }
        setGridDimensions() { this.setGridSize(), !this.mobile && this.checkIfMobile() ? (this.mobile = !this.mobile, this.renderer.addClass(this.el, "mobile")) : this.mobile && !this.checkIfMobile() && (this.mobile = !this.mobile, this.renderer.removeClass(this.el, "mobile")); let t = this.$options.minRows, i = this.$options.minCols, s = this.grid.length - 1, o; for (; s >= 0; s--)
            o = this.grid[s], o.notPlaced || (t = Math.max(t, o.$item.y + o.$item.rows), i = Math.max(i, o.$item.x + o.$item.cols)); t += this.$options.addEmptyRowsCount, (this.columns !== i || this.rows !== t) && (this.columns = i, this.rows = t, this.options.gridSizeChangedCallback && this.options.gridSizeChangedCallback(this)); }
        calculateLayout() { if (this.compact && this.compact.checkCompact(), this.setGridDimensions(), this.$options.outerMargin) {
            let s = -this.$options.margin;
            this.$options.outerMarginLeft !== null ? (s += this.$options.outerMarginLeft, this.renderer.setStyle(this.el, "padding-left", this.$options.outerMarginLeft + "px")) : (s += this.$options.margin, this.renderer.setStyle(this.el, "padding-left", this.$options.margin + "px")), this.$options.outerMarginRight !== null ? (s += this.$options.outerMarginRight, this.renderer.setStyle(this.el, "padding-right", this.$options.outerMarginRight + "px")) : (s += this.$options.margin, this.renderer.setStyle(this.el, "padding-right", this.$options.margin + "px")), this.curColWidth = (this.curWidth - s) / this.columns;
            let o = -this.$options.margin;
            this.$options.outerMarginTop !== null ? (o += this.$options.outerMarginTop, this.renderer.setStyle(this.el, "padding-top", this.$options.outerMarginTop + "px")) : (o += this.$options.margin, this.renderer.setStyle(this.el, "padding-top", this.$options.margin + "px")), this.$options.outerMarginBottom !== null ? (o += this.$options.outerMarginBottom, this.renderer.setStyle(this.el, "padding-bottom", this.$options.outerMarginBottom + "px")) : (o += this.$options.margin, this.renderer.setStyle(this.el, "padding-bottom", this.$options.margin + "px")), this.curRowHeight = (this.curHeight - o) / this.rows * this.$options.rowHeightRatio;
        }
        else
            this.curColWidth = (this.curWidth + this.$options.margin) / this.columns, this.curRowHeight = (this.curHeight + this.$options.margin) / this.rows * this.$options.rowHeightRatio, this.renderer.setStyle(this.el, "padding-left", "0px"), this.renderer.setStyle(this.el, "padding-right", "0px"), this.renderer.setStyle(this.el, "padding-top", "0px"), this.renderer.setStyle(this.el, "padding-bottom", "0px"); this.gridRenderer.updateGridster(), this.$options.setGridSize ? (this.renderer.addClass(this.el, "gridSize"), this.mobile || (this.renderer.setStyle(this.el, "width", this.columns * this.curColWidth + this.$options.margin + "px"), this.renderer.setStyle(this.el, "height", this.rows * this.curRowHeight + this.$options.margin + "px"))) : (this.renderer.removeClass(this.el, "gridSize"), this.renderer.setStyle(this.el, "width", ""), this.renderer.setStyle(this.el, "height", "")), this.updateGrid(); let t = this.grid.length - 1, i; for (; t >= 0; t--)
            i = this.grid[t], i.setSize(), i.drag.toggle(), i.resize.toggle(); this.resize$.next(); }
        updateGrid() { this.$options.displayGrid === "always" && !this.mobile ? this.renderer.addClass(this.el, "display-grid") : this.$options.displayGrid === "onDrag&Resize" && this.dragInProgress ? this.renderer.addClass(this.el, "display-grid") : (this.$options.displayGrid === "none" || !this.dragInProgress || this.mobile) && this.renderer.removeClass(this.el, "display-grid"), this.setGridDimensions(), this.gridColumns.length = n.getNewArrayLength(this.columns, this.curWidth, this.curColWidth), this.gridRows.length = n.getNewArrayLength(this.rows, this.curHeight, this.curRowHeight), this.cdRef.markForCheck(); }
        addItem(t) { t.$item.cols === void 0 && (t.$item.cols = this.$options.defaultItemCols, t.item.cols = t.$item.cols, t.itemChanged()), t.$item.rows === void 0 && (t.$item.rows = this.$options.defaultItemRows, t.item.rows = t.$item.rows, t.itemChanged()), t.$item.x === -1 || t.$item.y === -1 ? this.autoPositionItem(t) : this.checkCollision(t.$item) && (this.$options.disableWarnings || (t.notPlaced = !0, console.warn("Can't be placed in the bounds of the dashboard, trying to auto position!/n" + JSON.stringify(t.item, ["cols", "rows", "x", "y"]))), this.$options.disableAutoPositionOnConflict ? t.notPlaced = !0 : this.autoPositionItem(t)), this.grid.push(t), this.calculateLayout$.next(); }
        removeItem(t) { this.grid.splice(this.grid.indexOf(t), 1), this.calculateLayout$.next(), this.options.itemRemovedCallback && this.options.itemRemovedCallback(t.item, t); }
        checkCollision(t, i) { let s = !1; if (this.options.itemValidateCallback && (s = !this.options.itemValidateCallback(t)), !s && this.checkGridCollision(t, i) && (s = !0), !s) {
            let o = this.findItemWithItem(t);
            o && (s = o);
        } return s; }
        checkGridCollision(t, i = !1) { let s = t.y > -1 && t.x > -1, o = t.cols + t.x <= this.$options.maxCols, h = t.rows + t.y <= this.$options.maxRows, l = t.maxItemCols === void 0 ? this.$options.maxItemCols : t.maxItemCols, a = t.minItemCols === void 0 ? this.$options.minItemCols : t.minItemCols, d = t.maxItemRows === void 0 ? this.$options.maxItemRows : t.maxItemRows, u = t.minItemRows === void 0 ? this.$options.minItemRows : t.minItemRows, m = t.cols <= l && t.cols >= a, g = t.rows <= d && t.rows >= u, $ = !0; if (i) {
            let z = t.itemAspectRatio || this.$options.itemAspectRatio;
            z && ($ = t.cols / t.rows === z);
        } let T = t.minItemArea === void 0 ? this.$options.minItemArea : t.minItemArea, b = t.maxItemArea === void 0 ? this.$options.maxItemArea : t.maxItemArea, C = t.cols * t.rows, v = T <= C, R = b >= C; return !(s && o && h && $ && m && g && v && R); }
        findItemWithItem(t) { let i = 0, s; for (; i < this.grid.length; i++)
            if (s = this.grid[i], s.$item !== t && this.checkCollisionTwoItems(s.$item, t))
                return s; return !1; }
        findItemsWithItem(t) { let i = [], s = 0, o; for (; s < this.grid.length; s++)
            o = this.grid[s], o.$item !== t && this.checkCollisionTwoItems(o.$item, t) && i.push(o); return i; }
        autoPositionItem(t) { this.getNextPossiblePosition(t.$item) ? (t.notPlaced = !1, t.item.x = t.$item.x, t.item.y = t.$item.y, t.itemChanged()) : (t.notPlaced = !0, this.$options.disableWarnings || console.warn("Can't be placed in the bounds of the dashboard!/n" + JSON.stringify(t.item, ["cols", "rows", "x", "y"]))); }
        getNextPossiblePosition = (t, i = {}) => { t.cols === -1 && (t.cols = this.$options.defaultItemCols), t.rows === -1 && (t.rows = this.$options.defaultItemRows), this.setGridDimensions(); let s = i.y || 0, o; for (; s < this.rows; s++)
            for (t.y = s, o = i.x || 0; o < this.columns; o++)
                if (t.x = o, !this.checkCollision(t))
                    return !0; let h = this.$options.maxRows >= this.rows + t.rows, l = this.$options.maxCols >= this.columns + t.cols; return !(this.rows <= this.columns && h) && l ? (t.x = this.columns, t.y = 0, !0) : h ? (t.y = this.rows, t.x = 0, !0) : !1; };
        getFirstPossiblePosition = t => { let i = Object.assign({}, t); return this.getNextPossiblePosition(i), i; };
        getLastPossiblePosition = t => { let i = { y: 0, x: 0 }; i = this.grid.reduce((o, h) => { let l = { y: h.$item.y + h.$item.rows - 1, x: h.$item.x + h.$item.cols - 1 }; return y.compareItems(o, l) === 1 ? l : o; }, i); let s = Object.assign({}, t); return this.getNextPossiblePosition(s, i), s; };
        pixelsToPositionX(t, i, s) { let o = i(t / this.curColWidth); return s ? o : Math.max(o, 0); }
        pixelsToPositionY(t, i, s) { let o = i(t / this.curRowHeight); return s ? o : Math.max(o, 0); }
        positionXToPixels(t) { return t * this.curColWidth; }
        positionYToPixels(t) { return t * this.curRowHeight; }
        getItemComponent(t) { return this.grid.find(i => i.item === t); }
        checkCollisionForSwaping(t) { let i = !1; if (this.options.itemValidateCallback && (i = !this.options.itemValidateCallback(t)), !i && this.checkGridCollision(t) && (i = !0), !i) {
            let s = this.findItemWithItemForSwapping(t);
            s && (i = s);
        } return i; }
        findItemWithItemForSwapping(t) { let i = this.grid.length - 1, s; for (; i > -1; i--)
            if (s = this.grid[i], s.$item !== t && n.checkCollisionTwoItemsForSwaping(s.$item, t))
                return s; return !1; }
        previewStyle(t = !1) { this.movingItem ? (this.compact && t && this.compact.checkCompactItem(this.movingItem), this.previewStyle$.next(this.movingItem)) : this.previewStyle$.next(null); }
        static getNewArrayLength(t, i, s) { let o = Math.max(t, Math.floor(i / s)); return o < 0 ? 0 : Number.isFinite(o) ? Math.floor(o) : 0; }
        static \u0275fac = function (i) { return new (i || n)(r.\u0275\u0275directiveInject(st), r.\u0275\u0275directiveInject(rt), r.\u0275\u0275directiveInject(wt), r.\u0275\u0275directiveInject(ot)); };
        static \u0275cmp = r.\u0275\u0275defineComponent({ type: n, selectors: [["gridster"]], inputs: { options: "options" }, features: [r.\u0275\u0275NgOnChangesFeature], ngContentSelectors: nt, decls: 6, vars: 2, consts: [[1, "gridster-column", 3, "ngStyle"], [1, "gridster-row", 3, "ngStyle"], [1, "gridster-preview", 3, "gridRenderer", "previewStyle$"]], template: function (i, s) { i & 1 && (r.\u0275\u0275projectionDef(), r.\u0275\u0275repeaterCreate(0, xt, 1, 1, "div", 0, r.\u0275\u0275repeaterTrackByIndex), r.\u0275\u0275repeaterCreate(2, vt, 1, 1, "div", 1, r.\u0275\u0275repeaterTrackByIndex), r.\u0275\u0275projection(4), r.\u0275\u0275element(5, "gridster-preview", 2)), i & 2 && (r.\u0275\u0275repeater(s.gridColumns), r.\u0275\u0275advance(2), r.\u0275\u0275repeater(s.gridRows), r.\u0275\u0275advance(3), r.\u0275\u0275property("gridRenderer", s.gridRenderer)("previewStyle$", s.previewStyle$)); }, dependencies: [yt, Lt], styles: [`gridster{position:relative;box-sizing:border-box;background:gray;width:100%;height:100%;-webkit-user-select:none;user-select:none;display:block}gridster.fit{overflow-x:hidden;overflow-y:hidden}gridster.scrollVertical{overflow-x:hidden;overflow-y:auto}gridster.scrollHorizontal{overflow-x:auto;overflow-y:hidden}gridster.fixed{overflow:auto}gridster.mobile{overflow-x:hidden;overflow-y:auto}gridster.mobile gridster-item{position:relative}gridster.gridSize{height:initial;width:initial}gridster.gridSize.fit{height:100%;width:100%}gridster .gridster-column,gridster .gridster-row{position:absolute;display:none;transition:.3s;box-sizing:border-box}gridster.display-grid .gridster-column,gridster.display-grid .gridster-row{display:block}gridster .gridster-column{border-left:1px solid white;border-right:1px solid white}gridster .gridster-row{border-top:1px solid white;border-bottom:1px solid white}
`], encapsulation: 2 });
    }
    return n;
})(), H = class {
    fromSouth;
    fromNorth;
    fromEast;
    fromWest;
    pushedItems;
    pushedItemsTemp;
    pushedItemsTempPath;
    pushedItemsPath;
    gridsterItem;
    gridster;
    pushedItemsOrder;
    tryPattern;
    iteration = 0;
    constructor(e) { this.pushedItems = [], this.pushedItemsTemp = [], this.pushedItemsTempPath = [], this.pushedItemsPath = [], this.gridsterItem = e, this.gridster = e.gridster, this.tryPattern = { fromEast: [this.tryWest, this.trySouth, this.tryNorth, this.tryEast], fromWest: [this.tryEast, this.trySouth, this.tryNorth, this.tryWest], fromNorth: [this.trySouth, this.tryEast, this.tryWest, this.tryNorth], fromSouth: [this.tryNorth, this.tryEast, this.tryWest, this.trySouth] }, this.fromSouth = "fromSouth", this.fromNorth = "fromNorth", this.fromEast = "fromEast", this.fromWest = "fromWest"; }
    destroy() { this.gridster = this.gridsterItem = null; }
    pushItems(e, t) { if (this.gridster.$options.pushItems && !t) {
        this.pushedItemsOrder = [], this.iteration = 0;
        let i = this.push(this.gridsterItem, e);
        return i || this.restoreTempItems(), this.pushedItemsOrder = [], this.pushedItemsTemp = [], this.pushedItemsTempPath = [], i;
    }
    else
        return !1; }
    restoreTempItems() { let e = this.pushedItemsTemp.length - 1; for (; e > -1; e--)
        this.removeFromTempPushed(this.pushedItemsTemp[e]); }
    restoreItems() { let e = 0, t = this.pushedItems.length, i; for (; e < t; e++)
        i = this.pushedItems[e], i.$item.x = i.item.x || 0, i.$item.y = i.item.y || 0, i.setSize(); this.pushedItems = [], this.pushedItemsPath = []; }
    setPushedItems() { let e = 0, t = this.pushedItems.length, i; for (; e < t; e++)
        i = this.pushedItems[e], i.checkItemChanges(i.$item, i.item); this.pushedItems = [], this.pushedItemsPath = []; }
    checkPushBack() { let e = this.pushedItems.length - 1, t = !1; for (; e > -1; e--)
        this.checkPushedItem(this.pushedItems[e], e) && (t = !0); t && this.checkPushBack(); }
    push(e, t) { if (this.iteration > 100)
        return console.warn("max iteration reached"), !1; if (this.gridster.checkGridCollision(e.$item) || t === "")
        return !1; let i = this.gridster.findItemsWithItem(e.$item), s = t === this.fromNorth || t === this.fromWest; i.sort((d, u) => s ? u.$item.y - d.$item.y || u.$item.x - d.$item.x : d.$item.y - u.$item.y || d.$item.x - u.$item.x); let o = 0, h, l = !0, a = []; for (; o < i.length; o++) {
        if (h = i[o], h === this.gridsterItem)
            continue;
        if (!h.canBeDragged()) {
            l = !1;
            break;
        }
        let d = this.pushedItemsTemp.indexOf(h);
        if (d > -1 && this.pushedItemsTempPath[d].length > 10) {
            l = !1;
            break;
        }
        if (this.tryPattern[t][0].call(this, h, e))
            this.pushedItemsOrder.push(h), a.push(h);
        else if (this.tryPattern[t][1].call(this, h, e))
            this.pushedItemsOrder.push(h), a.push(h);
        else if (this.tryPattern[t][2].call(this, h, e))
            this.pushedItemsOrder.push(h), a.push(h);
        else if (this.tryPattern[t][3].call(this, h, e))
            this.pushedItemsOrder.push(h), a.push(h);
        else {
            l = !1;
            break;
        }
    } if (!l && (o = this.pushedItemsOrder.lastIndexOf(a[0]), o > -1)) {
        let d = this.pushedItemsOrder.length - 1;
        for (; d >= o; d--)
            h = this.pushedItemsOrder[d], this.pushedItemsOrder.pop(), this.removeFromTempPushed(h), this.removeFromPushedItem(h);
    } return this.iteration++, l; }
    trySouth(e, t) { return this.gridster.$options.pushDirections.south ? (this.addToTempPushed(e), e.$item.y = t.$item.y + t.$item.rows, this.push(e, this.fromNorth) ? (e.setSize(), this.addToPushed(e), !0) : (this.removeFromTempPushed(e), !1)) : !1; }
    tryNorth(e, t) { return this.gridster.$options.pushDirections.north ? (this.addToTempPushed(e), e.$item.y = t.$item.y - e.$item.rows, this.push(e, this.fromSouth) ? (e.setSize(), this.addToPushed(e), !0) : (this.removeFromTempPushed(e), !1)) : !1; }
    tryEast(e, t) { return this.gridster.$options.pushDirections.east ? (this.addToTempPushed(e), e.$item.x = t.$item.x + t.$item.cols, this.push(e, this.fromWest) ? (e.setSize(), this.addToPushed(e), !0) : (this.removeFromTempPushed(e), !1)) : !1; }
    tryWest(e, t) { return this.gridster.$options.pushDirections.west ? (this.addToTempPushed(e), e.$item.x = t.$item.x - e.$item.cols, this.push(e, this.fromEast) ? (e.setSize(), this.addToPushed(e), !0) : (this.removeFromTempPushed(e), !1)) : !1; }
    addToTempPushed(e) { let t = this.pushedItemsTemp.indexOf(e); t === -1 && (t = this.pushedItemsTemp.push(e) - 1, this.pushedItemsTempPath[t] = []), this.pushedItemsTempPath[t].push({ x: e.$item.x, y: e.$item.y }); }
    removeFromTempPushed(e) { let t = this.pushedItemsTemp.indexOf(e), i = this.pushedItemsTempPath[t].pop(); i && (e.$item.x = i.x, e.$item.y = i.y, e.setSize(), this.pushedItemsTempPath[t].length || (this.pushedItemsTemp.splice(t, 1), this.pushedItemsTempPath.splice(t, 1))); }
    addToPushed(e) { if (this.pushedItems.indexOf(e) < 0)
        this.pushedItems.push(e), this.pushedItemsPath.push([{ x: e.item.x || 0, y: e.item.y || 0 }, { x: e.$item.x, y: e.$item.y }]);
    else {
        let t = this.pushedItems.indexOf(e);
        this.pushedItemsPath[t].push({ x: e.$item.x, y: e.$item.y });
    } }
    removeFromPushed(e) { e > -1 && (this.pushedItems.splice(e, 1), this.pushedItemsPath.splice(e, 1)); }
    removeFromPushedItem(e) { let t = this.pushedItems.indexOf(e); t > -1 && (this.pushedItemsPath[t].pop(), this.pushedItemsPath.length || (this.pushedItems.splice(t, 1), this.pushedItemsPath.splice(t, 1))); }
    checkPushedItem(e, t) { let i = this.pushedItemsPath[t], s = i.length - 2, o, h, l, a = !1; for (; s > -1; s--)
        o = i[s], h = e.$item.x, l = e.$item.y, e.$item.x = o.x, e.$item.y = o.y, this.gridster.findItemWithItem(e.$item) ? (e.$item.x = h, e.$item.y = l) : (e.setSize(), i.splice(s + 1, i.length - s - 1), a = !0); return i.length < 2 && this.removeFromPushed(t), a; }
}, P, E, lt = 50, I, M, x, L, F, _, D;
function dt(n, e, t, i, s, o, h, l, a, d) { P = n.$options.scrollSensitivity, E = n.$options.scrollSpeed, I = n.el, M = a, x = d; let u = I.offsetWidth, m = I.offsetHeight, g = I.scrollLeft, $ = I.scrollTop, T = t - $, b = m + $ - t - s, { clientX: C, clientY: v } = o; if (!n.$options.disableScrollVertical)
    if (h.clientY < v && b < P) {
        if (pt(), M && x && !x.south || D)
            return;
        D = Q(1, l, h);
    }
    else if (h.clientY > v && $ > 0 && T < P) {
        if (gt(), M && x && !x.north || _)
            return;
        _ = Q(-1, l, h);
    }
    else
        h.clientY !== v && J(); let R = g + u - e - i, z = e - g; if (!n.$options.disableScrollHorizontal) {
    let S = n.$options.dirType === f.RTL, Z = h.clientX < C, q = h.clientX > C, ut = S ? q : Z, ft = S ? Z : q;
    if (ut && R <= P) {
        if (ct(), M && x && !x.east || L)
            return;
        L = tt(1, l, h, S);
    }
    else if (ft && g > 0 && z < P) {
        if (mt(), M && x && !x.west || F)
            return;
        F = tt(-1, l, h, S);
    }
    else
        h.clientX !== C && j();
} }
function Q(n, e, t) { let i = t.clientY; return window.setInterval(() => { (!I || n === -1 && I.scrollTop - E < 0) && J(), I.scrollTop += n * E, i += n * E, e({ clientX: t.clientX, clientY: i }); }, lt); }
function tt(n, e, t, i) { let s = t.clientX; return window.setInterval(() => { if (!I) {
    j();
    return;
} let o = n * E, h = i ? -o : o; I.scrollBy({ left: h, behavior: "auto" }), s += h, e({ clientX: s, clientY: t.clientY }); }, lt); }
function at() { j(), J(), I = null; }
function j() { mt(), ct(); }
function J() { pt(), gt(); }
function mt() { L && (clearInterval(L), L = 0); }
function ct() { F && (clearInterval(F), F = 0); }
function gt() { D && (clearInterval(D), D = 0); }
function pt() { _ && (clearInterval(_), _ = 0); }
var G = class {
    swapedItem;
    gridsterItem;
    gridster;
    constructor(e) { this.gridsterItem = e, this.gridster = e.gridster; }
    destroy() { this.gridster = this.gridsterItem = this.swapedItem = null; }
    swapItems() { this.gridster.$options.swap && (this.checkSwapBack(), this.checkSwap(this.gridsterItem)); }
    checkSwapBack() { if (this.swapedItem) {
        let e = this.swapedItem.$item.x, t = this.swapedItem.$item.y;
        this.swapedItem.$item.x = this.swapedItem.item.x || 0, this.swapedItem.$item.y = this.swapedItem.item.y || 0, this.gridster.checkCollision(this.swapedItem.$item) ? (this.swapedItem.$item.x = e, this.swapedItem.$item.y = t) : (this.swapedItem.setSize(), this.gridsterItem.$item.x = this.gridsterItem.item.x || 0, this.gridsterItem.$item.y = this.gridsterItem.item.y || 0, this.swapedItem = void 0);
    } }
    restoreSwapItem() { this.swapedItem && (this.swapedItem.$item.x = this.swapedItem.item.x || 0, this.swapedItem.$item.y = this.swapedItem.item.y || 0, this.swapedItem.setSize(), this.swapedItem = void 0); }
    setSwapItem() { this.swapedItem && (this.swapedItem.checkItemChanges(this.swapedItem.$item, this.swapedItem.item), this.swapedItem = void 0); }
    checkSwap(e) { let t; if (this.gridster.$options.swapWhileDragging ? t = this.gridster.checkCollisionForSwaping(e.$item) : t = this.gridster.checkCollision(e.$item), t && t !== !0 && t.canBeDragged()) {
        let i = t, s = i.$item.x, o = i.$item.y, h = e.$item.x, l = e.$item.y, a = h - s, d = l - o;
        i.$item.x = e.item.x - a, i.$item.y = e.item.y - d, e.$item.x = i.item.x + a, e.$item.y = i.item.y + d, this.gridster.checkCollision(i.$item) || this.gridster.checkCollision(e.$item) ? (e.$item.x = h, e.$item.y = l, i.$item.x = s, i.$item.y = o) : (i.setSize(), this.swapedItem = i, this.gridster.$options.swapWhileDragging && (this.gridsterItem.checkItemChanges(this.gridsterItem.$item, this.gridsterItem.item), this.setSwapItem()));
    } }
}, _t = "gridster-item-resizable-handler", w = (function (n) { return n.UP = "UP", n.DOWN = "DOWN", n.LEFT = "LEFT", n.RIGHT = "RIGHT", n; })(w || {}), A = class {
    zone;
    gridsterItem;
    gridster;
    lastMouse;
    offsetLeft;
    offsetTop;
    margin;
    outerMarginTop;
    outerMarginRight;
    outerMarginBottom;
    outerMarginLeft;
    diffTop;
    diffLeft;
    originalClientX;
    originalClientY;
    top;
    left;
    height;
    width;
    positionX;
    positionY;
    positionXBackup;
    positionYBackup;
    enabled;
    mousemove;
    mouseup;
    mouseleave;
    cancelOnBlur;
    touchmove;
    touchend;
    touchcancel;
    mousedown;
    touchstart;
    push;
    swap;
    path;
    collision = !1;
    constructor(e, t, i) { this.zone = i, this.gridsterItem = e, this.gridster = t, this.lastMouse = { clientX: 0, clientY: 0 }, this.path = []; }
    destroy() { this.gridster.previewStyle && this.gridster.previewStyle(!0), this.gridsterItem = this.gridster = this.collision = null, this.mousedown && (this.mousedown(), this.touchstart()); }
    dragStart(e) { e.which && e.which !== 1 || this.gridster.dragInProgress || (this.gridster.options.draggable && this.gridster.options.draggable.start && this.gridster.options.draggable.start(this.gridsterItem.item, this.gridsterItem, e), e.stopPropagation(), e.preventDefault(), this.zone.runOutsideAngular(() => { this.mousemove = this.gridsterItem.renderer.listen("document", "mousemove", this.dragMove), this.touchmove = this.gridster.renderer.listen(this.gridster.el, "touchmove", this.dragMove); }), this.mouseup = this.gridsterItem.renderer.listen("document", "mouseup", this.dragStop), this.mouseleave = this.gridsterItem.renderer.listen("document", "mouseleave", this.dragStop), this.cancelOnBlur = this.gridsterItem.renderer.listen("window", "blur", this.dragStop), this.touchend = this.gridsterItem.renderer.listen("document", "touchend", this.dragStop), this.touchcancel = this.gridsterItem.renderer.listen("document", "touchcancel", this.dragStop), this.gridsterItem.renderer.addClass(this.gridsterItem.el, "gridster-item-moving"), this.margin = this.gridster.$options.margin, this.outerMarginTop = this.gridster.$options.outerMarginTop, this.outerMarginRight = this.gridster.$options.outerMarginRight, this.outerMarginBottom = this.gridster.$options.outerMarginBottom, this.outerMarginLeft = this.gridster.$options.outerMarginLeft, this.offsetLeft = this.gridster.el.scrollLeft - this.gridster.el.offsetLeft, this.offsetTop = this.gridster.el.scrollTop - this.gridster.el.offsetTop, this.left = this.gridsterItem.left - this.margin, this.top = this.gridsterItem.top - this.margin, this.originalClientX = e.clientX, this.originalClientY = e.clientY, this.width = this.gridsterItem.width, this.height = this.gridsterItem.height, this.gridster.$options.dirType === f.RTL ? this.diffLeft = e.clientX - this.gridster.el.scrollWidth + this.gridsterItem.left : this.diffLeft = e.clientX + this.offsetLeft - this.margin - this.left, this.diffTop = e.clientY + this.offsetTop - this.margin - this.top, this.gridster.movingItem = this.gridsterItem.$item, this.gridster.previewStyle(!0), this.push = new H(this.gridsterItem), this.swap = new G(this.gridsterItem), this.gridster.dragInProgress = !0, this.gridster.updateGrid(), this.path.push({ x: this.gridsterItem.item.x || 0, y: this.gridsterItem.item.y || 0 })); }
    dragMove = e => { e.stopPropagation(), e.preventDefault(), y.checkTouchEvent(e); let t = this.getDirections(e); this.gridster.options.enableBoundaryControl && (t.includes(w.UP) && this.gridsterItem.el.getBoundingClientRect().top < this.gridster.el.getBoundingClientRect().top + (this.outerMarginTop ?? this.margin) && (t = t.filter(i => i != w.UP), e = new MouseEvent(e.type, { clientX: e.clientX, clientY: this.lastMouse.clientY })), t.includes(w.LEFT) && this.gridsterItem.el.getBoundingClientRect().left < this.gridster.el.getBoundingClientRect().left + (this.outerMarginLeft ?? this.margin) && (t = t.filter(i => i != w.LEFT), e = new MouseEvent(e.type, { clientX: this.lastMouse.clientX, clientY: e.clientY })), t.includes(w.RIGHT) && this.gridsterItem.el.getBoundingClientRect().right > this.gridster.el.getBoundingClientRect().right - (this.outerMarginRight ?? this.margin) && (t = t.filter(i => i != w.RIGHT), e = new MouseEvent(e.type, { clientX: this.lastMouse.clientX, clientY: e.clientY })), t.includes(w.DOWN) && this.gridsterItem.el.getBoundingClientRect().bottom > this.gridster.el.getBoundingClientRect().bottom - (this.outerMarginBottom ?? this.margin) && (t = t.filter(i => i != w.DOWN), e = new MouseEvent(e.type, { clientX: e.clientX, clientY: this.lastMouse.clientY }))), t.length && (this.offsetLeft = this.gridster.el.scrollLeft - this.gridster.el.offsetLeft, this.offsetTop = this.gridster.el.scrollTop - this.gridster.el.offsetTop, dt(this.gridster, this.left, this.top, this.width, this.height, e, this.lastMouse, this.calculateItemPositionFromMousePosition), this.calculateItemPositionFromMousePosition(e)); };
    calculateItemPositionFromMousePosition = e => { this.gridster.options.scale ? this.calculateItemPositionWithScale(e, this.gridster.options.scale) : this.calculateItemPositionWithoutScale(e), this.calculateItemPosition(), this.lastMouse.clientX = e.clientX, this.lastMouse.clientY = e.clientY, this.zone.run(() => { this.gridster.updateGrid(); }); };
    calculateItemPositionWithScale(e, t) { this.gridster.$options.dirType === f.RTL ? this.left = this.gridster.el.scrollWidth - this.originalClientX + (e.clientX - this.originalClientX) / t + this.diffLeft : this.left = this.originalClientX + (e.clientX - this.originalClientX) / t + this.offsetLeft - this.diffLeft, this.top = this.originalClientY + (e.clientY - this.originalClientY) / t + this.offsetTop - this.diffTop; }
    calculateItemPositionWithoutScale(e) { this.gridster.$options.dirType === f.RTL ? this.left = this.gridster.el.offsetWidth - (e.clientX + this.offsetLeft - this.diffLeft) : this.left = e.clientX + this.offsetLeft - this.diffLeft, this.top = e.clientY + this.offsetTop - this.diffTop; }
    dragStop = e => { e.stopPropagation(), e.preventDefault(), at(), this.cancelOnBlur(), this.mousemove(), this.mouseup(), this.mouseleave(), this.touchmove(), this.touchend(), this.touchcancel(), this.gridsterItem.renderer.removeClass(this.gridsterItem.el, "gridster-item-moving"), this.gridster.dragInProgress = !1, this.gridster.updateGrid(), this.path = [], this.gridster.options.draggable && this.gridster.options.draggable.stop ? Promise.resolve(this.gridster.options.draggable.stop(this.gridsterItem.item, this.gridsterItem, e)).then(this.makeDrag, this.cancelDrag) : this.makeDrag(), setTimeout(() => { this.gridster && (this.gridster.movingItem = null, this.gridster.previewStyle(!0)); }); };
    cancelDrag = () => { this.gridsterItem.$item.x = this.gridsterItem.item.x || 0, this.gridsterItem.$item.y = this.gridsterItem.item.y || 0, this.gridsterItem.setSize(), this.push && this.push.restoreItems(), this.swap && this.swap.restoreSwapItem(), this.push && (this.push.destroy(), this.push = null), this.swap && (this.swap.destroy(), this.swap = null); };
    makeDrag = () => { this.gridster.$options.draggable.dropOverItems && this.gridster.options.draggable && this.gridster.options.draggable.dropOverItemsCallback && this.collision && this.collision !== !0 && this.collision.$item && this.gridster.options.draggable.dropOverItemsCallback(this.gridsterItem.item, this.collision.item, this.gridster), this.collision = !1, this.gridsterItem.setSize(), this.gridsterItem.checkItemChanges(this.gridsterItem.$item, this.gridsterItem.item), this.push && this.push.setPushedItems(), this.swap && this.swap.setSwapItem(), this.push && (this.push.destroy(), this.push = null), this.swap && (this.swap.destroy(), this.swap = null); };
    calculateItemPosition() { if (this.gridster.movingItem = this.gridsterItem.$item, this.positionX = this.gridster.pixelsToPositionX(this.left, Math.round), this.positionY = this.gridster.pixelsToPositionY(this.top, Math.round), this.positionXBackup = this.gridsterItem.$item.x, this.positionYBackup = this.gridsterItem.$item.y, this.gridsterItem.$item.x = this.positionX, this.gridster.checkGridCollision(this.gridsterItem.$item) && (this.gridsterItem.$item.x = this.positionXBackup), this.gridsterItem.$item.y = this.positionY, this.gridster.checkGridCollision(this.gridsterItem.$item) && (this.gridsterItem.$item.y = this.positionYBackup), this.gridster.gridRenderer.setCellPosition(this.gridsterItem.renderer, this.gridsterItem.el, this.left, this.top), this.positionXBackup !== this.gridsterItem.$item.x || this.positionYBackup !== this.gridsterItem.$item.y) {
        let e = this.path[this.path.length - 1], t = "";
        e.x < this.gridsterItem.$item.x ? t = this.push.fromWest : e.x > this.gridsterItem.$item.x ? t = this.push.fromEast : e.y < this.gridsterItem.$item.y ? t = this.push.fromNorth : e.y > this.gridsterItem.$item.y && (t = this.push.fromSouth), this.push.pushItems(t, this.gridster.$options.disablePushOnDrag), this.swap.swapItems(), this.collision = this.gridster.checkCollision(this.gridsterItem.$item), this.collision ? (this.gridsterItem.$item.x = this.positionXBackup, this.gridsterItem.$item.y = this.positionYBackup, this.gridster.$options.draggable.dropOverItems && this.collision !== !0 && this.collision.$item && (this.gridster.movingItem = null)) : this.path.push({ x: this.gridsterItem.$item.x, y: this.gridsterItem.$item.y }), this.push.checkPushBack();
    }
    else
        this.collision = !1; this.gridster.previewStyle(!0); }
    toggle() { let e = this.gridsterItem.canBeDragged(); !this.enabled && e ? (this.enabled = !this.enabled, this.mousedown = this.gridsterItem.renderer.listen(this.gridsterItem.el, "mousedown", this.dragStartDelay), this.touchstart = this.gridsterItem.renderer.listen(this.gridsterItem.el, "touchstart", this.dragStartDelay)) : this.enabled && !e && (this.enabled = !this.enabled, this.mousedown(), this.touchstart()); }
    dragStartDelay = e => { if (e.target.classList.contains(_t) || y.checkContentClassForEvent(this.gridster, e))
        return; if (y.checkTouchEvent(e), !this.gridster.$options.draggable.delayStart) {
        this.dragStart(e);
        return;
    } let i = setTimeout(() => { this.dragStart(e), m(); }, this.gridster.$options.draggable.delayStart), s = this.gridsterItem.renderer.listen("document", "mouseup", m), o = this.gridsterItem.renderer.listen("document", "mouseleave", m), h = this.gridsterItem.renderer.listen("window", "blur", m), l = this.gridsterItem.renderer.listen("document", "touchmove", u), a = this.gridsterItem.renderer.listen("document", "touchend", m), d = this.gridsterItem.renderer.listen("document", "touchcancel", m); function u(g) { y.checkTouchEvent(g), (Math.abs(g.clientX - e.clientX) > 9 || Math.abs(g.clientY - e.clientY) > 9) && m(); } function m() { clearTimeout(i), h(), s(), o(), l(), a(), d(); } };
    getDirections(e) { let t = []; return this.lastMouse.clientX === 0 && this.lastMouse.clientY === 0 && (this.lastMouse.clientY = e.clientY, this.lastMouse.clientX = e.clientX), this.lastMouse.clientY > e.clientY && t.push(w.UP), this.lastMouse.clientY < e.clientY && t.push(w.DOWN), this.lastMouse.clientX < e.clientX && t.push(w.RIGHT), this.lastMouse.clientX > e.clientX && t.push(w.LEFT), t; }
}, V = class {
    fromSouth;
    fromNorth;
    fromEast;
    fromWest;
    pushedItems;
    pushedItemsPath;
    gridsterItem;
    gridster;
    tryPattern;
    constructor(e) { this.pushedItems = [], this.pushedItemsPath = [], this.gridsterItem = e, this.gridster = e.gridster, this.tryPattern = { fromEast: this.tryWest, fromWest: this.tryEast, fromNorth: this.trySouth, fromSouth: this.tryNorth }, this.fromSouth = "fromSouth", this.fromNorth = "fromNorth", this.fromEast = "fromEast", this.fromWest = "fromWest"; }
    destroy() { this.gridster = this.gridsterItem = null; }
    pushItems(e) { return this.gridster.$options.pushResizeItems ? this.push(this.gridsterItem, e) : !1; }
    restoreItems() { let e = 0, t = this.pushedItems.length, i; for (; e < t; e++)
        i = this.pushedItems[e], i.$item.x = i.item.x || 0, i.$item.y = i.item.y || 0, i.$item.cols = i.item.cols || 1, i.$item.row = i.item.row || 1, i.setSize(); this.pushedItems = [], this.pushedItemsPath = []; }
    setPushedItems() { let e = 0, t = this.pushedItems.length, i; for (; e < t; e++)
        i = this.pushedItems[e], i.checkItemChanges(i.$item, i.item); this.pushedItems = [], this.pushedItemsPath = []; }
    checkPushBack() { let e = this.pushedItems.length - 1, t = !1; for (; e > -1; e--)
        this.checkPushedItem(this.pushedItems[e], e) && (t = !0); t && this.checkPushBack(); }
    push(e, t) { let i = this.gridster.checkCollision(e.$item); if (i && i !== !0 && i !== this.gridsterItem && i.canBeResized()) {
        if (this.tryPattern[t].call(this, i, e, t))
            return !0;
    }
    else if (i === !1)
        return !0; return !1; }
    trySouth(e, t, i) { let s = e.$item.y, o = e.$item.rows; return e.$item.y = t.$item.y + t.$item.rows, e.$item.rows = o + s - e.$item.y, !this.gridster.checkCollisionTwoItems(e.$item, t.$item) && !this.gridster.checkGridCollision(e.$item) ? (e.setSize(), this.addToPushed(e), this.push(t, i), !0) : (e.$item.y = s, e.$item.rows = o, !1); }
    tryNorth(e, t, i) { let s = e.$item.rows; return e.$item.rows = t.$item.y - e.$item.y, !this.gridster.checkCollisionTwoItems(e.$item, t.$item) && !this.gridster.checkGridCollision(e.$item) ? (e.setSize(), this.addToPushed(e), this.push(t, i), !0) : (e.$item.rows = s, !1); }
    tryEast(e, t, i) { let s = e.$item.x, o = e.$item.cols; return e.$item.x = t.$item.x + t.$item.cols, e.$item.cols = o + s - e.$item.x, !this.gridster.checkCollisionTwoItems(e.$item, t.$item) && !this.gridster.checkGridCollision(e.$item) ? (e.setSize(), this.addToPushed(e), this.push(t, i), !0) : (e.$item.x = s, e.$item.cols = o, !1); }
    tryWest(e, t, i) { let s = e.$item.cols; return e.$item.cols = t.$item.x - e.$item.x, !this.gridster.checkCollisionTwoItems(e.$item, t.$item) && !this.gridster.checkGridCollision(e.$item) ? (e.setSize(), this.addToPushed(e), this.push(t, i), !0) : (e.$item.cols = s, !1); }
    addToPushed(e) { if (this.pushedItems.indexOf(e) < 0)
        this.pushedItems.push(e), this.pushedItemsPath.push([{ x: e.item.x || 0, y: e.item.y || 0, cols: e.item.cols || 0, rows: e.item.rows || 0 }, { x: e.$item.x, y: e.$item.y, cols: e.$item.cols, rows: e.$item.rows }]);
    else {
        let t = this.pushedItems.indexOf(e);
        this.pushedItemsPath[t].push({ x: e.$item.x, y: e.$item.y, cols: e.$item.cols, rows: e.$item.rows });
    } }
    removeFromPushed(e) { e > -1 && (this.pushedItems.splice(e, 1), this.pushedItemsPath.splice(e, 1)); }
    checkPushedItem(e, t) { let i = this.pushedItemsPath[t], s = i.length - 2, o, h, l, a, d; for (; s > -1; s--)
        o = i[s], h = e.$item.x, l = e.$item.y, a = e.$item.cols, d = e.$item.rows, e.$item.x = o.x, e.$item.y = o.y, e.$item.cols = o.cols, e.$item.rows = o.rows, this.gridster.findItemWithItem(e.$item) ? (e.$item.x = h, e.$item.y = l, e.$item.cols = a, e.$item.rows = d) : (e.setSize(), i.splice(s + 1, i.length - 1 - s)); return i.length < 2 ? (this.removeFromPushed(t), !0) : !1; }
}, U = class {
    zone;
    gridsterItem;
    gridster;
    lastMouse;
    itemBackup = { x: 0, y: 0, cols: 0, rows: 0 };
    resizeEventScrollType;
    directionFunction = null;
    resizeEnabled;
    resizableHandles;
    mousemove;
    mouseup;
    mouseleave;
    cancelOnBlur;
    touchmove;
    touchend;
    touchcancel;
    push;
    pushResize;
    minHeight;
    minWidth;
    offsetTop;
    offsetLeft;
    diffTop;
    diffLeft;
    diffRight;
    diffBottom;
    margin;
    outerMarginTop;
    outerMarginRight;
    outerMarginBottom;
    outerMarginLeft;
    originalClientX;
    originalClientY;
    top;
    left;
    bottom;
    right;
    width;
    height;
    hasRatio;
    constructor(e, t, i) { this.zone = i, this.gridsterItem = e, this.gridster = t, this.lastMouse = { clientX: 0, clientY: 0 }, this.resizeEventScrollType = { west: !1, east: !1, north: !1, south: !1 }; }
    destroy() { this.gridster?.previewStyle(), this.gridster = this.gridsterItem = null; }
    dragStart(e) { if (e.which && e.which !== 1 || this.gridster.dragInProgress)
        return; this.gridster.options.resizable && this.gridster.options.resizable.start && this.gridster.options.resizable.start(this.gridsterItem.item, this.gridsterItem, e), e.stopPropagation(), e.preventDefault(), this.zone.runOutsideAngular(() => { this.mousemove = this.gridsterItem.renderer.listen("document", "mousemove", this.dragMove), this.touchmove = this.gridster.renderer.listen(this.gridster.el, "touchmove", this.dragMove); }), this.mouseup = this.gridsterItem.renderer.listen("document", "mouseup", this.dragStop), this.mouseleave = this.gridsterItem.renderer.listen("document", "mouseleave", this.dragStop), this.cancelOnBlur = this.gridsterItem.renderer.listen("window", "blur", this.dragStop), this.touchend = this.gridsterItem.renderer.listen("document", "touchend", this.dragStop), this.touchcancel = this.gridsterItem.renderer.listen("document", "touchcancel", this.dragStop), this.gridsterItem.renderer.addClass(this.gridsterItem.el, "gridster-item-resizing"), this.lastMouse.clientX = e.clientX, this.lastMouse.clientY = e.clientY, this.left = this.gridsterItem.left, this.top = this.gridsterItem.top, this.originalClientX = e.clientX, this.originalClientY = e.clientY, this.width = this.gridsterItem.width, this.height = this.gridsterItem.height, this.bottom = this.gridsterItem.top + this.gridsterItem.height, this.right = this.gridsterItem.left + this.gridsterItem.width, this.margin = this.gridster.$options.margin, this.outerMarginTop = this.gridster.$options.outerMarginTop, this.outerMarginRight = this.gridster.$options.outerMarginRight, this.outerMarginBottom = this.gridster.$options.outerMarginBottom, this.outerMarginLeft = this.gridster.$options.outerMarginLeft, this.offsetLeft = this.gridster.el.scrollLeft - this.gridster.el.offsetLeft, this.offsetTop = this.gridster.el.scrollTop - this.gridster.el.offsetTop, this.diffLeft = e.clientX + this.offsetLeft - this.left, this.diffRight = e.clientX + this.offsetLeft - this.right, this.diffTop = e.clientY + this.offsetTop - this.top, this.diffBottom = e.clientY + this.offsetTop - this.bottom, this.minHeight = this.gridster.positionYToPixels(this.gridsterItem.$item.minItemRows || this.gridster.$options.minItemRows) - this.margin, this.minWidth = this.gridster.positionXToPixels(this.gridsterItem.$item.minItemCols || this.gridster.$options.minItemCols) - this.margin, this.gridster.movingItem = this.gridsterItem.$item, this.gridster.previewStyle(), this.push = new H(this.gridsterItem), this.pushResize = new V(this.gridsterItem), this.gridster.dragInProgress = !0, this.hasRatio = !!(this.gridster.$options.itemAspectRatio || this.gridsterItem.$item.itemAspectRatio), this.itemBackup = { x: 0, y: 0, cols: 0, rows: 0 }, this.gridster.updateGrid(); let { classList: t } = e.target; t.contains("handle-n") ? (this.resizeEventScrollType.north = !0, this.directionFunction = this.handleNorth) : t.contains("handle-w") ? this.gridster.$options.dirType === f.RTL ? (this.resizeEventScrollType.east = !0, this.directionFunction = this.handleEast) : (this.resizeEventScrollType.west = !0, this.directionFunction = this.handleWest) : t.contains("handle-s") ? (this.resizeEventScrollType.south = !0, this.directionFunction = this.handleSouth) : t.contains("handle-e") ? this.gridster.$options.dirType === f.RTL ? (this.resizeEventScrollType.west = !0, this.directionFunction = this.handleWest) : (this.resizeEventScrollType.east = !0, this.directionFunction = this.handleEast) : t.contains("handle-nw") ? this.gridster.$options.dirType === f.RTL ? (this.resizeEventScrollType.north = !0, this.resizeEventScrollType.east = !0, this.directionFunction = this.handleNorthEast) : (this.resizeEventScrollType.north = !0, this.resizeEventScrollType.west = !0, this.directionFunction = this.handleNorthWest) : t.contains("handle-ne") ? this.gridster.$options.dirType === f.RTL ? (this.resizeEventScrollType.north = !0, this.resizeEventScrollType.west = !0, this.directionFunction = this.handleNorthWest) : (this.resizeEventScrollType.north = !0, this.resizeEventScrollType.east = !0, this.directionFunction = this.handleNorthEast) : t.contains("handle-sw") ? this.gridster.$options.dirType === f.RTL ? (this.resizeEventScrollType.south = !0, this.resizeEventScrollType.east = !0, this.directionFunction = this.handleSouthEast) : (this.resizeEventScrollType.south = !0, this.resizeEventScrollType.west = !0, this.directionFunction = this.handleSouthWest) : t.contains("handle-se") && (this.gridster.$options.dirType === f.RTL ? (this.resizeEventScrollType.south = !0, this.resizeEventScrollType.west = !0, this.directionFunction = this.handleSouthWest) : (this.resizeEventScrollType.south = !0, this.resizeEventScrollType.east = !0, this.directionFunction = this.handleSouthEast)); }
    dragMove = e => { if (this.directionFunction === null)
        throw new Error("The `directionFunction` has not been set before calling `dragMove`."); e.stopPropagation(), e.preventDefault(), y.checkTouchEvent(e), this.offsetTop = this.gridster.el.scrollTop - this.gridster.el.offsetTop, this.offsetLeft = this.gridster.el.scrollLeft - this.gridster.el.offsetLeft, dt(this.gridster, this.left, this.top, this.width, this.height, e, this.lastMouse, this.directionFunction, !0, this.resizeEventScrollType); let t = this.gridster.options.scale || 1; this.directionFunction({ clientX: this.originalClientX + (e.clientX - this.originalClientX) / t, clientY: this.originalClientY + (e.clientY - this.originalClientY) / t }), this.lastMouse.clientX = e.clientX, this.lastMouse.clientY = e.clientY, this.zone.run(() => { this.gridster.updateGrid(); }); };
    dragStop = e => { e.stopPropagation(), e.preventDefault(), at(), this.mousemove(), this.mouseup(), this.mouseleave(), this.cancelOnBlur(), this.touchmove(), this.touchend(), this.touchcancel(), this.gridster.dragInProgress = !1, this.resizeEventScrollType = { west: !1, east: !1, north: !1, south: !1 }, this.gridster.updateGrid(), this.gridster.options.resizable && this.gridster.options.resizable.stop ? Promise.resolve(this.gridster.options.resizable.stop(this.gridsterItem.item, this.gridsterItem, e)).then(this.makeResize, this.cancelResize) : this.makeResize(), setTimeout(() => { this.gridsterItem.renderer.removeClass(this.gridsterItem.el, "gridster-item-resizing"), this.gridster && (this.gridster.movingItem = null, this.gridster.previewStyle()); }); };
    cancelResize = () => { this.gridsterItem.$item.cols = this.gridsterItem.item.cols || 1, this.gridsterItem.$item.rows = this.gridsterItem.item.rows || 1, this.gridsterItem.$item.x = this.gridsterItem.item.x || 0, this.gridsterItem.$item.y = this.gridsterItem.item.y || 0, this.gridsterItem.setSize(), this.push.restoreItems(), this.pushResize.restoreItems(), this.push.destroy(), this.push = null, this.pushResize.destroy(), this.pushResize = null; };
    makeResize = () => { this.gridsterItem.setSize(), this.gridsterItem.checkItemChanges(this.gridsterItem.$item, this.gridsterItem.item), this.push.setPushedItems(), this.pushResize.setPushedItems(), this.push.destroy(), this.push = null, this.pushResize.destroy(), this.pushResize = null; };
    check = e => (this.hasRatio && this.enforceAspectRatio(), this.pushResize.pushItems(e), this.push.pushItems(e, this.gridster.$options.disablePushOnResize), this.gridster.checkCollision(this.gridsterItem.$item, !0) ? (this.resetItem(this.hasRatio), !1) : (this.gridster.previewStyle(), this.pushResize.checkPushBack(), this.push.checkPushBack(), !0));
    getNewNorthPosition = e => { this.top = e.clientY + this.offsetTop - this.diffTop, this.height = this.bottom - this.top, this.minHeight > this.height ? (this.height = this.minHeight, this.top = this.bottom - this.minHeight) : this.gridster.options.enableBoundaryControl && (this.top = Math.max(0, this.top), this.height = this.bottom - this.top); let t = this.gridster.options.pushItems ? this.margin : 0; return this.gridster.pixelsToPositionY(this.top + t, Math.floor); };
    handleNorth = e => { let t = this.getNewNorthPosition(e); this.gridsterItem.$item.y !== t && (this.makeItemBackup(), this.gridsterItem.$item.rows += this.gridsterItem.$item.y - t, this.gridsterItem.$item.y = t, !this.check(this.pushResize.fromSouth)) || (this.setItemTop(this.top), this.setItemHeight(this.height)); };
    getNewWestPosition = e => { let t = this.gridster.$options.dirType === f.RTL ? this.originalClientX + (this.originalClientX - e.clientX) : e.clientX; this.left = t + this.offsetLeft - this.diffLeft, this.width = this.right - this.left, this.minWidth > this.width ? (this.width = this.minWidth, this.left = this.right - this.minWidth) : this.gridster.options.enableBoundaryControl && (this.left = Math.max(0, this.left), this.width = this.right - this.left); let i = this.gridster.options.pushItems ? this.margin : 0; return this.gridster.pixelsToPositionX(this.left + i, Math.floor); };
    handleWest = e => { let t = this.getNewWestPosition(e); this.gridsterItem.$item.x !== t && (this.makeItemBackup(), this.gridsterItem.$item.cols += this.gridsterItem.$item.x - t, this.gridsterItem.$item.x = t, !this.check(this.pushResize.fromEast)) || (this.setItemLeft(this.left), this.setItemWidth(this.width)); };
    getNewSouthPosition = e => { if (this.height = e.clientY + this.offsetTop - this.diffBottom - this.top, this.minHeight > this.height && (this.height = this.minHeight), this.bottom = this.top + this.height, this.gridster.options.enableBoundaryControl) {
        let i = this.outerMarginBottom ?? this.margin, s = this.gridster.el.getBoundingClientRect();
        this.bottom = Math.min(this.bottom, s.bottom - s.top - 2 * i), this.height = this.bottom - this.top;
    } let t = this.gridster.options.pushItems ? 0 : this.margin; return this.gridster.pixelsToPositionY(this.bottom + t, Math.ceil); };
    handleSouth = e => { let t = this.getNewSouthPosition(e); this.gridsterItem.$item.y + this.gridsterItem.$item.rows !== t && (this.makeItemBackup(), this.gridsterItem.$item.rows = t - this.gridsterItem.$item.y, !this.check(this.pushResize.fromNorth)) || this.setItemHeight(this.height); };
    getNewEastPosition = e => { let t = this.gridster.$options.dirType === f.RTL ? this.originalClientX + (this.originalClientX - e.clientX) : e.clientX; if (this.width = t + this.offsetLeft - this.diffRight - this.left, this.minWidth > this.width && (this.width = this.minWidth), this.right = this.left + this.width, this.gridster.options.enableBoundaryControl) {
        let s = this.outerMarginRight ?? this.margin, o = this.gridster.el.getBoundingClientRect();
        this.right = Math.min(this.right, o.right - o.left - 2 * s), this.width = this.right - this.left;
    } let i = this.gridster.options.pushItems ? 0 : this.margin; return this.gridster.pixelsToPositionX(this.right + i, Math.ceil); };
    handleEast = e => { let t = this.getNewEastPosition(e); this.gridsterItem.$item.x + this.gridsterItem.$item.cols !== t && (this.makeItemBackup(), this.gridsterItem.$item.cols = t - this.gridsterItem.$item.x, !this.check(this.pushResize.fromWest)) || this.setItemWidth(this.width); };
    handleNorthWest = e => { let t = this.getNewNorthPosition(e), i = this.getNewWestPosition(e); (this.gridsterItem.$item.y !== t || this.gridsterItem.$item.x !== i) && (this.makeItemBackup(), this.gridsterItem.$item.rows += this.gridsterItem.$item.y - t, this.gridsterItem.$item.y = t, this.gridsterItem.$item.cols += this.gridsterItem.$item.x - i, this.gridsterItem.$item.x = i, !this.check(this.pushResize.fromSouth)) || (this.setItemTop(this.top), this.setItemHeight(this.height), this.setItemLeft(this.left), this.setItemWidth(this.width)); };
    handleNorthEast = e => { let t = this.getNewNorthPosition(e), i = this.getNewEastPosition(e); (this.gridsterItem.$item.y !== t || this.gridsterItem.$item.x + this.gridsterItem.$item.cols !== i) && (this.makeItemBackup(), this.gridsterItem.$item.rows += this.gridsterItem.$item.y - t, this.gridsterItem.$item.y = t, this.gridsterItem.$item.cols = i - this.gridsterItem.$item.x, !this.check(this.pushResize.fromSouth)) || (this.setItemTop(this.top), this.setItemHeight(this.height), this.setItemWidth(this.width)); };
    handleSouthWest = e => { let t = this.getNewSouthPosition(e), i = this.getNewWestPosition(e); (this.gridsterItem.$item.y + this.gridsterItem.$item.rows !== t || this.gridsterItem.$item.x !== i) && (this.makeItemBackup(), this.gridsterItem.$item.rows = t - this.gridsterItem.$item.y, this.gridsterItem.$item.cols += this.gridsterItem.$item.x - i, this.gridsterItem.$item.x = i, !this.check(this.pushResize.fromNorth)) || (this.setItemLeft(this.left), this.setItemHeight(this.height), this.setItemWidth(this.width)); };
    handleSouthEast = e => { let t = this.getNewSouthPosition(e), i = this.getNewEastPosition(e); (this.gridsterItem.$item.y + this.gridsterItem.$item.rows !== t || this.gridsterItem.$item.x + this.gridsterItem.$item.cols !== i) && (this.makeItemBackup(), this.gridsterItem.$item.rows = t - this.gridsterItem.$item.y, this.gridsterItem.$item.cols = i - this.gridsterItem.$item.x, !this.check(this.pushResize.fromNorth)) || (this.setItemHeight(this.height), this.setItemWidth(this.width)); };
    makeItemBackup() { this.itemBackup.x = this.gridsterItem.$item.x, this.itemBackup.y = this.gridsterItem.$item.y, this.itemBackup.cols = this.gridsterItem.$item.cols, this.itemBackup.rows = this.gridsterItem.$item.rows; }
    resetItem(e = !1) { this.gridsterItem.$item.x !== this.itemBackup.x && (this.gridsterItem.$item.x = this.itemBackup.x, e || (this.left = this.gridster.positionXToPixels(this.gridsterItem.$item.y), this.setItemLeft(this.left))), this.gridsterItem.$item.y !== this.itemBackup.y && (this.gridsterItem.$item.y = this.itemBackup.y, e || (this.top = this.gridster.positionYToPixels(this.gridsterItem.$item.y), this.setItemTop(this.top))), this.gridsterItem.$item.cols !== this.itemBackup.cols && (this.gridsterItem.$item.cols = this.itemBackup.cols, e || this.setItemWidth(this.gridster.positionXToPixels(this.gridsterItem.$item.cols) - this.margin)), this.gridsterItem.$item.rows !== this.itemBackup.rows && (this.gridsterItem.$item.rows = this.itemBackup.rows, e || this.setItemHeight(this.gridster.positionYToPixels(this.gridsterItem.$item.rows) - this.margin)); }
    toggle() { this.resizeEnabled = this.gridsterItem.canBeResized(), this.resizableHandles = this.gridsterItem.getResizableHandles(); }
    dragStartDelay(e) { if (y.checkTouchEvent(e), !this.gridster.$options.resizable.delayStart) {
        this.dragStart(e);
        return;
    } let t = setTimeout(() => { this.dragStart(e), u(); }, this.gridster.$options.resizable.delayStart), { cancelMouse: i, cancelMouseLeave: s, cancelOnBlur: o, cancelTouchMove: h, cancelTouchEnd: l, cancelTouchCancel: a } = this.zone.runOutsideAngular(() => { let m = this.gridsterItem.renderer.listen("document", "mouseup", u), g = this.gridsterItem.renderer.listen("document", "mouseleave", u), $ = this.gridsterItem.renderer.listen("window", "blur", u), T = this.gridsterItem.renderer.listen("document", "touchmove", d), b = this.gridsterItem.renderer.listen("document", "touchend", u), C = this.gridsterItem.renderer.listen("document", "touchcancel", u); return { cancelMouse: m, cancelMouseLeave: g, cancelOnBlur: $, cancelTouchMove: T, cancelTouchEnd: b, cancelTouchCancel: C }; }); function d(m) { y.checkTouchEvent(m), (Math.abs(m.clientX - e.clientX) > 9 || Math.abs(m.clientY - e.clientY) > 9) && u(); } function u() { clearTimeout(t), o(), i(), s(), h(), l(), a(); } }
    setItemTop(e) { this.gridster.gridRenderer.setCellPosition(this.gridsterItem.renderer, this.gridsterItem.el, this.left, e); }
    setItemLeft(e) { this.gridster.gridRenderer.setCellPosition(this.gridsterItem.renderer, this.gridsterItem.el, e, this.top); }
    setItemHeight(e) { this.gridsterItem.renderer.setStyle(this.gridsterItem.el, "height", e + "px"); }
    setItemWidth(e) { this.gridsterItem.renderer.setStyle(this.gridsterItem.el, "width", e + "px"); }
    enforceAspectRatio() { let e = this.gridsterItem.$item.itemAspectRatio || this.gridster.$options.itemAspectRatio; if (!e)
        return; let t = e * (this.gridster.curColWidth / this.gridster.curRowHeight), i = this.gridsterItem.$item.minItemCols || this.gridster.$options.minItemCols, s = this.gridsterItem.$item.minItemRows || this.gridster.$options.minItemRows, o = this.gridster.positionXToPixels(i) - this.margin, h = this.gridster.positionYToPixels(s) - this.margin, l = this.gridsterItem.$item.maxItemCols || this.gridster.$options.maxItemCols || 0, a = this.gridsterItem.$item.maxItemRows || this.gridster.$options.maxItemRows || 0, d = l ? this.gridster.positionXToPixels(l) - this.margin : Number.MAX_VALUE, u = a ? this.gridster.positionYToPixels(a) - this.margin : Number.MAX_VALUE, m = this.width, g = this.height; if (this.resizeEventScrollType.north || this.resizeEventScrollType.south ? (m = this.height * t, m < o ? (m = o, g = o / t) : m > d && (m = d, g = d / t)) : (this.resizeEventScrollType.east || this.resizeEventScrollType.west) && (g = this.width / t, g < h ? (g = h, m = h * t) : g > u && (g = u, m = u * t)), this.gridster.options.enableBoundaryControl) {
        let v = this.gridster.el.getBoundingClientRect(), R = Math.max(this.outerMarginTop || this.margin, this.outerMarginRight || this.margin, this.outerMarginBottom || this.margin, this.outerMarginLeft || this.margin), z = v.width - 2 * R, S = v.height - 2 * R;
        this.resizeEventScrollType.west ? this.right - m < 0 && (m = this.right, g = m / t) : this.resizeEventScrollType.east && this.left + m > z && (m = z - this.left, g = m / t), this.resizeEventScrollType.north ? this.bottom - g < 0 && (g = this.bottom, m = g * t) : this.resizeEventScrollType.south && this.top + g > S && (g = S - this.top, m = g * t);
    } this.width = m, this.height = g, this.resizeEventScrollType.west && (this.left = this.right - this.width), this.resizeEventScrollType.north && (this.top = this.bottom - this.height); let $ = this.gridster.options.pushItems ? 0 : this.margin, T = this.gridster.options.pushItems ? 0 : this.margin, b = this.gridster.options.pushItems ? this.margin : 0, C = this.gridster.options.pushItems ? this.margin : 0; this.gridsterItem.$item.x = this.gridster.pixelsToPositionX(this.left + $, Math.floor), this.gridsterItem.$item.y = this.gridster.pixelsToPositionY(this.top + T, Math.floor), this.gridsterItem.$item.cols = this.gridster.pixelsToPositionX(this.width + b, Math.ceil), this.gridsterItem.$item.rows = this.gridster.pixelsToPositionY(this.height + C, Math.ceil), this.setItemTop(this.top), this.setItemLeft(this.left), this.setItemWidth(this.width), this.setItemHeight(this.height); }
}, Vt = (() => {
    class n {
        renderer;
        zone;
        item;
        itemInit = new W;
        itemChange = new W;
        itemResize = new W;
        $item;
        el;
        gridster;
        top;
        left;
        width;
        height;
        drag;
        resize;
        notPlaced;
        init;
        get zIndex() { return this.getLayerIndex() + this.gridster.$options.baseLayerIndex; }
        constructor(t, i, s, o) { this.renderer = s, this.zone = o, this.el = t.nativeElement, this.$item = { cols: -1, rows: -1, x: -1, y: -1 }, this.gridster = i, this.drag = new A(this, i, this.zone), this.resize = new U(this, i, this.zone); }
        ngOnInit() { this.gridster.addItem(this); }
        ngOnChanges(t) { t.item && (this.updateOptions(), this.init || this.gridster.calculateLayout$.next()), t.item && t.item.previousValue && this.setSize(); }
        updateOptions() { this.$item = y.merge(this.$item, this.item, { cols: void 0, rows: void 0, x: void 0, y: void 0, layerIndex: void 0, dragEnabled: void 0, resizeEnabled: void 0, compactEnabled: void 0, itemAspectRatio: void 0, maxItemRows: void 0, minItemRows: void 0, maxItemCols: void 0, minItemCols: void 0, maxItemArea: void 0, minItemArea: void 0, resizableHandles: { s: void 0, e: void 0, n: void 0, w: void 0, se: void 0, ne: void 0, sw: void 0, nw: void 0 } }); }
        ngOnDestroy() { this.gridster.removeItem(this), this.drag.destroy(), this.resize.destroy(), this.gridster = this.drag = this.resize = null; }
        setSize() { this.renderer.setStyle(this.el, "display", this.notPlaced ? "" : "block"), this.gridster.gridRenderer.updateItem(this.el, this.$item, this.renderer), this.updateItemSize(); }
        updateItemSize() { let t = this.$item.y * this.gridster.curRowHeight, i = this.$item.x * this.gridster.curColWidth, s = this.$item.cols * this.gridster.curColWidth - this.gridster.$options.margin, o = this.$item.rows * this.gridster.curRowHeight - this.gridster.$options.margin; this.top = t, this.left = i, !this.init && s > 0 && o > 0 && (this.init = !0, this.item.initCallback && this.item.initCallback(this.item, this), this.gridster.options.itemInitCallback && this.gridster.options.itemInitCallback(this.item, this), this.itemInit.next({ item: this.item, itemComponent: this }), this.gridster.$options.scrollToNewItems && this.el.scrollIntoView({ block: "end", inline: "nearest", behavior: "smooth" })), (s !== this.width || o !== this.height) && (this.width = s, this.height = o, this.gridster.options.itemResizeCallback && this.gridster.options.itemResizeCallback(this.item, this), this.itemResize.next({ item: this.item, itemComponent: this })); }
        itemChanged() { this.gridster.options.itemChangeCallback && this.gridster.options.itemChangeCallback(this.item, this), this.itemChange.next({ item: this.item, itemComponent: this }); }
        checkItemChanges(t, i) { t.rows === i.rows && t.cols === i.cols && t.x === i.x && t.y === i.y || (this.gridster.checkCollision(this.$item) ? (this.$item.x = i.x || 0, this.$item.y = i.y || 0, this.$item.cols = i.cols || 1, this.$item.rows = i.rows || 1, this.setSize()) : (this.item.cols = this.$item.cols, this.item.rows = this.$item.rows, this.item.x = this.$item.x, this.item.y = this.$item.y, this.gridster.calculateLayout$.next(), this.itemChanged())); }
        canBeDragged() { let t = this.gridster.$options.draggable.enabled, i = this.$item.dragEnabled === void 0 ? t : this.$item.dragEnabled; return !this.gridster.mobile && t && i; }
        canBeResized() { let t = this.gridster.$options.resizable.enabled, i = this.$item.resizeEnabled === void 0 ? t : this.$item.resizeEnabled; return !this.gridster.mobile && t && i; }
        getResizableHandles() { let t = this.gridster.$options.resizable.handles, i = this.$item.resizableHandles; return i === void 0 ? t : k(k({}, t), i); }
        bringToFront(t) { if (t && t <= 0)
            return; let i = this.getLayerIndex(), s = this.gridster.$options.maxLayerIndex; if (i < s) {
            let o = t ? i + t : s;
            this.item.layerIndex = this.$item.layerIndex = o > s ? s : o;
        } }
        sendToBack(t) { if (t && t <= 0)
            return; let i = this.getLayerIndex(); if (i > 0) {
            let s = t ? i - t : 0;
            this.item.layerIndex = this.$item.layerIndex = s < 0 ? 0 : s;
        } }
        getLayerIndex() { return this.item.layerIndex !== void 0 ? this.item.layerIndex : this.gridster.$options.defaultLayerIndex !== void 0 ? this.gridster.$options.defaultLayerIndex : 0; }
        static \u0275fac = function (i) { return new (i || n)(r.\u0275\u0275directiveInject(st), r.\u0275\u0275directiveInject(Ft), r.\u0275\u0275directiveInject(rt), r.\u0275\u0275directiveInject(ot)); };
        static \u0275cmp = r.\u0275\u0275defineComponent({ type: n, selectors: [["gridster-item"]], hostVars: 2, hostBindings: function (i, s) { i & 2 && r.\u0275\u0275styleProp("z-index", s.zIndex); }, inputs: { item: "item" }, outputs: { itemInit: "itemInit", itemChange: "itemChange", itemResize: "itemResize" }, features: [r.\u0275\u0275NgOnChangesFeature], ngContentSelectors: nt, decls: 9, vars: 8, consts: [[1, "gridster-item-resizable-handler", "handle-s"], [1, "gridster-item-resizable-handler", "handle-e"], [1, "gridster-item-resizable-handler", "handle-n"], [1, "gridster-item-resizable-handler", "handle-w"], [1, "gridster-item-resizable-handler", "handle-se"], [1, "gridster-item-resizable-handler", "handle-ne"], [1, "gridster-item-resizable-handler", "handle-sw"], [1, "gridster-item-resizable-handler", "handle-nw"], [1, "gridster-item-resizable-handler", "handle-s", 3, "mousedown", "touchstart"], [1, "gridster-item-resizable-handler", "handle-e", 3, "mousedown", "touchstart"], [1, "gridster-item-resizable-handler", "handle-n", 3, "mousedown", "touchstart"], [1, "gridster-item-resizable-handler", "handle-w", 3, "mousedown", "touchstart"], [1, "gridster-item-resizable-handler", "handle-se", 3, "mousedown", "touchstart"], [1, "gridster-item-resizable-handler", "handle-ne", 3, "mousedown", "touchstart"], [1, "gridster-item-resizable-handler", "handle-sw", 3, "mousedown", "touchstart"], [1, "gridster-item-resizable-handler", "handle-nw", 3, "mousedown", "touchstart"]], template: function (i, s) { i & 1 && (r.\u0275\u0275projectionDef(), r.\u0275\u0275projection(0), r.\u0275\u0275conditionalCreate(1, Tt, 1, 0, "div", 0), r.\u0275\u0275conditionalCreate(2, bt, 1, 0, "div", 1), r.\u0275\u0275conditionalCreate(3, zt, 1, 0, "div", 2), r.\u0275\u0275conditionalCreate(4, St, 1, 0, "div", 3), r.\u0275\u0275conditionalCreate(5, Rt, 1, 0, "div", 4), r.\u0275\u0275conditionalCreate(6, kt, 1, 0, "div", 5), r.\u0275\u0275conditionalCreate(7, Pt, 1, 0, "div", 6), r.\u0275\u0275conditionalCreate(8, Mt, 1, 0, "div", 7)), i & 2 && (r.\u0275\u0275advance(), r.\u0275\u0275conditional(s.resize.resizableHandles != null && s.resize.resizableHandles.s && s.resize.resizeEnabled ? 1 : -1), r.\u0275\u0275advance(), r.\u0275\u0275conditional(s.resize.resizableHandles != null && s.resize.resizableHandles.e && s.resize.resizeEnabled ? 2 : -1), r.\u0275\u0275advance(), r.\u0275\u0275conditional(s.resize.resizableHandles != null && s.resize.resizableHandles.n && s.resize.resizeEnabled ? 3 : -1), r.\u0275\u0275advance(), r.\u0275\u0275conditional(s.resize.resizableHandles != null && s.resize.resizableHandles.w && s.resize.resizeEnabled ? 4 : -1), r.\u0275\u0275advance(), r.\u0275\u0275conditional(s.resize.resizableHandles != null && s.resize.resizableHandles.se && s.resize.resizeEnabled ? 5 : -1), r.\u0275\u0275advance(), r.\u0275\u0275conditional(s.resize.resizableHandles != null && s.resize.resizableHandles.ne && s.resize.resizeEnabled ? 6 : -1), r.\u0275\u0275advance(), r.\u0275\u0275conditional(s.resize.resizableHandles != null && s.resize.resizableHandles.sw && s.resize.resizeEnabled ? 7 : -1), r.\u0275\u0275advance(), r.\u0275\u0275conditional(s.resize.resizableHandles != null && s.resize.resizableHandles.nw && s.resize.resizeEnabled ? 8 : -1)); }, styles: [`gridster-item{box-sizing:border-box;z-index:1;position:absolute;overflow:hidden;transition:.3s;display:none;background:#fff;-webkit-user-select:text;user-select:text}gridster-item.gridster-item-moving{cursor:move}gridster-item.gridster-item-resizing,gridster-item.gridster-item-moving{transition:0s;z-index:2;box-shadow:0 0 5px 5px #0003,0 6px 10px #00000024,0 1px 18px #0000001f}.gridster-item-resizable-handler{position:absolute;z-index:2}.gridster-item-resizable-handler.handle-n{cursor:ns-resize;height:10px;right:0;top:0;left:0}.gridster-item-resizable-handler.handle-e{cursor:ew-resize;width:10px;bottom:0;right:0;top:0}.gridster-item-resizable-handler.handle-s{cursor:ns-resize;height:10px;right:0;bottom:0;left:0}.gridster-item-resizable-handler.handle-w{cursor:ew-resize;width:10px;left:0;top:0;bottom:0}.gridster-item-resizable-handler.handle-ne{cursor:ne-resize;width:10px;height:10px;right:0;top:0}.gridster-item-resizable-handler.handle-nw{cursor:nw-resize;width:10px;height:10px;left:0;top:0}.gridster-item-resizable-handler.handle-se{cursor:se-resize;width:0;height:0;right:0;bottom:0;border-style:solid;border-width:0 0 10px 10px;border-color:transparent}.gridster-item-resizable-handler.handle-sw{cursor:sw-resize;width:10px;height:10px;left:0;bottom:0}gridster-item:hover .gridster-item-resizable-handler.handle-se{border-color:transparent transparent #ccc}
`], encapsulation: 2 });
    }
    return n;
})(), et = class {
    item;
    $item;
    top;
    left;
    width;
    height;
    drag;
    resize;
    notPlaced;
    updateOptions;
    itemChanged;
    setSize;
    checkItemChanges;
    canBeDragged;
    canBeResized;
    getResizableHandles;
    bringToFront;
    sendToBack;
    el;
    gridster;
    renderer;
}, it = class {
    $options;
    grid;
    checkCollision;
    checkCollisionForSwaping;
    positionXToPixels;
    pixelsToPositionX;
    positionYToPixels;
    pixelsToPositionY;
    findItemWithItem;
    findItemsWithItem;
    checkGridCollision;
    checkCollisionTwoItems;
    getItemComponent;
    el;
    renderer;
    gridRenderer;
    cdRef;
    options;
    calculateLayout$;
    updateGrid;
    movingItem;
    addItem;
    removeItem;
    previewStyle;
    mobile;
    curWidth;
    curHeight;
    columns;
    rows;
    curColWidth;
    curRowHeight;
    windowResize;
    setGridDimensions;
    dragInProgress;
    emptyCell;
    compact;
    zone;
    gridRows;
    gridColumns;
}, Ut = (() => { class n {
    static \u0275fac = function (i) { return new (i || n); };
    static \u0275mod = r.\u0275\u0275defineNgModule({ type: n });
    static \u0275inj = r.\u0275\u0275defineInjector({});
} return n; })();
export { p as CompactType, f as DirTypes, ht as DisplayGrid, c as GridType, Ft as GridsterComponent, it as GridsterComponentInterface, Et as GridsterConfigService, Vt as GridsterItemComponent, et as GridsterItemComponentInterface, Ut as GridsterModule, H as GridsterPush, V as GridsterPushResize, G as GridsterSwap };
//# sourceMappingURL=angular_gridster2.obaXVZ7Dzk.js.map
