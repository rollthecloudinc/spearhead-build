{"version":3,"file":"1873.6fb6a7d3e4578de2.js","mappings":"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","names":["MATERIAL_ANIMATIONS","InjectionToken","AnimationCurves","_createClass","_classCallCheck","this","_defineProperty","AnimationDurations","reducedMotion","_getAnimationsState","_inject","inject","optional","animationsDisabled","ANIMATION_MODULE_TYPE","MediaMatcher","matchMedia","matches","_animationsDisabled","MATERIAL_SANITY_CHECKS","providedIn","factory","MatCommonModule","_MatCommonModule","HighContrastModeDetector","_applyBodyHighContrastModeCssClasses","__ngFactoryType__","i0","type","imports","BidiModule","RippleState","FADING_IN","VISIBLE","FADING_OUT","HIDDEN","RippleRef","_renderer","element","config","_animationForciblyDisabledThroughCss","arguments","length","undefined","key","value","fadeOutRipple","passiveCapturingEventOptions$1","normalizePassiveListenerOptions","passive","capture","RippleEventManager","_this","Map","event","_this$_events$get","target","_getEventTarget","_events","get","forEach","handlers","contains","handler","handleEvent","ngZone","name","_this2","handlersForEvent","handlersForElement","add","set","Set","runOutsideAngular","document","addEventListener","_delegateEventHandler","delete","size","removeEventListener","defaultRippleAnimationConfig","enterDuration","exitDuration","passiveCapturingEventOptions","pointerDownEvents","pointerUpEvents","_MatRippleStylesLoader","_MatRippleStylesLoader2","selectors","hostAttrs","decls","vars","template","rf","ctx","styles","encapsulation","changeDetection","RippleRenderer","_target","_ngZone","elementOrElementRef","_platform","injector","isBrowser","_containerElement","coerceElement","_CdkPrivateStyleLoader","load","x","y","_this3","containerRect","_containerRect","getBoundingClientRect","animationConfig","_objectSpread","animation","centered","left","width","top","height","radius","distanceToFurthestCorner","rect","distX","Math","max","abs","right","distY","bottom","sqrt","offsetX","offsetY","ripple","createElement","classList","style","concat","color","backgroundColor","transitionDuration","appendChild","computedStyles","window","getComputedStyle","userTransitionDuration","animationForciblyDisabledThroughCss","transitionProperty","rippleRef","transform","state","persistent","_mostRecentTransientRipple","eventListeners","onTransitionEnd","fallbackTimer","clearTimeout","_finishRippleTransition","onTransitionCancel","_destroyRipple","setTimeout","_activeRipples","rippleEl","opacity","_getActiveRipples","fadeOut","_this4","_triggerElement","_removeTriggerEvents","_eventManager","addHandler","_this5","_onMousedown","_onTouchStart","_onPointerUp","_pointerUpEventsRegistered","_startFadeOutTransition","isMostRecentTransientRipple","_isPointerDown","_this$_activeRipples$","remove","isFakeMousedown","isFakeMousedownFromScreenReader","isSyntheticEvent","_lastTouchStartEvent","Date","now","rippleDisabled","fadeInRipple","clientX","clientY","rippleConfig","isFakeTouchstartFromScreenReader","touches","changedTouches","i","terminateOnPointerUp","Array","from","keys","_this6","trigger","removeHandler","MAT_RIPPLE_GLOBAL_OPTIONS","MatRipple","_MatRipple","ElementRef","NgZone","platform","Platform","globalOptions","Injector","_globalOptions","_rippleRenderer","_elementRef","_disabled","fadeOutAllNonPersistent","_setupTriggerEventsIfEnabled","_trigger","nativeElement","_isInitialized","fadeOutAll","disabled","setupTriggerEvents","configOrX","hostVars","hostBindings","unbounded","inputs","exportAs","_StructuralStylesLoader","_StructuralStylesLoader2"],"ignoreList":[],"sourceRoot":"webpack:///","sources":["./node_modules/@angular/material/fesm2022/animation.mjs","./node_modules/@angular/material/fesm2022/common-module.mjs","./node_modules/@angular/material/fesm2022/ripple.mjs","./node_modules/@angular/material/fesm2022/structural-styles.mjs"],"sourcesContent":["import { MediaMatcher } from '@angular/cdk/layout';\nimport { InjectionToken, inject, ANIMATION_MODULE_TYPE } from '@angular/core';\n\n/** Injection token used to configure the animations in Angular Material. */\nconst MATERIAL_ANIMATIONS = new InjectionToken('MATERIAL_ANIMATIONS');\n/**\n * @deprecated No longer used, will be removed.\n * @breaking-change 21.0.0\n * @docs-private\n */\nclass AnimationCurves {\n    static STANDARD_CURVE = 'cubic-bezier(0.4,0.0,0.2,1)';\n    static DECELERATION_CURVE = 'cubic-bezier(0.0,0.0,0.2,1)';\n    static ACCELERATION_CURVE = 'cubic-bezier(0.4,0.0,1,1)';\n    static SHARP_CURVE = 'cubic-bezier(0.4,0.0,0.6,1)';\n}\n/**\n * @deprecated No longer used, will be removed.\n * @breaking-change 21.0.0\n * @docs-private\n */\nclass AnimationDurations {\n    static COMPLEX = '375ms';\n    static ENTERING = '225ms';\n    static EXITING = '195ms';\n}\nlet reducedMotion = null;\n/**\n * Gets the the configured animations state.\n * @docs-private\n */\nfunction _getAnimationsState() {\n    if (inject(MATERIAL_ANIMATIONS, { optional: true })?.animationsDisabled ||\n        inject(ANIMATION_MODULE_TYPE, { optional: true }) === 'NoopAnimations') {\n        return 'di-disabled';\n    }\n    reducedMotion ??= inject(MediaMatcher).matchMedia('(prefers-reduced-motion)').matches;\n    return reducedMotion ? 'reduced-motion' : 'enabled';\n}\n/**\n * Returns whether animations have been disabled by DI. Must be called in a DI context.\n * @docs-private\n */\nfunction _animationsDisabled() {\n    return _getAnimationsState() !== 'enabled';\n}\n\nexport { AnimationCurves, AnimationDurations, MATERIAL_ANIMATIONS, _animationsDisabled, _getAnimationsState };\n","import { HighContrastModeDetector } from '@angular/cdk/a11y';\nimport { BidiModule } from '@angular/cdk/bidi';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, inject, NgModule } from '@angular/core';\n\n/**\n * Injection token that configures whether the Material sanity checks are enabled.\n * @deprecated No longer used and will be removed.\n * @breaking-change 21.0.0\n */\nconst MATERIAL_SANITY_CHECKS = new InjectionToken('mat-sanity-checks', {\n    providedIn: 'root',\n    factory: () => true,\n});\n/**\n * Module that captures anything that should be loaded and/or run for *all* Angular Material\n * components. This includes Bidi, etc.\n *\n * This module should be imported to each top-level component module (e.g., MatTabsModule).\n * @deprecated No longer used and will be removed.\n * @breaking-change 21.0.0\n */\nclass MatCommonModule {\n    constructor() {\n        // While A11yModule also does this, we repeat it here to avoid importing A11yModule\n        // in MatCommonModule.\n        inject(HighContrastModeDetector)._applyBodyHighContrastModeCssClasses();\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: MatCommonModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\n    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: MatCommonModule, imports: [BidiModule], exports: [BidiModule] });\n    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: MatCommonModule, imports: [BidiModule, BidiModule] });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: MatCommonModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [BidiModule],\n                    exports: [BidiModule],\n                }]\n        }], ctorParameters: () => [] });\n\nexport { MATERIAL_SANITY_CHECKS, MatCommonModule };\n","import { normalizePassiveListenerOptions, _getEventTarget, Platform } from '@angular/cdk/platform';\nimport * as i0 from '@angular/core';\nimport { Component, ChangeDetectionStrategy, ViewEncapsulation, InjectionToken, inject, ElementRef, NgZone, Injector, Directive, Input } from '@angular/core';\nimport { isFakeMousedownFromScreenReader, isFakeTouchstartFromScreenReader } from '@angular/cdk/a11y';\nimport { coerceElement } from '@angular/cdk/coercion';\nimport { _CdkPrivateStyleLoader } from '@angular/cdk/private';\nimport { _animationsDisabled } from './animation.mjs';\n\n/** Possible states for a ripple element. */\nvar RippleState;\n(function (RippleState) {\n    RippleState[RippleState[\"FADING_IN\"] = 0] = \"FADING_IN\";\n    RippleState[RippleState[\"VISIBLE\"] = 1] = \"VISIBLE\";\n    RippleState[RippleState[\"FADING_OUT\"] = 2] = \"FADING_OUT\";\n    RippleState[RippleState[\"HIDDEN\"] = 3] = \"HIDDEN\";\n})(RippleState || (RippleState = {}));\n/**\n * Reference to a previously launched ripple element.\n */\nclass RippleRef {\n    _renderer;\n    element;\n    config;\n    _animationForciblyDisabledThroughCss;\n    /** Current state of the ripple. */\n    state = RippleState.HIDDEN;\n    constructor(_renderer, \n    /** Reference to the ripple HTML element. */\n    element, \n    /** Ripple configuration used for the ripple. */\n    config, \n    /* Whether animations are forcibly disabled for ripples through CSS. */\n    _animationForciblyDisabledThroughCss = false) {\n        this._renderer = _renderer;\n        this.element = element;\n        this.config = config;\n        this._animationForciblyDisabledThroughCss = _animationForciblyDisabledThroughCss;\n    }\n    /** Fades out the ripple element. */\n    fadeOut() {\n        this._renderer.fadeOutRipple(this);\n    }\n}\n\n/** Options used to bind a passive capturing event. */\nconst passiveCapturingEventOptions$1 = normalizePassiveListenerOptions({\n    passive: true,\n    capture: true,\n});\n/** Manages events through delegation so that as few event handlers as possible are bound. */\nclass RippleEventManager {\n    _events = new Map();\n    /** Adds an event handler. */\n    addHandler(ngZone, name, element, handler) {\n        const handlersForEvent = this._events.get(name);\n        if (handlersForEvent) {\n            const handlersForElement = handlersForEvent.get(element);\n            if (handlersForElement) {\n                handlersForElement.add(handler);\n            }\n            else {\n                handlersForEvent.set(element, new Set([handler]));\n            }\n        }\n        else {\n            this._events.set(name, new Map([[element, new Set([handler])]]));\n            ngZone.runOutsideAngular(() => {\n                document.addEventListener(name, this._delegateEventHandler, passiveCapturingEventOptions$1);\n            });\n        }\n    }\n    /** Removes an event handler. */\n    removeHandler(name, element, handler) {\n        const handlersForEvent = this._events.get(name);\n        if (!handlersForEvent) {\n            return;\n        }\n        const handlersForElement = handlersForEvent.get(element);\n        if (!handlersForElement) {\n            return;\n        }\n        handlersForElement.delete(handler);\n        if (handlersForElement.size === 0) {\n            handlersForEvent.delete(element);\n        }\n        if (handlersForEvent.size === 0) {\n            this._events.delete(name);\n            document.removeEventListener(name, this._delegateEventHandler, passiveCapturingEventOptions$1);\n        }\n    }\n    /** Event handler that is bound and which dispatches the events to the different targets. */\n    _delegateEventHandler = (event) => {\n        const target = _getEventTarget(event);\n        if (target) {\n            this._events.get(event.type)?.forEach((handlers, element) => {\n                if (element === target || element.contains(target)) {\n                    handlers.forEach(handler => handler.handleEvent(event));\n                }\n            });\n        }\n    };\n}\n\n/**\n * Default ripple animation configuration for ripples without an explicit\n * animation config specified.\n */\nconst defaultRippleAnimationConfig = {\n    enterDuration: 225,\n    exitDuration: 150,\n};\n/**\n * Timeout for ignoring mouse events. Mouse events will be temporary ignored after touch\n * events to avoid synthetic mouse events.\n */\nconst ignoreMouseEventsTimeout = 800;\n/** Options used to bind a passive capturing event. */\nconst passiveCapturingEventOptions = normalizePassiveListenerOptions({\n    passive: true,\n    capture: true,\n});\n/** Events that signal that the pointer is down. */\nconst pointerDownEvents = ['mousedown', 'touchstart'];\n/** Events that signal that the pointer is up. */\nconst pointerUpEvents = ['mouseup', 'mouseleave', 'touchend', 'touchcancel'];\nclass _MatRippleStylesLoader {\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: _MatRippleStylesLoader, deps: [], target: i0.ɵɵFactoryTarget.Component });\n    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"14.0.0\", version: \"20.2.0-next.2\", type: _MatRippleStylesLoader, isStandalone: true, selector: \"ng-component\", host: { attributes: { \"mat-ripple-style-loader\": \"\" } }, ngImport: i0, template: '', isInline: true, styles: [\".mat-ripple{overflow:hidden;position:relative}.mat-ripple:not(:empty){transform:translateZ(0)}.mat-ripple.mat-ripple-unbounded{overflow:visible}.mat-ripple-element{position:absolute;border-radius:50%;pointer-events:none;transition:opacity,transform 0ms cubic-bezier(0, 0, 0.2, 1);transform:scale3d(0, 0, 0);background-color:var(--mat-ripple-color, color-mix(in srgb, var(--mat-sys-on-surface) 10%, transparent))}@media(forced-colors: active){.mat-ripple-element{display:none}}.cdk-drag-preview .mat-ripple-element,.cdk-drag-placeholder .mat-ripple-element{display:none}\\n\"], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: _MatRippleStylesLoader, decorators: [{\n            type: Component,\n            args: [{ template: '', changeDetection: ChangeDetectionStrategy.OnPush, encapsulation: ViewEncapsulation.None, host: { 'mat-ripple-style-loader': '' }, styles: [\".mat-ripple{overflow:hidden;position:relative}.mat-ripple:not(:empty){transform:translateZ(0)}.mat-ripple.mat-ripple-unbounded{overflow:visible}.mat-ripple-element{position:absolute;border-radius:50%;pointer-events:none;transition:opacity,transform 0ms cubic-bezier(0, 0, 0.2, 1);transform:scale3d(0, 0, 0);background-color:var(--mat-ripple-color, color-mix(in srgb, var(--mat-sys-on-surface) 10%, transparent))}@media(forced-colors: active){.mat-ripple-element{display:none}}.cdk-drag-preview .mat-ripple-element,.cdk-drag-placeholder .mat-ripple-element{display:none}\\n\"] }]\n        }] });\n/**\n * Helper service that performs DOM manipulations. Not intended to be used outside this module.\n * The constructor takes a reference to the ripple directive's host element and a map of DOM\n * event handlers to be installed on the element that triggers ripple animations.\n * This will eventually become a custom renderer once Angular support exists.\n * @docs-private\n */\nclass RippleRenderer {\n    _target;\n    _ngZone;\n    _platform;\n    /** Element where the ripples are being added to. */\n    _containerElement;\n    /** Element which triggers the ripple elements on mouse events. */\n    _triggerElement;\n    /** Whether the pointer is currently down or not. */\n    _isPointerDown = false;\n    /**\n     * Map of currently active ripple references.\n     * The ripple reference is mapped to its element event listeners.\n     * The reason why `| null` is used is that event listeners are added only\n     * when the condition is truthy (see the `_startFadeOutTransition` method).\n     */\n    _activeRipples = new Map();\n    /** Latest non-persistent ripple that was triggered. */\n    _mostRecentTransientRipple;\n    /** Time in milliseconds when the last touchstart event happened. */\n    _lastTouchStartEvent;\n    /** Whether pointer-up event listeners have been registered. */\n    _pointerUpEventsRegistered = false;\n    /**\n     * Cached dimensions of the ripple container. Set when the first\n     * ripple is shown and cleared once no more ripples are visible.\n     */\n    _containerRect;\n    static _eventManager = new RippleEventManager();\n    constructor(_target, _ngZone, elementOrElementRef, _platform, injector) {\n        this._target = _target;\n        this._ngZone = _ngZone;\n        this._platform = _platform;\n        // Only do anything if we're on the browser.\n        if (_platform.isBrowser) {\n            this._containerElement = coerceElement(elementOrElementRef);\n        }\n        if (injector) {\n            injector.get(_CdkPrivateStyleLoader).load(_MatRippleStylesLoader);\n        }\n    }\n    /**\n     * Fades in a ripple at the given coordinates.\n     * @param x Coordinate within the element, along the X axis at which to start the ripple.\n     * @param y Coordinate within the element, along the Y axis at which to start the ripple.\n     * @param config Extra ripple options.\n     */\n    fadeInRipple(x, y, config = {}) {\n        const containerRect = (this._containerRect =\n            this._containerRect || this._containerElement.getBoundingClientRect());\n        const animationConfig = { ...defaultRippleAnimationConfig, ...config.animation };\n        if (config.centered) {\n            x = containerRect.left + containerRect.width / 2;\n            y = containerRect.top + containerRect.height / 2;\n        }\n        const radius = config.radius || distanceToFurthestCorner(x, y, containerRect);\n        const offsetX = x - containerRect.left;\n        const offsetY = y - containerRect.top;\n        const enterDuration = animationConfig.enterDuration;\n        const ripple = document.createElement('div');\n        ripple.classList.add('mat-ripple-element');\n        ripple.style.left = `${offsetX - radius}px`;\n        ripple.style.top = `${offsetY - radius}px`;\n        ripple.style.height = `${radius * 2}px`;\n        ripple.style.width = `${radius * 2}px`;\n        // If a custom color has been specified, set it as inline style. If no color is\n        // set, the default color will be applied through the ripple theme styles.\n        if (config.color != null) {\n            ripple.style.backgroundColor = config.color;\n        }\n        ripple.style.transitionDuration = `${enterDuration}ms`;\n        this._containerElement.appendChild(ripple);\n        // By default the browser does not recalculate the styles of dynamically created\n        // ripple elements. This is critical to ensure that the `scale` animates properly.\n        // We enforce a style recalculation by calling `getComputedStyle` and *accessing* a property.\n        // See: https://gist.github.com/paulirish/5d52fb081b3570c81e3a\n        const computedStyles = window.getComputedStyle(ripple);\n        const userTransitionProperty = computedStyles.transitionProperty;\n        const userTransitionDuration = computedStyles.transitionDuration;\n        // Note: We detect whether animation is forcibly disabled through CSS (e.g. through\n        // `transition: none` or `display: none`). This is technically unexpected since animations are\n        // controlled through the animation config, but this exists for backwards compatibility. This\n        // logic does not need to be super accurate since it covers some edge cases which can be easily\n        // avoided by users.\n        const animationForciblyDisabledThroughCss = userTransitionProperty === 'none' ||\n            // Note: The canonical unit for serialized CSS `<time>` properties is seconds. Additionally\n            // some browsers expand the duration for every property (in our case `opacity` and `transform`).\n            userTransitionDuration === '0s' ||\n            userTransitionDuration === '0s, 0s' ||\n            // If the container is 0x0, it's likely `display: none`.\n            (containerRect.width === 0 && containerRect.height === 0);\n        // Exposed reference to the ripple that will be returned.\n        const rippleRef = new RippleRef(this, ripple, config, animationForciblyDisabledThroughCss);\n        // Start the enter animation by setting the transform/scale to 100%. The animation will\n        // execute as part of this statement because we forced a style recalculation before.\n        // Note: We use a 3d transform here in order to avoid an issue in Safari where\n        // the ripples aren't clipped when inside the shadow DOM (see #24028).\n        ripple.style.transform = 'scale3d(1, 1, 1)';\n        rippleRef.state = RippleState.FADING_IN;\n        if (!config.persistent) {\n            this._mostRecentTransientRipple = rippleRef;\n        }\n        let eventListeners = null;\n        // Do not register the `transition` event listener if fade-in and fade-out duration\n        // are set to zero. The events won't fire anyway and we can save resources here.\n        if (!animationForciblyDisabledThroughCss && (enterDuration || animationConfig.exitDuration)) {\n            this._ngZone.runOutsideAngular(() => {\n                const onTransitionEnd = () => {\n                    // Clear the fallback timer since the transition fired correctly.\n                    if (eventListeners) {\n                        eventListeners.fallbackTimer = null;\n                    }\n                    clearTimeout(fallbackTimer);\n                    this._finishRippleTransition(rippleRef);\n                };\n                const onTransitionCancel = () => this._destroyRipple(rippleRef);\n                // In some cases where there's a higher load on the browser, it can choose not to dispatch\n                // neither `transitionend` nor `transitioncancel` (see b/227356674). This timer serves as a\n                // fallback for such cases so that the ripple doesn't become stuck. We add a 100ms buffer\n                // because timers aren't precise. Note that another approach can be to transition the ripple\n                // to the `VISIBLE` state immediately above and to `FADING_IN` afterwards inside\n                // `transitionstart`. We go with the timer because it's one less event listener and\n                // it's less likely to break existing tests.\n                const fallbackTimer = setTimeout(onTransitionCancel, enterDuration + 100);\n                ripple.addEventListener('transitionend', onTransitionEnd);\n                // If the transition is cancelled (e.g. due to DOM removal), we destroy the ripple\n                // directly as otherwise we would keep it part of the ripple container forever.\n                // https://www.w3.org/TR/css-transitions-1/#:~:text=no%20longer%20in%20the%20document.\n                ripple.addEventListener('transitioncancel', onTransitionCancel);\n                eventListeners = { onTransitionEnd, onTransitionCancel, fallbackTimer };\n            });\n        }\n        // Add the ripple reference to the list of all active ripples.\n        this._activeRipples.set(rippleRef, eventListeners);\n        // In case there is no fade-in transition duration, we need to manually call the transition\n        // end listener because `transitionend` doesn't fire if there is no transition.\n        if (animationForciblyDisabledThroughCss || !enterDuration) {\n            this._finishRippleTransition(rippleRef);\n        }\n        return rippleRef;\n    }\n    /** Fades out a ripple reference. */\n    fadeOutRipple(rippleRef) {\n        // For ripples already fading out or hidden, this should be a noop.\n        if (rippleRef.state === RippleState.FADING_OUT || rippleRef.state === RippleState.HIDDEN) {\n            return;\n        }\n        const rippleEl = rippleRef.element;\n        const animationConfig = { ...defaultRippleAnimationConfig, ...rippleRef.config.animation };\n        // This starts the fade-out transition and will fire the transition end listener that\n        // removes the ripple element from the DOM.\n        rippleEl.style.transitionDuration = `${animationConfig.exitDuration}ms`;\n        rippleEl.style.opacity = '0';\n        rippleRef.state = RippleState.FADING_OUT;\n        // In case there is no fade-out transition duration, we need to manually call the\n        // transition end listener because `transitionend` doesn't fire if there is no transition.\n        if (rippleRef._animationForciblyDisabledThroughCss || !animationConfig.exitDuration) {\n            this._finishRippleTransition(rippleRef);\n        }\n    }\n    /** Fades out all currently active ripples. */\n    fadeOutAll() {\n        this._getActiveRipples().forEach(ripple => ripple.fadeOut());\n    }\n    /** Fades out all currently active non-persistent ripples. */\n    fadeOutAllNonPersistent() {\n        this._getActiveRipples().forEach(ripple => {\n            if (!ripple.config.persistent) {\n                ripple.fadeOut();\n            }\n        });\n    }\n    /** Sets up the trigger event listeners */\n    setupTriggerEvents(elementOrElementRef) {\n        const element = coerceElement(elementOrElementRef);\n        if (!this._platform.isBrowser || !element || element === this._triggerElement) {\n            return;\n        }\n        // Remove all previously registered event listeners from the trigger element.\n        this._removeTriggerEvents();\n        this._triggerElement = element;\n        // Use event delegation for the trigger events since they're\n        // set up during creation and are performance-sensitive.\n        pointerDownEvents.forEach(type => {\n            RippleRenderer._eventManager.addHandler(this._ngZone, type, element, this);\n        });\n    }\n    /**\n     * Handles all registered events.\n     * @docs-private\n     */\n    handleEvent(event) {\n        if (event.type === 'mousedown') {\n            this._onMousedown(event);\n        }\n        else if (event.type === 'touchstart') {\n            this._onTouchStart(event);\n        }\n        else {\n            this._onPointerUp();\n        }\n        // If pointer-up events haven't been registered yet, do so now.\n        // We do this on-demand in order to reduce the total number of event listeners\n        // registered by the ripples, which speeds up the rendering time for large UIs.\n        if (!this._pointerUpEventsRegistered) {\n            // The events for hiding the ripple are bound directly on the trigger, because:\n            // 1. Some of them occur frequently (e.g. `mouseleave`) and any advantage we get from\n            // delegation will be diminished by having to look through all the data structures often.\n            // 2. They aren't as performance-sensitive, because they're bound only after the user\n            // has interacted with an element.\n            this._ngZone.runOutsideAngular(() => {\n                pointerUpEvents.forEach(type => {\n                    this._triggerElement.addEventListener(type, this, passiveCapturingEventOptions);\n                });\n            });\n            this._pointerUpEventsRegistered = true;\n        }\n    }\n    /** Method that will be called if the fade-in or fade-in transition completed. */\n    _finishRippleTransition(rippleRef) {\n        if (rippleRef.state === RippleState.FADING_IN) {\n            this._startFadeOutTransition(rippleRef);\n        }\n        else if (rippleRef.state === RippleState.FADING_OUT) {\n            this._destroyRipple(rippleRef);\n        }\n    }\n    /**\n     * Starts the fade-out transition of the given ripple if it's not persistent and the pointer\n     * is not held down anymore.\n     */\n    _startFadeOutTransition(rippleRef) {\n        const isMostRecentTransientRipple = rippleRef === this._mostRecentTransientRipple;\n        const { persistent } = rippleRef.config;\n        rippleRef.state = RippleState.VISIBLE;\n        // When the timer runs out while the user has kept their pointer down, we want to\n        // keep only the persistent ripples and the latest transient ripple. We do this,\n        // because we don't want stacked transient ripples to appear after their enter\n        // animation has finished.\n        if (!persistent && (!isMostRecentTransientRipple || !this._isPointerDown)) {\n            rippleRef.fadeOut();\n        }\n    }\n    /** Destroys the given ripple by removing it from the DOM and updating its state. */\n    _destroyRipple(rippleRef) {\n        const eventListeners = this._activeRipples.get(rippleRef) ?? null;\n        this._activeRipples.delete(rippleRef);\n        // Clear out the cached bounding rect if we have no more ripples.\n        if (!this._activeRipples.size) {\n            this._containerRect = null;\n        }\n        // If the current ref is the most recent transient ripple, unset it\n        // avoid memory leaks.\n        if (rippleRef === this._mostRecentTransientRipple) {\n            this._mostRecentTransientRipple = null;\n        }\n        rippleRef.state = RippleState.HIDDEN;\n        if (eventListeners !== null) {\n            rippleRef.element.removeEventListener('transitionend', eventListeners.onTransitionEnd);\n            rippleRef.element.removeEventListener('transitioncancel', eventListeners.onTransitionCancel);\n            if (eventListeners.fallbackTimer !== null) {\n                clearTimeout(eventListeners.fallbackTimer);\n            }\n        }\n        rippleRef.element.remove();\n    }\n    /** Function being called whenever the trigger is being pressed using mouse. */\n    _onMousedown(event) {\n        // Screen readers will fire fake mouse events for space/enter. Skip launching a\n        // ripple in this case for consistency with the non-screen-reader experience.\n        const isFakeMousedown = isFakeMousedownFromScreenReader(event);\n        const isSyntheticEvent = this._lastTouchStartEvent &&\n            Date.now() < this._lastTouchStartEvent + ignoreMouseEventsTimeout;\n        if (!this._target.rippleDisabled && !isFakeMousedown && !isSyntheticEvent) {\n            this._isPointerDown = true;\n            this.fadeInRipple(event.clientX, event.clientY, this._target.rippleConfig);\n        }\n    }\n    /** Function being called whenever the trigger is being pressed using touch. */\n    _onTouchStart(event) {\n        if (!this._target.rippleDisabled && !isFakeTouchstartFromScreenReader(event)) {\n            // Some browsers fire mouse events after a `touchstart` event. Those synthetic mouse\n            // events will launch a second ripple if we don't ignore mouse events for a specific\n            // time after a touchstart event.\n            this._lastTouchStartEvent = Date.now();\n            this._isPointerDown = true;\n            // Use `changedTouches` so we skip any touches where the user put\n            // their finger down, but used another finger to tap the element again.\n            const touches = event.changedTouches;\n            // According to the typings the touches should always be defined, but in some cases\n            // the browser appears to not assign them in tests which leads to flakes.\n            if (touches) {\n                for (let i = 0; i < touches.length; i++) {\n                    this.fadeInRipple(touches[i].clientX, touches[i].clientY, this._target.rippleConfig);\n                }\n            }\n        }\n    }\n    /** Function being called whenever the trigger is being released. */\n    _onPointerUp() {\n        if (!this._isPointerDown) {\n            return;\n        }\n        this._isPointerDown = false;\n        // Fade-out all ripples that are visible and not persistent.\n        this._getActiveRipples().forEach(ripple => {\n            // By default, only ripples that are completely visible will fade out on pointer release.\n            // If the `terminateOnPointerUp` option is set, ripples that still fade in will also fade out.\n            const isVisible = ripple.state === RippleState.VISIBLE ||\n                (ripple.config.terminateOnPointerUp && ripple.state === RippleState.FADING_IN);\n            if (!ripple.config.persistent && isVisible) {\n                ripple.fadeOut();\n            }\n        });\n    }\n    _getActiveRipples() {\n        return Array.from(this._activeRipples.keys());\n    }\n    /** Removes previously registered event listeners from the trigger element. */\n    _removeTriggerEvents() {\n        const trigger = this._triggerElement;\n        if (trigger) {\n            pointerDownEvents.forEach(type => RippleRenderer._eventManager.removeHandler(type, trigger, this));\n            if (this._pointerUpEventsRegistered) {\n                pointerUpEvents.forEach(type => trigger.removeEventListener(type, this, passiveCapturingEventOptions));\n                this._pointerUpEventsRegistered = false;\n            }\n        }\n    }\n}\n/**\n * Returns the distance from the point (x, y) to the furthest corner of a rectangle.\n */\nfunction distanceToFurthestCorner(x, y, rect) {\n    const distX = Math.max(Math.abs(x - rect.left), Math.abs(x - rect.right));\n    const distY = Math.max(Math.abs(y - rect.top), Math.abs(y - rect.bottom));\n    return Math.sqrt(distX * distX + distY * distY);\n}\n\n/** Injection token that can be used to specify the global ripple options. */\nconst MAT_RIPPLE_GLOBAL_OPTIONS = new InjectionToken('mat-ripple-global-options');\nclass MatRipple {\n    _elementRef = inject(ElementRef);\n    _animationsDisabled = _animationsDisabled();\n    /** Custom color for all ripples. */\n    color;\n    /** Whether the ripples should be visible outside the component's bounds. */\n    unbounded;\n    /**\n     * Whether the ripple always originates from the center of the host element's bounds, rather\n     * than originating from the location of the click event.\n     */\n    centered;\n    /**\n     * If set, the radius in pixels of foreground ripples when fully expanded. If unset, the radius\n     * will be the distance from the center of the ripple to the furthest corner of the host element's\n     * bounding rectangle.\n     */\n    radius = 0;\n    /**\n     * Configuration for the ripple animation. Allows modifying the enter and exit animation\n     * duration of the ripples. The animation durations will be overwritten if the\n     * `NoopAnimationsModule` is being used.\n     */\n    animation;\n    /**\n     * Whether click events will not trigger the ripple. Ripples can be still launched manually\n     * by using the `launch()` method.\n     */\n    get disabled() {\n        return this._disabled;\n    }\n    set disabled(value) {\n        if (value) {\n            this.fadeOutAllNonPersistent();\n        }\n        this._disabled = value;\n        this._setupTriggerEventsIfEnabled();\n    }\n    _disabled = false;\n    /**\n     * The element that triggers the ripple when click events are received.\n     * Defaults to the directive's host element.\n     */\n    get trigger() {\n        return this._trigger || this._elementRef.nativeElement;\n    }\n    set trigger(trigger) {\n        this._trigger = trigger;\n        this._setupTriggerEventsIfEnabled();\n    }\n    _trigger;\n    /** Renderer for the ripple DOM manipulations. */\n    _rippleRenderer;\n    /** Options that are set globally for all ripples. */\n    _globalOptions;\n    /** @docs-private Whether ripple directive is initialized and the input bindings are set. */\n    _isInitialized = false;\n    constructor() {\n        const ngZone = inject(NgZone);\n        const platform = inject(Platform);\n        const globalOptions = inject(MAT_RIPPLE_GLOBAL_OPTIONS, { optional: true });\n        const injector = inject(Injector);\n        // Note: cannot use `inject()` here, because this class\n        // gets instantiated manually in the ripple loader.\n        this._globalOptions = globalOptions || {};\n        this._rippleRenderer = new RippleRenderer(this, ngZone, this._elementRef, platform, injector);\n    }\n    ngOnInit() {\n        this._isInitialized = true;\n        this._setupTriggerEventsIfEnabled();\n    }\n    ngOnDestroy() {\n        this._rippleRenderer._removeTriggerEvents();\n    }\n    /** Fades out all currently showing ripple elements. */\n    fadeOutAll() {\n        this._rippleRenderer.fadeOutAll();\n    }\n    /** Fades out all currently showing non-persistent ripple elements. */\n    fadeOutAllNonPersistent() {\n        this._rippleRenderer.fadeOutAllNonPersistent();\n    }\n    /**\n     * Ripple configuration from the directive's input values.\n     * @docs-private Implemented as part of RippleTarget\n     */\n    get rippleConfig() {\n        return {\n            centered: this.centered,\n            radius: this.radius,\n            color: this.color,\n            animation: {\n                ...this._globalOptions.animation,\n                ...(this._animationsDisabled ? { enterDuration: 0, exitDuration: 0 } : {}),\n                ...this.animation,\n            },\n            terminateOnPointerUp: this._globalOptions.terminateOnPointerUp,\n        };\n    }\n    /**\n     * Whether ripples on pointer-down are disabled or not.\n     * @docs-private Implemented as part of RippleTarget\n     */\n    get rippleDisabled() {\n        return this.disabled || !!this._globalOptions.disabled;\n    }\n    /** Sets up the trigger event listeners if ripples are enabled. */\n    _setupTriggerEventsIfEnabled() {\n        if (!this.disabled && this._isInitialized) {\n            this._rippleRenderer.setupTriggerEvents(this.trigger);\n        }\n    }\n    /** Launches a manual ripple at the specified coordinated or just by the ripple config. */\n    launch(configOrX, y = 0, config) {\n        if (typeof configOrX === 'number') {\n            return this._rippleRenderer.fadeInRipple(configOrX, y, { ...this.rippleConfig, ...config });\n        }\n        else {\n            return this._rippleRenderer.fadeInRipple(0, 0, { ...this.rippleConfig, ...configOrX });\n        }\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: MatRipple, deps: [], target: i0.ɵɵFactoryTarget.Directive });\n    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"20.2.0-next.2\", type: MatRipple, isStandalone: true, selector: \"[mat-ripple], [matRipple]\", inputs: { color: [\"matRippleColor\", \"color\"], unbounded: [\"matRippleUnbounded\", \"unbounded\"], centered: [\"matRippleCentered\", \"centered\"], radius: [\"matRippleRadius\", \"radius\"], animation: [\"matRippleAnimation\", \"animation\"], disabled: [\"matRippleDisabled\", \"disabled\"], trigger: [\"matRippleTrigger\", \"trigger\"] }, host: { properties: { \"class.mat-ripple-unbounded\": \"unbounded\" }, classAttribute: \"mat-ripple\" }, exportAs: [\"matRipple\"], ngImport: i0 });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: MatRipple, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[mat-ripple], [matRipple]',\n                    exportAs: 'matRipple',\n                    host: {\n                        'class': 'mat-ripple',\n                        '[class.mat-ripple-unbounded]': 'unbounded',\n                    },\n                }]\n        }], ctorParameters: () => [], propDecorators: { color: [{\n                type: Input,\n                args: ['matRippleColor']\n            }], unbounded: [{\n                type: Input,\n                args: ['matRippleUnbounded']\n            }], centered: [{\n                type: Input,\n                args: ['matRippleCentered']\n            }], radius: [{\n                type: Input,\n                args: ['matRippleRadius']\n            }], animation: [{\n                type: Input,\n                args: ['matRippleAnimation']\n            }], disabled: [{\n                type: Input,\n                args: ['matRippleDisabled']\n            }], trigger: [{\n                type: Input,\n                args: ['matRippleTrigger']\n            }] } });\n\nexport { MAT_RIPPLE_GLOBAL_OPTIONS, MatRipple, RippleRef, RippleRenderer, RippleState, defaultRippleAnimationConfig };\n","import * as i0 from '@angular/core';\nimport { Component, ViewEncapsulation, ChangeDetectionStrategy } from '@angular/core';\n\n/**\n * Component used to load structural styles for focus indicators.\n * @docs-private\n */\nclass _StructuralStylesLoader {\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: _StructuralStylesLoader, deps: [], target: i0.ɵɵFactoryTarget.Component });\n    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"14.0.0\", version: \"20.2.0-next.2\", type: _StructuralStylesLoader, isStandalone: true, selector: \"structural-styles\", ngImport: i0, template: '', isInline: true, styles: [\".mat-focus-indicator{position:relative}.mat-focus-indicator::before{top:0;left:0;right:0;bottom:0;position:absolute;box-sizing:border-box;pointer-events:none;display:var(--mat-focus-indicator-display, none);border-width:var(--mat-focus-indicator-border-width, 3px);border-style:var(--mat-focus-indicator-border-style, solid);border-color:var(--mat-focus-indicator-border-color, transparent);border-radius:var(--mat-focus-indicator-border-radius, 4px)}.mat-focus-indicator:focus::before{content:\\\"\\\"}@media(forced-colors: active){html{--mat-focus-indicator-display: block}}\\n\"], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: _StructuralStylesLoader, decorators: [{\n            type: Component,\n            args: [{ selector: 'structural-styles', encapsulation: ViewEncapsulation.None, template: '', changeDetection: ChangeDetectionStrategy.OnPush, styles: [\".mat-focus-indicator{position:relative}.mat-focus-indicator::before{top:0;left:0;right:0;bottom:0;position:absolute;box-sizing:border-box;pointer-events:none;display:var(--mat-focus-indicator-display, none);border-width:var(--mat-focus-indicator-border-width, 3px);border-style:var(--mat-focus-indicator-border-style, solid);border-color:var(--mat-focus-indicator-border-color, transparent);border-radius:var(--mat-focus-indicator-border-radius, 4px)}.mat-focus-indicator:focus::before{content:\\\"\\\"}@media(forced-colors: active){html{--mat-focus-indicator-display: block}}\\n\"] }]\n        }] });\n\nexport { _StructuralStylesLoader };\n"],"x_google_ignoreList":[0,1,2,3]}