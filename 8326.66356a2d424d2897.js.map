{"version":3,"file":"8326.66356a2d424d2897.js","mappings":"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","names":["ScrollingModule","_ScrollingModule","_createClass","_classCallCheck","this","_defineProperty","__ngFactoryType__","i0","type","_ResponsiveStepperComponent_mat_horizontal_stepper_1_Template","rf","ctx","_r1","$event","ctx_r1","animationDone","emit","selectionChange","labelPosition","linear","selected","selectedIndex","_ResponsiveStepperComponent_mat_vertical_stepper_2_Template","_r3","MAT_STEPPER_PROXY_FACTORY_PROVIDER","provide","MatStepper","deps","forwardRef","ResponsiveStepperComponent","Optional","Directionality","ChangeDetectorRef","Inject","DOCUMENT","useFactory","MAT_STEPPER_PROXY_FACTORY","CDK_STEPPER_PROXY_FACTORY_PROVIDER","_objectSpread","CdkStepper","component","directionality","changeDetectorRef","document","elementRef","ElementRef","createElement","stepper","Proxy","get","target","property","Reflect","set","value","_ResponsiveStepperComponent","EventEmitter","orientationChange","needsFocus","htmlSteps","key","stepperList","first","_this","reset","changes","subscribe","e","lastSelectedIndex","syncHTMLSteps","setTimeout","_this$stepper","_keyManager","_elementRef","nativeElement","focus","setActiveItem","orientation","next","previous","step","enabled","length","style","pointerEvents","increment","querySelector","i","children","push","_this2","steps","toArray","notifyOnChanges","ɵfac","ɵcmp","selectors","contentQueries","dirIndex","_t","MatStep","viewQuery","inputs","outputs","standalone","features","decls","vars","consts","template","dependencies","i1","i2","encapsulation","changeDetection","MaterialModule","_MaterialModule","ɵmod","ɵinj","imports","CommonModule","CdkStepperModule","MatStepperModule","A11yModule","CdkTableModule","CdkTreeModule","DragDropModule","MatAutocompleteModule","MatBadgeModule","MatBottomSheetModule","MatButtonModule","MatButtonToggleModule","MatCardModule","MatCheckboxModule","MatChipsModule","MatDatepickerModule","MatDialogModule","MatDividerModule","MatExpansionModule","MatGridListModule","MatIconModule","MatInputModule","MatListModule","MatMenuModule","MatNativeDateModule","MatPaginatorModule","MatProgressBarModule","MatProgressSpinnerModule","MatRadioModule","MatRippleModule","MatSelectModule","MatSidenavModule","MatSliderModule","MatSlideToggleModule","MatSnackBarModule","MatSortModule","MatTableModule","MatTabsModule","MatToolbarModule","MatTooltipModule","MatTreeModule","PortalModule","ScrollingModule$1"],"ignoreList":[],"sourceRoot":"webpack:///","sources":["./node_modules/@angular/cdk-experimental/fesm2022/scrolling.mjs","./node_modules/@rollthecloudinc/material/fesm2022/rollthecloudinc-material.mjs"],"sourcesContent":["import { coerceNumberProperty } from '@angular/cdk/coercion';\nimport { VIRTUAL_SCROLL_STRATEGY } from '@angular/cdk/scrolling';\nimport * as i0 from '@angular/core';\nimport { forwardRef, Directive, Input, NgModule } from '@angular/core';\nimport { Observable } from 'rxjs';\n\n/**\n * A class that tracks the size of items that have been seen and uses it to estimate the average\n * item size.\n */\nclass ItemSizeAverager {\n    /** The total amount of weight behind the current average. */\n    _totalWeight = 0;\n    /** The current average item size. */\n    _averageItemSize;\n    /** The default size to use for items when no data is available. */\n    _defaultItemSize;\n    /** @param defaultItemSize The default size to use for items when no data is available. */\n    constructor(defaultItemSize = 50) {\n        this._defaultItemSize = defaultItemSize;\n        this._averageItemSize = defaultItemSize;\n    }\n    /** Returns the average item size. */\n    getAverageItemSize() {\n        return this._averageItemSize;\n    }\n    /**\n     * Adds a measurement sample for the estimator to consider.\n     * @param range The measured range.\n     * @param size The measured size of the given range in pixels.\n     */\n    addSample(range, size) {\n        const newTotalWeight = this._totalWeight + range.end - range.start;\n        if (newTotalWeight) {\n            const newAverageItemSize = (size + this._averageItemSize * this._totalWeight) / newTotalWeight;\n            if (newAverageItemSize) {\n                this._averageItemSize = newAverageItemSize;\n                this._totalWeight = newTotalWeight;\n            }\n        }\n    }\n    /** Resets the averager. */\n    reset() {\n        this._averageItemSize = this._defaultItemSize;\n        this._totalWeight = 0;\n    }\n}\n/** Virtual scrolling strategy for lists with items of unknown or dynamic size. */\nclass AutoSizeVirtualScrollStrategy {\n    /** @docs-private Implemented as part of VirtualScrollStrategy. */\n    scrolledIndexChange = new Observable(() => {\n        // TODO(mmalerba): Implement.\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            throw Error('cdk-virtual-scroll: scrolledIndexChange is currently not supported for the' +\n                ' autosize scroll strategy');\n        }\n    });\n    /** The attached viewport. */\n    _viewport = null;\n    /** The minimum amount of buffer rendered beyond the viewport (in pixels). */\n    _minBufferPx;\n    /** The number of buffer items to render beyond the edge of the viewport (in pixels). */\n    _maxBufferPx;\n    /** The estimator used to estimate the size of unseen items. */\n    _averager;\n    /** The last measured scroll offset of the viewport. */\n    _lastScrollOffset;\n    /** The last measured size of the rendered content in the viewport. */\n    _lastRenderedContentSize;\n    /** The last measured size of the rendered content in the viewport. */\n    _lastRenderedContentOffset;\n    /**\n     * The number of consecutive cycles where removing extra items has failed. Failure here means that\n     * we estimated how many items we could safely remove, but our estimate turned out to be too much\n     * and it wasn't safe to remove that many elements.\n     */\n    _removalFailures = 0;\n    /**\n     * @param minBufferPx The minimum amount of buffer rendered beyond the viewport (in pixels).\n     *     If the amount of buffer dips below this number, more items will be rendered.\n     * @param maxBufferPx The number of pixels worth of buffer to shoot for when rendering new items.\n     *     If the actual amount turns out to be less it will not necessarily trigger an additional\n     *     rendering cycle (as long as the amount of buffer is still greater than `minBufferPx`).\n     * @param averager The averager used to estimate the size of unseen items.\n     */\n    constructor(minBufferPx, maxBufferPx, averager = new ItemSizeAverager()) {\n        this._minBufferPx = minBufferPx;\n        this._maxBufferPx = maxBufferPx;\n        this._averager = averager;\n    }\n    /**\n     * Attaches this scroll strategy to a viewport.\n     * @param viewport The viewport to attach this strategy to.\n     */\n    attach(viewport) {\n        this._averager.reset();\n        this._viewport = viewport;\n        this._renderContentForCurrentOffset();\n    }\n    /** Detaches this scroll strategy from the currently attached viewport. */\n    detach() {\n        this._viewport = null;\n    }\n    /** @docs-private Implemented as part of VirtualScrollStrategy. */\n    onContentScrolled() {\n        if (this._viewport) {\n            this._updateRenderedContentAfterScroll();\n        }\n    }\n    /** @docs-private Implemented as part of VirtualScrollStrategy. */\n    onDataLengthChanged() {\n        if (this._viewport) {\n            this._renderContentForCurrentOffset();\n            this._checkRenderedContentSize();\n        }\n    }\n    /** @docs-private Implemented as part of VirtualScrollStrategy. */\n    onContentRendered() {\n        if (this._viewport) {\n            this._checkRenderedContentSize();\n        }\n    }\n    /** @docs-private Implemented as part of VirtualScrollStrategy. */\n    onRenderedOffsetChanged() {\n        if (this._viewport) {\n            this._checkRenderedContentOffset();\n        }\n    }\n    /** Scroll to the offset for the given index. */\n    scrollToIndex() {\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            // TODO(mmalerba): Implement.\n            throw Error('cdk-virtual-scroll: scrollToIndex is currently not supported for the autosize' +\n                ' scroll strategy');\n        }\n    }\n    /**\n     * Update the buffer parameters.\n     * @param minBufferPx The minimum amount of buffer rendered beyond the viewport (in pixels).\n     * @param maxBufferPx The number of buffer items to render beyond the edge of the viewport (in\n     *     pixels).\n     */\n    updateBufferSize(minBufferPx, maxBufferPx) {\n        if (maxBufferPx < minBufferPx) {\n            throw Error('CDK virtual scroll: maxBufferPx must be greater than or equal to minBufferPx');\n        }\n        this._minBufferPx = minBufferPx;\n        this._maxBufferPx = maxBufferPx;\n    }\n    /** Update the rendered content after the user scrolls. */\n    _updateRenderedContentAfterScroll() {\n        const viewport = this._viewport;\n        // The current scroll offset.\n        const scrollOffset = viewport.measureScrollOffset();\n        // The delta between the current scroll offset and the previously recorded scroll offset.\n        let scrollDelta = scrollOffset - this._lastScrollOffset;\n        // The magnitude of the scroll delta.\n        let scrollMagnitude = Math.abs(scrollDelta);\n        // The currently rendered range.\n        const renderedRange = viewport.getRenderedRange();\n        // If we're scrolling toward the top, we need to account for the fact that the predicted amount\n        // of content and the actual amount of scrollable space may differ. We address this by slowly\n        // correcting the difference on each scroll event.\n        let offsetCorrection = 0;\n        if (scrollDelta < 0) {\n            // The content offset we would expect based on the average item size.\n            const predictedOffset = renderedRange.start * this._averager.getAverageItemSize();\n            // The difference between the predicted size of the un-rendered content at the beginning and\n            // the actual available space to scroll over. We need to reduce this to zero by the time the\n            // user scrolls to the top.\n            // - 0 indicates that the predicted size and available space are the same.\n            // - A negative number that the predicted size is smaller than the available space.\n            // - A positive number indicates the predicted size is larger than the available space\n            const offsetDifference = predictedOffset - this._lastRenderedContentOffset;\n            // The amount of difference to correct during this scroll event. We calculate this as a\n            // percentage of the total difference based on the percentage of the distance toward the top\n            // that the user scrolled.\n            offsetCorrection = Math.round(offsetDifference *\n                Math.max(0, Math.min(1, scrollMagnitude / (scrollOffset + scrollMagnitude))));\n            // Based on the offset correction above, we pretend that the scroll delta was bigger or\n            // smaller than it actually was, this way we can start to eliminate the difference.\n            scrollDelta = scrollDelta - offsetCorrection;\n            scrollMagnitude = Math.abs(scrollDelta);\n        }\n        // The current amount of buffer past the start of the viewport.\n        const startBuffer = this._lastScrollOffset - this._lastRenderedContentOffset;\n        // The current amount of buffer past the end of the viewport.\n        const endBuffer = this._lastRenderedContentOffset +\n            this._lastRenderedContentSize -\n            (this._lastScrollOffset + viewport.getViewportSize());\n        // The amount of unfilled space that should be filled on the side the user is scrolling toward\n        // in order to safely absorb the scroll delta.\n        const underscan = scrollMagnitude + this._minBufferPx - (scrollDelta < 0 ? startBuffer : endBuffer);\n        // Check if there's unfilled space that we need to render new elements to fill.\n        if (underscan > 0) {\n            // Check if the scroll magnitude was larger than the viewport size. In this case the user\n            // won't notice a discontinuity if we just jump to the new estimated position in the list.\n            // However, if the scroll magnitude is smaller than the viewport the user might notice some\n            // jitteriness if we just jump to the estimated position. Instead we make sure to scroll by\n            // the same number of pixels as the scroll magnitude.\n            if (scrollMagnitude >= viewport.getViewportSize()) {\n                this._renderContentForCurrentOffset();\n            }\n            else {\n                // The number of new items to render on the side the user is scrolling towards. Rather than\n                // just filling the underscan space, we actually fill enough to have a buffer size of\n                // `maxBufferPx`. This gives us a little wiggle room in case our item size estimate is off.\n                const addItems = Math.max(0, Math.ceil((underscan - this._minBufferPx + this._maxBufferPx) /\n                    this._averager.getAverageItemSize()));\n                // The amount of filled space beyond what is necessary on the side the user is scrolling\n                // away from.\n                const overscan = (scrollDelta < 0 ? endBuffer : startBuffer) - this._minBufferPx + scrollMagnitude;\n                // The number of currently rendered items to remove on the side the user is scrolling away\n                // from. If removal has failed in recent cycles we are less aggressive in how much we try to\n                // remove.\n                const unboundedRemoveItems = Math.floor(overscan / this._averager.getAverageItemSize() / (this._removalFailures + 1));\n                const removeItems = Math.min(renderedRange.end - renderedRange.start, Math.max(0, unboundedRemoveItems));\n                // The new range we will tell the viewport to render. We first expand it to include the new\n                // items we want rendered, we then contract the opposite side to remove items we no longer\n                // want rendered.\n                const range = this._expandRange(renderedRange, scrollDelta < 0 ? addItems : 0, scrollDelta > 0 ? addItems : 0);\n                if (scrollDelta < 0) {\n                    range.end = Math.max(range.start + 1, range.end - removeItems);\n                }\n                else {\n                    range.start = Math.min(range.end - 1, range.start + removeItems);\n                }\n                // The new offset we want to set on the rendered content. To determine this we measure the\n                // number of pixels we removed and then adjust the offset to the start of the rendered\n                // content or to the end of the rendered content accordingly (whichever one doesn't require\n                // that the newly added items to be rendered to calculate.)\n                let contentOffset;\n                let contentOffsetTo;\n                if (scrollDelta < 0) {\n                    let removedSize = viewport.measureRangeSize({\n                        start: range.end,\n                        end: renderedRange.end,\n                    });\n                    // Check that we're not removing too much.\n                    if (removedSize <= overscan) {\n                        contentOffset =\n                            this._lastRenderedContentOffset + this._lastRenderedContentSize - removedSize;\n                        this._removalFailures = 0;\n                    }\n                    else {\n                        // If the removal is more than the overscan can absorb just undo it and record the fact\n                        // that the removal failed so we can be less aggressive next time.\n                        range.end = renderedRange.end;\n                        contentOffset = this._lastRenderedContentOffset + this._lastRenderedContentSize;\n                        this._removalFailures++;\n                    }\n                    contentOffsetTo = 'to-end';\n                }\n                else {\n                    const removedSize = viewport.measureRangeSize({\n                        start: renderedRange.start,\n                        end: range.start,\n                    });\n                    // Check that we're not removing too much.\n                    if (removedSize <= overscan) {\n                        contentOffset = this._lastRenderedContentOffset + removedSize;\n                        this._removalFailures = 0;\n                    }\n                    else {\n                        // If the removal is more than the overscan can absorb just undo it and record the fact\n                        // that the removal failed so we can be less aggressive next time.\n                        range.start = renderedRange.start;\n                        contentOffset = this._lastRenderedContentOffset;\n                        this._removalFailures++;\n                    }\n                    contentOffsetTo = 'to-start';\n                }\n                // Set the range and offset we calculated above.\n                viewport.setRenderedRange(range);\n                viewport.setRenderedContentOffset(contentOffset + offsetCorrection, contentOffsetTo);\n            }\n        }\n        else if (offsetCorrection) {\n            // Even if the rendered range didn't change, we may still need to adjust the content offset to\n            // simulate scrolling slightly slower or faster than the user actually scrolled.\n            viewport.setRenderedContentOffset(this._lastRenderedContentOffset + offsetCorrection);\n        }\n        // Save the scroll offset to be compared to the new value on the next scroll event.\n        this._lastScrollOffset = scrollOffset;\n    }\n    /**\n     * Checks the size of the currently rendered content and uses it to update the estimated item size\n     * and estimated total content size.\n     */\n    _checkRenderedContentSize() {\n        const viewport = this._viewport;\n        this._lastRenderedContentSize = viewport.measureRenderedContentSize();\n        this._averager.addSample(viewport.getRenderedRange(), this._lastRenderedContentSize);\n        this._updateTotalContentSize(this._lastRenderedContentSize);\n    }\n    /** Checks the currently rendered content offset and saves the value for later use. */\n    _checkRenderedContentOffset() {\n        const viewport = this._viewport;\n        this._lastRenderedContentOffset = viewport.getOffsetToRenderedContentStart();\n    }\n    /**\n     * Recalculates the rendered content based on our estimate of what should be shown at the current\n     * scroll offset.\n     */\n    _renderContentForCurrentOffset() {\n        const viewport = this._viewport;\n        const scrollOffset = viewport.measureScrollOffset();\n        this._lastScrollOffset = scrollOffset;\n        this._removalFailures = 0;\n        const itemSize = this._averager.getAverageItemSize();\n        const firstVisibleIndex = Math.min(viewport.getDataLength() - 1, Math.floor(scrollOffset / itemSize));\n        const bufferSize = Math.ceil(this._maxBufferPx / itemSize);\n        const range = this._expandRange(this._getVisibleRangeForIndex(firstVisibleIndex), bufferSize, bufferSize);\n        viewport.setRenderedRange(range);\n        viewport.setRenderedContentOffset(itemSize * range.start);\n    }\n    // TODO: maybe move to base class, can probably share with fixed size strategy.\n    /**\n     * Gets the visible range of data for the given start index. If the start index is too close to\n     * the end of the list it may be backed up to ensure the estimated size of the range is enough to\n     * fill the viewport.\n     * Note: must not be called if `this._viewport` is null\n     * @param startIndex The index to start the range at\n     * @return a range estimated to be large enough to fill the viewport when rendered.\n     */\n    _getVisibleRangeForIndex(startIndex) {\n        const viewport = this._viewport;\n        const range = {\n            start: startIndex,\n            end: startIndex + Math.ceil(viewport.getViewportSize() / this._averager.getAverageItemSize()),\n        };\n        const extra = range.end - viewport.getDataLength();\n        if (extra > 0) {\n            range.start = Math.max(0, range.start - extra);\n        }\n        return range;\n    }\n    // TODO: maybe move to base class, can probably share with fixed size strategy.\n    /**\n     * Expand the given range by the given amount in either direction.\n     * Note: must not be called if `this._viewport` is null\n     * @param range The range to expand\n     * @param expandStart The number of items to expand the start of the range by.\n     * @param expandEnd The number of items to expand the end of the range by.\n     * @return The expanded range.\n     */\n    _expandRange(range, expandStart, expandEnd) {\n        const viewport = this._viewport;\n        const start = Math.max(0, range.start - expandStart);\n        const end = Math.min(viewport.getDataLength(), range.end + expandEnd);\n        return { start, end };\n    }\n    /** Update the viewport's total content size. */\n    _updateTotalContentSize(renderedContentSize) {\n        const viewport = this._viewport;\n        const renderedRange = viewport.getRenderedRange();\n        const totalSize = renderedContentSize +\n            (viewport.getDataLength() - (renderedRange.end - renderedRange.start)) *\n                this._averager.getAverageItemSize();\n        viewport.setTotalContentSize(totalSize);\n    }\n}\n/**\n * Provider factory for `AutoSizeVirtualScrollStrategy` that simply extracts the already created\n * `AutoSizeVirtualScrollStrategy` from the given directive.\n * @param autoSizeDir The instance of `CdkAutoSizeVirtualScroll` to extract the\n *     `AutoSizeVirtualScrollStrategy` from.\n */\nfunction _autoSizeVirtualScrollStrategyFactory(autoSizeDir) {\n    return autoSizeDir._scrollStrategy;\n}\n/** A virtual scroll strategy that supports unknown or dynamic size items. */\nclass CdkAutoSizeVirtualScroll {\n    /**\n     * The minimum amount of buffer rendered beyond the viewport (in pixels).\n     * If the amount of buffer dips below this number, more items will be rendered. Defaults to 100px.\n     */\n    get minBufferPx() {\n        return this._minBufferPx;\n    }\n    set minBufferPx(value) {\n        this._minBufferPx = coerceNumberProperty(value);\n    }\n    _minBufferPx = 100;\n    /**\n     * The number of pixels worth of buffer to shoot for when rendering new items.\n     * If the actual amount turns out to be less it will not necessarily trigger an additional\n     * rendering cycle (as long as the amount of buffer is still greater than `minBufferPx`).\n     * Defaults to 200px.\n     */\n    get maxBufferPx() {\n        return this._maxBufferPx;\n    }\n    set maxBufferPx(value) {\n        this._maxBufferPx = coerceNumberProperty(value);\n    }\n    _maxBufferPx = 200;\n    /** The scroll strategy used by this directive. */\n    _scrollStrategy = new AutoSizeVirtualScrollStrategy(this.minBufferPx, this.maxBufferPx);\n    ngOnChanges() {\n        this._scrollStrategy.updateBufferSize(this.minBufferPx, this.maxBufferPx);\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: CdkAutoSizeVirtualScroll, deps: [], target: i0.ɵɵFactoryTarget.Directive });\n    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"20.2.0-next.2\", type: CdkAutoSizeVirtualScroll, isStandalone: true, selector: \"cdk-virtual-scroll-viewport[autosize]\", inputs: { minBufferPx: \"minBufferPx\", maxBufferPx: \"maxBufferPx\" }, providers: [\n            {\n                provide: VIRTUAL_SCROLL_STRATEGY,\n                useFactory: _autoSizeVirtualScrollStrategyFactory,\n                deps: [forwardRef(() => CdkAutoSizeVirtualScroll)],\n            },\n        ], usesOnChanges: true, ngImport: i0 });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: CdkAutoSizeVirtualScroll, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: 'cdk-virtual-scroll-viewport[autosize]',\n                    providers: [\n                        {\n                            provide: VIRTUAL_SCROLL_STRATEGY,\n                            useFactory: _autoSizeVirtualScrollStrategyFactory,\n                            deps: [forwardRef(() => CdkAutoSizeVirtualScroll)],\n                        },\n                    ],\n                }]\n        }], propDecorators: { minBufferPx: [{\n                type: Input\n            }], maxBufferPx: [{\n                type: Input\n            }] } });\n\nclass ScrollingModule {\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: ScrollingModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\n    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: ScrollingModule, imports: [CdkAutoSizeVirtualScroll], exports: [CdkAutoSizeVirtualScroll] });\n    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: ScrollingModule });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: ScrollingModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [CdkAutoSizeVirtualScroll],\n                    exports: [CdkAutoSizeVirtualScroll],\n                }]\n        }] });\n\nexport { AutoSizeVirtualScrollStrategy, CdkAutoSizeVirtualScroll, ItemSizeAverager, ScrollingModule, _autoSizeVirtualScrollStrategyFactory };\n","import * as i1 from '@angular/common';\nimport { CommonModule } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { forwardRef, Optional, ChangeDetectorRef, Inject, DOCUMENT, ElementRef, EventEmitter, ContentChildren, ViewChildren, Output, Input, ChangeDetectionStrategy, Component, NgModule } from '@angular/core';\nimport { A11yModule } from '@angular/cdk/a11y';\nimport { DragDropModule } from '@angular/cdk/drag-drop';\nimport { PortalModule } from '@angular/cdk/portal';\nimport { ScrollingModule } from '@angular/cdk/scrolling';\nimport { CdkStepper, CdkStepperModule } from '@angular/cdk/stepper';\nimport { CdkTableModule } from '@angular/cdk/table';\nimport { CdkTreeModule } from '@angular/cdk/tree';\nimport { MatAutocompleteModule } from '@angular/material/autocomplete';\nimport { MatBadgeModule } from '@angular/material/badge';\nimport { MatBottomSheetModule } from '@angular/material/bottom-sheet';\nimport { MatButtonModule } from '@angular/material/button';\nimport { MatButtonToggleModule } from '@angular/material/button-toggle';\nimport { MatCardModule } from '@angular/material/card';\nimport { MatCheckboxModule } from '@angular/material/checkbox';\nimport { MatChipsModule } from '@angular/material/chips';\nimport * as i2 from '@angular/material/stepper';\nimport { MatStepper, MatStep, MatStepperModule } from '@angular/material/stepper';\nimport { MatDatepickerModule } from '@angular/material/datepicker';\nimport { MatDialogModule } from '@angular/material/dialog';\nimport { MatDividerModule } from '@angular/material/divider';\nimport { MatExpansionModule } from '@angular/material/expansion';\nimport { MatGridListModule } from '@angular/material/grid-list';\nimport { MatIconModule } from '@angular/material/icon';\nimport { MatInputModule } from '@angular/material/input';\nimport { MatListModule } from '@angular/material/list';\nimport { MatMenuModule } from '@angular/material/menu';\nimport { MatNativeDateModule, MatRippleModule } from '@angular/material/core';\nimport { MatPaginatorModule } from '@angular/material/paginator';\nimport { MatProgressBarModule } from '@angular/material/progress-bar';\nimport { MatProgressSpinnerModule } from '@angular/material/progress-spinner';\nimport { MatRadioModule } from '@angular/material/radio';\nimport { MatSelectModule } from '@angular/material/select';\nimport { MatSidenavModule } from '@angular/material/sidenav';\nimport { MatSliderModule } from '@angular/material/slider';\nimport { MatSlideToggleModule } from '@angular/material/slide-toggle';\nimport { MatSnackBarModule } from '@angular/material/snack-bar';\nimport { MatSortModule } from '@angular/material/sort';\nimport { MatTableModule } from '@angular/material/table';\nimport { MatTabsModule } from '@angular/material/tabs';\nimport { MatToolbarModule } from '@angular/material/toolbar';\nimport { MatTooltipModule } from '@angular/material/tooltip';\nimport { MatTreeModule } from '@angular/material/tree';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { ScrollingModule as ScrollingModule$1 } from '@angular/cdk-experimental/scrolling';\n\nconst MAT_STEPPER_PROXY_FACTORY_PROVIDER = {\n    provide: MatStepper,\n    deps: [\n        forwardRef(() => ResponsiveStepperComponent),\n        [new Optional(), Directionality],\n        ChangeDetectorRef,\n        [new Inject(DOCUMENT)]\n    ],\n    useFactory: MAT_STEPPER_PROXY_FACTORY\n};\nconst CDK_STEPPER_PROXY_FACTORY_PROVIDER = { ...MAT_STEPPER_PROXY_FACTORY_PROVIDER, provide: CdkStepper };\nfunction MAT_STEPPER_PROXY_FACTORY(component, directionality, changeDetectorRef, document) {\n    // We create a fake stepper primarily so we can generate a proxy from it. The fake one, however, is used until\n    // our view is initialized. The reason we need a proxy is so we can toggle between our 2 steppers\n    // (vertical and horizontal) depending on  our \"orientation\" property. Probably a good idea to include a polyfill\n    // for the Proxy class: https://github.com/GoogleChrome/proxy-polyfill.\n    const elementRef = new ElementRef(document.createElement('mat-horizontal-stepper'));\n    const stepper = new MatStepper(directionality, changeDetectorRef, elementRef /*, document*/);\n    return new Proxy(stepper, {\n        get: (target, property) => Reflect.get(component.stepper || target, property),\n        set: (target, property, value) => Reflect.set(component.stepper || target, property, value)\n    });\n}\n/**\n * Configurable vertical/horizontal layout.<br>\n * Keeps input fields state.<br>\n * Allow to make headers un-clickable (disabled) with normal cursor: see updateStepState().\n *\n * Authors: @grant77, @davideas\n */\nclass ResponsiveStepperComponent {\n    constructor() {\n        // public events\n        this.animationDone = new EventEmitter();\n        this.selectionChange = new EventEmitter();\n        this.orientationChange = new EventEmitter();\n        this.needsFocus = false;\n        this.htmlSteps = [];\n    }\n    get stepper() {\n        return this.stepperList && this.stepperList.first;\n    }\n    /*constructor(private changeDetectorRef: ChangeDetectorRef) {\n    }*/\n    ngAfterViewInit() {\n        this.reset();\n        this.stepperList.changes.subscribe(() => this.reset());\n        // Emitted from (animationDone) event\n        this.selectionChange.subscribe((e) => this.lastSelectedIndex = e.selectedIndex);\n        this.syncHTMLSteps();\n        // Initial step selection with enter animation if initial step > 1\n        setTimeout(() => this.stepper.selectedIndex = this.selectedIndex, 400);\n    }\n    ngAfterViewChecked() {\n        if (this.needsFocus) {\n            this.needsFocus = false;\n            const { _elementRef, _keyManager, selectedIndex } = this.stepper;\n            _elementRef.nativeElement.focus();\n            _keyManager.setActiveItem(selectedIndex);\n        }\n    }\n    get isHorizontal() {\n        return this.orientation === 'horizontal';\n    }\n    get isVertical() {\n        return this.orientation === 'vertical';\n    }\n    next() {\n        this.stepper.next();\n    }\n    previous() {\n        this.stepper.previous();\n    }\n    /**\n     * Enable/Disable the click on the step header.\n     *\n     * @param step The step number\n     * @param enabled The new state\n     */\n    updateStepState(step, enabled) {\n        if (this.htmlSteps.length > 0) {\n            this.htmlSteps[step - 1].style.pointerEvents = enabled ? '' : 'none';\n        }\n    }\n    /**\n     * Sync from the dom the list of HTML elements for the steps.\n     */\n    syncHTMLSteps() {\n        this.htmlSteps = [];\n        let increment = 1;\n        let stepper = document.querySelector('.mat-stepper-vertical');\n        if (!stepper) {\n            increment = 2; // 2, because Angular adds 2 elements for each horizontal step\n            stepper = document.querySelector('.mat-horizontal-stepper-header-container');\n        }\n        for (let i = 0; i < stepper.children.length; i += increment) {\n            this.htmlSteps.push(stepper.children[i]);\n        }\n    }\n    reset() {\n        // Delay is necessary (Too early in AfterViewInit: HTMLElements not loaded)\n        setTimeout(() => this.syncHTMLSteps(), 100);\n        const { stepper, steps, /*, changeDetectorRef,*/ lastSelectedIndex } = this;\n        stepper.steps.reset(steps.toArray());\n        stepper.steps.notifyOnChanges();\n        if (lastSelectedIndex) {\n            stepper.selectedIndex = lastSelectedIndex;\n            // After htmlSteps have been synced\n            setTimeout(() => this.orientationChange.emit(this.orientation), 101);\n        }\n        /*Promise.resolve().then(() => {\n            this.needsFocus = true;\n            changeDetectorRef.markForCheck();\n        });*/\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: ResponsiveStepperComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }\n    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"14.0.0\", version: \"20.3.6\", type: ResponsiveStepperComponent, isStandalone: false, selector: \"responsive-stepper\", inputs: { labelPosition: \"labelPosition\", linear: \"linear\", orientation: \"orientation\", selected: \"selected\", selectedIndex: \"selectedIndex\" }, outputs: { animationDone: \"animationDone\", selectionChange: \"selectionChange\", orientationChange: \"orientationChange\" }, providers: [\n            MAT_STEPPER_PROXY_FACTORY_PROVIDER,\n            CDK_STEPPER_PROXY_FACTORY_PROVIDER\n        ], queries: [{ propertyName: \"steps\", predicate: MatStep }], viewQueries: [{ propertyName: \"stepperList\", predicate: MatStepper, descendants: true }], ngImport: i0, template: `\n        <ng-container [ngSwitch]=\"orientation\">\n            <mat-horizontal-stepper *ngSwitchDefault\n                                    [labelPosition]=\"labelPosition\"\n                                    [linear]=\"linear\"\n                                    [selected]=\"selected\"\n                                    [selectedIndex]=\"selectedIndex\"\n                                    (animationDone)=\"animationDone.emit($event)\"\n                                    (selectionChange)=\"selectionChange.emit($event)\">\n            </mat-horizontal-stepper>\n            <mat-vertical-stepper *ngSwitchCase=\"'vertical'\"\n                                  [linear]=\"linear\"\n                                  [selected]=\"selected\"\n                                  [selectedIndex]=\"selectedIndex\"\n                                  (animationDone)=\"animationDone.emit($event)\"\n                                  (selectionChange)=\"selectionChange.emit($event)\">\n            </mat-vertical-stepper>\n        </ng-container>`, isInline: true, dependencies: [{ kind: \"directive\", type: i1.NgSwitch, selector: \"[ngSwitch]\", inputs: [\"ngSwitch\"] }, { kind: \"directive\", type: i1.NgSwitchCase, selector: \"[ngSwitchCase]\", inputs: [\"ngSwitchCase\"] }, { kind: \"directive\", type: i1.NgSwitchDefault, selector: \"[ngSwitchDefault]\" }, { kind: \"component\", type: i2.MatStepper, selector: \"mat-stepper, mat-vertical-stepper, mat-horizontal-stepper, [matStepper]\", inputs: [\"disableRipple\", \"color\", \"labelPosition\", \"headerPosition\", \"animationDuration\"], outputs: [\"animationDone\"], exportAs: [\"matStepper\", \"matVerticalStepper\", \"matHorizontalStepper\"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: ResponsiveStepperComponent, decorators: [{\n            type: Component,\n            args: [{\n                    selector: 'responsive-stepper',\n                    // templateUrl: './stepper.component.html',\n                    // styleUrls: ['./stepper.component.scss'],\n                    changeDetection: ChangeDetectionStrategy.OnPush,\n                    providers: [\n                        MAT_STEPPER_PROXY_FACTORY_PROVIDER,\n                        CDK_STEPPER_PROXY_FACTORY_PROVIDER\n                    ],\n                    template: `\n        <ng-container [ngSwitch]=\"orientation\">\n            <mat-horizontal-stepper *ngSwitchDefault\n                                    [labelPosition]=\"labelPosition\"\n                                    [linear]=\"linear\"\n                                    [selected]=\"selected\"\n                                    [selectedIndex]=\"selectedIndex\"\n                                    (animationDone)=\"animationDone.emit($event)\"\n                                    (selectionChange)=\"selectionChange.emit($event)\">\n            </mat-horizontal-stepper>\n            <mat-vertical-stepper *ngSwitchCase=\"'vertical'\"\n                                  [linear]=\"linear\"\n                                  [selected]=\"selected\"\n                                  [selectedIndex]=\"selectedIndex\"\n                                  (animationDone)=\"animationDone.emit($event)\"\n                                  (selectionChange)=\"selectionChange.emit($event)\">\n            </mat-vertical-stepper>\n        </ng-container>`,\n                    standalone: false\n                }]\n        }], propDecorators: { labelPosition: [{\n                type: Input\n            }], linear: [{\n                type: Input\n            }], orientation: [{\n                type: Input\n            }], selected: [{\n                type: Input\n            }], selectedIndex: [{\n                type: Input\n            }], animationDone: [{\n                type: Output\n            }], selectionChange: [{\n                type: Output\n            }], orientationChange: [{\n                type: Output\n            }], stepperList: [{\n                type: ViewChildren,\n                args: [MatStepper]\n            }], steps: [{\n                type: ContentChildren,\n                args: [MatStep]\n            }] } });\n\nclass MaterialModule {\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: MaterialModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }\n    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"20.3.6\", ngImport: i0, type: MaterialModule, declarations: [ResponsiveStepperComponent], imports: [CommonModule, CdkStepperModule, MatStepperModule], exports: [A11yModule,\n            CdkStepperModule,\n            CdkTableModule,\n            CdkTreeModule,\n            DragDropModule,\n            MatAutocompleteModule,\n            MatBadgeModule,\n            MatBottomSheetModule,\n            MatButtonModule,\n            MatButtonToggleModule,\n            MatCardModule,\n            MatCheckboxModule,\n            MatChipsModule,\n            MatStepperModule,\n            MatDatepickerModule,\n            MatDialogModule,\n            MatDividerModule,\n            MatExpansionModule,\n            MatGridListModule,\n            MatIconModule,\n            MatInputModule,\n            MatListModule,\n            MatMenuModule,\n            MatNativeDateModule,\n            MatPaginatorModule,\n            MatProgressBarModule,\n            MatProgressSpinnerModule,\n            MatRadioModule,\n            MatRippleModule,\n            MatSelectModule,\n            MatSidenavModule,\n            MatSliderModule,\n            MatSlideToggleModule,\n            MatSnackBarModule,\n            MatSortModule,\n            MatTableModule,\n            MatTabsModule,\n            MatToolbarModule,\n            MatTooltipModule,\n            MatTreeModule,\n            PortalModule,\n            ScrollingModule,\n            ScrollingModule$1,\n            // MatFormFieldModule,\n            ResponsiveStepperComponent] }); }\n    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: MaterialModule, imports: [CommonModule, CdkStepperModule, MatStepperModule, A11yModule,\n            CdkStepperModule,\n            CdkTableModule,\n            CdkTreeModule,\n            DragDropModule,\n            MatAutocompleteModule,\n            MatBadgeModule,\n            MatBottomSheetModule,\n            MatButtonModule,\n            MatButtonToggleModule,\n            MatCardModule,\n            MatCheckboxModule,\n            MatChipsModule,\n            MatStepperModule,\n            MatDatepickerModule,\n            MatDialogModule,\n            MatDividerModule,\n            MatExpansionModule,\n            MatGridListModule,\n            MatIconModule,\n            MatInputModule,\n            MatListModule,\n            MatMenuModule,\n            MatNativeDateModule,\n            MatPaginatorModule,\n            MatProgressBarModule,\n            MatProgressSpinnerModule,\n            MatRadioModule,\n            MatRippleModule,\n            MatSelectModule,\n            MatSidenavModule,\n            MatSliderModule,\n            MatSlideToggleModule,\n            MatSnackBarModule,\n            MatSortModule,\n            MatTableModule,\n            MatTabsModule,\n            MatToolbarModule,\n            MatTooltipModule,\n            MatTreeModule,\n            PortalModule,\n            ScrollingModule,\n            ScrollingModule$1] }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.3.6\", ngImport: i0, type: MaterialModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [CommonModule, CdkStepperModule, MatStepperModule],\n                    exports: [\n                        A11yModule,\n                        CdkStepperModule,\n                        CdkTableModule,\n                        CdkTreeModule,\n                        DragDropModule,\n                        MatAutocompleteModule,\n                        MatBadgeModule,\n                        MatBottomSheetModule,\n                        MatButtonModule,\n                        MatButtonToggleModule,\n                        MatCardModule,\n                        MatCheckboxModule,\n                        MatChipsModule,\n                        MatStepperModule,\n                        MatDatepickerModule,\n                        MatDialogModule,\n                        MatDividerModule,\n                        MatExpansionModule,\n                        MatGridListModule,\n                        MatIconModule,\n                        MatInputModule,\n                        MatListModule,\n                        MatMenuModule,\n                        MatNativeDateModule,\n                        MatPaginatorModule,\n                        MatProgressBarModule,\n                        MatProgressSpinnerModule,\n                        MatRadioModule,\n                        MatRippleModule,\n                        MatSelectModule,\n                        MatSidenavModule,\n                        MatSliderModule,\n                        MatSlideToggleModule,\n                        MatSnackBarModule,\n                        MatSortModule,\n                        MatTableModule,\n                        MatTabsModule,\n                        MatToolbarModule,\n                        MatTooltipModule,\n                        MatTreeModule,\n                        PortalModule,\n                        ScrollingModule,\n                        ScrollingModule$1,\n                        // MatFormFieldModule,\n                        ResponsiveStepperComponent\n                    ],\n                    declarations: [ResponsiveStepperComponent]\n                }]\n        }] });\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { MAT_STEPPER_PROXY_FACTORY, MaterialModule, ResponsiveStepperComponent };\n"],"x_google_ignoreList":[0,1]}