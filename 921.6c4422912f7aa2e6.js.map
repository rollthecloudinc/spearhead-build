{"version":3,"file":"921.6c4422912f7aa2e6.js","mappings":"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","names":["combineLatest","_len","arguments","length","args","Array","_key","scheduler","popScheduler","resultSelector","popResultSelector","_argsArgArrayOrObject","argsArgArrayOrObject","observables","keys","from","result","Observable","combineLatestInit","valueTransform","undefined","identity","subscriber","maybeSchedule","values","active","remainingFirstValues","_loop","i","source","hasFirstValue","subscribe","createOperatorSubscriber","value","next","slice","complete","createObject","pipe","mapOneOrManyArgs","execute","subscription","executeSchedule","IsFocusableConfig","_createClass","_classCallCheck","this","_defineProperty","InteractivityChecker","_InteractivityChecker","inject","Platform","key","element","hasAttribute","hasGeometry","offsetWidth","offsetHeight","getClientRects","getComputedStyle","visibility","_platform","isBrowser","frameElement","getFrameElement","window","getWindow","node","ownerDocument","defaultView","getTabIndexValue","isVisible","nodeName","toLowerCase","tabIndexValue","WEBKIT","IOS","isPotentiallyTabbableIOS","inputType","type","FIREFOX","tabIndex","config","isPotentiallyFocusable","isHiddenInput","isInputElement","isNativeFormElement","isAnchorWithHref","isAnchorElement","hasValidTabIndex","isDisabled","ignoreVisibility","__ngFactoryType__","i0","token","factory","Éµfac","providedIn","getAttribute","isNaN","parseInt","FocusTrap","_element","_checker","_ngZone","_document","_this","deferAnchors","_injector","focusLastTabbableElement","focusFirstTabbableElement","attachAnchors","get","_enabled","set","_startAnchor","_endAnchor","_toggleAnchorTabIndex","startAnchor","endAnchor","removeEventListener","startAnchorListener","remove","endAnchorListener","_hasAttached","_this2","runOutsideAngular","_createAnchor","addEventListener","parentNode","insertBefore","nextSibling","options","_this3","Promise","resolve","_executeOnStable","focusInitialElement","_this4","_this5","bound","markers","querySelectorAll","concat","_getFirstTabbableElement","_getLastTabbableElement","redirectToElement","querySelector","isFocusable","focusableChild","focus","_getRegionBoundary","root","isTabbable","children","tabbableChild","nodeType","ELEMENT_NODE","anchor","createElement","classList","add","setAttribute","isEnabled","removeAttribute","enabled","fn","afterNextRender","injector","setTimeout","FocusTrapFactory","_FocusTrapFactory","NgZone","DOCUMENT","Injector","_CdkPrivateStyleLoader","load","_VisuallyHiddenLoader","CdkTrapFocus","_CdkTrapFocus","ElementRef","platform","focusTrap","_focusTrapFactory","create","_elementRef","nativeElement","_this$focusTrap","_this$focusTrap2","destroy","_previouslyFocusedElement","_this$focusTrap3","autoCapture","_captureFocus","hasAttached","changes","_this$focusTrap4","autoCaptureChange","firstChange","_this$focusTrap5","_getFocusedElementPierceShadowDom","focusInitialElementWhenReady","selectors","inputs","booleanAttribute","exportAs","features","LIVE_ANNOUNCER_ELEMENT_TOKEN","InjectionToken","LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY","LIVE_ANNOUNCER_DEFAULT_OPTIONS","uniqueIds","LiveAnnouncer","_LiveAnnouncer","optional","elementToken","_liveElement","_createLiveElement","message","politeness","duration","_this6","defaultOptions","_defaultOptions","clear","clearTimeout","_previousTimeout","id","_exposeAnnouncerToModals","_currentPromise","_currentResolve","_this6$_currentResolv","textContent","call","_this$_liveElement","_this$_currentResolve","elementClass","previousElements","getElementsByClassName","liveEl","body","appendChild","modals","modal","ariaOwns","indexOf","CdkAriaLive","_CdkAriaLive","ContentObserver","_politeness","_this7","_subscription","unsubscribe","_contentObserver","observe","elementText","_previousAnnouncedText","_liveAnnouncer","announce","HighContrastMode","NONE","BLACK_ON_WHITE","WHITE_ON_BLACK","BLACK_ON_WHITE_CSS_CLASS","WHITE_ON_BLACK_CSS_CLASS","HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS","HighContrastModeDetector","_HighContrastModeDetector","_this8","_breakpointSubscription","BreakpointObserver","_hasCheckedHighContrastMode","_applyBodyHighContrastModeCssClasses","testElement","style","backgroundColor","position","documentWindow","computedStyle","computedColor","replace","bodyClasses","mode","getHighContrastMode","A11yModule","_A11yModule","imports","ObserversModule","mediaQueryStyleNode","mediaQueriesForWebkitCompatibility","Set","MediaMatcher","_MediaMatcher","CSP_NONCE","_matchMedia","matchMedia","bind","noopMatchMedia","query","BLINK","createEmptyStyleRule","nonce","has","document","head","sheet","insertRule","e","console","error","_nonce","matches","media","addListener","removeListener","_BreakpointObserver","Map","Subject","_destroySubject","splitQueries","coerceArray","some","mediaQuery","_registerQuery","mql","map","observable","stateObservable","take","skip","debounceTime","breakpointStates","response","breakpoints","forEach","_ref","_queries","_mediaMatcher","output","observer","handler","_zone","run","startWith","_ref2","takeUntil","queries","split","reduce","a1","a2","trim","isFakeMousedownFromScreenReader","event","buttons","detail","isFakeTouchstartFromScreenReader","touch","touches","changedTouches","identifier","radiusX","radiusY","INPUT_MODALITY_DETECTOR_OPTIONS","INPUT_MODALITY_DETECTOR_DEFAULT_OPTIONS","ignoreKeys","ALT","CONTROL","MAC_META","META","SHIFT","modalityEventListenerOptions","passive","capture","InputModalityDetector","_InputModalityDetector","BehaviorSubject","_this$_options","_options","keyCode","_modality","_mostRecentTarget","_getEventTarget","Date","now","_lastTouchMs","ngZone","_objectSpread","modalityDetected","modalityChanged","distinctUntilChanged","renderer","RendererFactory2","createRenderer","_listenerCleanups","listen","_onKeydown","_onMousedown","_onTouchstart","_this$_listenerCleanu","cleanup","FocusMonitorDetectionMode","IMMEDIATE","EVENTUAL","FOCUS_MONITOR_DEFAULT_OPTIONS","captureEventListenerOptions","normalizePassiveListenerOptions","FocusMonitor","_FocusMonitor","_windowFocused","_windowFocusTimeoutId","target","parentElement","_onFocus","_onBlur","_detectionMode","detectionMode","checkChildren","coerceElement","of","rootNode","_getShadowRoot","cachedInfo","_elementInfo","subject","info","_registerGlobalListeners","elementInfo","_setClasses","delete","_removeGlobalListeners","origin","activeElement","_getClosestElementsInfo","_slicedToArray","_originChanged","_setOrigin","_info","stopMonitoring","focusEventTarget","_origin","_originFromTouchInteraction","_shouldBeAttributedToTouch","_lastFocusOrigin","_isLastInteractionFromInputLabel","contains","_inputModalityDetector","toggle","isFromInteraction","_originTimeoutId","_getFocusOrigin","relatedTarget","Node","_emitOrigin","observers","rootNodeFocusListeners","_rootNodeFocusListenerCount","_rootNodeFocusAndBlurListener","_monitoredElementCount","_getWindow","_windowFocusListener","_stopInputModalityDetector","modality","results","currentElement","push","_this$_inputModalityD","mostRecentTarget","mostRecentModality","disabled","labels","CdkMonitorFocus","_CdkMonitorFocus","EventEmitter","_focusOrigin","_monitorSubscription","_focusMonitor","monitor","cdkFocusChange","emit","outputs","MutationObserverFactory","_MutationObserverFactory","callback","MutationObserver","_ContentObserver","_observedElements","_","_cleanupObserver","elementOrRef","_observeElement","records","filter","record","shouldIgnoreRecord","Comment","addedNodes","removedNodes","_unobserveElement","count","stream","_mutationObserverFactory","mutations","characterData","childList","subtree","_this$_observedElemen","disconnect","CdkObserveContent","_CdkObserveContent","_disabled","_unsubscribe","_subscribe","_debounce","coerceNumberProperty","_currentSubscription","debounce","_this$_currentSubscri","_ObserversModule","providers","supportsPassiveEvents","supportsPassiveEventListeners","Object","defineProperty","_VisuallyHiddenLoader2","decls","vars","template","rf","ctx","styles","encapsulation","changeDetection"],"ignoreList":[],"sourceRoot":"webpack:///","sources":["./node_modules/rxjs/dist/esm/internal/observable/combineLatest.js","./node_modules/@angular/cdk/fesm2022/a11y-module.mjs","./node_modules/@angular/cdk/fesm2022/breakpoints-observer.mjs","./node_modules/@angular/cdk/fesm2022/fake-event-detection.mjs","./node_modules/@angular/cdk/fesm2022/focus-monitor.mjs","./node_modules/@angular/cdk/fesm2022/observers.mjs","./node_modules/@angular/cdk/fesm2022/passive-listeners.mjs","./node_modules/@angular/cdk/fesm2022/private.mjs"],"sourcesContent":["import { Observable } from '../Observable';\nimport { argsArgArrayOrObject } from '../util/argsArgArrayOrObject';\nimport { from } from './from';\nimport { identity } from '../util/identity';\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\nimport { popResultSelector, popScheduler } from '../util/args';\nimport { createObject } from '../util/createObject';\nimport { createOperatorSubscriber } from '../operators/OperatorSubscriber';\nimport { executeSchedule } from '../util/executeSchedule';\nexport function combineLatest(...args) {\n    const scheduler = popScheduler(args);\n    const resultSelector = popResultSelector(args);\n    const { args: observables, keys } = argsArgArrayOrObject(args);\n    if (observables.length === 0) {\n        return from([], scheduler);\n    }\n    const result = new Observable(combineLatestInit(observables, scheduler, keys\n        ?\n            (values) => createObject(keys, values)\n        :\n            identity));\n    return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;\n}\nexport function combineLatestInit(observables, scheduler, valueTransform = identity) {\n    return (subscriber) => {\n        maybeSchedule(scheduler, () => {\n            const { length } = observables;\n            const values = new Array(length);\n            let active = length;\n            let remainingFirstValues = length;\n            for (let i = 0; i < length; i++) {\n                maybeSchedule(scheduler, () => {\n                    const source = from(observables[i], scheduler);\n                    let hasFirstValue = false;\n                    source.subscribe(createOperatorSubscriber(subscriber, (value) => {\n                        values[i] = value;\n                        if (!hasFirstValue) {\n                            hasFirstValue = true;\n                            remainingFirstValues--;\n                        }\n                        if (!remainingFirstValues) {\n                            subscriber.next(valueTransform(values.slice()));\n                        }\n                    }, () => {\n                        if (!--active) {\n                            subscriber.complete();\n                        }\n                    }));\n                }, subscriber);\n            }\n        }, subscriber);\n    };\n}\nfunction maybeSchedule(scheduler, execute, subscription) {\n    if (scheduler) {\n        executeSchedule(subscription, scheduler, execute);\n    }\n    else {\n        execute();\n    }\n}\n","import * as i0 from '@angular/core';\nimport { inject, Injectable, afterNextRender, NgZone, DOCUMENT, Injector, ElementRef, booleanAttribute, Directive, Input, InjectionToken, NgModule } from '@angular/core';\nimport { CdkMonitorFocus } from './focus-monitor.mjs';\nimport { Platform } from './platform2.mjs';\nimport { _getFocusedElementPierceShadowDom } from './shadow-dom.mjs';\nimport { _CdkPrivateStyleLoader } from './style-loader.mjs';\nimport { _VisuallyHiddenLoader } from './private.mjs';\nimport { BreakpointObserver } from './breakpoints-observer.mjs';\nimport { ContentObserver, ObserversModule } from './observers.mjs';\n\n/**\n * Configuration for the isFocusable method.\n */\nclass IsFocusableConfig {\n    /**\n     * Whether to count an element as focusable even if it is not currently visible.\n     */\n    ignoreVisibility = false;\n}\n// The InteractivityChecker leans heavily on the ally.js accessibility utilities.\n// Methods like `isTabbable` are only covering specific edge-cases for the browsers which are\n// supported.\n/**\n * Utility for checking the interactivity of an element, such as whether it is focusable or\n * tabbable.\n */\nclass InteractivityChecker {\n    _platform = inject(Platform);\n    constructor() { }\n    /**\n     * Gets whether an element is disabled.\n     *\n     * @param element Element to be checked.\n     * @returns Whether the element is disabled.\n     */\n    isDisabled(element) {\n        // This does not capture some cases, such as a non-form control with a disabled attribute or\n        // a form control inside of a disabled form, but should capture the most common cases.\n        return element.hasAttribute('disabled');\n    }\n    /**\n     * Gets whether an element is visible for the purposes of interactivity.\n     *\n     * This will capture states like `display: none` and `visibility: hidden`, but not things like\n     * being clipped by an `overflow: hidden` parent or being outside the viewport.\n     *\n     * @returns Whether the element is visible.\n     */\n    isVisible(element) {\n        return hasGeometry(element) && getComputedStyle(element).visibility === 'visible';\n    }\n    /**\n     * Gets whether an element can be reached via Tab key.\n     * Assumes that the element has already been checked with isFocusable.\n     *\n     * @param element Element to be checked.\n     * @returns Whether the element is tabbable.\n     */\n    isTabbable(element) {\n        // Nothing is tabbable on the server ðŸ˜Ž\n        if (!this._platform.isBrowser) {\n            return false;\n        }\n        const frameElement = getFrameElement(getWindow(element));\n        if (frameElement) {\n            // Frame elements inherit their tabindex onto all child elements.\n            if (getTabIndexValue(frameElement) === -1) {\n                return false;\n            }\n            // Browsers disable tabbing to an element inside of an invisible frame.\n            if (!this.isVisible(frameElement)) {\n                return false;\n            }\n        }\n        let nodeName = element.nodeName.toLowerCase();\n        let tabIndexValue = getTabIndexValue(element);\n        if (element.hasAttribute('contenteditable')) {\n            return tabIndexValue !== -1;\n        }\n        if (nodeName === 'iframe' || nodeName === 'object') {\n            // The frame or object's content may be tabbable depending on the content, but it's\n            // not possibly to reliably detect the content of the frames. We always consider such\n            // elements as non-tabbable.\n            return false;\n        }\n        // In iOS, the browser only considers some specific elements as tabbable.\n        if (this._platform.WEBKIT && this._platform.IOS && !isPotentiallyTabbableIOS(element)) {\n            return false;\n        }\n        if (nodeName === 'audio') {\n            // Audio elements without controls enabled are never tabbable, regardless\n            // of the tabindex attribute explicitly being set.\n            if (!element.hasAttribute('controls')) {\n                return false;\n            }\n            // Audio elements with controls are by default tabbable unless the\n            // tabindex attribute is set to `-1` explicitly.\n            return tabIndexValue !== -1;\n        }\n        if (nodeName === 'video') {\n            // For all video elements, if the tabindex attribute is set to `-1`, the video\n            // is not tabbable. Note: We cannot rely on the default `HTMLElement.tabIndex`\n            // property as that one is set to `-1` in Chrome, Edge and Safari v13.1. The\n            // tabindex attribute is the source of truth here.\n            if (tabIndexValue === -1) {\n                return false;\n            }\n            // If the tabindex is explicitly set, and not `-1` (as per check before), the\n            // video element is always tabbable (regardless of whether it has controls or not).\n            if (tabIndexValue !== null) {\n                return true;\n            }\n            // Otherwise (when no explicit tabindex is set), a video is only tabbable if it\n            // has controls enabled. Firefox is special as videos are always tabbable regardless\n            // of whether there are controls or not.\n            return this._platform.FIREFOX || element.hasAttribute('controls');\n        }\n        return element.tabIndex >= 0;\n    }\n    /**\n     * Gets whether an element can be focused by the user.\n     *\n     * @param element Element to be checked.\n     * @param config The config object with options to customize this method's behavior\n     * @returns Whether the element is focusable.\n     */\n    isFocusable(element, config) {\n        // Perform checks in order of left to most expensive.\n        // Again, naive approach that does not capture many edge cases and browser quirks.\n        return (isPotentiallyFocusable(element) &&\n            !this.isDisabled(element) &&\n            (config?.ignoreVisibility || this.isVisible(element)));\n    }\n    static Éµfac = i0.ÉµÉµngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: InteractivityChecker, deps: [], target: i0.ÉµÉµFactoryTarget.Injectable });\n    static Éµprov = i0.ÉµÉµngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: InteractivityChecker, providedIn: 'root' });\n}\ni0.ÉµÉµngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: InteractivityChecker, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [] });\n/**\n * Returns the frame element from a window object. Since browsers like MS Edge throw errors if\n * the frameElement property is being accessed from a different host address, this property\n * should be accessed carefully.\n */\nfunction getFrameElement(window) {\n    try {\n        return window.frameElement;\n    }\n    catch {\n        return null;\n    }\n}\n/** Checks whether the specified element has any geometry / rectangles. */\nfunction hasGeometry(element) {\n    // Use logic from jQuery to check for an invisible element.\n    // See https://github.com/jquery/jquery/blob/master/src/css/hiddenVisibleSelectors.js#L12\n    return !!(element.offsetWidth ||\n        element.offsetHeight ||\n        (typeof element.getClientRects === 'function' && element.getClientRects().length));\n}\n/** Gets whether an element's  */\nfunction isNativeFormElement(element) {\n    let nodeName = element.nodeName.toLowerCase();\n    return (nodeName === 'input' ||\n        nodeName === 'select' ||\n        nodeName === 'button' ||\n        nodeName === 'textarea');\n}\n/** Gets whether an element is an `<input type=\"hidden\">`. */\nfunction isHiddenInput(element) {\n    return isInputElement(element) && element.type == 'hidden';\n}\n/** Gets whether an element is an anchor that has an href attribute. */\nfunction isAnchorWithHref(element) {\n    return isAnchorElement(element) && element.hasAttribute('href');\n}\n/** Gets whether an element is an input element. */\nfunction isInputElement(element) {\n    return element.nodeName.toLowerCase() == 'input';\n}\n/** Gets whether an element is an anchor element. */\nfunction isAnchorElement(element) {\n    return element.nodeName.toLowerCase() == 'a';\n}\n/** Gets whether an element has a valid tabindex. */\nfunction hasValidTabIndex(element) {\n    if (!element.hasAttribute('tabindex') || element.tabIndex === undefined) {\n        return false;\n    }\n    let tabIndex = element.getAttribute('tabindex');\n    return !!(tabIndex && !isNaN(parseInt(tabIndex, 10)));\n}\n/**\n * Returns the parsed tabindex from the element attributes instead of returning the\n * evaluated tabindex from the browsers defaults.\n */\nfunction getTabIndexValue(element) {\n    if (!hasValidTabIndex(element)) {\n        return null;\n    }\n    // See browser issue in Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=1128054\n    const tabIndex = parseInt(element.getAttribute('tabindex') || '', 10);\n    return isNaN(tabIndex) ? -1 : tabIndex;\n}\n/** Checks whether the specified element is potentially tabbable on iOS */\nfunction isPotentiallyTabbableIOS(element) {\n    let nodeName = element.nodeName.toLowerCase();\n    let inputType = nodeName === 'input' && element.type;\n    return (inputType === 'text' ||\n        inputType === 'password' ||\n        nodeName === 'select' ||\n        nodeName === 'textarea');\n}\n/**\n * Gets whether an element is potentially focusable without taking current visible/disabled state\n * into account.\n */\nfunction isPotentiallyFocusable(element) {\n    // Inputs are potentially focusable *unless* they're type=\"hidden\".\n    if (isHiddenInput(element)) {\n        return false;\n    }\n    return (isNativeFormElement(element) ||\n        isAnchorWithHref(element) ||\n        element.hasAttribute('contenteditable') ||\n        hasValidTabIndex(element));\n}\n/** Gets the parent window of a DOM node with regards of being inside of an iframe. */\nfunction getWindow(node) {\n    // ownerDocument is null if `node` itself *is* a document.\n    return (node.ownerDocument && node.ownerDocument.defaultView) || window;\n}\n\n/**\n * Class that allows for trapping focus within a DOM element.\n *\n * This class currently uses a relatively simple approach to focus trapping.\n * It assumes that the tab order is the same as DOM order, which is not necessarily true.\n * Things like `tabIndex > 0`, flex `order`, and shadow roots can cause the two to be misaligned.\n */\nclass FocusTrap {\n    _element;\n    _checker;\n    _ngZone;\n    _document;\n    _injector;\n    _startAnchor;\n    _endAnchor;\n    _hasAttached = false;\n    // Event listeners for the anchors. Need to be regular functions so that we can unbind them later.\n    startAnchorListener = () => this.focusLastTabbableElement();\n    endAnchorListener = () => this.focusFirstTabbableElement();\n    /** Whether the focus trap is active. */\n    get enabled() {\n        return this._enabled;\n    }\n    set enabled(value) {\n        this._enabled = value;\n        if (this._startAnchor && this._endAnchor) {\n            this._toggleAnchorTabIndex(value, this._startAnchor);\n            this._toggleAnchorTabIndex(value, this._endAnchor);\n        }\n    }\n    _enabled = true;\n    constructor(_element, _checker, _ngZone, _document, deferAnchors = false, \n    /** @breaking-change 20.0.0 param to become required */\n    _injector) {\n        this._element = _element;\n        this._checker = _checker;\n        this._ngZone = _ngZone;\n        this._document = _document;\n        this._injector = _injector;\n        if (!deferAnchors) {\n            this.attachAnchors();\n        }\n    }\n    /** Destroys the focus trap by cleaning up the anchors. */\n    destroy() {\n        const startAnchor = this._startAnchor;\n        const endAnchor = this._endAnchor;\n        if (startAnchor) {\n            startAnchor.removeEventListener('focus', this.startAnchorListener);\n            startAnchor.remove();\n        }\n        if (endAnchor) {\n            endAnchor.removeEventListener('focus', this.endAnchorListener);\n            endAnchor.remove();\n        }\n        this._startAnchor = this._endAnchor = null;\n        this._hasAttached = false;\n    }\n    /**\n     * Inserts the anchors into the DOM. This is usually done automatically\n     * in the constructor, but can be deferred for cases like directives with `*ngIf`.\n     * @returns Whether the focus trap managed to attach successfully. This may not be the case\n     * if the target element isn't currently in the DOM.\n     */\n    attachAnchors() {\n        // If we're not on the browser, there can be no focus to trap.\n        if (this._hasAttached) {\n            return true;\n        }\n        this._ngZone.runOutsideAngular(() => {\n            if (!this._startAnchor) {\n                this._startAnchor = this._createAnchor();\n                this._startAnchor.addEventListener('focus', this.startAnchorListener);\n            }\n            if (!this._endAnchor) {\n                this._endAnchor = this._createAnchor();\n                this._endAnchor.addEventListener('focus', this.endAnchorListener);\n            }\n        });\n        if (this._element.parentNode) {\n            this._element.parentNode.insertBefore(this._startAnchor, this._element);\n            this._element.parentNode.insertBefore(this._endAnchor, this._element.nextSibling);\n            this._hasAttached = true;\n        }\n        return this._hasAttached;\n    }\n    /**\n     * Waits for the zone to stabilize, then focuses the first tabbable element.\n     * @returns Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfully.\n     */\n    focusInitialElementWhenReady(options) {\n        return new Promise(resolve => {\n            this._executeOnStable(() => resolve(this.focusInitialElement(options)));\n        });\n    }\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the first tabbable element within the focus trap region.\n     * @returns Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfully.\n     */\n    focusFirstTabbableElementWhenReady(options) {\n        return new Promise(resolve => {\n            this._executeOnStable(() => resolve(this.focusFirstTabbableElement(options)));\n        });\n    }\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the last tabbable element within the focus trap region.\n     * @returns Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfully.\n     */\n    focusLastTabbableElementWhenReady(options) {\n        return new Promise(resolve => {\n            this._executeOnStable(() => resolve(this.focusLastTabbableElement(options)));\n        });\n    }\n    /**\n     * Get the specified boundary element of the trapped region.\n     * @param bound The boundary to get (start or end of trapped region).\n     * @returns The boundary element.\n     */\n    _getRegionBoundary(bound) {\n        // Contains the deprecated version of selector, for temporary backwards comparability.\n        const markers = this._element.querySelectorAll(`[cdk-focus-region-${bound}], ` + `[cdkFocusRegion${bound}], ` + `[cdk-focus-${bound}]`);\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            for (let i = 0; i < markers.length; i++) {\n                // @breaking-change 8.0.0\n                if (markers[i].hasAttribute(`cdk-focus-${bound}`)) {\n                    console.warn(`Found use of deprecated attribute 'cdk-focus-${bound}', ` +\n                        `use 'cdkFocusRegion${bound}' instead. The deprecated ` +\n                        `attribute will be removed in 8.0.0.`, markers[i]);\n                }\n                else if (markers[i].hasAttribute(`cdk-focus-region-${bound}`)) {\n                    console.warn(`Found use of deprecated attribute 'cdk-focus-region-${bound}', ` +\n                        `use 'cdkFocusRegion${bound}' instead. The deprecated attribute ` +\n                        `will be removed in 8.0.0.`, markers[i]);\n                }\n            }\n        }\n        if (bound == 'start') {\n            return markers.length ? markers[0] : this._getFirstTabbableElement(this._element);\n        }\n        return markers.length\n            ? markers[markers.length - 1]\n            : this._getLastTabbableElement(this._element);\n    }\n    /**\n     * Focuses the element that should be focused when the focus trap is initialized.\n     * @returns Whether focus was moved successfully.\n     */\n    focusInitialElement(options) {\n        // Contains the deprecated version of selector, for temporary backwards comparability.\n        const redirectToElement = this._element.querySelector(`[cdk-focus-initial], ` + `[cdkFocusInitial]`);\n        if (redirectToElement) {\n            // @breaking-change 8.0.0\n            if ((typeof ngDevMode === 'undefined' || ngDevMode) &&\n                redirectToElement.hasAttribute(`cdk-focus-initial`)) {\n                console.warn(`Found use of deprecated attribute 'cdk-focus-initial', ` +\n                    `use 'cdkFocusInitial' instead. The deprecated attribute ` +\n                    `will be removed in 8.0.0`, redirectToElement);\n            }\n            // Warn the consumer if the element they've pointed to\n            // isn't focusable, when not in production mode.\n            if ((typeof ngDevMode === 'undefined' || ngDevMode) &&\n                !this._checker.isFocusable(redirectToElement)) {\n                console.warn(`Element matching '[cdkFocusInitial]' is not focusable.`, redirectToElement);\n            }\n            if (!this._checker.isFocusable(redirectToElement)) {\n                const focusableChild = this._getFirstTabbableElement(redirectToElement);\n                focusableChild?.focus(options);\n                return !!focusableChild;\n            }\n            redirectToElement.focus(options);\n            return true;\n        }\n        return this.focusFirstTabbableElement(options);\n    }\n    /**\n     * Focuses the first tabbable element within the focus trap region.\n     * @returns Whether focus was moved successfully.\n     */\n    focusFirstTabbableElement(options) {\n        const redirectToElement = this._getRegionBoundary('start');\n        if (redirectToElement) {\n            redirectToElement.focus(options);\n        }\n        return !!redirectToElement;\n    }\n    /**\n     * Focuses the last tabbable element within the focus trap region.\n     * @returns Whether focus was moved successfully.\n     */\n    focusLastTabbableElement(options) {\n        const redirectToElement = this._getRegionBoundary('end');\n        if (redirectToElement) {\n            redirectToElement.focus(options);\n        }\n        return !!redirectToElement;\n    }\n    /**\n     * Checks whether the focus trap has successfully been attached.\n     */\n    hasAttached() {\n        return this._hasAttached;\n    }\n    /** Get the first tabbable element from a DOM subtree (inclusive). */\n    _getFirstTabbableElement(root) {\n        if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\n            return root;\n        }\n        const children = root.children;\n        for (let i = 0; i < children.length; i++) {\n            const tabbableChild = children[i].nodeType === this._document.ELEMENT_NODE\n                ? this._getFirstTabbableElement(children[i])\n                : null;\n            if (tabbableChild) {\n                return tabbableChild;\n            }\n        }\n        return null;\n    }\n    /** Get the last tabbable element from a DOM subtree (inclusive). */\n    _getLastTabbableElement(root) {\n        if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\n            return root;\n        }\n        // Iterate in reverse DOM order.\n        const children = root.children;\n        for (let i = children.length - 1; i >= 0; i--) {\n            const tabbableChild = children[i].nodeType === this._document.ELEMENT_NODE\n                ? this._getLastTabbableElement(children[i])\n                : null;\n            if (tabbableChild) {\n                return tabbableChild;\n            }\n        }\n        return null;\n    }\n    /** Creates an anchor element. */\n    _createAnchor() {\n        const anchor = this._document.createElement('div');\n        this._toggleAnchorTabIndex(this._enabled, anchor);\n        anchor.classList.add('cdk-visually-hidden');\n        anchor.classList.add('cdk-focus-trap-anchor');\n        anchor.setAttribute('aria-hidden', 'true');\n        return anchor;\n    }\n    /**\n     * Toggles the `tabindex` of an anchor, based on the enabled state of the focus trap.\n     * @param isEnabled Whether the focus trap is enabled.\n     * @param anchor Anchor on which to toggle the tabindex.\n     */\n    _toggleAnchorTabIndex(isEnabled, anchor) {\n        // Remove the tabindex completely, rather than setting it to -1, because if the\n        // element has a tabindex, the user might still hit it when navigating with the arrow keys.\n        isEnabled ? anchor.setAttribute('tabindex', '0') : anchor.removeAttribute('tabindex');\n    }\n    /**\n     * Toggles the`tabindex` of both anchors to either trap Tab focus or allow it to escape.\n     * @param enabled: Whether the anchors should trap Tab.\n     */\n    toggleAnchors(enabled) {\n        if (this._startAnchor && this._endAnchor) {\n            this._toggleAnchorTabIndex(enabled, this._startAnchor);\n            this._toggleAnchorTabIndex(enabled, this._endAnchor);\n        }\n    }\n    /** Executes a function when the zone is stable. */\n    _executeOnStable(fn) {\n        // TODO: remove this conditional when injector is required in the constructor.\n        if (this._injector) {\n            afterNextRender(fn, { injector: this._injector });\n        }\n        else {\n            setTimeout(fn);\n        }\n    }\n}\n/**\n * Factory that allows easy instantiation of focus traps.\n */\nclass FocusTrapFactory {\n    _checker = inject(InteractivityChecker);\n    _ngZone = inject(NgZone);\n    _document = inject(DOCUMENT);\n    _injector = inject(Injector);\n    constructor() {\n        inject(_CdkPrivateStyleLoader).load(_VisuallyHiddenLoader);\n    }\n    /**\n     * Creates a focus-trapped region around the given element.\n     * @param element The element around which focus will be trapped.\n     * @param deferCaptureElements Defers the creation of focus-capturing elements to be done\n     *     manually by the user.\n     * @returns The created focus trap instance.\n     */\n    create(element, deferCaptureElements = false) {\n        return new FocusTrap(element, this._checker, this._ngZone, this._document, deferCaptureElements, this._injector);\n    }\n    static Éµfac = i0.ÉµÉµngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: FocusTrapFactory, deps: [], target: i0.ÉµÉµFactoryTarget.Injectable });\n    static Éµprov = i0.ÉµÉµngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: FocusTrapFactory, providedIn: 'root' });\n}\ni0.ÉµÉµngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: FocusTrapFactory, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [] });\n/** Directive for trapping focus within a region. */\nclass CdkTrapFocus {\n    _elementRef = inject(ElementRef);\n    _focusTrapFactory = inject(FocusTrapFactory);\n    /** Underlying FocusTrap instance. */\n    focusTrap;\n    /** Previously focused element to restore focus to upon destroy when using autoCapture. */\n    _previouslyFocusedElement = null;\n    /** Whether the focus trap is active. */\n    get enabled() {\n        return this.focusTrap?.enabled || false;\n    }\n    set enabled(value) {\n        if (this.focusTrap) {\n            this.focusTrap.enabled = value;\n        }\n    }\n    /**\n     * Whether the directive should automatically move focus into the trapped region upon\n     * initialization and return focus to the previous activeElement upon destruction.\n     */\n    autoCapture;\n    constructor() {\n        const platform = inject(Platform);\n        if (platform.isBrowser) {\n            this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, true);\n        }\n    }\n    ngOnDestroy() {\n        this.focusTrap?.destroy();\n        // If we stored a previously focused element when using autoCapture, return focus to that\n        // element now that the trapped region is being destroyed.\n        if (this._previouslyFocusedElement) {\n            this._previouslyFocusedElement.focus();\n            this._previouslyFocusedElement = null;\n        }\n    }\n    ngAfterContentInit() {\n        this.focusTrap?.attachAnchors();\n        if (this.autoCapture) {\n            this._captureFocus();\n        }\n    }\n    ngDoCheck() {\n        if (this.focusTrap && !this.focusTrap.hasAttached()) {\n            this.focusTrap.attachAnchors();\n        }\n    }\n    ngOnChanges(changes) {\n        const autoCaptureChange = changes['autoCapture'];\n        if (autoCaptureChange &&\n            !autoCaptureChange.firstChange &&\n            this.autoCapture &&\n            this.focusTrap?.hasAttached()) {\n            this._captureFocus();\n        }\n    }\n    _captureFocus() {\n        this._previouslyFocusedElement = _getFocusedElementPierceShadowDom();\n        this.focusTrap?.focusInitialElementWhenReady();\n    }\n    static Éµfac = i0.ÉµÉµngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: CdkTrapFocus, deps: [], target: i0.ÉµÉµFactoryTarget.Directive });\n    static Éµdir = i0.ÉµÉµngDeclareDirective({ minVersion: \"16.1.0\", version: \"20.2.0-next.2\", type: CdkTrapFocus, isStandalone: true, selector: \"[cdkTrapFocus]\", inputs: { enabled: [\"cdkTrapFocus\", \"enabled\", booleanAttribute], autoCapture: [\"cdkTrapFocusAutoCapture\", \"autoCapture\", booleanAttribute] }, exportAs: [\"cdkTrapFocus\"], usesOnChanges: true, ngImport: i0 });\n}\ni0.ÉµÉµngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: CdkTrapFocus, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[cdkTrapFocus]',\n                    exportAs: 'cdkTrapFocus',\n                }]\n        }], ctorParameters: () => [], propDecorators: { enabled: [{\n                type: Input,\n                args: [{ alias: 'cdkTrapFocus', transform: booleanAttribute }]\n            }], autoCapture: [{\n                type: Input,\n                args: [{ alias: 'cdkTrapFocusAutoCapture', transform: booleanAttribute }]\n            }] } });\n\nconst LIVE_ANNOUNCER_ELEMENT_TOKEN = new InjectionToken('liveAnnouncerElement', {\n    providedIn: 'root',\n    factory: LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY,\n});\n/**\n * @docs-private\n * @deprecated No longer used, will be removed.\n * @breaking-change 21.0.0\n */\nfunction LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY() {\n    return null;\n}\n/** Injection token that can be used to configure the default options for the LiveAnnouncer. */\nconst LIVE_ANNOUNCER_DEFAULT_OPTIONS = new InjectionToken('LIVE_ANNOUNCER_DEFAULT_OPTIONS');\n\nlet uniqueIds = 0;\nclass LiveAnnouncer {\n    _ngZone = inject(NgZone);\n    _defaultOptions = inject(LIVE_ANNOUNCER_DEFAULT_OPTIONS, {\n        optional: true,\n    });\n    _liveElement;\n    _document = inject(DOCUMENT);\n    _previousTimeout;\n    _currentPromise;\n    _currentResolve;\n    constructor() {\n        const elementToken = inject(LIVE_ANNOUNCER_ELEMENT_TOKEN, { optional: true });\n        this._liveElement = elementToken || this._createLiveElement();\n    }\n    announce(message, ...args) {\n        const defaultOptions = this._defaultOptions;\n        let politeness;\n        let duration;\n        if (args.length === 1 && typeof args[0] === 'number') {\n            duration = args[0];\n        }\n        else {\n            [politeness, duration] = args;\n        }\n        this.clear();\n        clearTimeout(this._previousTimeout);\n        if (!politeness) {\n            politeness =\n                defaultOptions && defaultOptions.politeness ? defaultOptions.politeness : 'polite';\n        }\n        if (duration == null && defaultOptions) {\n            duration = defaultOptions.duration;\n        }\n        // TODO: ensure changing the politeness works on all environments we support.\n        this._liveElement.setAttribute('aria-live', politeness);\n        if (this._liveElement.id) {\n            this._exposeAnnouncerToModals(this._liveElement.id);\n        }\n        // This 100ms timeout is necessary for some browser + screen-reader combinations:\n        // - Both JAWS and NVDA over IE11 will not announce anything without a non-zero timeout.\n        // - With Chrome and IE11 with NVDA or JAWS, a repeated (identical) message won't be read a\n        //   second time without clearing and then using a non-zero delay.\n        // (using JAWS 17 at time of this writing).\n        return this._ngZone.runOutsideAngular(() => {\n            if (!this._currentPromise) {\n                this._currentPromise = new Promise(resolve => (this._currentResolve = resolve));\n            }\n            clearTimeout(this._previousTimeout);\n            this._previousTimeout = setTimeout(() => {\n                this._liveElement.textContent = message;\n                if (typeof duration === 'number') {\n                    this._previousTimeout = setTimeout(() => this.clear(), duration);\n                }\n                // For some reason in tests this can be undefined\n                // Probably related to ZoneJS and every other thing that patches browser APIs in tests\n                this._currentResolve?.();\n                this._currentPromise = this._currentResolve = undefined;\n            }, 100);\n            return this._currentPromise;\n        });\n    }\n    /**\n     * Clears the current text from the announcer element. Can be used to prevent\n     * screen readers from reading the text out again while the user is going\n     * through the page landmarks.\n     */\n    clear() {\n        if (this._liveElement) {\n            this._liveElement.textContent = '';\n        }\n    }\n    ngOnDestroy() {\n        clearTimeout(this._previousTimeout);\n        this._liveElement?.remove();\n        this._liveElement = null;\n        this._currentResolve?.();\n        this._currentPromise = this._currentResolve = undefined;\n    }\n    _createLiveElement() {\n        const elementClass = 'cdk-live-announcer-element';\n        const previousElements = this._document.getElementsByClassName(elementClass);\n        const liveEl = this._document.createElement('div');\n        // Remove any old containers. This can happen when coming in from a server-side-rendered page.\n        for (let i = 0; i < previousElements.length; i++) {\n            previousElements[i].remove();\n        }\n        liveEl.classList.add(elementClass);\n        liveEl.classList.add('cdk-visually-hidden');\n        liveEl.setAttribute('aria-atomic', 'true');\n        liveEl.setAttribute('aria-live', 'polite');\n        liveEl.id = `cdk-live-announcer-${uniqueIds++}`;\n        this._document.body.appendChild(liveEl);\n        return liveEl;\n    }\n    /**\n     * Some browsers won't expose the accessibility node of the live announcer element if there is an\n     * `aria-modal` and the live announcer is outside of it. This method works around the issue by\n     * pointing the `aria-owns` of all modals to the live announcer element.\n     */\n    _exposeAnnouncerToModals(id) {\n        // TODO(http://github.com/angular/components/issues/26853): consider de-duplicating this with\n        // the `SnakBarContainer` and other usages.\n        //\n        // Note that the selector here is limited to CDK overlays at the moment in order to reduce the\n        // section of the DOM we need to look through. This should cover all the cases we support, but\n        // the selector can be expanded if it turns out to be too narrow.\n        const modals = this._document.querySelectorAll('body > .cdk-overlay-container [aria-modal=\"true\"]');\n        for (let i = 0; i < modals.length; i++) {\n            const modal = modals[i];\n            const ariaOwns = modal.getAttribute('aria-owns');\n            if (!ariaOwns) {\n                modal.setAttribute('aria-owns', id);\n            }\n            else if (ariaOwns.indexOf(id) === -1) {\n                modal.setAttribute('aria-owns', ariaOwns + ' ' + id);\n            }\n        }\n    }\n    static Éµfac = i0.ÉµÉµngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: LiveAnnouncer, deps: [], target: i0.ÉµÉµFactoryTarget.Injectable });\n    static Éµprov = i0.ÉµÉµngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: LiveAnnouncer, providedIn: 'root' });\n}\ni0.ÉµÉµngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: LiveAnnouncer, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [] });\n/**\n * A directive that works similarly to aria-live, but uses the LiveAnnouncer to ensure compatibility\n * with a wider range of browsers and screen readers.\n */\nclass CdkAriaLive {\n    _elementRef = inject(ElementRef);\n    _liveAnnouncer = inject(LiveAnnouncer);\n    _contentObserver = inject(ContentObserver);\n    _ngZone = inject(NgZone);\n    /** The aria-live politeness level to use when announcing messages. */\n    get politeness() {\n        return this._politeness;\n    }\n    set politeness(value) {\n        this._politeness = value === 'off' || value === 'assertive' ? value : 'polite';\n        if (this._politeness === 'off') {\n            if (this._subscription) {\n                this._subscription.unsubscribe();\n                this._subscription = null;\n            }\n        }\n        else if (!this._subscription) {\n            this._subscription = this._ngZone.runOutsideAngular(() => {\n                return this._contentObserver.observe(this._elementRef).subscribe(() => {\n                    // Note that we use textContent here, rather than innerText, in order to avoid a reflow.\n                    const elementText = this._elementRef.nativeElement.textContent;\n                    // The `MutationObserver` fires also for attribute\n                    // changes which we don't want to announce.\n                    if (elementText !== this._previousAnnouncedText) {\n                        this._liveAnnouncer.announce(elementText, this._politeness, this.duration);\n                        this._previousAnnouncedText = elementText;\n                    }\n                });\n            });\n        }\n    }\n    _politeness = 'polite';\n    /** Time in milliseconds after which to clear out the announcer element. */\n    duration;\n    _previousAnnouncedText;\n    _subscription;\n    constructor() {\n        inject(_CdkPrivateStyleLoader).load(_VisuallyHiddenLoader);\n    }\n    ngOnDestroy() {\n        if (this._subscription) {\n            this._subscription.unsubscribe();\n        }\n    }\n    static Éµfac = i0.ÉµÉµngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: CdkAriaLive, deps: [], target: i0.ÉµÉµFactoryTarget.Directive });\n    static Éµdir = i0.ÉµÉµngDeclareDirective({ minVersion: \"14.0.0\", version: \"20.2.0-next.2\", type: CdkAriaLive, isStandalone: true, selector: \"[cdkAriaLive]\", inputs: { politeness: [\"cdkAriaLive\", \"politeness\"], duration: [\"cdkAriaLiveDuration\", \"duration\"] }, exportAs: [\"cdkAriaLive\"], ngImport: i0 });\n}\ni0.ÉµÉµngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: CdkAriaLive, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[cdkAriaLive]',\n                    exportAs: 'cdkAriaLive',\n                }]\n        }], ctorParameters: () => [], propDecorators: { politeness: [{\n                type: Input,\n                args: ['cdkAriaLive']\n            }], duration: [{\n                type: Input,\n                args: ['cdkAriaLiveDuration']\n            }] } });\n\n/** Set of possible high-contrast mode backgrounds. */\nvar HighContrastMode;\n(function (HighContrastMode) {\n    HighContrastMode[HighContrastMode[\"NONE\"] = 0] = \"NONE\";\n    HighContrastMode[HighContrastMode[\"BLACK_ON_WHITE\"] = 1] = \"BLACK_ON_WHITE\";\n    HighContrastMode[HighContrastMode[\"WHITE_ON_BLACK\"] = 2] = \"WHITE_ON_BLACK\";\n})(HighContrastMode || (HighContrastMode = {}));\n/** CSS class applied to the document body when in black-on-white high-contrast mode. */\nconst BLACK_ON_WHITE_CSS_CLASS = 'cdk-high-contrast-black-on-white';\n/** CSS class applied to the document body when in white-on-black high-contrast mode. */\nconst WHITE_ON_BLACK_CSS_CLASS = 'cdk-high-contrast-white-on-black';\n/** CSS class applied to the document body when in high-contrast mode. */\nconst HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS = 'cdk-high-contrast-active';\n/**\n * Service to determine whether the browser is currently in a high-contrast-mode environment.\n *\n * Microsoft Windows supports an accessibility feature called \"High Contrast Mode\". This mode\n * changes the appearance of all applications, including web applications, to dramatically increase\n * contrast.\n *\n * IE, Edge, and Firefox currently support this mode. Chrome does not support Windows High Contrast\n * Mode. This service does not detect high-contrast mode as added by the Chrome \"High Contrast\"\n * browser extension.\n */\nclass HighContrastModeDetector {\n    _platform = inject(Platform);\n    /**\n     * Figuring out the high contrast mode and adding the body classes can cause\n     * some expensive layouts. This flag is used to ensure that we only do it once.\n     */\n    _hasCheckedHighContrastMode;\n    _document = inject(DOCUMENT);\n    _breakpointSubscription;\n    constructor() {\n        this._breakpointSubscription = inject(BreakpointObserver)\n            .observe('(forced-colors: active)')\n            .subscribe(() => {\n            if (this._hasCheckedHighContrastMode) {\n                this._hasCheckedHighContrastMode = false;\n                this._applyBodyHighContrastModeCssClasses();\n            }\n        });\n    }\n    /** Gets the current high-contrast-mode for the page. */\n    getHighContrastMode() {\n        if (!this._platform.isBrowser) {\n            return HighContrastMode.NONE;\n        }\n        // Create a test element with an arbitrary background-color that is neither black nor\n        // white; high-contrast mode will coerce the color to either black or white. Also ensure that\n        // appending the test element to the DOM does not affect layout by absolutely positioning it\n        const testElement = this._document.createElement('div');\n        testElement.style.backgroundColor = 'rgb(1,2,3)';\n        testElement.style.position = 'absolute';\n        this._document.body.appendChild(testElement);\n        // Get the computed style for the background color, collapsing spaces to normalize between\n        // browsers. Once we get this color, we no longer need the test element. Access the `window`\n        // via the document so we can fake it in tests. Note that we have extra null checks, because\n        // this logic will likely run during app bootstrap and throwing can break the entire app.\n        const documentWindow = this._document.defaultView || window;\n        const computedStyle = documentWindow && documentWindow.getComputedStyle\n            ? documentWindow.getComputedStyle(testElement)\n            : null;\n        const computedColor = ((computedStyle && computedStyle.backgroundColor) || '').replace(/ /g, '');\n        testElement.remove();\n        switch (computedColor) {\n            // Pre Windows 11 dark theme.\n            case 'rgb(0,0,0)':\n            // Windows 11 dark themes.\n            case 'rgb(45,50,54)':\n            case 'rgb(32,32,32)':\n                return HighContrastMode.WHITE_ON_BLACK;\n            // Pre Windows 11 light theme.\n            case 'rgb(255,255,255)':\n            // Windows 11 light theme.\n            case 'rgb(255,250,239)':\n                return HighContrastMode.BLACK_ON_WHITE;\n        }\n        return HighContrastMode.NONE;\n    }\n    ngOnDestroy() {\n        this._breakpointSubscription.unsubscribe();\n    }\n    /** Applies CSS classes indicating high-contrast mode to document body (browser-only). */\n    _applyBodyHighContrastModeCssClasses() {\n        if (!this._hasCheckedHighContrastMode && this._platform.isBrowser && this._document.body) {\n            const bodyClasses = this._document.body.classList;\n            bodyClasses.remove(HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS, BLACK_ON_WHITE_CSS_CLASS, WHITE_ON_BLACK_CSS_CLASS);\n            this._hasCheckedHighContrastMode = true;\n            const mode = this.getHighContrastMode();\n            if (mode === HighContrastMode.BLACK_ON_WHITE) {\n                bodyClasses.add(HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS, BLACK_ON_WHITE_CSS_CLASS);\n            }\n            else if (mode === HighContrastMode.WHITE_ON_BLACK) {\n                bodyClasses.add(HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS, WHITE_ON_BLACK_CSS_CLASS);\n            }\n        }\n    }\n    static Éµfac = i0.ÉµÉµngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: HighContrastModeDetector, deps: [], target: i0.ÉµÉµFactoryTarget.Injectable });\n    static Éµprov = i0.ÉµÉµngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: HighContrastModeDetector, providedIn: 'root' });\n}\ni0.ÉµÉµngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: HighContrastModeDetector, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [] });\n\nclass A11yModule {\n    constructor() {\n        inject(HighContrastModeDetector)._applyBodyHighContrastModeCssClasses();\n    }\n    static Éµfac = i0.ÉµÉµngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: A11yModule, deps: [], target: i0.ÉµÉµFactoryTarget.NgModule });\n    static Éµmod = i0.ÉµÉµngDeclareNgModule({ minVersion: \"14.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: A11yModule, imports: [ObserversModule, CdkAriaLive, CdkTrapFocus, CdkMonitorFocus], exports: [CdkAriaLive, CdkTrapFocus, CdkMonitorFocus] });\n    static Éµinj = i0.ÉµÉµngDeclareInjector({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: A11yModule, imports: [ObserversModule] });\n}\ni0.ÉµÉµngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: A11yModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [ObserversModule, CdkAriaLive, CdkTrapFocus, CdkMonitorFocus],\n                    exports: [CdkAriaLive, CdkTrapFocus, CdkMonitorFocus],\n                }]\n        }], ctorParameters: () => [] });\n\nexport { A11yModule, CdkAriaLive, CdkTrapFocus, FocusTrap, FocusTrapFactory, HighContrastMode, HighContrastModeDetector, InteractivityChecker, IsFocusableConfig, LIVE_ANNOUNCER_DEFAULT_OPTIONS, LIVE_ANNOUNCER_ELEMENT_TOKEN, LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY, LiveAnnouncer };\n","import * as i0 from '@angular/core';\nimport { inject, CSP_NONCE, Injectable, NgZone } from '@angular/core';\nimport { Subject, combineLatest, concat, Observable } from 'rxjs';\nimport { take, skip, debounceTime, map, startWith, takeUntil } from 'rxjs/operators';\nimport { Platform } from './platform2.mjs';\nimport { coerceArray } from './array.mjs';\n\n/** Global registry for all dynamically-created, injected media queries. */\nconst mediaQueriesForWebkitCompatibility = new Set();\n/** Style tag that holds all of the dynamically-created media queries. */\nlet mediaQueryStyleNode;\n/** A utility for calling matchMedia queries. */\nclass MediaMatcher {\n    _platform = inject(Platform);\n    _nonce = inject(CSP_NONCE, { optional: true });\n    /** The internal matchMedia method to return back a MediaQueryList like object. */\n    _matchMedia;\n    constructor() {\n        this._matchMedia =\n            this._platform.isBrowser && window.matchMedia\n                ? // matchMedia is bound to the window scope intentionally as it is an illegal invocation to\n                    // call it from a different scope.\n                    window.matchMedia.bind(window)\n                : noopMatchMedia;\n    }\n    /**\n     * Evaluates the given media query and returns the native MediaQueryList from which results\n     * can be retrieved.\n     * Confirms the layout engine will trigger for the selector query provided and returns the\n     * MediaQueryList for the query provided.\n     */\n    matchMedia(query) {\n        if (this._platform.WEBKIT || this._platform.BLINK) {\n            createEmptyStyleRule(query, this._nonce);\n        }\n        return this._matchMedia(query);\n    }\n    static Éµfac = i0.ÉµÉµngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: MediaMatcher, deps: [], target: i0.ÉµÉµFactoryTarget.Injectable });\n    static Éµprov = i0.ÉµÉµngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: MediaMatcher, providedIn: 'root' });\n}\ni0.ÉµÉµngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: MediaMatcher, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [] });\n/**\n * Creates an empty stylesheet that is used to work around browser inconsistencies related to\n * `matchMedia`. At the time of writing, it handles the following cases:\n * 1. On WebKit browsers, a media query has to have at least one rule in order for `matchMedia`\n * to fire. We work around it by declaring a dummy stylesheet with a `@media` declaration.\n * 2. In some cases Blink browsers will stop firing the `matchMedia` listener if none of the rules\n * inside the `@media` match existing elements on the page. We work around it by having one rule\n * targeting the `body`. See https://github.com/angular/components/issues/23546.\n */\nfunction createEmptyStyleRule(query, nonce) {\n    if (mediaQueriesForWebkitCompatibility.has(query)) {\n        return;\n    }\n    try {\n        if (!mediaQueryStyleNode) {\n            mediaQueryStyleNode = document.createElement('style');\n            if (nonce) {\n                mediaQueryStyleNode.setAttribute('nonce', nonce);\n            }\n            mediaQueryStyleNode.setAttribute('type', 'text/css');\n            document.head.appendChild(mediaQueryStyleNode);\n        }\n        if (mediaQueryStyleNode.sheet) {\n            mediaQueryStyleNode.sheet.insertRule(`@media ${query} {body{ }}`, 0);\n            mediaQueriesForWebkitCompatibility.add(query);\n        }\n    }\n    catch (e) {\n        console.error(e);\n    }\n}\n/** No-op matchMedia replacement for non-browser platforms. */\nfunction noopMatchMedia(query) {\n    // Use `as any` here to avoid adding additional necessary properties for\n    // the noop matcher.\n    return {\n        matches: query === 'all' || query === '',\n        media: query,\n        addListener: () => { },\n        removeListener: () => { },\n    };\n}\n\n/** Utility for checking the matching state of `@media` queries. */\nclass BreakpointObserver {\n    _mediaMatcher = inject(MediaMatcher);\n    _zone = inject(NgZone);\n    /**  A map of all media queries currently being listened for. */\n    _queries = new Map();\n    /** A subject for all other observables to takeUntil based on. */\n    _destroySubject = new Subject();\n    constructor() { }\n    /** Completes the active subject, signalling to all other observables to complete. */\n    ngOnDestroy() {\n        this._destroySubject.next();\n        this._destroySubject.complete();\n    }\n    /**\n     * Whether one or more media queries match the current viewport size.\n     * @param value One or more media queries to check.\n     * @returns Whether any of the media queries match.\n     */\n    isMatched(value) {\n        const queries = splitQueries(coerceArray(value));\n        return queries.some(mediaQuery => this._registerQuery(mediaQuery).mql.matches);\n    }\n    /**\n     * Gets an observable of results for the given queries that will emit new results for any changes\n     * in matching of the given queries.\n     * @param value One or more media queries to check.\n     * @returns A stream of matches for the given queries.\n     */\n    observe(value) {\n        const queries = splitQueries(coerceArray(value));\n        const observables = queries.map(query => this._registerQuery(query).observable);\n        let stateObservable = combineLatest(observables);\n        // Emit the first state immediately, and then debounce the subsequent emissions.\n        stateObservable = concat(stateObservable.pipe(take(1)), stateObservable.pipe(skip(1), debounceTime(0)));\n        return stateObservable.pipe(map(breakpointStates => {\n            const response = {\n                matches: false,\n                breakpoints: {},\n            };\n            breakpointStates.forEach(({ matches, query }) => {\n                response.matches = response.matches || matches;\n                response.breakpoints[query] = matches;\n            });\n            return response;\n        }));\n    }\n    /** Registers a specific query to be listened for. */\n    _registerQuery(query) {\n        // Only set up a new MediaQueryList if it is not already being listened for.\n        if (this._queries.has(query)) {\n            return this._queries.get(query);\n        }\n        const mql = this._mediaMatcher.matchMedia(query);\n        // Create callback for match changes and add it is as a listener.\n        const queryObservable = new Observable((observer) => {\n            // Listener callback methods are wrapped to be placed back in ngZone. Callbacks must be placed\n            // back into the zone because matchMedia is only included in Zone.js by loading the\n            // webapis-media-query.js file alongside the zone.js file.  Additionally, some browsers do not\n            // have MediaQueryList inherit from EventTarget, which causes inconsistencies in how Zone.js\n            // patches it.\n            const handler = (e) => this._zone.run(() => observer.next(e));\n            mql.addListener(handler);\n            return () => {\n                mql.removeListener(handler);\n            };\n        }).pipe(startWith(mql), map(({ matches }) => ({ query, matches })), takeUntil(this._destroySubject));\n        // Add the MediaQueryList to the set of queries.\n        const output = { observable: queryObservable, mql };\n        this._queries.set(query, output);\n        return output;\n    }\n    static Éµfac = i0.ÉµÉµngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: BreakpointObserver, deps: [], target: i0.ÉµÉµFactoryTarget.Injectable });\n    static Éµprov = i0.ÉµÉµngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: BreakpointObserver, providedIn: 'root' });\n}\ni0.ÉµÉµngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: BreakpointObserver, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [] });\n/**\n * Split each query string into separate query strings if two queries are provided as comma\n * separated.\n */\nfunction splitQueries(queries) {\n    return queries\n        .map(query => query.split(','))\n        .reduce((a1, a2) => a1.concat(a2))\n        .map(query => query.trim());\n}\n\nexport { BreakpointObserver, MediaMatcher };\n","/** Gets whether an event could be a faked `mousedown` event dispatched by a screen reader. */\nfunction isFakeMousedownFromScreenReader(event) {\n    // Some screen readers will dispatch a fake `mousedown` event when pressing enter or space on\n    // a clickable element. We can distinguish these events when `event.buttons` is zero, or\n    // `event.detail` is zero depending on the browser:\n    // - `event.buttons` works on Firefox, but fails on Chrome.\n    // - `detail` works on Chrome, but fails on Firefox.\n    return event.buttons === 0 || event.detail === 0;\n}\n/** Gets whether an event could be a faked `touchstart` event dispatched by a screen reader. */\nfunction isFakeTouchstartFromScreenReader(event) {\n    const touch = (event.touches && event.touches[0]) || (event.changedTouches && event.changedTouches[0]);\n    // A fake `touchstart` can be distinguished from a real one by looking at the `identifier`\n    // which is typically >= 0 on a real device versus -1 from a screen reader. Just to be safe,\n    // we can also look at `radiusX` and `radiusY`. This behavior was observed against a Windows 10\n    // device with a touch screen running NVDA v2020.4 and Firefox 85 or Chrome 88.\n    return (!!touch &&\n        touch.identifier === -1 &&\n        (touch.radiusX == null || touch.radiusX === 1) &&\n        (touch.radiusY == null || touch.radiusY === 1));\n}\n\nexport { isFakeMousedownFromScreenReader, isFakeTouchstartFromScreenReader };\n","import * as i0 from '@angular/core';\nimport { InjectionToken, inject, NgZone, DOCUMENT, RendererFactory2, Injectable, ElementRef, EventEmitter, Directive, Output } from '@angular/core';\nimport { BehaviorSubject, Subject, of } from 'rxjs';\nimport { skip, distinctUntilChanged, takeUntil } from 'rxjs/operators';\nimport { isFakeMousedownFromScreenReader, isFakeTouchstartFromScreenReader } from './fake-event-detection.mjs';\nimport { ALT, CONTROL, MAC_META, META, SHIFT } from './keycodes2.mjs';\nimport { _getEventTarget, _getShadowRoot } from './shadow-dom.mjs';\nimport { Platform } from './platform2.mjs';\nimport { normalizePassiveListenerOptions } from './passive-listeners.mjs';\nimport { coerceElement } from './element.mjs';\n\n/**\n * Injectable options for the InputModalityDetector. These are shallowly merged with the default\n * options.\n */\nconst INPUT_MODALITY_DETECTOR_OPTIONS = new InjectionToken('cdk-input-modality-detector-options');\n/**\n * Default options for the InputModalityDetector.\n *\n * Modifier keys are ignored by default (i.e. when pressed won't cause the service to detect\n * keyboard input modality) for two reasons:\n *\n * 1. Modifier keys are commonly used with mouse to perform actions such as 'right click' or 'open\n *    in new tab', and are thus less representative of actual keyboard interaction.\n * 2. VoiceOver triggers some keyboard events when linearly navigating with Control + Option (but\n *    confusingly not with Caps Lock). Thus, to have parity with other screen readers, we ignore\n *    these keys so as to not update the input modality.\n *\n * Note that we do not by default ignore the right Meta key on Safari because it has the same key\n * code as the ContextMenu key on other browsers. When we switch to using event.key, we can\n * distinguish between the two.\n */\nconst INPUT_MODALITY_DETECTOR_DEFAULT_OPTIONS = {\n    ignoreKeys: [ALT, CONTROL, MAC_META, META, SHIFT],\n};\n/**\n * The amount of time needed to pass after a touchstart event in order for a subsequent mousedown\n * event to be attributed as mouse and not touch.\n *\n * This is the value used by AngularJS Material. Through trial and error (on iPhone 6S) they found\n * that a value of around 650ms seems appropriate.\n */\nconst TOUCH_BUFFER_MS = 650;\n/**\n * Event listener options that enable capturing and also mark the listener as passive if the browser\n * supports it.\n */\nconst modalityEventListenerOptions = {\n    passive: true,\n    capture: true,\n};\n/**\n * Service that detects the user's input modality.\n *\n * This service does not update the input modality when a user navigates with a screen reader\n * (e.g. linear navigation with VoiceOver, object navigation / browse mode with NVDA, virtual PC\n * cursor mode with JAWS). This is in part due to technical limitations (i.e. keyboard events do not\n * fire as expected in these modes) but is also arguably the correct behavior. Navigating with a\n * screen reader is akin to visually scanning a page, and should not be interpreted as actual user\n * input interaction.\n *\n * When a user is not navigating but *interacting* with a screen reader, this service attempts to\n * update the input modality to keyboard, but in general this service's behavior is largely\n * undefined.\n */\nclass InputModalityDetector {\n    _platform = inject(Platform);\n    _listenerCleanups;\n    /** Emits whenever an input modality is detected. */\n    modalityDetected;\n    /** Emits when the input modality changes. */\n    modalityChanged;\n    /** The most recently detected input modality. */\n    get mostRecentModality() {\n        return this._modality.value;\n    }\n    /**\n     * The most recently detected input modality event target. Is null if no input modality has been\n     * detected or if the associated event target is null for some unknown reason.\n     */\n    _mostRecentTarget = null;\n    /** The underlying BehaviorSubject that emits whenever an input modality is detected. */\n    _modality = new BehaviorSubject(null);\n    /** Options for this InputModalityDetector. */\n    _options;\n    /**\n     * The timestamp of the last touch input modality. Used to determine whether mousedown events\n     * should be attributed to mouse or touch.\n     */\n    _lastTouchMs = 0;\n    /**\n     * Handles keydown events. Must be an arrow function in order to preserve the context when it gets\n     * bound.\n     */\n    _onKeydown = (event) => {\n        // If this is one of the keys we should ignore, then ignore it and don't update the input\n        // modality to keyboard.\n        if (this._options?.ignoreKeys?.some(keyCode => keyCode === event.keyCode)) {\n            return;\n        }\n        this._modality.next('keyboard');\n        this._mostRecentTarget = _getEventTarget(event);\n    };\n    /**\n     * Handles mousedown events. Must be an arrow function in order to preserve the context when it\n     * gets bound.\n     */\n    _onMousedown = (event) => {\n        // Touches trigger both touch and mouse events, so we need to distinguish between mouse events\n        // that were triggered via mouse vs touch. To do so, check if the mouse event occurs closely\n        // after the previous touch event.\n        if (Date.now() - this._lastTouchMs < TOUCH_BUFFER_MS) {\n            return;\n        }\n        // Fake mousedown events are fired by some screen readers when controls are activated by the\n        // screen reader. Attribute them to keyboard input modality.\n        this._modality.next(isFakeMousedownFromScreenReader(event) ? 'keyboard' : 'mouse');\n        this._mostRecentTarget = _getEventTarget(event);\n    };\n    /**\n     * Handles touchstart events. Must be an arrow function in order to preserve the context when it\n     * gets bound.\n     */\n    _onTouchstart = (event) => {\n        // Same scenario as mentioned in _onMousedown, but on touch screen devices, fake touchstart\n        // events are fired. Again, attribute to keyboard input modality.\n        if (isFakeTouchstartFromScreenReader(event)) {\n            this._modality.next('keyboard');\n            return;\n        }\n        // Store the timestamp of this touch event, as it's used to distinguish between mouse events\n        // triggered via mouse vs touch.\n        this._lastTouchMs = Date.now();\n        this._modality.next('touch');\n        this._mostRecentTarget = _getEventTarget(event);\n    };\n    constructor() {\n        const ngZone = inject(NgZone);\n        const document = inject(DOCUMENT);\n        const options = inject(INPUT_MODALITY_DETECTOR_OPTIONS, { optional: true });\n        this._options = {\n            ...INPUT_MODALITY_DETECTOR_DEFAULT_OPTIONS,\n            ...options,\n        };\n        // Skip the first emission as it's null.\n        this.modalityDetected = this._modality.pipe(skip(1));\n        this.modalityChanged = this.modalityDetected.pipe(distinctUntilChanged());\n        // If we're not in a browser, this service should do nothing, as there's no relevant input\n        // modality to detect.\n        if (this._platform.isBrowser) {\n            const renderer = inject(RendererFactory2).createRenderer(null, null);\n            this._listenerCleanups = ngZone.runOutsideAngular(() => {\n                return [\n                    renderer.listen(document, 'keydown', this._onKeydown, modalityEventListenerOptions),\n                    renderer.listen(document, 'mousedown', this._onMousedown, modalityEventListenerOptions),\n                    renderer.listen(document, 'touchstart', this._onTouchstart, modalityEventListenerOptions),\n                ];\n            });\n        }\n    }\n    ngOnDestroy() {\n        this._modality.complete();\n        this._listenerCleanups?.forEach(cleanup => cleanup());\n    }\n    static Éµfac = i0.ÉµÉµngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: InputModalityDetector, deps: [], target: i0.ÉµÉµFactoryTarget.Injectable });\n    static Éµprov = i0.ÉµÉµngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: InputModalityDetector, providedIn: 'root' });\n}\ni0.ÉµÉµngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: InputModalityDetector, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [] });\n\n/** Detection mode used for attributing the origin of a focus event. */\nvar FocusMonitorDetectionMode;\n(function (FocusMonitorDetectionMode) {\n    /**\n     * Any mousedown, keydown, or touchstart event that happened in the previous\n     * tick or the current tick will be used to assign a focus event's origin (to\n     * either mouse, keyboard, or touch). This is the default option.\n     */\n    FocusMonitorDetectionMode[FocusMonitorDetectionMode[\"IMMEDIATE\"] = 0] = \"IMMEDIATE\";\n    /**\n     * A focus event's origin is always attributed to the last corresponding\n     * mousedown, keydown, or touchstart event, no matter how long ago it occurred.\n     */\n    FocusMonitorDetectionMode[FocusMonitorDetectionMode[\"EVENTUAL\"] = 1] = \"EVENTUAL\";\n})(FocusMonitorDetectionMode || (FocusMonitorDetectionMode = {}));\n/** InjectionToken for FocusMonitorOptions. */\nconst FOCUS_MONITOR_DEFAULT_OPTIONS = new InjectionToken('cdk-focus-monitor-default-options');\n/**\n * Event listener options that enable capturing and also\n * mark the listener as passive if the browser supports it.\n */\nconst captureEventListenerOptions = normalizePassiveListenerOptions({\n    passive: true,\n    capture: true,\n});\n/** Monitors mouse and keyboard events to determine the cause of focus events. */\nclass FocusMonitor {\n    _ngZone = inject(NgZone);\n    _platform = inject(Platform);\n    _inputModalityDetector = inject(InputModalityDetector);\n    /** The focus origin that the next focus event is a result of. */\n    _origin = null;\n    /** The FocusOrigin of the last focus event tracked by the FocusMonitor. */\n    _lastFocusOrigin;\n    /** Whether the window has just been focused. */\n    _windowFocused = false;\n    /** The timeout id of the window focus timeout. */\n    _windowFocusTimeoutId;\n    /** The timeout id of the origin clearing timeout. */\n    _originTimeoutId;\n    /**\n     * Whether the origin was determined via a touch interaction. Necessary as properly attributing\n     * focus events to touch interactions requires special logic.\n     */\n    _originFromTouchInteraction = false;\n    /** Map of elements being monitored to their info. */\n    _elementInfo = new Map();\n    /** The number of elements currently being monitored. */\n    _monitoredElementCount = 0;\n    /**\n     * Keeps track of the root nodes to which we've currently bound a focus/blur handler,\n     * as well as the number of monitored elements that they contain. We have to treat focus/blur\n     * handlers differently from the rest of the events, because the browser won't emit events\n     * to the document when focus moves inside of a shadow root.\n     */\n    _rootNodeFocusListenerCount = new Map();\n    /**\n     * The specified detection mode, used for attributing the origin of a focus\n     * event.\n     */\n    _detectionMode;\n    /**\n     * Event listener for `focus` events on the window.\n     * Needs to be an arrow function in order to preserve the context when it gets bound.\n     */\n    _windowFocusListener = () => {\n        // Make a note of when the window regains focus, so we can\n        // restore the origin info for the focused element.\n        this._windowFocused = true;\n        this._windowFocusTimeoutId = setTimeout(() => (this._windowFocused = false));\n    };\n    /** Used to reference correct document/window */\n    _document = inject(DOCUMENT);\n    /** Subject for stopping our InputModalityDetector subscription. */\n    _stopInputModalityDetector = new Subject();\n    constructor() {\n        const options = inject(FOCUS_MONITOR_DEFAULT_OPTIONS, {\n            optional: true,\n        });\n        this._detectionMode = options?.detectionMode || FocusMonitorDetectionMode.IMMEDIATE;\n    }\n    /**\n     * Event listener for `focus` and 'blur' events on the document.\n     * Needs to be an arrow function in order to preserve the context when it gets bound.\n     */\n    _rootNodeFocusAndBlurListener = (event) => {\n        const target = _getEventTarget(event);\n        // We need to walk up the ancestor chain in order to support `checkChildren`.\n        for (let element = target; element; element = element.parentElement) {\n            if (event.type === 'focus') {\n                this._onFocus(event, element);\n            }\n            else {\n                this._onBlur(event, element);\n            }\n        }\n    };\n    monitor(element, checkChildren = false) {\n        const nativeElement = coerceElement(element);\n        // Do nothing if we're not on the browser platform or the passed in node isn't an element.\n        if (!this._platform.isBrowser || nativeElement.nodeType !== 1) {\n            // Note: we don't want the observable to emit at all so we don't pass any parameters.\n            return of();\n        }\n        // If the element is inside the shadow DOM, we need to bind our focus/blur listeners to\n        // the shadow root, rather than the `document`, because the browser won't emit focus events\n        // to the `document`, if focus is moving within the same shadow root.\n        const rootNode = _getShadowRoot(nativeElement) || this._document;\n        const cachedInfo = this._elementInfo.get(nativeElement);\n        // Check if we're already monitoring this element.\n        if (cachedInfo) {\n            if (checkChildren) {\n                // TODO(COMP-318): this can be problematic, because it'll turn all non-checkChildren\n                // observers into ones that behave as if `checkChildren` was turned on. We need a more\n                // robust solution.\n                cachedInfo.checkChildren = true;\n            }\n            return cachedInfo.subject;\n        }\n        // Create monitored element info.\n        const info = {\n            checkChildren: checkChildren,\n            subject: new Subject(),\n            rootNode,\n        };\n        this._elementInfo.set(nativeElement, info);\n        this._registerGlobalListeners(info);\n        return info.subject;\n    }\n    stopMonitoring(element) {\n        const nativeElement = coerceElement(element);\n        const elementInfo = this._elementInfo.get(nativeElement);\n        if (elementInfo) {\n            elementInfo.subject.complete();\n            this._setClasses(nativeElement);\n            this._elementInfo.delete(nativeElement);\n            this._removeGlobalListeners(elementInfo);\n        }\n    }\n    focusVia(element, origin, options) {\n        const nativeElement = coerceElement(element);\n        const focusedElement = this._document.activeElement;\n        // If the element is focused already, calling `focus` again won't trigger the event listener\n        // which means that the focus classes won't be updated. If that's the case, update the classes\n        // directly without waiting for an event.\n        if (nativeElement === focusedElement) {\n            this._getClosestElementsInfo(nativeElement).forEach(([currentElement, info]) => this._originChanged(currentElement, origin, info));\n        }\n        else {\n            this._setOrigin(origin);\n            // `focus` isn't available on the server\n            if (typeof nativeElement.focus === 'function') {\n                nativeElement.focus(options);\n            }\n        }\n    }\n    ngOnDestroy() {\n        this._elementInfo.forEach((_info, element) => this.stopMonitoring(element));\n    }\n    /** Use defaultView of injected document if available or fallback to global window reference */\n    _getWindow() {\n        return this._document.defaultView || window;\n    }\n    _getFocusOrigin(focusEventTarget) {\n        if (this._origin) {\n            // If the origin was realized via a touch interaction, we need to perform additional checks\n            // to determine whether the focus origin should be attributed to touch or program.\n            if (this._originFromTouchInteraction) {\n                return this._shouldBeAttributedToTouch(focusEventTarget) ? 'touch' : 'program';\n            }\n            else {\n                return this._origin;\n            }\n        }\n        // If the window has just regained focus, we can restore the most recent origin from before the\n        // window blurred. Otherwise, we've reached the point where we can't identify the source of the\n        // focus. This typically means one of two things happened:\n        //\n        // 1) The element was programmatically focused, or\n        // 2) The element was focused via screen reader navigation (which generally doesn't fire\n        //    events).\n        //\n        // Because we can't distinguish between these two cases, we default to setting `program`.\n        if (this._windowFocused && this._lastFocusOrigin) {\n            return this._lastFocusOrigin;\n        }\n        // If the interaction is coming from an input label, we consider it a mouse interactions.\n        // This is a special case where focus moves on `click`, rather than `mousedown` which breaks\n        // our detection, because all our assumptions are for `mousedown`. We need to handle this\n        // special case, because it's very common for checkboxes and radio buttons.\n        if (focusEventTarget && this._isLastInteractionFromInputLabel(focusEventTarget)) {\n            return 'mouse';\n        }\n        return 'program';\n    }\n    /**\n     * Returns whether the focus event should be attributed to touch. Recall that in IMMEDIATE mode, a\n     * touch origin isn't immediately reset at the next tick (see _setOrigin). This means that when we\n     * handle a focus event following a touch interaction, we need to determine whether (1) the focus\n     * event was directly caused by the touch interaction or (2) the focus event was caused by a\n     * subsequent programmatic focus call triggered by the touch interaction.\n     * @param focusEventTarget The target of the focus event under examination.\n     */\n    _shouldBeAttributedToTouch(focusEventTarget) {\n        // Please note that this check is not perfect. Consider the following edge case:\n        //\n        // <div #parent tabindex=\"0\">\n        //   <div #child tabindex=\"0\" (click)=\"#parent.focus()\"></div>\n        // </div>\n        //\n        // Suppose there is a FocusMonitor in IMMEDIATE mode attached to #parent. When the user touches\n        // #child, #parent is programmatically focused. This code will attribute the focus to touch\n        // instead of program. This is a relatively minor edge-case that can be worked around by using\n        // focusVia(parent, 'program') to focus #parent.\n        return (this._detectionMode === FocusMonitorDetectionMode.EVENTUAL ||\n            !!focusEventTarget?.contains(this._inputModalityDetector._mostRecentTarget));\n    }\n    /**\n     * Sets the focus classes on the element based on the given focus origin.\n     * @param element The element to update the classes on.\n     * @param origin The focus origin.\n     */\n    _setClasses(element, origin) {\n        element.classList.toggle('cdk-focused', !!origin);\n        element.classList.toggle('cdk-touch-focused', origin === 'touch');\n        element.classList.toggle('cdk-keyboard-focused', origin === 'keyboard');\n        element.classList.toggle('cdk-mouse-focused', origin === 'mouse');\n        element.classList.toggle('cdk-program-focused', origin === 'program');\n    }\n    /**\n     * Updates the focus origin. If we're using immediate detection mode, we schedule an async\n     * function to clear the origin at the end of a timeout. The duration of the timeout depends on\n     * the origin being set.\n     * @param origin The origin to set.\n     * @param isFromInteraction Whether we are setting the origin from an interaction event.\n     */\n    _setOrigin(origin, isFromInteraction = false) {\n        this._ngZone.runOutsideAngular(() => {\n            this._origin = origin;\n            this._originFromTouchInteraction = origin === 'touch' && isFromInteraction;\n            // If we're in IMMEDIATE mode, reset the origin at the next tick (or in `TOUCH_BUFFER_MS` ms\n            // for a touch event). We reset the origin at the next tick because Firefox focuses one tick\n            // after the interaction event. We wait `TOUCH_BUFFER_MS` ms before resetting the origin for\n            // a touch event because when a touch event is fired, the associated focus event isn't yet in\n            // the event queue. Before doing so, clear any pending timeouts.\n            if (this._detectionMode === FocusMonitorDetectionMode.IMMEDIATE) {\n                clearTimeout(this._originTimeoutId);\n                const ms = this._originFromTouchInteraction ? TOUCH_BUFFER_MS : 1;\n                this._originTimeoutId = setTimeout(() => (this._origin = null), ms);\n            }\n        });\n    }\n    /**\n     * Handles focus events on a registered element.\n     * @param event The focus event.\n     * @param element The monitored element.\n     */\n    _onFocus(event, element) {\n        // NOTE(mmalerba): We currently set the classes based on the focus origin of the most recent\n        // focus event affecting the monitored element. If we want to use the origin of the first event\n        // instead we should check for the cdk-focused class here and return if the element already has\n        // it. (This only matters for elements that have includesChildren = true).\n        // If we are not counting child-element-focus as focused, make sure that the event target is the\n        // monitored element itself.\n        const elementInfo = this._elementInfo.get(element);\n        const focusEventTarget = _getEventTarget(event);\n        if (!elementInfo || (!elementInfo.checkChildren && element !== focusEventTarget)) {\n            return;\n        }\n        this._originChanged(element, this._getFocusOrigin(focusEventTarget), elementInfo);\n    }\n    /**\n     * Handles blur events on a registered element.\n     * @param event The blur event.\n     * @param element The monitored element.\n     */\n    _onBlur(event, element) {\n        // If we are counting child-element-focus as focused, make sure that we aren't just blurring in\n        // order to focus another child of the monitored element.\n        const elementInfo = this._elementInfo.get(element);\n        if (!elementInfo ||\n            (elementInfo.checkChildren &&\n                event.relatedTarget instanceof Node &&\n                element.contains(event.relatedTarget))) {\n            return;\n        }\n        this._setClasses(element);\n        this._emitOrigin(elementInfo, null);\n    }\n    _emitOrigin(info, origin) {\n        if (info.subject.observers.length) {\n            this._ngZone.run(() => info.subject.next(origin));\n        }\n    }\n    _registerGlobalListeners(elementInfo) {\n        if (!this._platform.isBrowser) {\n            return;\n        }\n        const rootNode = elementInfo.rootNode;\n        const rootNodeFocusListeners = this._rootNodeFocusListenerCount.get(rootNode) || 0;\n        if (!rootNodeFocusListeners) {\n            this._ngZone.runOutsideAngular(() => {\n                rootNode.addEventListener('focus', this._rootNodeFocusAndBlurListener, captureEventListenerOptions);\n                rootNode.addEventListener('blur', this._rootNodeFocusAndBlurListener, captureEventListenerOptions);\n            });\n        }\n        this._rootNodeFocusListenerCount.set(rootNode, rootNodeFocusListeners + 1);\n        // Register global listeners when first element is monitored.\n        if (++this._monitoredElementCount === 1) {\n            // Note: we listen to events in the capture phase so we\n            // can detect them even if the user stops propagation.\n            this._ngZone.runOutsideAngular(() => {\n                const window = this._getWindow();\n                window.addEventListener('focus', this._windowFocusListener);\n            });\n            // The InputModalityDetector is also just a collection of global listeners.\n            this._inputModalityDetector.modalityDetected\n                .pipe(takeUntil(this._stopInputModalityDetector))\n                .subscribe(modality => {\n                this._setOrigin(modality, true /* isFromInteraction */);\n            });\n        }\n    }\n    _removeGlobalListeners(elementInfo) {\n        const rootNode = elementInfo.rootNode;\n        if (this._rootNodeFocusListenerCount.has(rootNode)) {\n            const rootNodeFocusListeners = this._rootNodeFocusListenerCount.get(rootNode);\n            if (rootNodeFocusListeners > 1) {\n                this._rootNodeFocusListenerCount.set(rootNode, rootNodeFocusListeners - 1);\n            }\n            else {\n                rootNode.removeEventListener('focus', this._rootNodeFocusAndBlurListener, captureEventListenerOptions);\n                rootNode.removeEventListener('blur', this._rootNodeFocusAndBlurListener, captureEventListenerOptions);\n                this._rootNodeFocusListenerCount.delete(rootNode);\n            }\n        }\n        // Unregister global listeners when last element is unmonitored.\n        if (!--this._monitoredElementCount) {\n            const window = this._getWindow();\n            window.removeEventListener('focus', this._windowFocusListener);\n            // Equivalently, stop our InputModalityDetector subscription.\n            this._stopInputModalityDetector.next();\n            // Clear timeouts for all potentially pending timeouts to prevent the leaks.\n            clearTimeout(this._windowFocusTimeoutId);\n            clearTimeout(this._originTimeoutId);\n        }\n    }\n    /** Updates all the state on an element once its focus origin has changed. */\n    _originChanged(element, origin, elementInfo) {\n        this._setClasses(element, origin);\n        this._emitOrigin(elementInfo, origin);\n        this._lastFocusOrigin = origin;\n    }\n    /**\n     * Collects the `MonitoredElementInfo` of a particular element and\n     * all of its ancestors that have enabled `checkChildren`.\n     * @param element Element from which to start the search.\n     */\n    _getClosestElementsInfo(element) {\n        const results = [];\n        this._elementInfo.forEach((info, currentElement) => {\n            if (currentElement === element || (info.checkChildren && currentElement.contains(element))) {\n                results.push([currentElement, info]);\n            }\n        });\n        return results;\n    }\n    /**\n     * Returns whether an interaction is likely to have come from the user clicking the `label` of\n     * an `input` or `textarea` in order to focus it.\n     * @param focusEventTarget Target currently receiving focus.\n     */\n    _isLastInteractionFromInputLabel(focusEventTarget) {\n        const { _mostRecentTarget: mostRecentTarget, mostRecentModality } = this._inputModalityDetector;\n        // If the last interaction used the mouse on an element contained by one of the labels\n        // of an `input`/`textarea` that is currently focused, it is very likely that the\n        // user redirected focus using the label.\n        if (mostRecentModality !== 'mouse' ||\n            !mostRecentTarget ||\n            mostRecentTarget === focusEventTarget ||\n            (focusEventTarget.nodeName !== 'INPUT' && focusEventTarget.nodeName !== 'TEXTAREA') ||\n            focusEventTarget.disabled) {\n            return false;\n        }\n        const labels = focusEventTarget.labels;\n        if (labels) {\n            for (let i = 0; i < labels.length; i++) {\n                if (labels[i].contains(mostRecentTarget)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    static Éµfac = i0.ÉµÉµngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: FocusMonitor, deps: [], target: i0.ÉµÉµFactoryTarget.Injectable });\n    static Éµprov = i0.ÉµÉµngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: FocusMonitor, providedIn: 'root' });\n}\ni0.ÉµÉµngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: FocusMonitor, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [] });\n/**\n * Directive that determines how a particular element was focused (via keyboard, mouse, touch, or\n * programmatically) and adds corresponding classes to the element.\n *\n * There are two variants of this directive:\n * 1) cdkMonitorElementFocus: does not consider an element to be focused if one of its children is\n *    focused.\n * 2) cdkMonitorSubtreeFocus: considers an element focused if it or any of its children are focused.\n */\nclass CdkMonitorFocus {\n    _elementRef = inject(ElementRef);\n    _focusMonitor = inject(FocusMonitor);\n    _monitorSubscription;\n    _focusOrigin = null;\n    cdkFocusChange = new EventEmitter();\n    constructor() { }\n    get focusOrigin() {\n        return this._focusOrigin;\n    }\n    ngAfterViewInit() {\n        const element = this._elementRef.nativeElement;\n        this._monitorSubscription = this._focusMonitor\n            .monitor(element, element.nodeType === 1 && element.hasAttribute('cdkMonitorSubtreeFocus'))\n            .subscribe(origin => {\n            this._focusOrigin = origin;\n            this.cdkFocusChange.emit(origin);\n        });\n    }\n    ngOnDestroy() {\n        this._focusMonitor.stopMonitoring(this._elementRef);\n        if (this._monitorSubscription) {\n            this._monitorSubscription.unsubscribe();\n        }\n    }\n    static Éµfac = i0.ÉµÉµngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: CdkMonitorFocus, deps: [], target: i0.ÉµÉµFactoryTarget.Directive });\n    static Éµdir = i0.ÉµÉµngDeclareDirective({ minVersion: \"14.0.0\", version: \"20.2.0-next.2\", type: CdkMonitorFocus, isStandalone: true, selector: \"[cdkMonitorElementFocus], [cdkMonitorSubtreeFocus]\", outputs: { cdkFocusChange: \"cdkFocusChange\" }, exportAs: [\"cdkMonitorFocus\"], ngImport: i0 });\n}\ni0.ÉµÉµngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: CdkMonitorFocus, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[cdkMonitorElementFocus], [cdkMonitorSubtreeFocus]',\n                    exportAs: 'cdkMonitorFocus',\n                }]\n        }], ctorParameters: () => [], propDecorators: { cdkFocusChange: [{\n                type: Output\n            }] } });\n\nexport { CdkMonitorFocus, FOCUS_MONITOR_DEFAULT_OPTIONS, FocusMonitor, FocusMonitorDetectionMode, INPUT_MODALITY_DETECTOR_DEFAULT_OPTIONS, INPUT_MODALITY_DETECTOR_OPTIONS, InputModalityDetector };\n","import * as i0 from '@angular/core';\nimport { Injectable, inject, NgZone, ElementRef, EventEmitter, booleanAttribute, Directive, Output, Input, NgModule } from '@angular/core';\nimport { Observable, Subject } from 'rxjs';\nimport { map, filter, debounceTime } from 'rxjs/operators';\nimport { coerceNumberProperty, coerceElement } from './element.mjs';\n\n// Angular may add, remove, or edit comment nodes during change detection. We don't care about\n// these changes because they don't affect the user-preceived content, and worse it can cause\n// infinite change detection cycles where the change detection updates a comment, triggering the\n// MutationObserver, triggering another change detection and kicking the cycle off again.\nfunction shouldIgnoreRecord(record) {\n    // Ignore changes to comment text.\n    if (record.type === 'characterData' && record.target instanceof Comment) {\n        return true;\n    }\n    // Ignore addition / removal of comments.\n    if (record.type === 'childList') {\n        for (let i = 0; i < record.addedNodes.length; i++) {\n            if (!(record.addedNodes[i] instanceof Comment)) {\n                return false;\n            }\n        }\n        for (let i = 0; i < record.removedNodes.length; i++) {\n            if (!(record.removedNodes[i] instanceof Comment)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    // Observe everything else.\n    return false;\n}\n/**\n * Factory that creates a new MutationObserver and allows us to stub it out in unit tests.\n * @docs-private\n */\nclass MutationObserverFactory {\n    create(callback) {\n        return typeof MutationObserver === 'undefined' ? null : new MutationObserver(callback);\n    }\n    static Éµfac = i0.ÉµÉµngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: MutationObserverFactory, deps: [], target: i0.ÉµÉµFactoryTarget.Injectable });\n    static Éµprov = i0.ÉµÉµngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: MutationObserverFactory, providedIn: 'root' });\n}\ni0.ÉµÉµngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: MutationObserverFactory, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }] });\n/** An injectable service that allows watching elements for changes to their content. */\nclass ContentObserver {\n    _mutationObserverFactory = inject(MutationObserverFactory);\n    /** Keeps track of the existing MutationObservers so they can be reused. */\n    _observedElements = new Map();\n    _ngZone = inject(NgZone);\n    constructor() { }\n    ngOnDestroy() {\n        this._observedElements.forEach((_, element) => this._cleanupObserver(element));\n    }\n    observe(elementOrRef) {\n        const element = coerceElement(elementOrRef);\n        return new Observable((observer) => {\n            const stream = this._observeElement(element);\n            const subscription = stream\n                .pipe(map(records => records.filter(record => !shouldIgnoreRecord(record))), filter(records => !!records.length))\n                .subscribe(records => {\n                this._ngZone.run(() => {\n                    observer.next(records);\n                });\n            });\n            return () => {\n                subscription.unsubscribe();\n                this._unobserveElement(element);\n            };\n        });\n    }\n    /**\n     * Observes the given element by using the existing MutationObserver if available, or creating a\n     * new one if not.\n     */\n    _observeElement(element) {\n        return this._ngZone.runOutsideAngular(() => {\n            if (!this._observedElements.has(element)) {\n                const stream = new Subject();\n                const observer = this._mutationObserverFactory.create(mutations => stream.next(mutations));\n                if (observer) {\n                    observer.observe(element, {\n                        characterData: true,\n                        childList: true,\n                        subtree: true,\n                    });\n                }\n                this._observedElements.set(element, { observer, stream, count: 1 });\n            }\n            else {\n                this._observedElements.get(element).count++;\n            }\n            return this._observedElements.get(element).stream;\n        });\n    }\n    /**\n     * Un-observes the given element and cleans up the underlying MutationObserver if nobody else is\n     * observing this element.\n     */\n    _unobserveElement(element) {\n        if (this._observedElements.has(element)) {\n            this._observedElements.get(element).count--;\n            if (!this._observedElements.get(element).count) {\n                this._cleanupObserver(element);\n            }\n        }\n    }\n    /** Clean up the underlying MutationObserver for the specified element. */\n    _cleanupObserver(element) {\n        if (this._observedElements.has(element)) {\n            const { observer, stream } = this._observedElements.get(element);\n            if (observer) {\n                observer.disconnect();\n            }\n            stream.complete();\n            this._observedElements.delete(element);\n        }\n    }\n    static Éµfac = i0.ÉµÉµngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: ContentObserver, deps: [], target: i0.ÉµÉµFactoryTarget.Injectable });\n    static Éµprov = i0.ÉµÉµngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: ContentObserver, providedIn: 'root' });\n}\ni0.ÉµÉµngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: ContentObserver, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [] });\n/**\n * Directive that triggers a callback whenever the content of\n * its associated element has changed.\n */\nclass CdkObserveContent {\n    _contentObserver = inject(ContentObserver);\n    _elementRef = inject(ElementRef);\n    /** Event emitted for each change in the element's content. */\n    event = new EventEmitter();\n    /**\n     * Whether observing content is disabled. This option can be used\n     * to disconnect the underlying MutationObserver until it is needed.\n     */\n    get disabled() {\n        return this._disabled;\n    }\n    set disabled(value) {\n        this._disabled = value;\n        this._disabled ? this._unsubscribe() : this._subscribe();\n    }\n    _disabled = false;\n    /** Debounce interval for emitting the changes. */\n    get debounce() {\n        return this._debounce;\n    }\n    set debounce(value) {\n        this._debounce = coerceNumberProperty(value);\n        this._subscribe();\n    }\n    _debounce;\n    _currentSubscription = null;\n    constructor() { }\n    ngAfterContentInit() {\n        if (!this._currentSubscription && !this.disabled) {\n            this._subscribe();\n        }\n    }\n    ngOnDestroy() {\n        this._unsubscribe();\n    }\n    _subscribe() {\n        this._unsubscribe();\n        const stream = this._contentObserver.observe(this._elementRef);\n        this._currentSubscription = (this.debounce ? stream.pipe(debounceTime(this.debounce)) : stream).subscribe(this.event);\n    }\n    _unsubscribe() {\n        this._currentSubscription?.unsubscribe();\n    }\n    static Éµfac = i0.ÉµÉµngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: CdkObserveContent, deps: [], target: i0.ÉµÉµFactoryTarget.Directive });\n    static Éµdir = i0.ÉµÉµngDeclareDirective({ minVersion: \"16.1.0\", version: \"20.2.0-next.2\", type: CdkObserveContent, isStandalone: true, selector: \"[cdkObserveContent]\", inputs: { disabled: [\"cdkObserveContentDisabled\", \"disabled\", booleanAttribute], debounce: \"debounce\" }, outputs: { event: \"cdkObserveContent\" }, exportAs: [\"cdkObserveContent\"], ngImport: i0 });\n}\ni0.ÉµÉµngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: CdkObserveContent, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[cdkObserveContent]',\n                    exportAs: 'cdkObserveContent',\n                }]\n        }], ctorParameters: () => [], propDecorators: { event: [{\n                type: Output,\n                args: ['cdkObserveContent']\n            }], disabled: [{\n                type: Input,\n                args: [{ alias: 'cdkObserveContentDisabled', transform: booleanAttribute }]\n            }], debounce: [{\n                type: Input\n            }] } });\nclass ObserversModule {\n    static Éµfac = i0.ÉµÉµngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: ObserversModule, deps: [], target: i0.ÉµÉµFactoryTarget.NgModule });\n    static Éµmod = i0.ÉµÉµngDeclareNgModule({ minVersion: \"14.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: ObserversModule, imports: [CdkObserveContent], exports: [CdkObserveContent] });\n    static Éµinj = i0.ÉµÉµngDeclareInjector({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: ObserversModule, providers: [MutationObserverFactory] });\n}\ni0.ÉµÉµngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: ObserversModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [CdkObserveContent],\n                    exports: [CdkObserveContent],\n                    providers: [MutationObserverFactory],\n                }]\n        }] });\n\nexport { CdkObserveContent, ContentObserver, MutationObserverFactory, ObserversModule };\n","/** Cached result of whether the user's browser supports passive event listeners. */\nlet supportsPassiveEvents;\n/**\n * Checks whether the user's browser supports passive event listeners.\n * See: https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\n */\nfunction supportsPassiveEventListeners() {\n    if (supportsPassiveEvents == null && typeof window !== 'undefined') {\n        try {\n            window.addEventListener('test', null, Object.defineProperty({}, 'passive', {\n                get: () => (supportsPassiveEvents = true),\n            }));\n        }\n        finally {\n            supportsPassiveEvents = supportsPassiveEvents || false;\n        }\n    }\n    return supportsPassiveEvents;\n}\n/**\n * Normalizes an `AddEventListener` object to something that can be passed\n * to `addEventListener` on any browser, no matter whether it supports the\n * `options` parameter.\n * @param options Object to be normalized.\n */\nfunction normalizePassiveListenerOptions(options) {\n    return supportsPassiveEventListeners() ? options : !!options.capture;\n}\n\nexport { normalizePassiveListenerOptions, supportsPassiveEventListeners };\n","export { _CdkPrivateStyleLoader } from './style-loader.mjs';\nimport * as i0 from '@angular/core';\nimport { Component, ViewEncapsulation, ChangeDetectionStrategy } from '@angular/core';\n\n/**\n * Component used to load the .cdk-visually-hidden styles.\n * @docs-private\n */\nclass _VisuallyHiddenLoader {\n    static Éµfac = i0.ÉµÉµngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: _VisuallyHiddenLoader, deps: [], target: i0.ÉµÉµFactoryTarget.Component });\n    static Éµcmp = i0.ÉµÉµngDeclareComponent({ minVersion: \"14.0.0\", version: \"20.2.0-next.2\", type: _VisuallyHiddenLoader, isStandalone: true, selector: \"ng-component\", exportAs: [\"cdkVisuallyHidden\"], ngImport: i0, template: '', isInline: true, styles: [\".cdk-visually-hidden{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px;white-space:nowrap;outline:0;-webkit-appearance:none;-moz-appearance:none;left:0}[dir=rtl] .cdk-visually-hidden{left:auto;right:0}\\n\"], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None });\n}\ni0.ÉµÉµngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: _VisuallyHiddenLoader, decorators: [{\n            type: Component,\n            args: [{ exportAs: 'cdkVisuallyHidden', encapsulation: ViewEncapsulation.None, template: '', changeDetection: ChangeDetectionStrategy.OnPush, styles: [\".cdk-visually-hidden{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px;white-space:nowrap;outline:0;-webkit-appearance:none;-moz-appearance:none;left:0}[dir=rtl] .cdk-visually-hidden{left:auto;right:0}\\n\"] }]\n        }] });\n\nexport { _VisuallyHiddenLoader };\n"],"x_google_ignoreList":[0,1,2,3,4,5,6,7]}