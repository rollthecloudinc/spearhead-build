{"version":3,"file":"9637.78535340b34dab0e.js","mappings":"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","names":["supportsPassiveEvents","supportsPassiveEventListeners","window","addEventListener","Object","defineProperty","get","normalizePassiveListenerOptions","options","capture","hasV8BreakIterator","Intl","v8BreakIterator","Platform","_Platform","_createClass","_classCallCheck","this","_defineProperty","inject","PLATFORM_ID","_platformId","isPlatformBrowser","document","isBrowser","test","navigator","userAgent","chrome","CSS","EDGE","TRIDENT","BLINK","WEBKIT","__ngFactoryType__","i0","token","factory","ɵfac","providedIn","rtlScrollAxisType","scrollBehaviorSupported","RtlScrollAxisType","NORMAL","NEGATED","INVERTED","supportsScrollBehavior","_document$documentEle","Element","documentElement","style","scrollToFunction","prototype","scrollTo","toString","getRtlScrollAxisType","scrollContainer","createElement","containerStyle","dir","width","overflow","visibility","pointerEvents","position","content","contentStyle","height","appendChild","body","scrollLeft","remove","shadowDomIsSupported","_supportsShadowDom","head","createShadowRoot","attachShadow","_getShadowRoot","element","rootNode","getRootNode","ShadowRoot","_getFocusedElementPierceShadowDom","activeElement","shadowRoot","newActiveElement","_getEventTarget","event","composedPath","target","_isTestEnvironment","__karma__","jasmine","jest","Mocha"],"ignoreList":[],"sourceRoot":"webpack:///","sources":["./node_modules/@angular/cdk/fesm2022/passive-listeners.mjs","./node_modules/@angular/cdk/fesm2022/platform2.mjs","./node_modules/@angular/cdk/fesm2022/scrolling2.mjs","./node_modules/@angular/cdk/fesm2022/shadow-dom.mjs","./node_modules/@angular/cdk/fesm2022/test-environment.mjs"],"sourcesContent":["/** Cached result of whether the user's browser supports passive event listeners. */\nlet supportsPassiveEvents;\n/**\n * Checks whether the user's browser supports passive event listeners.\n * See: https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\n */\nfunction supportsPassiveEventListeners() {\n    if (supportsPassiveEvents == null && typeof window !== 'undefined') {\n        try {\n            window.addEventListener('test', null, Object.defineProperty({}, 'passive', {\n                get: () => (supportsPassiveEvents = true),\n            }));\n        }\n        finally {\n            supportsPassiveEvents = supportsPassiveEvents || false;\n        }\n    }\n    return supportsPassiveEvents;\n}\n/**\n * Normalizes an `AddEventListener` object to something that can be passed\n * to `addEventListener` on any browser, no matter whether it supports the\n * `options` parameter.\n * @param options Object to be normalized.\n */\nfunction normalizePassiveListenerOptions(options) {\n    return supportsPassiveEventListeners() ? options : !!options.capture;\n}\n\nexport { normalizePassiveListenerOptions, supportsPassiveEventListeners };\n","import * as i0 from '@angular/core';\nimport { inject, PLATFORM_ID, Injectable } from '@angular/core';\nimport { isPlatformBrowser } from '@angular/common';\n\n// Whether the current platform supports the V8 Break Iterator. The V8 check\n// is necessary to detect all Blink based browsers.\nlet hasV8BreakIterator;\n// We need a try/catch around the reference to `Intl`, because accessing it in some cases can\n// cause IE to throw. These cases are tied to particular versions of Windows and can happen if\n// the consumer is providing a polyfilled `Map`. See:\n// https://github.com/Microsoft/ChakraCore/issues/3189\n// https://github.com/angular/components/issues/15687\ntry {\n    hasV8BreakIterator = typeof Intl !== 'undefined' && Intl.v8BreakIterator;\n}\ncatch {\n    hasV8BreakIterator = false;\n}\n/**\n * Service to detect the current platform by comparing the userAgent strings and\n * checking browser-specific global properties.\n */\nclass Platform {\n    _platformId = inject(PLATFORM_ID);\n    // We want to use the Angular platform check because if the Document is shimmed\n    // without the navigator, the following checks will fail. This is preferred because\n    // sometimes the Document may be shimmed without the user's knowledge or intention\n    /** Whether the Angular application is being rendered in the browser. */\n    isBrowser = this._platformId\n        ? isPlatformBrowser(this._platformId)\n        : typeof document === 'object' && !!document;\n    /** Whether the current browser is Microsoft Edge. */\n    EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent);\n    /** Whether the current rendering engine is Microsoft Trident. */\n    TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent);\n    // EdgeHTML and Trident mock Blink specific things and need to be excluded from this check.\n    /** Whether the current rendering engine is Blink. */\n    BLINK = this.isBrowser &&\n        !!(window.chrome || hasV8BreakIterator) &&\n        typeof CSS !== 'undefined' &&\n        !this.EDGE &&\n        !this.TRIDENT;\n    // Webkit is part of the userAgent in EdgeHTML, Blink and Trident. Therefore we need to\n    // ensure that Webkit runs standalone and is not used as another engine's base.\n    /** Whether the current rendering engine is WebKit. */\n    WEBKIT = this.isBrowser &&\n        /AppleWebKit/i.test(navigator.userAgent) &&\n        !this.BLINK &&\n        !this.EDGE &&\n        !this.TRIDENT;\n    /** Whether the current platform is Apple iOS. */\n    IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !('MSStream' in window);\n    // It's difficult to detect the plain Gecko engine, because most of the browsers identify\n    // them self as Gecko-like browsers and modify the userAgent's according to that.\n    // Since we only cover one explicit Firefox case, we can simply check for Firefox\n    // instead of having an unstable check for Gecko.\n    /** Whether the current browser is Firefox. */\n    FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent);\n    /** Whether the current platform is Android. */\n    // Trident on mobile adds the android platform to the userAgent to trick detections.\n    ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT;\n    // Safari browsers will include the Safari keyword in their userAgent. Some browsers may fake\n    // this and just place the Safari keyword in the userAgent. To be more safe about Safari every\n    // Safari browser should also use Webkit as its layout engine.\n    /** Whether the current browser is Safari. */\n    SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT;\n    constructor() { }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: Platform, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: Platform, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: Platform, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [] });\n\nexport { Platform };\n","/** The possible ways the browser may handle the horizontal scroll axis in RTL languages. */\nvar RtlScrollAxisType;\n(function (RtlScrollAxisType) {\n    /**\n     * scrollLeft is 0 when scrolled all the way left and (scrollWidth - clientWidth) when scrolled\n     * all the way right.\n     */\n    RtlScrollAxisType[RtlScrollAxisType[\"NORMAL\"] = 0] = \"NORMAL\";\n    /**\n     * scrollLeft is -(scrollWidth - clientWidth) when scrolled all the way left and 0 when scrolled\n     * all the way right.\n     */\n    RtlScrollAxisType[RtlScrollAxisType[\"NEGATED\"] = 1] = \"NEGATED\";\n    /**\n     * scrollLeft is (scrollWidth - clientWidth) when scrolled all the way left and 0 when scrolled\n     * all the way right.\n     */\n    RtlScrollAxisType[RtlScrollAxisType[\"INVERTED\"] = 2] = \"INVERTED\";\n})(RtlScrollAxisType || (RtlScrollAxisType = {}));\n/** Cached result of the way the browser handles the horizontal scroll axis in RTL mode. */\nlet rtlScrollAxisType;\n/** Cached result of the check that indicates whether the browser supports scroll behaviors. */\nlet scrollBehaviorSupported;\n/** Check whether the browser supports scroll behaviors. */\nfunction supportsScrollBehavior() {\n    if (scrollBehaviorSupported == null) {\n        // If we're not in the browser, it can't be supported. Also check for `Element`, because\n        // some projects stub out the global `document` during SSR which can throw us off.\n        if (typeof document !== 'object' || !document || typeof Element !== 'function' || !Element) {\n            scrollBehaviorSupported = false;\n            return scrollBehaviorSupported;\n        }\n        // If the element can have a `scrollBehavior` style, we can be sure that it's supported.\n        if (document.documentElement?.style && 'scrollBehavior' in document.documentElement.style) {\n            scrollBehaviorSupported = true;\n        }\n        else {\n            // At this point we have 3 possibilities: `scrollTo` isn't supported at all, it's\n            // supported but it doesn't handle scroll behavior, or it has been polyfilled.\n            const scrollToFunction = Element.prototype.scrollTo;\n            if (scrollToFunction) {\n                // We can detect if the function has been polyfilled by calling `toString` on it. Native\n                // functions are obfuscated using `[native code]`, whereas if it was overwritten we'd get\n                // the actual function source. Via https://davidwalsh.name/detect-native-function. Consider\n                // polyfilled functions as supporting scroll behavior.\n                scrollBehaviorSupported = !/\\{\\s*\\[native code\\]\\s*\\}/.test(scrollToFunction.toString());\n            }\n            else {\n                scrollBehaviorSupported = false;\n            }\n        }\n    }\n    return scrollBehaviorSupported;\n}\n/**\n * Checks the type of RTL scroll axis used by this browser. As of time of writing, Chrome is NORMAL,\n * Firefox & Safari are NEGATED, and IE & Edge are INVERTED.\n */\nfunction getRtlScrollAxisType() {\n    // We can't check unless we're on the browser. Just assume 'normal' if we're not.\n    if (typeof document !== 'object' || !document) {\n        return RtlScrollAxisType.NORMAL;\n    }\n    if (rtlScrollAxisType == null) {\n        // Create a 1px wide scrolling container and a 2px wide content element.\n        const scrollContainer = document.createElement('div');\n        const containerStyle = scrollContainer.style;\n        scrollContainer.dir = 'rtl';\n        containerStyle.width = '1px';\n        containerStyle.overflow = 'auto';\n        containerStyle.visibility = 'hidden';\n        containerStyle.pointerEvents = 'none';\n        containerStyle.position = 'absolute';\n        const content = document.createElement('div');\n        const contentStyle = content.style;\n        contentStyle.width = '2px';\n        contentStyle.height = '1px';\n        scrollContainer.appendChild(content);\n        document.body.appendChild(scrollContainer);\n        rtlScrollAxisType = RtlScrollAxisType.NORMAL;\n        // The viewport starts scrolled all the way to the right in RTL mode. If we are in a NORMAL\n        // browser this would mean that the scrollLeft should be 1. If it's zero instead we know we're\n        // dealing with one of the other two types of browsers.\n        if (scrollContainer.scrollLeft === 0) {\n            // In a NEGATED browser the scrollLeft is always somewhere in [-maxScrollAmount, 0]. For an\n            // INVERTED browser it is always somewhere in [0, maxScrollAmount]. We can determine which by\n            // setting to the scrollLeft to 1. This is past the max for a NEGATED browser, so it will\n            // return 0 when we read it again.\n            scrollContainer.scrollLeft = 1;\n            rtlScrollAxisType =\n                scrollContainer.scrollLeft === 0 ? RtlScrollAxisType.NEGATED : RtlScrollAxisType.INVERTED;\n        }\n        scrollContainer.remove();\n    }\n    return rtlScrollAxisType;\n}\n\nexport { RtlScrollAxisType, getRtlScrollAxisType, supportsScrollBehavior };\n","let shadowDomIsSupported;\n/** Checks whether the user's browser support Shadow DOM. */\nfunction _supportsShadowDom() {\n    if (shadowDomIsSupported == null) {\n        const head = typeof document !== 'undefined' ? document.head : null;\n        shadowDomIsSupported = !!(head && (head.createShadowRoot || head.attachShadow));\n    }\n    return shadowDomIsSupported;\n}\n/** Gets the shadow root of an element, if supported and the element is inside the Shadow DOM. */\nfunction _getShadowRoot(element) {\n    if (_supportsShadowDom()) {\n        const rootNode = element.getRootNode ? element.getRootNode() : null;\n        // Note that this should be caught by `_supportsShadowDom`, but some\n        // teams have been able to hit this code path on unsupported browsers.\n        if (typeof ShadowRoot !== 'undefined' && ShadowRoot && rootNode instanceof ShadowRoot) {\n            return rootNode;\n        }\n    }\n    return null;\n}\n/**\n * Gets the currently-focused element on the page while\n * also piercing through Shadow DOM boundaries.\n */\nfunction _getFocusedElementPierceShadowDom() {\n    let activeElement = typeof document !== 'undefined' && document\n        ? document.activeElement\n        : null;\n    while (activeElement && activeElement.shadowRoot) {\n        const newActiveElement = activeElement.shadowRoot.activeElement;\n        if (newActiveElement === activeElement) {\n            break;\n        }\n        else {\n            activeElement = newActiveElement;\n        }\n    }\n    return activeElement;\n}\n/** Gets the target of an event while accounting for Shadow DOM. */\nfunction _getEventTarget(event) {\n    // If an event is bound outside the Shadow DOM, the `event.target` will\n    // point to the shadow root so we have to use `composedPath` instead.\n    return (event.composedPath ? event.composedPath()[0] : event.target);\n}\n\nexport { _getEventTarget, _getFocusedElementPierceShadowDom, _getShadowRoot, _supportsShadowDom };\n","/** Gets whether the code is currently running in a test environment. */\nfunction _isTestEnvironment() {\n    // We can't use `declare const` because it causes conflicts inside Google with the real typings\n    // for these symbols and we can't read them off the global object, because they don't appear to\n    // be attached there for some runners like Jest.\n    // (see: https://github.com/angular/components/issues/23365#issuecomment-938146643)\n    return (\n    // @ts-ignore\n    (typeof __karma__ !== 'undefined' && !!__karma__) ||\n        // @ts-ignore\n        (typeof jasmine !== 'undefined' && !!jasmine) ||\n        // @ts-ignore\n        (typeof jest !== 'undefined' && !!jest) ||\n        // @ts-ignore\n        (typeof Mocha !== 'undefined' && !!Mocha));\n}\n\nexport { _isTestEnvironment };\n"],"x_google_ignoreList":[0,1,2,3,4]}