{"version":3,"file":"788.c4c1480444d58c73.js","mappings":"kJAQMA,EAAW,CAAC,EAEZC,EAAY,eAAAC,EAAZD,EAAY,WACS,SAAAE,KADT,SAAAF,KAAAG,OAAAC,KAAAJ,IAAA,EAAAK,KAAAD,KAAA,YACLE,UAAOC,UAAO,IAAAC,IAAA,QAAAC,eAKjBC,GAGF,MAAoB,OAAhBN,KAAKO,SACLD,GAAUN,KAAKO,QAEdZ,EAASa,eAAeF,KACzBX,EAASW,GAAU,GAEvB,GAAAG,OAAUH,GAAMG,OAAGd,EAASW,KAChC,IAAC,CAhBa,GAgBbT,SAhBCD,KAAYK,KAAZL,EAAY,qBAAAc,GAAA,WAAAA,GAiB4Fd,EAAY,MAAAK,KAjBpHL,EAAY,aAiBkFe,+BAAE,CAAAC,MACYhB,EAAYiB,QAAZjB,EAAYkB,UAAAC,WAAc,UAlBtInB,CAAY,iGCEZoB,EAAyB,eAAAC,EAAzBD,EAAyB,WACZ,SAAAlB,KADY,SAAAkB,KAAAjB,OAAAC,KAAAgB,IAAA,EAAAf,KAAAD,KAAA,aACd,GAAE,IAAAI,IAAA,SAAAC,eAMRa,EAAIC,GAAM,IACuBC,EADvBC,KAAAC,KACQtB,KAAKuB,YAAU,IAApC,IAAAF,EAAAG,MAAAJ,EAAAC,EAAAI,KAAAC,OACIC,EADaP,EAAAf,OACJa,EAAIC,EAChB,OAAAS,GAAAP,EAAAQ,EAAAD,EAAA,SAAAP,EAAAS,GAAA,CACL,GACA,CAAA1B,IAAA,SAAAC,MAIA,SAAOsB,GAAU,IAAAI,EAAA/B,KACb,OAAAA,KAAKuB,WAAWS,KAAKL,GACd,WACHI,EAAKR,WAAaQ,EAAKR,WAAWU,OAAO,SAACC,GACtC,OAAOP,IAAaO,CACxB,EACJ,CACJ,GAAC,CAAA9B,IAAA,cAAAC,MACD,WACIL,KAAKuB,WAAa,EACtB,IAAC,CA1B0B,GA0B1BN,SA1BCD,KAAyBf,KAAzBe,EAAyB,qBAAAN,GAAA,WAAAA,GA2B+EM,EAAyB,MAAAf,KA3BjIe,EAAyB,aA2BqEL,+BAAE,CAAAC,MACYI,EAAyBH,QAAzBG,EAAyBF,UAAAC,WAAc,UA5BnJC,CAAyB","names":["counters","_IdGenerator","_IdGenerator2","_createClass","_classCallCheck","this","_defineProperty","inject","APP_ID","key","value","prefix","_appId","hasOwnProperty","concat","__ngFactoryType__","i0","token","factory","ɵfac","providedIn","UniqueSelectionDispatcher","_UniqueSelectionDispatcher","id","name","_step","_iterator","_createForOfIteratorHelper","_listeners","s","n","done","listener","err","e","f","_this","push","filter","registered"],"ignoreList":[],"sourceRoot":"webpack:///","sources":["./node_modules/@angular/cdk/fesm2022/id-generator.mjs","./node_modules/@angular/cdk/fesm2022/unique-selection-dispatcher.mjs"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { inject, APP_ID, Injectable } from '@angular/core';\n\n/**\n * Keeps track of the ID count per prefix. This helps us make the IDs a bit more deterministic\n * like they were before the service was introduced. Note that ideally we wouldn't have to do\n * this, but there are some internal tests that rely on the IDs.\n */\nconst counters = {};\n/** Service that generates unique IDs for DOM nodes. */\nclass _IdGenerator {\n    _appId = inject(APP_ID);\n    /**\n     * Generates a unique ID with a specific prefix.\n     * @param prefix Prefix to add to the ID.\n     */\n    getId(prefix) {\n        // Omit the app ID if it's the default `ng`. Since the vast majority of pages have one\n        // Angular app on them, we can reduce the amount of breakages by not adding it.\n        if (this._appId !== 'ng') {\n            prefix += this._appId;\n        }\n        if (!counters.hasOwnProperty(prefix)) {\n            counters[prefix] = 0;\n        }\n        return `${prefix}${counters[prefix]++}`;\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: _IdGenerator, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: _IdGenerator, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: _IdGenerator, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }] });\n\nexport { _IdGenerator };\n","import * as i0 from '@angular/core';\nimport { Injectable } from '@angular/core';\n\n/**\n * Class to coordinate unique selection based on name.\n * Intended to be consumed as an Angular service.\n * This service is needed because native radio change events are only fired on the item currently\n * being selected, and we still need to uncheck the previous selection.\n *\n * This service does not *store* any IDs and names because they may change at any time, so it is\n * less error-prone if they are simply passed through when the events occur.\n */\nclass UniqueSelectionDispatcher {\n    _listeners = [];\n    /**\n     * Notify other items that selection for the given name has been set.\n     * @param id ID of the item.\n     * @param name Name of the item.\n     */\n    notify(id, name) {\n        for (let listener of this._listeners) {\n            listener(id, name);\n        }\n    }\n    /**\n     * Listen for future changes to item selection.\n     * @return Function used to deregister listener\n     */\n    listen(listener) {\n        this._listeners.push(listener);\n        return () => {\n            this._listeners = this._listeners.filter((registered) => {\n                return listener !== registered;\n            });\n        };\n    }\n    ngOnDestroy() {\n        this._listeners = [];\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: UniqueSelectionDispatcher, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: UniqueSelectionDispatcher, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: UniqueSelectionDispatcher, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }] });\n\nexport { UniqueSelectionDispatcher };\n"],"x_google_ignoreList":[0,1]}