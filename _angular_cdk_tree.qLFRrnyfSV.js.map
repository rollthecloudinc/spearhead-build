{
  "version": 3,
  "sources": ["../../@angular/cdk/fesm2022/tree.mjs"],
  "sourcesContent": ["import { SelectionModel } from './selection-model.mjs';\nimport { isObservable, Subject, BehaviorSubject, of, combineLatest, EMPTY, concat } from 'rxjs';\nimport { take, filter, takeUntil, startWith, tap, switchMap, map, reduce, concatMap, distinctUntilChanged } from 'rxjs/operators';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, inject, ViewContainerRef, Directive, TemplateRef, IterableDiffers, ChangeDetectorRef, ElementRef, Component, ViewEncapsulation, ChangeDetectionStrategy, Input, ViewChild, ContentChildren, EventEmitter, booleanAttribute, Output, numberAttribute, NgModule } from '@angular/core';\nimport { TREE_KEY_MANAGER } from './tree-key-manager.mjs';\nimport { Directionality } from './directionality.mjs';\nimport { isDataSource } from './data-source.mjs';\nimport { coerceObservable } from './coercion/private.mjs';\nimport './typeahead.mjs';\nimport './keycodes2.mjs';\n\n/**\n * Base tree control. It has basic toggle/expand/collapse operations on a single data node.\n *\n * @deprecated Use one of levelAccessor or childrenAccessor. To be removed in a future version.\n * @breaking-change 21.0.0\n */\nclass BaseTreeControl {\n  /** Saved data node for `expandAll` action. */\n  dataNodes;\n  /** A selection model with multi-selection to track expansion status. */\n  expansionModel = /*#__PURE__*/new SelectionModel(true);\n  /**\n   * Returns the identifier by which a dataNode should be tracked, should its\n   * reference change.\n   *\n   * Similar to trackBy for *ngFor\n   */\n  trackBy;\n  /** Get depth of a given data node, return the level number. This is for flat tree node. */\n  getLevel;\n  /**\n   * Whether the data node is expandable. Returns true if expandable.\n   * This is for flat tree node.\n   */\n  isExpandable;\n  /** Gets a stream that emits whenever the given data node's children change. */\n  getChildren;\n  /** Toggles one single data node's expanded/collapsed state. */\n  toggle(dataNode) {\n    this.expansionModel.toggle(this._trackByValue(dataNode));\n  }\n  /** Expands one single data node. */\n  expand(dataNode) {\n    this.expansionModel.select(this._trackByValue(dataNode));\n  }\n  /** Collapses one single data node. */\n  collapse(dataNode) {\n    this.expansionModel.deselect(this._trackByValue(dataNode));\n  }\n  /** Whether a given data node is expanded or not. Returns true if the data node is expanded. */\n  isExpanded(dataNode) {\n    return this.expansionModel.isSelected(this._trackByValue(dataNode));\n  }\n  /** Toggles a subtree rooted at `node` recursively. */\n  toggleDescendants(dataNode) {\n    this.expansionModel.isSelected(this._trackByValue(dataNode)) ? this.collapseDescendants(dataNode) : this.expandDescendants(dataNode);\n  }\n  /** Collapse all dataNodes in the tree. */\n  collapseAll() {\n    this.expansionModel.clear();\n  }\n  /** Expands a subtree rooted at given data node recursively. */\n  expandDescendants(dataNode) {\n    let toBeProcessed = [dataNode];\n    toBeProcessed.push(...this.getDescendants(dataNode));\n    this.expansionModel.select(...toBeProcessed.map(value => this._trackByValue(value)));\n  }\n  /** Collapses a subtree rooted at given data node recursively. */\n  collapseDescendants(dataNode) {\n    let toBeProcessed = [dataNode];\n    toBeProcessed.push(...this.getDescendants(dataNode));\n    this.expansionModel.deselect(...toBeProcessed.map(value => this._trackByValue(value)));\n  }\n  _trackByValue(value) {\n    return this.trackBy ? this.trackBy(value) : value;\n  }\n}\n\n/**\n * Flat tree control. Able to expand/collapse a subtree recursively for flattened tree.\n *\n * @deprecated Use one of levelAccessor or childrenAccessor instead. To be removed in a future\n * version.\n * @breaking-change 21.0.0\n */\nclass FlatTreeControl extends BaseTreeControl {\n  getLevel;\n  isExpandable;\n  options;\n  /** Construct with flat tree data node functions getLevel and isExpandable. */\n  constructor(getLevel, isExpandable, options) {\n    super();\n    this.getLevel = getLevel;\n    this.isExpandable = isExpandable;\n    this.options = options;\n    if (this.options) {\n      this.trackBy = this.options.trackBy;\n    }\n  }\n  /**\n   * Gets a list of the data node's subtree of descendent data nodes.\n   *\n   * To make this working, the `dataNodes` of the TreeControl must be flattened tree nodes\n   * with correct levels.\n   */\n  getDescendants(dataNode) {\n    const startIndex = this.dataNodes.indexOf(dataNode);\n    const results = [];\n    // Goes through flattened tree nodes in the `dataNodes` array, and get all descendants.\n    // The level of descendants of a tree node must be greater than the level of the given\n    // tree node.\n    // If we reach a node whose level is equal to the level of the tree node, we hit a sibling.\n    // If we reach a node whose level is greater than the level of the tree node, we hit a\n    // sibling of an ancestor.\n    for (let i = startIndex + 1; i < this.dataNodes.length && this.getLevel(dataNode) < this.getLevel(this.dataNodes[i]); i++) {\n      results.push(this.dataNodes[i]);\n    }\n    return results;\n  }\n  /**\n   * Expands all data nodes in the tree.\n   *\n   * To make this working, the `dataNodes` variable of the TreeControl must be set to all flattened\n   * data nodes of the tree.\n   */\n  expandAll() {\n    this.expansionModel.select(...this.dataNodes.map(node => this._trackByValue(node)));\n  }\n}\n\n/**\n * Nested tree control. Able to expand/collapse a subtree recursively for NestedNode type.\n *\n * @deprecated Use one of levelAccessor or childrenAccessor instead. To be removed in a future\n * version.\n * @breaking-change 21.0.0\n */\nclass NestedTreeControl extends BaseTreeControl {\n  getChildren;\n  options;\n  /** Construct with nested tree function getChildren. */\n  constructor(getChildren, options) {\n    super();\n    this.getChildren = getChildren;\n    this.options = options;\n    if (this.options) {\n      this.trackBy = this.options.trackBy;\n    }\n    if (this.options?.isExpandable) {\n      this.isExpandable = this.options.isExpandable;\n    }\n  }\n  /**\n   * Expands all dataNodes in the tree.\n   *\n   * To make this working, the `dataNodes` variable of the TreeControl must be set to all root level\n   * data nodes of the tree.\n   */\n  expandAll() {\n    this.expansionModel.clear();\n    const allNodes = this.dataNodes.reduce((accumulator, dataNode) => [...accumulator, ...this.getDescendants(dataNode), dataNode], []);\n    this.expansionModel.select(...allNodes.map(node => this._trackByValue(node)));\n  }\n  /** Gets a list of descendant dataNodes of a subtree rooted at given data node recursively. */\n  getDescendants(dataNode) {\n    const descendants = [];\n    this._getDescendants(descendants, dataNode);\n    // Remove the node itself\n    return descendants.splice(1);\n  }\n  /** A helper function to get descendants recursively. */\n  _getDescendants(descendants, dataNode) {\n    descendants.push(dataNode);\n    const childrenNodes = this.getChildren(dataNode);\n    if (Array.isArray(childrenNodes)) {\n      childrenNodes.forEach(child => this._getDescendants(descendants, child));\n    } else if (isObservable(childrenNodes)) {\n      // TypeScript as of version 3.5 doesn't seem to treat `Boolean` like a function that\n      // returns a `boolean` specifically in the context of `filter`, so we manually clarify that.\n      childrenNodes.pipe(take(1), filter(Boolean)).subscribe(children => {\n        for (const child of children) {\n          this._getDescendants(descendants, child);\n        }\n      });\n    }\n  }\n}\n\n/**\n * Injection token used to provide a `CdkTreeNode` to its outlet.\n * Used primarily to avoid circular imports.\n * @docs-private\n */\nconst CDK_TREE_NODE_OUTLET_NODE = /*#__PURE__*/new InjectionToken('CDK_TREE_NODE_OUTLET_NODE');\n/**\n * Outlet for nested CdkNode. Put `[cdkTreeNodeOutlet]` on a tag to place children dataNodes\n * inside the outlet.\n */\nlet CdkTreeNodeOutlet = /*#__PURE__*/(() => {\n  class CdkTreeNodeOutlet {\n    viewContainer = inject(ViewContainerRef);\n    _node = inject(CDK_TREE_NODE_OUTLET_NODE, {\n      optional: true\n    });\n    constructor() {}\n    static \u0275fac = function CdkTreeNodeOutlet_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkTreeNodeOutlet)();\n    };\n    static \u0275dir = /* @__PURE__ */i0.\u0275\u0275defineDirective({\n      type: CdkTreeNodeOutlet,\n      selectors: [[\"\", \"cdkTreeNodeOutlet\", \"\"]]\n    });\n  }\n  return CdkTreeNodeOutlet;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/** Context provided to the tree node component. */\nclass CdkTreeNodeOutletContext {\n  /** Data for the node. */\n  $implicit;\n  /** Depth of the node. */\n  level;\n  /** Index location of the node. */\n  index;\n  /** Length of the number of total dataNodes. */\n  count;\n  constructor(data) {\n    this.$implicit = data;\n  }\n}\n/**\n * Data node definition for the CdkTree.\n * Captures the node's template and a when predicate that describes when this node should be used.\n */\nlet CdkTreeNodeDef = /*#__PURE__*/(() => {\n  class CdkTreeNodeDef {\n    /** @docs-private */\n    template = inject(TemplateRef);\n    /**\n     * Function that should return true if this node template should be used for the provided node\n     * data and index. If left undefined, this node will be considered the default node template to\n     * use when no other when functions return true for the data.\n     * For every node, there must be at least one when function that passes or an undefined to\n     * default.\n     */\n    when;\n    constructor() {}\n    static \u0275fac = function CdkTreeNodeDef_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkTreeNodeDef)();\n    };\n    static \u0275dir = /* @__PURE__ */i0.\u0275\u0275defineDirective({\n      type: CdkTreeNodeDef,\n      selectors: [[\"\", \"cdkTreeNodeDef\", \"\"]],\n      inputs: {\n        when: [0, \"cdkTreeNodeDefWhen\", \"when\"]\n      }\n    });\n  }\n  return CdkTreeNodeDef;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Returns an error to be thrown when there is no usable data.\n * @docs-private\n */\nfunction getTreeNoValidDataSourceError() {\n  return Error(`A valid data source must be provided.`);\n}\n/**\n * Returns an error to be thrown when there are multiple nodes that are missing a when function.\n * @docs-private\n */\nfunction getTreeMultipleDefaultNodeDefsError() {\n  return Error(`There can only be one default row without a when predicate function.`);\n}\n/**\n * Returns an error to be thrown when there are no matching node defs for a particular set of data.\n * @docs-private\n */\nfunction getTreeMissingMatchingNodeDefError() {\n  return Error(`Could not find a matching node definition for the provided node data.`);\n}\n/**\n * Returns an error to be thrown when there is no tree control.\n * @docs-private\n */\nfunction getTreeControlMissingError() {\n  return Error(`Could not find a tree control, levelAccessor, or childrenAccessor for the tree.`);\n}\n/**\n * Returns an error to be thrown when there are multiple ways of specifying children or level\n * provided to the tree.\n * @docs-private\n */\nfunction getMultipleTreeControlsError() {\n  return Error(`More than one of tree control, levelAccessor, or childrenAccessor were provided.`);\n}\n\n/**\n * CDK tree component that connects with a data source to retrieve data of type `T` and renders\n * dataNodes with hierarchy. Updates the dataNodes when new data is provided by the data source.\n */\nlet CdkTree = /*#__PURE__*/(() => {\n  class CdkTree {\n    _differs = inject(IterableDiffers);\n    _changeDetectorRef = inject(ChangeDetectorRef);\n    _elementRef = inject(ElementRef);\n    _dir = inject(Directionality);\n    /** Subject that emits when the component has been destroyed. */\n    _onDestroy = new Subject();\n    /** Differ used to find the changes in the data provided by the data source. */\n    _dataDiffer;\n    /** Stores the node definition that does not have a when predicate. */\n    _defaultNodeDef;\n    /** Data subscription */\n    _dataSubscription;\n    /** Level of nodes */\n    _levels = new Map();\n    /** The immediate parents for a node. This is `null` if there is no parent. */\n    _parents = new Map();\n    /**\n     * Nodes grouped into each set, which is a list of nodes displayed together in the DOM.\n     *\n     * Lookup key is the parent of a set. Root nodes have key of null.\n     *\n     * Values is a 'set' of tree nodes. Each tree node maps to a treeitem element. Sets are in the\n     * order that it is rendered. Each set maps directly to aria-posinset and aria-setsize attributes.\n     */\n    _ariaSets = new Map();\n    /**\n     * Provides a stream containing the latest data array to render. Influenced by the tree's\n     * stream of view window (what dataNodes are currently on screen).\n     * Data source can be an observable of data array, or a data array to render.\n     */\n    get dataSource() {\n      return this._dataSource;\n    }\n    set dataSource(dataSource) {\n      if (this._dataSource !== dataSource) {\n        this._switchDataSource(dataSource);\n      }\n    }\n    _dataSource;\n    /**\n     * The tree controller\n     *\n     * @deprecated Use one of `levelAccessor` or `childrenAccessor` instead. To be removed in a\n     * future version.\n     * @breaking-change 21.0.0\n     */\n    treeControl;\n    /**\n     * Given a data node, determines what tree level the node is at.\n     *\n     * One of levelAccessor or childrenAccessor must be specified, not both.\n     * This is enforced at run-time.\n     */\n    levelAccessor;\n    /**\n     * Given a data node, determines what the children of that node are.\n     *\n     * One of levelAccessor or childrenAccessor must be specified, not both.\n     * This is enforced at run-time.\n     */\n    childrenAccessor;\n    /**\n     * Tracking function that will be used to check the differences in data changes. Used similarly\n     * to `ngFor` `trackBy` function. Optimize node operations by identifying a node based on its data\n     * relative to the function to know if a node should be added/removed/moved.\n     * Accepts a function that takes two parameters, `index` and `item`.\n     */\n    trackBy;\n    /**\n     * Given a data node, determines the key by which we determine whether or not this node is expanded.\n     */\n    expansionKey;\n    // Outlets within the tree's template where the dataNodes will be inserted.\n    _nodeOutlet;\n    /** The tree node template for the tree */\n    _nodeDefs;\n    // TODO(tinayuangao): Setup a listener for scrolling, emit the calculated view to viewChange.\n    //     Remove the MAX_VALUE in viewChange\n    /**\n     * Stream containing the latest information on what rows are being displayed on screen.\n     * Can be used by the data source to as a heuristic of what data should be provided.\n     */\n    viewChange = new BehaviorSubject({\n      start: 0,\n      end: Number.MAX_VALUE\n    });\n    /** Keep track of which nodes are expanded. */\n    _expansionModel;\n    /**\n     * Maintain a synchronous cache of flattened data nodes. This will only be\n     * populated after initial render, and in certain cases, will be delayed due to\n     * relying on Observable `getChildren` calls.\n     */\n    _flattenedNodes = new BehaviorSubject([]);\n    /** The automatically determined node type for the tree. */\n    _nodeType = new BehaviorSubject(null);\n    /** The mapping between data and the node that is rendered. */\n    _nodes = new BehaviorSubject(new Map());\n    /**\n     * Synchronous cache of nodes for the `TreeKeyManager`. This is separate\n     * from `_flattenedNodes` so they can be independently updated at different\n     * times.\n     */\n    _keyManagerNodes = new BehaviorSubject([]);\n    _keyManagerFactory = inject(TREE_KEY_MANAGER);\n    /** The key manager for this tree. Handles focus and activation based on user keyboard input. */\n    _keyManager;\n    _viewInit = false;\n    constructor() {}\n    ngAfterContentInit() {\n      this._initializeKeyManager();\n    }\n    ngAfterContentChecked() {\n      this._updateDefaultNodeDefinition();\n      this._subscribeToDataChanges();\n    }\n    ngOnDestroy() {\n      this._nodeOutlet.viewContainer.clear();\n      this._nodes.complete();\n      this._keyManagerNodes.complete();\n      this._nodeType.complete();\n      this._flattenedNodes.complete();\n      this.viewChange.complete();\n      this._onDestroy.next();\n      this._onDestroy.complete();\n      if (this._dataSource && typeof this._dataSource.disconnect === 'function') {\n        this.dataSource.disconnect(this);\n      }\n      if (this._dataSubscription) {\n        this._dataSubscription.unsubscribe();\n        this._dataSubscription = null;\n      }\n      // In certain tests, the tree might be destroyed before this is initialized\n      // in `ngAfterContentInit`.\n      this._keyManager?.destroy();\n    }\n    ngOnInit() {\n      this._checkTreeControlUsage();\n      this._initializeDataDiffer();\n    }\n    ngAfterViewInit() {\n      this._viewInit = true;\n    }\n    _updateDefaultNodeDefinition() {\n      const defaultNodeDefs = this._nodeDefs.filter(def => !def.when);\n      if (defaultNodeDefs.length > 1 && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throw getTreeMultipleDefaultNodeDefsError();\n      }\n      this._defaultNodeDef = defaultNodeDefs[0];\n    }\n    /**\n     * Sets the node type for the tree, if it hasn't been set yet.\n     *\n     * This will be called by the first node that's rendered in order for the tree\n     * to determine what data transformations are required.\n     */\n    _setNodeTypeIfUnset(newType) {\n      const currentType = this._nodeType.value;\n      if (currentType === null) {\n        this._nodeType.next(newType);\n      } else if ((typeof ngDevMode === 'undefined' || ngDevMode) && currentType !== newType) {\n        console.warn(`Tree is using conflicting node types which can cause unexpected behavior. ` + `Please use tree nodes of the same type (e.g. only flat or only nested). ` + `Current node type: \"${currentType}\", new node type \"${newType}\".`);\n      }\n    }\n    /**\n     * Switch to the provided data source by resetting the data and unsubscribing from the current\n     * render change subscription if one exists. If the data source is null, interpret this by\n     * clearing the node outlet. Otherwise start listening for new data.\n     */\n    _switchDataSource(dataSource) {\n      if (this._dataSource && typeof this._dataSource.disconnect === 'function') {\n        this.dataSource.disconnect(this);\n      }\n      if (this._dataSubscription) {\n        this._dataSubscription.unsubscribe();\n        this._dataSubscription = null;\n      }\n      // Remove the all dataNodes if there is now no data source\n      if (!dataSource) {\n        this._nodeOutlet.viewContainer.clear();\n      }\n      this._dataSource = dataSource;\n      if (this._nodeDefs) {\n        this._subscribeToDataChanges();\n      }\n    }\n    _getExpansionModel() {\n      if (!this.treeControl) {\n        this._expansionModel ??= new SelectionModel(true);\n        return this._expansionModel;\n      }\n      return this.treeControl.expansionModel;\n    }\n    /** Set up a subscription for the data provided by the data source. */\n    _subscribeToDataChanges() {\n      if (this._dataSubscription) {\n        return;\n      }\n      let dataStream;\n      if (isDataSource(this._dataSource)) {\n        dataStream = this._dataSource.connect(this);\n      } else if (isObservable(this._dataSource)) {\n        dataStream = this._dataSource;\n      } else if (Array.isArray(this._dataSource)) {\n        dataStream = of(this._dataSource);\n      }\n      if (!dataStream) {\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n          throw getTreeNoValidDataSourceError();\n        }\n        return;\n      }\n      this._dataSubscription = this._getRenderData(dataStream).pipe(takeUntil(this._onDestroy)).subscribe(renderingData => {\n        this._renderDataChanges(renderingData);\n      });\n    }\n    /** Given an Observable containing a stream of the raw data, returns an Observable containing the RenderingData */\n    _getRenderData(dataStream) {\n      const expansionModel = this._getExpansionModel();\n      return combineLatest([dataStream, this._nodeType,\n      // We don't use the expansion data directly, however we add it here to essentially\n      // trigger data rendering when expansion changes occur.\n      expansionModel.changed.pipe(startWith(null), tap(expansionChanges => {\n        this._emitExpansionChanges(expansionChanges);\n      }))]).pipe(switchMap(([data, nodeType]) => {\n        if (nodeType === null) {\n          return of({\n            renderNodes: data,\n            flattenedNodes: null,\n            nodeType\n          });\n        }\n        // If we're here, then we know what our node type is, and therefore can\n        // perform our usual rendering pipeline, which necessitates converting the data\n        return this._computeRenderingData(data, nodeType).pipe(map(convertedData => ({\n          ...convertedData,\n          nodeType\n        })));\n      }));\n    }\n    _renderDataChanges(data) {\n      if (data.nodeType === null) {\n        this.renderNodeChanges(data.renderNodes);\n        return;\n      }\n      // If we're here, then we know what our node type is, and therefore can\n      // perform our usual rendering pipeline.\n      this._updateCachedData(data.flattenedNodes);\n      this.renderNodeChanges(data.renderNodes);\n      this._updateKeyManagerItems(data.flattenedNodes);\n    }\n    _emitExpansionChanges(expansionChanges) {\n      if (!expansionChanges) {\n        return;\n      }\n      const nodes = this._nodes.value;\n      for (const added of expansionChanges.added) {\n        const node = nodes.get(added);\n        node?._emitExpansionState(true);\n      }\n      for (const removed of expansionChanges.removed) {\n        const node = nodes.get(removed);\n        node?._emitExpansionState(false);\n      }\n    }\n    _initializeKeyManager() {\n      const items = combineLatest([this._keyManagerNodes, this._nodes]).pipe(map(([keyManagerNodes, renderNodes]) => keyManagerNodes.reduce((items, data) => {\n        const node = renderNodes.get(this._getExpansionKey(data));\n        if (node) {\n          items.push(node);\n        }\n        return items;\n      }, [])));\n      const keyManagerOptions = {\n        trackBy: node => this._getExpansionKey(node.data),\n        skipPredicate: node => !!node.isDisabled,\n        typeAheadDebounceInterval: true,\n        horizontalOrientation: this._dir.value\n      };\n      this._keyManager = this._keyManagerFactory(items, keyManagerOptions);\n    }\n    _initializeDataDiffer() {\n      // Provide a default trackBy based on `_getExpansionKey` if one isn't provided.\n      const trackBy = this.trackBy ?? ((_index, item) => this._getExpansionKey(item));\n      this._dataDiffer = this._differs.find([]).create(trackBy);\n    }\n    _checkTreeControlUsage() {\n      if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        // Verify that Tree follows API contract of using one of TreeControl, levelAccessor or\n        // childrenAccessor. Throw an appropriate error if contract is not met.\n        let numTreeControls = 0;\n        if (this.treeControl) {\n          numTreeControls++;\n        }\n        if (this.levelAccessor) {\n          numTreeControls++;\n        }\n        if (this.childrenAccessor) {\n          numTreeControls++;\n        }\n        if (!numTreeControls) {\n          throw getTreeControlMissingError();\n        } else if (numTreeControls > 1) {\n          throw getMultipleTreeControlsError();\n        }\n      }\n    }\n    /** Check for changes made in the data and render each change (node added/removed/moved). */\n    renderNodeChanges(data, dataDiffer = this._dataDiffer, viewContainer = this._nodeOutlet.viewContainer, parentData) {\n      const changes = dataDiffer.diff(data);\n      // Some tree consumers expect change detection to propagate to nodes\n      // even when the array itself hasn't changed; we explicitly detect changes\n      // anyways in order for nodes to update their data.\n      //\n      // However, if change detection is called while the component's view is\n      // still initing, then the order of child views initing will be incorrect;\n      // to prevent this, we only exit early if the view hasn't initialized yet.\n      if (!changes && !this._viewInit) {\n        return;\n      }\n      changes?.forEachOperation((item, adjustedPreviousIndex, currentIndex) => {\n        if (item.previousIndex == null) {\n          this.insertNode(data[currentIndex], currentIndex, viewContainer, parentData);\n        } else if (currentIndex == null) {\n          viewContainer.remove(adjustedPreviousIndex);\n        } else {\n          const view = viewContainer.get(adjustedPreviousIndex);\n          viewContainer.move(view, currentIndex);\n        }\n      });\n      // If the data itself changes, but keeps the same trackBy, we need to update the templates'\n      // context to reflect the new object.\n      changes?.forEachIdentityChange(record => {\n        const newData = record.item;\n        if (record.currentIndex != undefined) {\n          const view = viewContainer.get(record.currentIndex);\n          view.context.$implicit = newData;\n        }\n      });\n      // Note: we only `detectChanges` from a top-level call, otherwise we risk overflowing\n      // the call stack since this method is called recursively (see #29733.)\n      // TODO: change to `this._changeDetectorRef.markForCheck()`,\n      // or just switch this component to use signals.\n      if (parentData) {\n        this._changeDetectorRef.markForCheck();\n      } else {\n        this._changeDetectorRef.detectChanges();\n      }\n    }\n    /**\n     * Finds the matching node definition that should be used for this node data. If there is only\n     * one node definition, it is returned. Otherwise, find the node definition that has a when\n     * predicate that returns true with the data. If none return true, return the default node\n     * definition.\n     */\n    _getNodeDef(data, i) {\n      if (this._nodeDefs.length === 1) {\n        return this._nodeDefs.first;\n      }\n      const nodeDef = this._nodeDefs.find(def => def.when && def.when(i, data)) || this._defaultNodeDef;\n      if (!nodeDef && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throw getTreeMissingMatchingNodeDefError();\n      }\n      return nodeDef;\n    }\n    /**\n     * Create the embedded view for the data node template and place it in the correct index location\n     * within the data node view container.\n     */\n    insertNode(nodeData, index, viewContainer, parentData) {\n      const levelAccessor = this._getLevelAccessor();\n      const node = this._getNodeDef(nodeData, index);\n      const key = this._getExpansionKey(nodeData);\n      // Node context that will be provided to created embedded view\n      const context = new CdkTreeNodeOutletContext(nodeData);\n      context.index = index;\n      parentData ??= this._parents.get(key) ?? undefined;\n      // If the tree is flat tree, then use the `getLevel` function in flat tree control\n      // Otherwise, use the level of parent node.\n      if (levelAccessor) {\n        context.level = levelAccessor(nodeData);\n      } else if (parentData !== undefined && this._levels.has(this._getExpansionKey(parentData))) {\n        context.level = this._levels.get(this._getExpansionKey(parentData)) + 1;\n      } else {\n        context.level = 0;\n      }\n      this._levels.set(key, context.level);\n      // Use default tree nodeOutlet, or nested node's nodeOutlet\n      const container = viewContainer ? viewContainer : this._nodeOutlet.viewContainer;\n      container.createEmbeddedView(node.template, context, index);\n      // Set the data to just created `CdkTreeNode`.\n      // The `CdkTreeNode` created from `createEmbeddedView` will be saved in static variable\n      //     `mostRecentTreeNode`. We get it from static variable and pass the node data to it.\n      if (CdkTreeNode.mostRecentTreeNode) {\n        CdkTreeNode.mostRecentTreeNode.data = nodeData;\n      }\n    }\n    /** Whether the data node is expanded or collapsed. Returns true if it's expanded. */\n    isExpanded(dataNode) {\n      return !!(this.treeControl?.isExpanded(dataNode) || this._expansionModel?.isSelected(this._getExpansionKey(dataNode)));\n    }\n    /** If the data node is currently expanded, collapse it. Otherwise, expand it. */\n    toggle(dataNode) {\n      if (this.treeControl) {\n        this.treeControl.toggle(dataNode);\n      } else if (this._expansionModel) {\n        this._expansionModel.toggle(this._getExpansionKey(dataNode));\n      }\n    }\n    /** Expand the data node. If it is already expanded, does nothing. */\n    expand(dataNode) {\n      if (this.treeControl) {\n        this.treeControl.expand(dataNode);\n      } else if (this._expansionModel) {\n        this._expansionModel.select(this._getExpansionKey(dataNode));\n      }\n    }\n    /** Collapse the data node. If it is already collapsed, does nothing. */\n    collapse(dataNode) {\n      if (this.treeControl) {\n        this.treeControl.collapse(dataNode);\n      } else if (this._expansionModel) {\n        this._expansionModel.deselect(this._getExpansionKey(dataNode));\n      }\n    }\n    /**\n     * If the data node is currently expanded, collapse it and all its descendants.\n     * Otherwise, expand it and all its descendants.\n     */\n    toggleDescendants(dataNode) {\n      if (this.treeControl) {\n        this.treeControl.toggleDescendants(dataNode);\n      } else if (this._expansionModel) {\n        if (this.isExpanded(dataNode)) {\n          this.collapseDescendants(dataNode);\n        } else {\n          this.expandDescendants(dataNode);\n        }\n      }\n    }\n    /**\n     * Expand the data node and all its descendants. If they are already expanded, does nothing.\n     */\n    expandDescendants(dataNode) {\n      if (this.treeControl) {\n        this.treeControl.expandDescendants(dataNode);\n      } else if (this._expansionModel) {\n        const expansionModel = this._expansionModel;\n        expansionModel.select(this._getExpansionKey(dataNode));\n        this._getDescendants(dataNode).pipe(take(1), takeUntil(this._onDestroy)).subscribe(children => {\n          expansionModel.select(...children.map(child => this._getExpansionKey(child)));\n        });\n      }\n    }\n    /** Collapse the data node and all its descendants. If it is already collapsed, does nothing. */\n    collapseDescendants(dataNode) {\n      if (this.treeControl) {\n        this.treeControl.collapseDescendants(dataNode);\n      } else if (this._expansionModel) {\n        const expansionModel = this._expansionModel;\n        expansionModel.deselect(this._getExpansionKey(dataNode));\n        this._getDescendants(dataNode).pipe(take(1), takeUntil(this._onDestroy)).subscribe(children => {\n          expansionModel.deselect(...children.map(child => this._getExpansionKey(child)));\n        });\n      }\n    }\n    /** Expands all data nodes in the tree. */\n    expandAll() {\n      if (this.treeControl) {\n        this.treeControl.expandAll();\n      } else if (this._expansionModel) {\n        this._forEachExpansionKey(keys => this._expansionModel?.select(...keys));\n      }\n    }\n    /** Collapse all data nodes in the tree. */\n    collapseAll() {\n      if (this.treeControl) {\n        this.treeControl.collapseAll();\n      } else if (this._expansionModel) {\n        this._forEachExpansionKey(keys => this._expansionModel?.deselect(...keys));\n      }\n    }\n    /** Level accessor, used for compatibility between the old Tree and new Tree */\n    _getLevelAccessor() {\n      return this.treeControl?.getLevel?.bind(this.treeControl) ?? this.levelAccessor;\n    }\n    /** Children accessor, used for compatibility between the old Tree and new Tree */\n    _getChildrenAccessor() {\n      return this.treeControl?.getChildren?.bind(this.treeControl) ?? this.childrenAccessor;\n    }\n    /**\n     * Gets the direct children of a node; used for compatibility between the old tree and the\n     * new tree.\n     */\n    _getDirectChildren(dataNode) {\n      const levelAccessor = this._getLevelAccessor();\n      const expansionModel = this._expansionModel ?? this.treeControl?.expansionModel;\n      if (!expansionModel) {\n        return of([]);\n      }\n      const key = this._getExpansionKey(dataNode);\n      const isExpanded = expansionModel.changed.pipe(switchMap(changes => {\n        if (changes.added.includes(key)) {\n          return of(true);\n        } else if (changes.removed.includes(key)) {\n          return of(false);\n        }\n        return EMPTY;\n      }), startWith(this.isExpanded(dataNode)));\n      if (levelAccessor) {\n        return combineLatest([isExpanded, this._flattenedNodes]).pipe(map(([expanded, flattenedNodes]) => {\n          if (!expanded) {\n            return [];\n          }\n          return this._findChildrenByLevel(levelAccessor, flattenedNodes, dataNode, 1);\n        }));\n      }\n      const childrenAccessor = this._getChildrenAccessor();\n      if (childrenAccessor) {\n        return coerceObservable(childrenAccessor(dataNode) ?? []);\n      }\n      throw getTreeControlMissingError();\n    }\n    /**\n     * Given the list of flattened nodes, the level accessor, and the level range within\n     * which to consider children, finds the children for a given node.\n     *\n     * For example, for direct children, `levelDelta` would be 1. For all descendants,\n     * `levelDelta` would be Infinity.\n     */\n    _findChildrenByLevel(levelAccessor, flattenedNodes, dataNode, levelDelta) {\n      const key = this._getExpansionKey(dataNode);\n      const startIndex = flattenedNodes.findIndex(node => this._getExpansionKey(node) === key);\n      const dataNodeLevel = levelAccessor(dataNode);\n      const expectedLevel = dataNodeLevel + levelDelta;\n      const results = [];\n      // Goes through flattened tree nodes in the `flattenedNodes` array, and get all\n      // descendants within a certain level range.\n      //\n      // If we reach a node whose level is equal to or less than the level of the tree node,\n      // we hit a sibling or parent's sibling, and should stop.\n      for (let i = startIndex + 1; i < flattenedNodes.length; i++) {\n        const currentLevel = levelAccessor(flattenedNodes[i]);\n        if (currentLevel <= dataNodeLevel) {\n          break;\n        }\n        if (currentLevel <= expectedLevel) {\n          results.push(flattenedNodes[i]);\n        }\n      }\n      return results;\n    }\n    /**\n     * Adds the specified node component to the tree's internal registry.\n     *\n     * This primarily facilitates keyboard navigation.\n     */\n    _registerNode(node) {\n      this._nodes.value.set(this._getExpansionKey(node.data), node);\n      this._nodes.next(this._nodes.value);\n    }\n    /** Removes the specified node component from the tree's internal registry. */\n    _unregisterNode(node) {\n      this._nodes.value.delete(this._getExpansionKey(node.data));\n      this._nodes.next(this._nodes.value);\n    }\n    /**\n     * For the given node, determine the level where this node appears in the tree.\n     *\n     * This is intended to be used for `aria-level` but is 0-indexed.\n     */\n    _getLevel(node) {\n      return this._levels.get(this._getExpansionKey(node));\n    }\n    /**\n     * For the given node, determine the size of the parent's child set.\n     *\n     * This is intended to be used for `aria-setsize`.\n     */\n    _getSetSize(dataNode) {\n      const set = this._getAriaSet(dataNode);\n      return set.length;\n    }\n    /**\n     * For the given node, determine the index (starting from 1) of the node in its parent's child set.\n     *\n     * This is intended to be used for `aria-posinset`.\n     */\n    _getPositionInSet(dataNode) {\n      const set = this._getAriaSet(dataNode);\n      const key = this._getExpansionKey(dataNode);\n      return set.findIndex(node => this._getExpansionKey(node) === key) + 1;\n    }\n    /** Given a CdkTreeNode, gets the node that renders that node's parent's data. */\n    _getNodeParent(node) {\n      const parent = this._parents.get(this._getExpansionKey(node.data));\n      return parent && this._nodes.value.get(this._getExpansionKey(parent));\n    }\n    /** Given a CdkTreeNode, gets the nodes that renders that node's child data. */\n    _getNodeChildren(node) {\n      return this._getDirectChildren(node.data).pipe(map(children => children.reduce((nodes, child) => {\n        const value = this._nodes.value.get(this._getExpansionKey(child));\n        if (value) {\n          nodes.push(value);\n        }\n        return nodes;\n      }, [])));\n    }\n    /** `keydown` event handler; this just passes the event to the `TreeKeyManager`. */\n    _sendKeydownToKeyManager(event) {\n      // Only handle events directly on the tree or directly on one of the nodes, otherwise\n      // we risk interfering with events in the projected content (see #29828).\n      if (event.target === this._elementRef.nativeElement) {\n        this._keyManager.onKeydown(event);\n      } else {\n        const nodes = this._nodes.getValue();\n        for (const [, node] of nodes) {\n          if (event.target === node._elementRef.nativeElement) {\n            this._keyManager.onKeydown(event);\n            break;\n          }\n        }\n      }\n    }\n    /** Gets all nested descendants of a given node. */\n    _getDescendants(dataNode) {\n      if (this.treeControl) {\n        return of(this.treeControl.getDescendants(dataNode));\n      }\n      if (this.levelAccessor) {\n        const results = this._findChildrenByLevel(this.levelAccessor, this._flattenedNodes.value, dataNode, Infinity);\n        return of(results);\n      }\n      if (this.childrenAccessor) {\n        return this._getAllChildrenRecursively(dataNode).pipe(reduce((allChildren, nextChildren) => {\n          allChildren.push(...nextChildren);\n          return allChildren;\n        }, []));\n      }\n      throw getTreeControlMissingError();\n    }\n    /**\n     * Gets all children and sub-children of the provided node.\n     *\n     * This will emit multiple times, in the order that the children will appear\n     * in the tree, and can be combined with a `reduce` operator.\n     */\n    _getAllChildrenRecursively(dataNode) {\n      if (!this.childrenAccessor) {\n        return of([]);\n      }\n      return coerceObservable(this.childrenAccessor(dataNode)).pipe(take(1), switchMap(children => {\n        // Here, we cache the parents of a particular child so that we can compute the levels.\n        for (const child of children) {\n          this._parents.set(this._getExpansionKey(child), dataNode);\n        }\n        return of(...children).pipe(concatMap(child => concat(of([child]), this._getAllChildrenRecursively(child))));\n      }));\n    }\n    _getExpansionKey(dataNode) {\n      // In the case that a key accessor function was not provided by the\n      // tree user, we'll default to using the node object itself as the key.\n      //\n      // This cast is safe since:\n      // - if an expansionKey is provided, TS will infer the type of K to be\n      //   the return type.\n      // - if it's not, then K will be defaulted to T.\n      return this.expansionKey?.(dataNode) ?? dataNode;\n    }\n    _getAriaSet(node) {\n      const key = this._getExpansionKey(node);\n      const parent = this._parents.get(key);\n      const parentKey = parent ? this._getExpansionKey(parent) : null;\n      const set = this._ariaSets.get(parentKey);\n      return set ?? [node];\n    }\n    /**\n     * Finds the parent for the given node. If this is a root node, this\n     * returns null. If we're unable to determine the parent, for example,\n     * if we don't have cached node data, this returns undefined.\n     */\n    _findParentForNode(node, index, cachedNodes) {\n      // In all cases, we have a mapping from node to level; all we need to do here is backtrack in\n      // our flattened list of nodes to determine the first node that's of a level lower than the\n      // provided node.\n      if (!cachedNodes.length) {\n        return null;\n      }\n      const currentLevel = this._levels.get(this._getExpansionKey(node)) ?? 0;\n      for (let parentIndex = index - 1; parentIndex >= 0; parentIndex--) {\n        const parentNode = cachedNodes[parentIndex];\n        const parentLevel = this._levels.get(this._getExpansionKey(parentNode)) ?? 0;\n        if (parentLevel < currentLevel) {\n          return parentNode;\n        }\n      }\n      return null;\n    }\n    /**\n     * Given a set of root nodes and the current node level, flattens any nested\n     * nodes into a single array.\n     *\n     * If any nodes are not expanded, then their children will not be added into the array.\n     * This will still traverse all nested children in order to build up our internal data\n     * models, but will not include them in the returned array.\n     */\n    _flattenNestedNodesWithExpansion(nodes, level = 0) {\n      const childrenAccessor = this._getChildrenAccessor();\n      // If we're using a level accessor, we don't need to flatten anything.\n      if (!childrenAccessor) {\n        return of([...nodes]);\n      }\n      return of(...nodes).pipe(concatMap(node => {\n        const parentKey = this._getExpansionKey(node);\n        if (!this._parents.has(parentKey)) {\n          this._parents.set(parentKey, null);\n        }\n        this._levels.set(parentKey, level);\n        const children = coerceObservable(childrenAccessor(node));\n        return concat(of([node]), children.pipe(take(1), tap(childNodes => {\n          this._ariaSets.set(parentKey, [...(childNodes ?? [])]);\n          for (const child of childNodes ?? []) {\n            const childKey = this._getExpansionKey(child);\n            this._parents.set(childKey, node);\n            this._levels.set(childKey, level + 1);\n          }\n        }), switchMap(childNodes => {\n          if (!childNodes) {\n            return of([]);\n          }\n          return this._flattenNestedNodesWithExpansion(childNodes, level + 1).pipe(map(nestedNodes => this.isExpanded(node) ? nestedNodes : []));\n        })));\n      }), reduce((results, children) => {\n        results.push(...children);\n        return results;\n      }, []));\n    }\n    /**\n     * Converts children for certain tree configurations.\n     *\n     * This also computes parent, level, and group data.\n     */\n    _computeRenderingData(nodes, nodeType) {\n      // The only situations where we have to convert children types is when\n      // they're mismatched; i.e. if the tree is using a childrenAccessor and the\n      // nodes are flat, or if the tree is using a levelAccessor and the nodes are\n      // nested.\n      if (this.childrenAccessor && nodeType === 'flat') {\n        // clear previously generated data so we don't keep end up retaining data overtime causing\n        // memory leaks.\n        this._clearPreviousCache();\n        // This flattens children into a single array.\n        this._ariaSets.set(null, [...nodes]);\n        return this._flattenNestedNodesWithExpansion(nodes).pipe(map(flattenedNodes => ({\n          renderNodes: flattenedNodes,\n          flattenedNodes\n        })));\n      } else if (this.levelAccessor && nodeType === 'nested') {\n        // In the nested case, we only look for root nodes. The CdkNestedNode\n        // itself will handle rendering each individual node's children.\n        const levelAccessor = this.levelAccessor;\n        return of(nodes.filter(node => levelAccessor(node) === 0)).pipe(map(rootNodes => ({\n          renderNodes: rootNodes,\n          flattenedNodes: nodes\n        })), tap(({\n          flattenedNodes\n        }) => {\n          this._calculateParents(flattenedNodes);\n        }));\n      } else if (nodeType === 'flat') {\n        // In the case of a TreeControl, we know that the node type matches up\n        // with the TreeControl, and so no conversions are necessary. Otherwise,\n        // we've already confirmed that the data model matches up with the\n        // desired node type here.\n        return of({\n          renderNodes: nodes,\n          flattenedNodes: nodes\n        }).pipe(tap(({\n          flattenedNodes\n        }) => {\n          this._calculateParents(flattenedNodes);\n        }));\n      } else {\n        // clear previously generated data so we don't keep end up retaining data overtime causing\n        // memory leaks.\n        this._clearPreviousCache();\n        // For nested nodes, we still need to perform the node flattening in order\n        // to maintain our caches for various tree operations.\n        this._ariaSets.set(null, [...nodes]);\n        return this._flattenNestedNodesWithExpansion(nodes).pipe(map(flattenedNodes => ({\n          renderNodes: nodes,\n          flattenedNodes\n        })));\n      }\n    }\n    _updateCachedData(flattenedNodes) {\n      this._flattenedNodes.next(flattenedNodes);\n    }\n    _updateKeyManagerItems(flattenedNodes) {\n      this._keyManagerNodes.next(flattenedNodes);\n    }\n    /** Traverse the flattened node data and compute parents, levels, and group data. */\n    _calculateParents(flattenedNodes) {\n      const levelAccessor = this._getLevelAccessor();\n      if (!levelAccessor) {\n        return;\n      }\n      // clear previously generated data so we don't keep end up retaining data overtime causing\n      // memory leaks.\n      this._clearPreviousCache();\n      for (let index = 0; index < flattenedNodes.length; index++) {\n        const dataNode = flattenedNodes[index];\n        const key = this._getExpansionKey(dataNode);\n        this._levels.set(key, levelAccessor(dataNode));\n        const parent = this._findParentForNode(dataNode, index, flattenedNodes);\n        this._parents.set(key, parent);\n        const parentKey = parent ? this._getExpansionKey(parent) : null;\n        const group = this._ariaSets.get(parentKey) ?? [];\n        group.splice(index, 0, dataNode);\n        this._ariaSets.set(parentKey, group);\n      }\n    }\n    /** Invokes a callback with all node expansion keys. */\n    _forEachExpansionKey(callback) {\n      const toToggle = [];\n      const observables = [];\n      this._nodes.value.forEach(node => {\n        toToggle.push(this._getExpansionKey(node.data));\n        observables.push(this._getDescendants(node.data));\n      });\n      if (observables.length > 0) {\n        combineLatest(observables).pipe(take(1), takeUntil(this._onDestroy)).subscribe(results => {\n          results.forEach(inner => inner.forEach(r => toToggle.push(this._getExpansionKey(r))));\n          callback(toToggle);\n        });\n      } else {\n        callback(toToggle);\n      }\n    }\n    /** Clears the maps we use to store parents, level & aria-sets in. */\n    _clearPreviousCache() {\n      this._parents.clear();\n      this._levels.clear();\n      this._ariaSets.clear();\n    }\n    static \u0275fac = function CdkTree_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkTree)();\n    };\n    static \u0275cmp = /* @__PURE__ */i0.\u0275\u0275defineComponent({\n      type: CdkTree,\n      selectors: [[\"cdk-tree\"]],\n      contentQueries: function CdkTree_ContentQueries(rf, ctx, dirIndex) {\n        if (rf & 1) {\n          i0.\u0275\u0275contentQuery(dirIndex, CdkTreeNodeDef, 5);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.\u0275\u0275queryRefresh(_t = i0.\u0275\u0275loadQuery()) && (ctx._nodeDefs = _t);\n        }\n      },\n      viewQuery: function CdkTree_Query(rf, ctx) {\n        if (rf & 1) {\n          i0.\u0275\u0275viewQuery(CdkTreeNodeOutlet, 7);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.\u0275\u0275queryRefresh(_t = i0.\u0275\u0275loadQuery()) && (ctx._nodeOutlet = _t.first);\n        }\n      },\n      hostAttrs: [\"role\", \"tree\", 1, \"cdk-tree\"],\n      hostBindings: function CdkTree_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.\u0275\u0275listener(\"keydown\", function CdkTree_keydown_HostBindingHandler($event) {\n            return ctx._sendKeydownToKeyManager($event);\n          });\n        }\n      },\n      inputs: {\n        dataSource: \"dataSource\",\n        treeControl: \"treeControl\",\n        levelAccessor: \"levelAccessor\",\n        childrenAccessor: \"childrenAccessor\",\n        trackBy: \"trackBy\",\n        expansionKey: \"expansionKey\"\n      },\n      exportAs: [\"cdkTree\"],\n      decls: 1,\n      vars: 0,\n      consts: [[\"cdkTreeNodeOutlet\", \"\"]],\n      template: function CdkTree_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.\u0275\u0275elementContainer(0, 0);\n        }\n      },\n      dependencies: [CdkTreeNodeOutlet],\n      encapsulation: 2\n    });\n  }\n  return CdkTree;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Tree node for CdkTree. It contains the data in the tree node.\n */\nlet CdkTreeNode = /*#__PURE__*/(() => {\n  class CdkTreeNode {\n    _elementRef = inject(ElementRef);\n    _tree = inject(CdkTree);\n    _tabindex = -1;\n    _type = 'flat';\n    /**\n     * The role of the tree node.\n     *\n     * @deprecated This will be ignored; the tree will automatically determine the appropriate role\n     * for tree node. This input will be removed in a future version.\n     * @breaking-change 21.0.0\n     */\n    get role() {\n      return 'treeitem';\n    }\n    set role(_role) {\n      // ignore any role setting, we handle this internally.\n    }\n    /**\n     * Whether or not this node is expandable.\n     *\n     * If not using `FlatTreeControl`, or if `isExpandable` is not provided to\n     * `NestedTreeControl`, this should be provided for correct node a11y.\n     */\n    get isExpandable() {\n      return this._isExpandable();\n    }\n    set isExpandable(isExpandable) {\n      this._inputIsExpandable = isExpandable;\n      if (this.data && !this._isExpandable || !this._inputIsExpandable) {\n        return;\n      }\n      // If the node is being set to expandable, ensure that the status of the\n      // node is propagated\n      if (this._inputIsExpanded) {\n        this.expand();\n      } else if (this._inputIsExpanded === false) {\n        this.collapse();\n      }\n    }\n    get isExpanded() {\n      return this._tree.isExpanded(this._data);\n    }\n    set isExpanded(isExpanded) {\n      this._inputIsExpanded = isExpanded;\n      if (isExpanded) {\n        this.expand();\n      } else {\n        this.collapse();\n      }\n    }\n    /**\n     * Whether or not this node is disabled. If it's disabled, then the user won't be able to focus\n     * or activate this node.\n     */\n    isDisabled;\n    /**\n     * The text used to locate this item during typeahead. If not specified, the `textContent` will\n     * will be used.\n     */\n    typeaheadLabel;\n    getLabel() {\n      return this.typeaheadLabel || this._elementRef.nativeElement.textContent?.trim() || '';\n    }\n    /** This emits when the node has been programatically activated or activated by keyboard. */\n    activation = new EventEmitter();\n    /** This emits when the node's expansion status has been changed. */\n    expandedChange = new EventEmitter();\n    /**\n     * The most recently created `CdkTreeNode`. We save it in static variable so we can retrieve it\n     * in `CdkTree` and set the data to it.\n     */\n    static mostRecentTreeNode = null;\n    /** Subject that emits when the component has been destroyed. */\n    _destroyed = new Subject();\n    /** Emits when the node's data has changed. */\n    _dataChanges = new Subject();\n    _inputIsExpandable = false;\n    _inputIsExpanded = undefined;\n    /**\n     * Flag used to determine whether or not we should be focusing the actual element based on\n     * some user interaction (click or focus). On click, we don't forcibly focus the element\n     * since the click could trigger some other component that wants to grab its own focus\n     * (e.g. menu, dialog).\n     */\n    _shouldFocus = true;\n    _parentNodeAriaLevel;\n    /** The tree node's data. */\n    get data() {\n      return this._data;\n    }\n    set data(value) {\n      if (value !== this._data) {\n        this._data = value;\n        this._dataChanges.next();\n      }\n    }\n    _data;\n    /* If leaf node, return true to not assign aria-expanded attribute */\n    get isLeafNode() {\n      // If flat tree node data returns false for expandable property, it's a leaf node\n      if (this._tree.treeControl?.isExpandable !== undefined && !this._tree.treeControl.isExpandable(this._data)) {\n        return true;\n        // If nested tree node data returns 0 descendants, it's a leaf node\n      } else if (this._tree.treeControl?.isExpandable === undefined && this._tree.treeControl?.getDescendants(this._data).length === 0) {\n        return true;\n      }\n      return false;\n    }\n    get level() {\n      // If the tree has a levelAccessor, use it to get the level. Otherwise read the\n      // aria-level off the parent node and use it as the level for this node (note aria-level is\n      // 1-indexed, while this property is 0-indexed, so we don't need to increment).\n      return this._tree._getLevel(this._data) ?? this._parentNodeAriaLevel;\n    }\n    /** Determines if the tree node is expandable. */\n    _isExpandable() {\n      if (this._tree.treeControl) {\n        if (this.isLeafNode) {\n          return false;\n        }\n        // For compatibility with trees created using TreeControl before we added\n        // CdkTreeNode#isExpandable.\n        return true;\n      }\n      return this._inputIsExpandable;\n    }\n    /**\n     * Determines the value for `aria-expanded`.\n     *\n     * For non-expandable nodes, this is `null`.\n     */\n    _getAriaExpanded() {\n      if (!this._isExpandable()) {\n        return null;\n      }\n      return String(this.isExpanded);\n    }\n    /**\n     * Determines the size of this node's parent's child set.\n     *\n     * This is intended to be used for `aria-setsize`.\n     */\n    _getSetSize() {\n      return this._tree._getSetSize(this._data);\n    }\n    /**\n     * Determines the index (starting from 1) of this node in its parent's child set.\n     *\n     * This is intended to be used for `aria-posinset`.\n     */\n    _getPositionInSet() {\n      return this._tree._getPositionInSet(this._data);\n    }\n    _changeDetectorRef = inject(ChangeDetectorRef);\n    constructor() {\n      CdkTreeNode.mostRecentTreeNode = this;\n    }\n    ngOnInit() {\n      this._parentNodeAriaLevel = getParentNodeAriaLevel(this._elementRef.nativeElement);\n      this._tree._getExpansionModel().changed.pipe(map(() => this.isExpanded), distinctUntilChanged(), takeUntil(this._destroyed)).pipe(takeUntil(this._destroyed)).subscribe(() => this._changeDetectorRef.markForCheck());\n      this._tree._setNodeTypeIfUnset(this._type);\n      this._tree._registerNode(this);\n    }\n    ngOnDestroy() {\n      // If this is the last tree node being destroyed,\n      // clear out the reference to avoid leaking memory.\n      if (CdkTreeNode.mostRecentTreeNode === this) {\n        CdkTreeNode.mostRecentTreeNode = null;\n      }\n      this._dataChanges.complete();\n      this._destroyed.next();\n      this._destroyed.complete();\n    }\n    getParent() {\n      return this._tree._getNodeParent(this) ?? null;\n    }\n    getChildren() {\n      return this._tree._getNodeChildren(this);\n    }\n    /** Focuses this data node. Implemented for TreeKeyManagerItem. */\n    focus() {\n      this._tabindex = 0;\n      if (this._shouldFocus) {\n        this._elementRef.nativeElement.focus();\n      }\n      this._changeDetectorRef.markForCheck();\n    }\n    /** Defocus this data node. */\n    unfocus() {\n      this._tabindex = -1;\n      this._changeDetectorRef.markForCheck();\n    }\n    /** Emits an activation event. Implemented for TreeKeyManagerItem. */\n    activate() {\n      if (this.isDisabled) {\n        return;\n      }\n      this.activation.next(this._data);\n    }\n    /** Collapses this data node. Implemented for TreeKeyManagerItem. */\n    collapse() {\n      if (this.isExpandable) {\n        this._tree.collapse(this._data);\n      }\n    }\n    /** Expands this data node. Implemented for TreeKeyManagerItem. */\n    expand() {\n      if (this.isExpandable) {\n        this._tree.expand(this._data);\n      }\n    }\n    /** Makes the node focusable. Implemented for TreeKeyManagerItem. */\n    makeFocusable() {\n      this._tabindex = 0;\n      this._changeDetectorRef.markForCheck();\n    }\n    _focusItem() {\n      if (this.isDisabled) {\n        return;\n      }\n      this._tree._keyManager.focusItem(this);\n    }\n    _setActiveItem() {\n      if (this.isDisabled) {\n        return;\n      }\n      this._shouldFocus = false;\n      this._tree._keyManager.focusItem(this);\n      this._shouldFocus = true;\n    }\n    _emitExpansionState(expanded) {\n      this.expandedChange.emit(expanded);\n    }\n    static \u0275fac = function CdkTreeNode_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkTreeNode)();\n    };\n    static \u0275dir = /* @__PURE__ */i0.\u0275\u0275defineDirective({\n      type: CdkTreeNode,\n      selectors: [[\"cdk-tree-node\"]],\n      hostAttrs: [\"role\", \"treeitem\", 1, \"cdk-tree-node\"],\n      hostVars: 5,\n      hostBindings: function CdkTreeNode_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.\u0275\u0275listener(\"click\", function CdkTreeNode_click_HostBindingHandler() {\n            return ctx._setActiveItem();\n          })(\"focus\", function CdkTreeNode_focus_HostBindingHandler() {\n            return ctx._focusItem();\n          });\n        }\n        if (rf & 2) {\n          i0.\u0275\u0275domProperty(\"tabIndex\", ctx._tabindex);\n          i0.\u0275\u0275attribute(\"aria-expanded\", ctx._getAriaExpanded())(\"aria-level\", ctx.level + 1)(\"aria-posinset\", ctx._getPositionInSet())(\"aria-setsize\", ctx._getSetSize());\n        }\n      },\n      inputs: {\n        role: \"role\",\n        isExpandable: [2, \"isExpandable\", \"isExpandable\", booleanAttribute],\n        isExpanded: \"isExpanded\",\n        isDisabled: [2, \"isDisabled\", \"isDisabled\", booleanAttribute],\n        typeaheadLabel: [0, \"cdkTreeNodeTypeaheadLabel\", \"typeaheadLabel\"]\n      },\n      outputs: {\n        activation: \"activation\",\n        expandedChange: \"expandedChange\"\n      },\n      exportAs: [\"cdkTreeNode\"]\n    });\n  }\n  return CdkTreeNode;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction getParentNodeAriaLevel(nodeElement) {\n  let parent = nodeElement.parentElement;\n  while (parent && !isNodeElement(parent)) {\n    parent = parent.parentElement;\n  }\n  if (!parent) {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      throw Error('Incorrect tree structure containing detached node.');\n    } else {\n      return -1;\n    }\n  } else if (parent.classList.contains('cdk-nested-tree-node')) {\n    return numberAttribute(parent.getAttribute('aria-level'));\n  } else {\n    // The ancestor element is the cdk-tree itself\n    return 0;\n  }\n}\nfunction isNodeElement(element) {\n  const classList = element.classList;\n  return !!(classList?.contains('cdk-nested-tree-node') || classList?.contains('cdk-tree'));\n}\n\n/**\n * Nested node is a child of `<cdk-tree>`. It works with nested tree.\n * By using `cdk-nested-tree-node` component in tree node template, children of the parent node will\n * be added in the `cdkTreeNodeOutlet` in tree node template.\n * The children of node will be automatically added to `cdkTreeNodeOutlet`.\n */\nlet CdkNestedTreeNode = /*#__PURE__*/(() => {\n  class CdkNestedTreeNode extends CdkTreeNode {\n    _type = 'nested';\n    _differs = inject(IterableDiffers);\n    /** Differ used to find the changes in the data provided by the data source. */\n    _dataDiffer;\n    /** The children data dataNodes of current node. They will be placed in `CdkTreeNodeOutlet`. */\n    _children;\n    /** The children node placeholder. */\n    nodeOutlet;\n    constructor() {\n      super();\n    }\n    ngAfterContentInit() {\n      this._dataDiffer = this._differs.find([]).create(this._tree.trackBy);\n      this._tree._getDirectChildren(this.data).pipe(takeUntil(this._destroyed)).subscribe(result => this.updateChildrenNodes(result));\n      this.nodeOutlet.changes.pipe(takeUntil(this._destroyed)).subscribe(() => this.updateChildrenNodes());\n    }\n    ngOnDestroy() {\n      this._clear();\n      super.ngOnDestroy();\n    }\n    /** Add children dataNodes to the NodeOutlet */\n    updateChildrenNodes(children) {\n      const outlet = this._getNodeOutlet();\n      if (children) {\n        this._children = children;\n      }\n      if (outlet && this._children) {\n        const viewContainer = outlet.viewContainer;\n        this._tree.renderNodeChanges(this._children, this._dataDiffer, viewContainer, this._data);\n      } else {\n        // Reset the data differ if there's no children nodes displayed\n        this._dataDiffer.diff([]);\n      }\n    }\n    /** Clear the children dataNodes. */\n    _clear() {\n      const outlet = this._getNodeOutlet();\n      if (outlet) {\n        outlet.viewContainer.clear();\n        this._dataDiffer.diff([]);\n      }\n    }\n    /** Gets the outlet for the current node. */\n    _getNodeOutlet() {\n      const outlets = this.nodeOutlet;\n      // Note that since we use `descendants: true` on the query, we have to ensure\n      // that we don't pick up the outlet of a child node by accident.\n      return outlets && outlets.find(outlet => !outlet._node || outlet._node === this);\n    }\n    static \u0275fac = function CdkNestedTreeNode_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkNestedTreeNode)();\n    };\n    static \u0275dir = /* @__PURE__ */i0.\u0275\u0275defineDirective({\n      type: CdkNestedTreeNode,\n      selectors: [[\"cdk-nested-tree-node\"]],\n      contentQueries: function CdkNestedTreeNode_ContentQueries(rf, ctx, dirIndex) {\n        if (rf & 1) {\n          i0.\u0275\u0275contentQuery(dirIndex, CdkTreeNodeOutlet, 5);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.\u0275\u0275queryRefresh(_t = i0.\u0275\u0275loadQuery()) && (ctx.nodeOutlet = _t);\n        }\n      },\n      hostAttrs: [1, \"cdk-nested-tree-node\"],\n      exportAs: [\"cdkNestedTreeNode\"],\n      features: [i0.\u0275\u0275ProvidersFeature([{\n        provide: CdkTreeNode,\n        useExisting: CdkNestedTreeNode\n      }, {\n        provide: CDK_TREE_NODE_OUTLET_NODE,\n        useExisting: CdkNestedTreeNode\n      }]), i0.\u0275\u0275InheritDefinitionFeature]\n    });\n  }\n  return CdkNestedTreeNode;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/** Regex used to split a string on its CSS units. */\nconst cssUnitPattern = /([A-Za-z%]+)$/;\n/**\n * Indent for the children tree dataNodes.\n * This directive will add left-padding to the node to show hierarchy.\n */\nlet CdkTreeNodePadding = /*#__PURE__*/(() => {\n  class CdkTreeNodePadding {\n    _treeNode = inject(CdkTreeNode);\n    _tree = inject(CdkTree);\n    _element = inject(ElementRef);\n    _dir = inject(Directionality, {\n      optional: true\n    });\n    /** Current padding value applied to the element. Used to avoid unnecessarily hitting the DOM. */\n    _currentPadding;\n    /** Subject that emits when the component has been destroyed. */\n    _destroyed = new Subject();\n    /** CSS units used for the indentation value. */\n    indentUnits = 'px';\n    /** The level of depth of the tree node. The padding will be `level * indent` pixels. */\n    get level() {\n      return this._level;\n    }\n    set level(value) {\n      this._setLevelInput(value);\n    }\n    _level;\n    /**\n     * The indent for each level. Can be a number or a CSS string.\n     * Default number 40px from material design menu sub-menu spec.\n     */\n    get indent() {\n      return this._indent;\n    }\n    set indent(indent) {\n      this._setIndentInput(indent);\n    }\n    _indent = 40;\n    constructor() {\n      this._setPadding();\n      this._dir?.change.pipe(takeUntil(this._destroyed)).subscribe(() => this._setPadding(true));\n      // In Ivy the indentation binding might be set before the tree node's data has been added,\n      // which means that we'll miss the first render. We have to subscribe to changes in the\n      // data to ensure that everything is up to date.\n      this._treeNode._dataChanges.subscribe(() => this._setPadding());\n    }\n    ngOnDestroy() {\n      this._destroyed.next();\n      this._destroyed.complete();\n    }\n    /** The padding indent value for the tree node. Returns a string with px numbers if not null. */\n    _paddingIndent() {\n      const nodeLevel = (this._treeNode.data && this._tree._getLevel(this._treeNode.data)) ?? null;\n      const level = this._level == null ? nodeLevel : this._level;\n      return typeof level === 'number' ? `${level * this._indent}${this.indentUnits}` : null;\n    }\n    _setPadding(forceChange = false) {\n      const padding = this._paddingIndent();\n      if (padding !== this._currentPadding || forceChange) {\n        const element = this._element.nativeElement;\n        const paddingProp = this._dir && this._dir.value === 'rtl' ? 'paddingRight' : 'paddingLeft';\n        const resetProp = paddingProp === 'paddingLeft' ? 'paddingRight' : 'paddingLeft';\n        element.style[paddingProp] = padding || '';\n        element.style[resetProp] = '';\n        this._currentPadding = padding;\n      }\n    }\n    /**\n     * This has been extracted to a util because of TS 4 and VE.\n     * View Engine doesn't support property rename inheritance.\n     * TS 4.0 doesn't allow properties to override accessors or vice-versa.\n     * @docs-private\n     */\n    _setLevelInput(value) {\n      // Set to null as the fallback value so that _setPadding can fall back to the node level if the\n      // consumer set the directive as `cdkTreeNodePadding=\"\"`. We still want to take this value if\n      // they set 0 explicitly.\n      this._level = isNaN(value) ? null : value;\n      this._setPadding();\n    }\n    /**\n     * This has been extracted to a util because of TS 4 and VE.\n     * View Engine doesn't support property rename inheritance.\n     * TS 4.0 doesn't allow properties to override accessors or vice-versa.\n     * @docs-private\n     */\n    _setIndentInput(indent) {\n      let value = indent;\n      let units = 'px';\n      if (typeof indent === 'string') {\n        const parts = indent.split(cssUnitPattern);\n        value = parts[0];\n        units = parts[1] || units;\n      }\n      this.indentUnits = units;\n      this._indent = numberAttribute(value);\n      this._setPadding();\n    }\n    static \u0275fac = function CdkTreeNodePadding_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkTreeNodePadding)();\n    };\n    static \u0275dir = /* @__PURE__ */i0.\u0275\u0275defineDirective({\n      type: CdkTreeNodePadding,\n      selectors: [[\"\", \"cdkTreeNodePadding\", \"\"]],\n      inputs: {\n        level: [2, \"cdkTreeNodePadding\", \"level\", numberAttribute],\n        indent: [0, \"cdkTreeNodePaddingIndent\", \"indent\"]\n      }\n    });\n  }\n  return CdkTreeNodePadding;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Node toggle to expand and collapse the node.\n */\nlet CdkTreeNodeToggle = /*#__PURE__*/(() => {\n  class CdkTreeNodeToggle {\n    _tree = inject(CdkTree);\n    _treeNode = inject(CdkTreeNode);\n    /** Whether expand/collapse the node recursively. */\n    recursive = false;\n    constructor() {}\n    // Toggle the expanded or collapsed state of this node.\n    //\n    // Focus this node with expanding or collapsing it. This ensures that the active node will always\n    // be visible when expanding and collapsing.\n    _toggle() {\n      this.recursive ? this._tree.toggleDescendants(this._treeNode.data) : this._tree.toggle(this._treeNode.data);\n      this._tree._keyManager.focusItem(this._treeNode);\n    }\n    static \u0275fac = function CdkTreeNodeToggle_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkTreeNodeToggle)();\n    };\n    static \u0275dir = /* @__PURE__ */i0.\u0275\u0275defineDirective({\n      type: CdkTreeNodeToggle,\n      selectors: [[\"\", \"cdkTreeNodeToggle\", \"\"]],\n      hostAttrs: [\"tabindex\", \"-1\"],\n      hostBindings: function CdkTreeNodeToggle_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.\u0275\u0275listener(\"click\", function CdkTreeNodeToggle_click_HostBindingHandler($event) {\n            ctx._toggle();\n            return $event.stopPropagation();\n          })(\"keydown.Enter\", function CdkTreeNodeToggle_keydown_Enter_HostBindingHandler($event) {\n            ctx._toggle();\n            return $event.preventDefault();\n          })(\"keydown.Space\", function CdkTreeNodeToggle_keydown_Space_HostBindingHandler($event) {\n            ctx._toggle();\n            return $event.preventDefault();\n          });\n        }\n      },\n      inputs: {\n        recursive: [2, \"cdkTreeNodeToggleRecursive\", \"recursive\", booleanAttribute]\n      }\n    });\n  }\n  return CdkTreeNodeToggle;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst EXPORTED_DECLARATIONS = [CdkNestedTreeNode, CdkTreeNodeDef, CdkTreeNodePadding, CdkTreeNodeToggle, CdkTree, CdkTreeNode, CdkTreeNodeOutlet];\nlet CdkTreeModule = /*#__PURE__*/(() => {\n  class CdkTreeModule {\n    static \u0275fac = function CdkTreeModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkTreeModule)();\n    };\n    static \u0275mod = /* @__PURE__ */i0.\u0275\u0275defineNgModule({\n      type: CdkTreeModule\n    });\n    static \u0275inj = /* @__PURE__ */i0.\u0275\u0275defineInjector({});\n  }\n  return CdkTreeModule;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nexport { BaseTreeControl, CDK_TREE_NODE_OUTLET_NODE, CdkNestedTreeNode, CdkTree, CdkTreeModule, CdkTreeNode, CdkTreeNodeDef, CdkTreeNodeOutlet, CdkTreeNodeOutletContext, CdkTreeNodePadding, CdkTreeNodeToggle, FlatTreeControl, NestedTreeControl, getMultipleTreeControlsError, getTreeControlMissingError, getTreeMissingMatchingNodeDefError, getTreeMultipleDefaultNodeDefsError, getTreeNoValidDataSourceError };\n"],
  "mappings": "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",
  "names": ["isObservable", "Subject", "BehaviorSubject", "of", "combineLatest", "EMPTY", "concat", "take", "filter", "takeUntil", "startWith", "tap", "switchMap", "map", "reduce", "concatMap", "distinctUntilChanged", "i0", "InjectionToken", "inject", "ViewContainerRef", "TemplateRef", "IterableDiffers", "ChangeDetectorRef", "ElementRef", "EventEmitter", "booleanAttribute", "numberAttribute", "BaseTreeControl", "SelectionModel", "dataNode", "toBeProcessed", "value", "FlatTreeControl", "getLevel", "isExpandable", "options", "startIndex", "results", "i", "node", "NestedTreeControl", "getChildren", "allNodes", "accumulator", "descendants", "childrenNodes", "child", "isObservable", "take", "filter", "children", "CDK_TREE_NODE_OUTLET_NODE", "InjectionToken", "CdkTreeNodeOutlet", "inject", "ViewContainerRef", "__ngFactoryType__", "CdkTreeNodeOutletContext", "data", "CdkTreeNodeDef", "TemplateRef", "getTreeNoValidDataSourceError", "getTreeMultipleDefaultNodeDefsError", "getTreeMissingMatchingNodeDefError", "getTreeControlMissingError", "getMultipleTreeControlsError", "CdkTree", "IterableDiffers", "ChangeDetectorRef", "ElementRef", "Directionality", "Subject", "dataSource", "BehaviorSubject", "TREE_KEY_MANAGER", "defaultNodeDefs", "def", "newType", "dataStream", "isDataSource", "of", "takeUntil", "renderingData", "expansionModel", "combineLatest", "startWith", "tap", "expansionChanges", "switchMap", "nodeType", "map", "convertedData", "__spreadProps", "__spreadValues", "nodes", "added", "removed", "items", "keyManagerNodes", "renderNodes", "keyManagerOptions", "trackBy", "_index", "item", "dataDiffer", "viewContainer", "parentData", "changes", "adjustedPreviousIndex", "currentIndex", "view", "record", "newData", "nodeDef", "nodeData", "index", "levelAccessor", "key", "context", "CdkTreeNode", "keys", "isExpanded", "EMPTY", "expanded", "flattenedNodes", "childrenAccessor", "coerceObservable", "levelDelta", "dataNodeLevel", "expectedLevel", "currentLevel", "set", "parent", "event", "reduce", "allChildren", "nextChildren", "concatMap", "concat", "parentKey", "cachedNodes", "parentIndex", "parentNode", "level", "childNodes", "childKey", "nestedNodes", "rootNodes", "group", "callback", "toToggle", "observables", "inner", "r", "rf", "ctx", "dirIndex", "_t", "$event", "_role", "EventEmitter", "getParentNodeAriaLevel", "distinctUntilChanged", "booleanAttribute", "nodeElement", "isNodeElement", "numberAttribute", "element", "classList", "CdkNestedTreeNode", "result", "outlet", "outlets", "cssUnitPattern", "CdkTreeNodePadding", "indent", "nodeLevel", "forceChange", "padding", "paddingProp", "resetProp", "units", "parts", "CdkTreeNodeToggle", "CdkTreeModule", "__ngFactoryType__"]
}
