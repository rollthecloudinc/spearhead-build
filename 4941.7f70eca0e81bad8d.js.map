{"version":3,"file":"4941.7f70eca0e81bad8d.js","mappings":"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","names":["coerceArray","value","Array","isArray","coerceCssPixelValue","concat","counters","_IdGenerator","_IdGenerator2","_createClass","_classCallCheck","this","_defineProperty","inject","APP_ID","key","prefix","_appId","hasOwnProperty","__ngFactoryType__","i0","token","factory","fac","providedIn","hasModifierKey","event","_len","arguments","length","modifiers","_key","some","modifier","altKey","shiftKey","ctrlKey","metaKey","MAC_ENTER","BACKSPACE","TAB","NUM_CENTER","ENTER","SHIFT","CONTROL","ALT","PAUSE","CAPS_LOCK","ESCAPE","SPACE","PAGE_UP","PAGE_DOWN","END","HOME","LEFT_ARROW","UP_ARROW","RIGHT_ARROW","DOWN_ARROW","PLUS_SIGN","PRINT_SCREEN","INSERT","DELETE","ZERO","ONE","TWO","THREE","FOUR","FIVE","SIX","SEVEN","EIGHT","NINE","FF_SEMICOLON","FF_EQUALS","QUESTION_MARK","AT_SIGN","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","META","MAC_WK_CMD_LEFT","MAC_WK_CMD_RIGHT","CONTEXT_MENU","NUMPAD_ZERO","NUMPAD_ONE","NUMPAD_TWO","NUMPAD_THREE","NUMPAD_FOUR","NUMPAD_FIVE","NUMPAD_SIX","NUMPAD_SEVEN","NUMPAD_EIGHT","NUMPAD_NINE","NUMPAD_MULTIPLY","NUMPAD_PLUS","NUMPAD_MINUS","NUMPAD_PERIOD","NUMPAD_DIVIDE","F1","F2","F3","F4","F5","F6","F7","F8","F9","F10","F11","F12","NUM_LOCK","SCROLL_LOCK","FIRST_MEDIA","FF_MINUS","MUTE","VOLUME_DOWN","VOLUME_UP","FF_MUTE","FF_VOLUME_DOWN","LAST_MEDIA","FF_VOLUME_UP","SEMICOLON","EQUALS","COMMA","DASH","PERIOD","SLASH","APOSTROPHE","TILDE","OPEN_SQUARE_BRACKET","BACKSLASH","CLOSE_SQUARE_BRACKET","SINGLE_QUOTE","MAC_META","scrollBehaviorSupported","supportsScrollBehavior","createBlockScrollStrategy","injector","BlockScrollStrategy","get","ViewportRuler","DOCUMENT","_viewportRuler","document","top","left","_document","_canBeEnabled","root","documentElement","_previousScrollPosition","getViewportScrollPosition","_previousHTMLStyles","style","classList","add","_isEnabled","html","htmlStyle","bodyStyle","body","previousHtmlScrollBehavior","scrollBehavior","previousBodyScrollBehavior","remove","window","scroll","contains","rootElement","viewport","getViewportSize","scrollHeight","height","scrollWidth","width","createCloseScrollStrategy","config","CloseScrollStrategy","ScrollDispatcher","NgZone","_scrollDispatcher","_ngZone","_config","_this","disable","_overlayRef","hasAttached","run","detach","overlayRef","_this2","_scrollSubscription","stream","scrolled","pipe","filter","scrollable","overlayElement","getElementRef","nativeElement","threshold","_initialScrollPosition","subscribe","scrollPosition","Math","abs","_detach","updatePosition","unsubscribe","createNoopScrollStrategy","NoopScrollStrategy","isElementScrolledOutsideView","element","scrollContainers","containerBounds","bottom","right","isElementClippedByScrolling","scrollContainerRect","createRepositionScrollStrategy","RepositionScrollStrategy","_this3","scrollThrottle","autoClose","overlayRect","getBoundingClientRect","_this3$_viewportRuler","ScrollStrategyOptions","_ScrollStrategyOptions","_this4","Injector","_injector","OverlayConfig","_i","_configKeys","Object","keys","undefined","ConnectionPositionPair","origin","overlay","offsetX","offsetY","panelClass","originX","originY","overlayX","overlayY","ScrollingVisibility","ConnectedOverlayPositionChange","connectionPair","scrollableViewProperties","validateVerticalPosition","property","Error","validateHorizontalPosition","BaseOverlayDispatcher","_BaseOverlayDispatcher","_attachedOverlays","push","index","indexOf","splice","OverlayKeyboardDispatcher","_OverlayKeyboardDispatcher","_BaseOverlayDispatche","_this5","args","_callSuper","RendererFactory2","createRenderer","overlays","_loop","i","_keydownEvents","observers","next","_inherits","_this6","_superPropGet","_isAttached","runOutsideAngular","_cleanupKeydown","_renderer","listen","_keydownListener","_this$_cleanupKeydown","call","_OverlayKeyboardDispatcher_BaseFactory","OverlayOutsideClickDispatcher","_OverlayOutsideClickDispatcher","_BaseOverlayDispatche2","_this7","_len2","_key2","Platform","_pointerDownEventTarget","_getEventTarget","target","type","_ret","slice","_loop2","_outsidePointerEvents","containsPierceShadowDom","outsidePointerEvents","_this8","eventOptions","capture","renderer","_cleanups","_pointerDownListener","_clickListener","_platform","IOS","_cursorStyleIsSet","_cursorOriginalValue","cursor","_this$_cleanups","forEach","cleanup","_OverlayOutsideClickDispatcher_BaseFactory","parent","child","supportsShadowRoot","ShadowRoot","current","host","parentNode","_CdkOverlayStyleLoader","_CdkOverlayStyleLoader2","selectors","hostAttrs","decls","vars","template","rf","ctx","styles","encapsulation","changeDetection","OverlayContainer","_OverlayContainer","_CdkPrivateStyleLoader","_this$_containerEleme","_containerElement","_loadStyles","_createContainer","containerClass","isBrowser","_isTestEnvironment","oppositePlatformContainers","querySelectorAll","container","createElement","setAttribute","appendChild","_styleLoader","load","BackdropRef","onClick","_this9","_this9$_cleanupClick","_this9$_cleanupTransi","clearTimeout","_fallbackTimeout","_cleanupClick","_cleanupTransitionEnd","_this0","_this0$_cleanupTransi","dispose","setTimeout","pointerEvents","OverlayRef","_portalOutlet","_host","_pane","_keyboardDispatcher","_location","_outsideClickDispatcher","_animationsDisabled","Subject","Subscription","EMPTY","scrollStrategy","_scrollStrategy","attach","_positionStrategy","positionStrategy","_this$_backdropRef","_backdropRef","portal","_this$_afterNextRende","_this1","parentElement","_previousHostParent","attachResult","_updateStackingOrder","_updateElementSize","_updateElementDirection","enable","_afterNextRenderRef","destroy","afterNextRender","_togglePointerEvents","hasBackdrop","_attachBackdrop","_toggleClasses","_attachments","_completeDetachContent","disposeOnNavigation","_locationChanges","onDestroy","Promise","resolve","then","detachBackdrop","detachmentResult","_detachments","_detachContentWhenEmpty","_this$_backdropRef2","_this$_host","_this$_afterNextRende2","isAttached","_disposeScrollStrategy","complete","_backdropClick","apply","strategy","sizeConfig","_objectSpread","dir","direction","classes","getDirection","minWidth","minHeight","maxWidth","maxHeight","enablePointer","_this$_backdropRef3","_this10","showingClass","backdropClass","insertBefore","requestAnimationFrame","_this10$_backdropRef","nextSibling","_this$_backdropRef4","_this$_backdropRef5","cssClasses","isAdd","_element$classList","_element$classList2","c","_toConsumableArray","_this11","rethrow","_detachContentAfterRenderRef","_detachContent","e","globalThis","MutationObserver","_detachContentMutationObserver","observe","childList","children","_this$_detachContentA","_this$_detachContentM","disconnect","_scrollStrategy$detac","boundingBoxClass","cssUnitPattern","createFlexibleConnectedPositionStrategy","FlexibleConnectedPositionStrategy","connectedTo","_overlayContainer","_positionChanges","setOrigin","_preferredPositions","_this12","_validatePositions","hostElement","_boundingBox","_isDisposed","_isInitialRender","_lastPosition","_resizeSubscription","change","_positionLocked","reapplyLastPosition","_clearPanelClasses","_resetOverlayElementStyles","_resetBoundingBoxStyles","_viewportRect","_getNarrowedViewportRect","_originRect","_getOriginRect","_overlayRect","_containerRect","getContainerElement","fallback","_step","originRect","viewportRect","containerRect","flexibleFits","_iterator","_createForOfIteratorHelper","s","n","done","pos","originPoint","_getOriginPoint","overlayPoint","_getOverlayPoint","overlayFit","_getOverlayFit","isCompletelyWithinViewport","_isPushed","_applyPosition","_canFitWithFlexibleDimensions","position","boundingBoxRect","_calculateBoundingBoxRect","visibleArea","err","f","_step2","bestFit","bestScore","_iterator2","fit","score","weight","_canPush","_previousPushAmount","extendStyles","alignItems","justifyContent","lastPosition","scrollables","_scrollables","positions","margin","_viewportMargin","_hasFlexibleDimensions","_growAfterOpen","_origin","offset","_offsetX","_offsetY","selector","_transformOriginSelector","x","y","startX","_isRtl","endX","overlayStartX","point","rawOverlayRect","getRoundedBoundingClientRect","_getOffset","topOverflow","bottomOverflow","visibleWidth","_subtractOverflows","visibleHeight","fitsInViewportVertically","fitsInViewportHorizontally","availableHeight","availableWidth","getPixelValue","getConfig","start","pushX","pushY","overflowRight","max","overflowBottom","overflowTop","overflowLeft","_setTransformOrigin","_setOverlayElementStyles","_setBoundingBoxStyles","_addPanelClasses","scrollVisibility","_getScrollVisibility","_lastScrollVisibility","compareScrollVisibility","a","b","isOriginClipped","isOriginOutsideView","isOverlayClipped","isOverlayOutsideView","changeEvent","xOrigin","elements","yOrigin","transformOrigin","isRtl","smallestDistanceToViewportEdge","min","previousHeight","_lastBoundingBoxSize","previousWidth","_hasExactPosition","transform","hasExactPosition","hasFlexibleDimensions","_getExactOverlayY","_getExactOverlayX","transformString","trim","_pushOverlayOnScreen","clientHeight","clientWidth","originBounds","overlayBounds","scrollContainerBounds","map","_len3","overflows","_key3","reduce","currentValue","currentOverflow","axis","_this13","cssClass","_appliedPanelClasses","_this14","ElementRef","Element","destination","source","input","_input$split","split","_input$split2","_slicedToArray","units","parseFloat","clientRect","floor","STANDARD_DROPDOWN_BELOW_POSITIONS","STANDARD_DROPDOWN_ADJACENT_POSITIONS","wrapperClass","createGlobalPositionStrategy","GlobalPositionStrategy","_width","updateSize","_height","_bottomOffset","_topOffset","_alignItems","_xOffset","_xPosition","parentStyles","shouldBeFlushHorizontally","shouldBeFlushVertically","xPosition","xOffset","marginLeft","marginRight","_cssPosition","marginTop","marginBottom","OverlayPositionBuilder","_OverlayPositionBuilder","createOverlayRef","_config$disableAnimat","overlayContainer","doc","idGenerator","appRef","ApplicationRef","directionality","Directionality","pane","id","getId","portalOutlet","DomPortalOutlet","overlayConfig","Renderer2","optional","Location","disableAnimations","ANIMATION_MODULE_TYPE","EnvironmentInjector","Overlay","_Overlay","_positionBuilder","defaultPositionList","CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY","InjectionToken","CdkOverlayOrigin","_CdkOverlayOrigin","exportAs","CdkConnectedOverlay","_CdkConnectedOverlay","EventEmitter","templateRef","TemplateRef","viewContainerRef","ViewContainerRef","_templatePortal","TemplatePortal","_scrollStrategyFactory","set","_position","_updatePositionStrategy","_disposeOnNavigation","_dir","_this$_overlayRef","_attachSubscription","_detachSubscription","_backdropSubscription","_positionSubscription","changes","_this$_overlayRef2","open","attachOverlay","detachOverlay","_this15","_buildConfig","attachments","emit","detachments","keydownEvents","overlayKeydown","keyCode","disableClose","preventDefault","_getOriginElement","overlayOutsideClick","_createPositionStrategy","_this16","currentPosition","_getOrigin","withPositions","withFlexibleDimensions","flexibleDimensions","withPush","withGrowAfterOpen","growAfterOpen","withViewportMargin","viewportMargin","withLockedPosition","lockPosition","withTransformOriginOn","transformOriginSelector","elementRef","_this17","_createOverlay","backdropClick","positionChange","positionChanges","takeWhile","predicate","inclusive","operate","subscriber","createOperatorSubscriber","result","_this$_overlayRef3","inputs","booleanAttribute","outputs","features","CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER","provide","useFactory","CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY","OverlayModule","_OverlayModule","providers","imports","BidiModule","PortalModule","ScrollingModule","shadowDomIsSupported","_supportsShadowDom","head","createShadowRoot","attachShadow","_getShadowRoot","rootNode","getRootNode","_getFocusedElementPierceShadowDom","activeElement","shadowRoot","newActiveElement","composedPath","appsWithLoaders","WeakMap","_CdkPrivateStyleLoader2","loader","_appRef","data","loaders","Set","refs","_appsWithLoaders$get","ref","delete","has","createComponent","environmentInjector","_environmentInjector","__karma__","jasmine","jest","Mocha"],"ignoreList":[],"sourceRoot":"webpack:///","sources":["./node_modules/@angular/cdk/fesm2022/array.mjs","./node_modules/@angular/cdk/fesm2022/css-pixel-value.mjs","./node_modules/@angular/cdk/fesm2022/id-generator.mjs","./node_modules/@angular/cdk/fesm2022/keycodes.mjs","./node_modules/@angular/cdk/fesm2022/keycodes2.mjs","./node_modules/@angular/cdk/fesm2022/overlay-module.mjs","./node_modules/rxjs/dist/esm/internal/operators/takeWhile.js","./node_modules/@angular/cdk/fesm2022/shadow-dom.mjs","./node_modules/@angular/cdk/fesm2022/style-loader.mjs","./node_modules/@angular/cdk/fesm2022/test-environment.mjs"],"sourcesContent":["function coerceArray(value) {\n    return Array.isArray(value) ? value : [value];\n}\n\nexport { coerceArray };\n","/** Coerces a value to a CSS pixel value. */\nfunction coerceCssPixelValue(value) {\n    if (value == null) {\n        return '';\n    }\n    return typeof value === 'string' ? value : `${value}px`;\n}\n\nexport { coerceCssPixelValue };\n","import * as i0 from '@angular/core';\nimport { inject, APP_ID, Injectable } from '@angular/core';\n\n/**\n * Keeps track of the ID count per prefix. This helps us make the IDs a bit more deterministic\n * like they were before the service was introduced. Note that ideally we wouldn't have to do\n * this, but there are some internal tests that rely on the IDs.\n */\nconst counters = {};\n/** Service that generates unique IDs for DOM nodes. */\nclass _IdGenerator {\n    _appId = inject(APP_ID);\n    /**\n     * Generates a unique ID with a specific prefix.\n     * @param prefix Prefix to add to the ID.\n     */\n    getId(prefix) {\n        // Omit the app ID if it's the default `ng`. Since the vast majority of pages have one\n        // Angular app on them, we can reduce the amount of breakages by not adding it.\n        if (this._appId !== 'ng') {\n            prefix += this._appId;\n        }\n        if (!counters.hasOwnProperty(prefix)) {\n            counters[prefix] = 0;\n        }\n        return `${prefix}${counters[prefix]++}`;\n    }\n    static fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: _IdGenerator, deps: [], target: i0.FactoryTarget.Injectable });\n    static prov = i0.ngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: _IdGenerator, providedIn: 'root' });\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: _IdGenerator, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }] });\n\nexport { _IdGenerator };\n","export { A, ALT, APOSTROPHE, AT_SIGN, B, BACKSLASH, BACKSPACE, C, CAPS_LOCK, CLOSE_SQUARE_BRACKET, COMMA, CONTEXT_MENU, CONTROL, D, DASH, DELETE, DOWN_ARROW, E, EIGHT, END, ENTER, EQUALS, ESCAPE, F, F1, F10, F11, F12, F2, F3, F4, F5, F6, F7, F8, F9, FF_EQUALS, FF_MINUS, FF_MUTE, FF_SEMICOLON, FF_VOLUME_DOWN, FF_VOLUME_UP, FIRST_MEDIA, FIVE, FOUR, G, H, HOME, I, INSERT, J, K, L, LAST_MEDIA, LEFT_ARROW, M, MAC_ENTER, MAC_META, MAC_WK_CMD_LEFT, MAC_WK_CMD_RIGHT, META, MUTE, N, NINE, NUMPAD_DIVIDE, NUMPAD_EIGHT, NUMPAD_FIVE, NUMPAD_FOUR, NUMPAD_MINUS, NUMPAD_MULTIPLY, NUMPAD_NINE, NUMPAD_ONE, NUMPAD_PERIOD, NUMPAD_PLUS, NUMPAD_SEVEN, NUMPAD_SIX, NUMPAD_THREE, NUMPAD_TWO, NUMPAD_ZERO, NUM_CENTER, NUM_LOCK, O, ONE, OPEN_SQUARE_BRACKET, P, PAGE_DOWN, PAGE_UP, PAUSE, PERIOD, PLUS_SIGN, PRINT_SCREEN, Q, QUESTION_MARK, R, RIGHT_ARROW, S, SCROLL_LOCK, SEMICOLON, SEVEN, SHIFT, SINGLE_QUOTE, SIX, SLASH, SPACE, T, TAB, THREE, TILDE, TWO, U, UP_ARROW, V, VOLUME_DOWN, VOLUME_UP, W, X, Y, Z, ZERO } from './keycodes2.mjs';\n\n/**\n * Checks whether a modifier key is pressed.\n * @param event Event to be checked.\n */\nfunction hasModifierKey(event, ...modifiers) {\n    if (modifiers.length) {\n        return modifiers.some(modifier => event[modifier]);\n    }\n    return event.altKey || event.shiftKey || event.ctrlKey || event.metaKey;\n}\n\nexport { hasModifierKey };\n","const MAC_ENTER = 3;\nconst BACKSPACE = 8;\nconst TAB = 9;\nconst NUM_CENTER = 12;\nconst ENTER = 13;\nconst SHIFT = 16;\nconst CONTROL = 17;\nconst ALT = 18;\nconst PAUSE = 19;\nconst CAPS_LOCK = 20;\nconst ESCAPE = 27;\nconst SPACE = 32;\nconst PAGE_UP = 33;\nconst PAGE_DOWN = 34;\nconst END = 35;\nconst HOME = 36;\nconst LEFT_ARROW = 37;\nconst UP_ARROW = 38;\nconst RIGHT_ARROW = 39;\nconst DOWN_ARROW = 40;\nconst PLUS_SIGN = 43;\nconst PRINT_SCREEN = 44;\nconst INSERT = 45;\nconst DELETE = 46;\nconst ZERO = 48;\nconst ONE = 49;\nconst TWO = 50;\nconst THREE = 51;\nconst FOUR = 52;\nconst FIVE = 53;\nconst SIX = 54;\nconst SEVEN = 55;\nconst EIGHT = 56;\nconst NINE = 57;\nconst FF_SEMICOLON = 59; // Firefox (Gecko) fires this for semicolon instead of 186\nconst FF_EQUALS = 61; // Firefox (Gecko) fires this for equals instead of 187\nconst QUESTION_MARK = 63;\nconst AT_SIGN = 64;\nconst A = 65;\nconst B = 66;\nconst C = 67;\nconst D = 68;\nconst E = 69;\nconst F = 70;\nconst G = 71;\nconst H = 72;\nconst I = 73;\nconst J = 74;\nconst K = 75;\nconst L = 76;\nconst M = 77;\nconst N = 78;\nconst O = 79;\nconst P = 80;\nconst Q = 81;\nconst R = 82;\nconst S = 83;\nconst T = 84;\nconst U = 85;\nconst V = 86;\nconst W = 87;\nconst X = 88;\nconst Y = 89;\nconst Z = 90;\nconst META = 91; // WIN_KEY_LEFT\nconst MAC_WK_CMD_LEFT = 91;\nconst MAC_WK_CMD_RIGHT = 93;\nconst CONTEXT_MENU = 93;\nconst NUMPAD_ZERO = 96;\nconst NUMPAD_ONE = 97;\nconst NUMPAD_TWO = 98;\nconst NUMPAD_THREE = 99;\nconst NUMPAD_FOUR = 100;\nconst NUMPAD_FIVE = 101;\nconst NUMPAD_SIX = 102;\nconst NUMPAD_SEVEN = 103;\nconst NUMPAD_EIGHT = 104;\nconst NUMPAD_NINE = 105;\nconst NUMPAD_MULTIPLY = 106;\nconst NUMPAD_PLUS = 107;\nconst NUMPAD_MINUS = 109;\nconst NUMPAD_PERIOD = 110;\nconst NUMPAD_DIVIDE = 111;\nconst F1 = 112;\nconst F2 = 113;\nconst F3 = 114;\nconst F4 = 115;\nconst F5 = 116;\nconst F6 = 117;\nconst F7 = 118;\nconst F8 = 119;\nconst F9 = 120;\nconst F10 = 121;\nconst F11 = 122;\nconst F12 = 123;\nconst NUM_LOCK = 144;\nconst SCROLL_LOCK = 145;\nconst FIRST_MEDIA = 166;\nconst FF_MINUS = 173;\nconst MUTE = 173; // Firefox (Gecko) fires 181 for MUTE\nconst VOLUME_DOWN = 174; // Firefox (Gecko) fires 182 for VOLUME_DOWN\nconst VOLUME_UP = 175; // Firefox (Gecko) fires 183 for VOLUME_UP\nconst FF_MUTE = 181;\nconst FF_VOLUME_DOWN = 182;\nconst LAST_MEDIA = 183;\nconst FF_VOLUME_UP = 183;\nconst SEMICOLON = 186; // Firefox (Gecko) fires 59 for SEMICOLON\nconst EQUALS = 187; // Firefox (Gecko) fires 61 for EQUALS\nconst COMMA = 188;\nconst DASH = 189; // Firefox (Gecko) fires 173 for DASH/MINUS\nconst PERIOD = 190;\nconst SLASH = 191;\nconst APOSTROPHE = 192;\nconst TILDE = 192;\nconst OPEN_SQUARE_BRACKET = 219;\nconst BACKSLASH = 220;\nconst CLOSE_SQUARE_BRACKET = 221;\nconst SINGLE_QUOTE = 222;\nconst MAC_META = 224;\n\nexport { A, ALT, APOSTROPHE, AT_SIGN, B, BACKSLASH, BACKSPACE, C, CAPS_LOCK, CLOSE_SQUARE_BRACKET, COMMA, CONTEXT_MENU, CONTROL, D, DASH, DELETE, DOWN_ARROW, E, EIGHT, END, ENTER, EQUALS, ESCAPE, F, F1, F10, F11, F12, F2, F3, F4, F5, F6, F7, F8, F9, FF_EQUALS, FF_MINUS, FF_MUTE, FF_SEMICOLON, FF_VOLUME_DOWN, FF_VOLUME_UP, FIRST_MEDIA, FIVE, FOUR, G, H, HOME, I, INSERT, J, K, L, LAST_MEDIA, LEFT_ARROW, M, MAC_ENTER, MAC_META, MAC_WK_CMD_LEFT, MAC_WK_CMD_RIGHT, META, MUTE, N, NINE, NUMPAD_DIVIDE, NUMPAD_EIGHT, NUMPAD_FIVE, NUMPAD_FOUR, NUMPAD_MINUS, NUMPAD_MULTIPLY, NUMPAD_NINE, NUMPAD_ONE, NUMPAD_PERIOD, NUMPAD_PLUS, NUMPAD_SEVEN, NUMPAD_SIX, NUMPAD_THREE, NUMPAD_TWO, NUMPAD_ZERO, NUM_CENTER, NUM_LOCK, O, ONE, OPEN_SQUARE_BRACKET, P, PAGE_DOWN, PAGE_UP, PAUSE, PERIOD, PLUS_SIGN, PRINT_SCREEN, Q, QUESTION_MARK, R, RIGHT_ARROW, S, SCROLL_LOCK, SEMICOLON, SEVEN, SHIFT, SINGLE_QUOTE, SIX, SLASH, SPACE, T, TAB, THREE, TILDE, TWO, U, UP_ARROW, V, VOLUME_DOWN, VOLUME_UP, W, X, Y, Z, ZERO };\n","import * as i0 from '@angular/core';\nimport { DOCUMENT, NgZone, inject, Injector, Injectable, RendererFactory2, Component, ChangeDetectionStrategy, ViewEncapsulation, afterNextRender, ElementRef, ApplicationRef, Renderer2, ANIMATION_MODULE_TYPE, EnvironmentInjector, InjectionToken, Directive, EventEmitter, TemplateRef, ViewContainerRef, booleanAttribute, Input, Output, NgModule } from '@angular/core';\nimport { Location } from '@angular/common';\nimport { Platform } from './platform2.mjs';\nimport { _getEventTarget } from './shadow-dom.mjs';\nimport { _isTestEnvironment } from './test-environment.mjs';\nimport { _CdkPrivateStyleLoader } from './style-loader.mjs';\nimport { Subject, Subscription } from 'rxjs';\nimport { coerceCssPixelValue } from './css-pixel-value.mjs';\nimport { coerceArray } from './array.mjs';\nimport { ViewportRuler, ScrollDispatcher, ScrollingModule } from './scrolling.mjs';\nimport { DomPortalOutlet, TemplatePortal, PortalModule } from './portal.mjs';\nimport { supportsScrollBehavior } from './scrolling2.mjs';\nimport { filter, takeWhile } from 'rxjs/operators';\nimport { _IdGenerator } from './id-generator.mjs';\nimport { Directionality } from './directionality.mjs';\nimport { ESCAPE } from './keycodes2.mjs';\nimport { hasModifierKey } from './keycodes.mjs';\nimport { BidiModule } from './bidi.mjs';\n\nconst scrollBehaviorSupported = supportsScrollBehavior();\n/**\n * Creates a scroll strategy that prevents the user from scrolling while the overlay is open.\n * @param injector Injector used to resolve dependencies of the scroll strategy.\n * @param config Configuration options for the scroll strategy.\n */\nfunction createBlockScrollStrategy(injector) {\n    return new BlockScrollStrategy(injector.get(ViewportRuler), injector.get(DOCUMENT));\n}\n/**\n * Strategy that will prevent the user from scrolling while the overlay is visible.\n */\nclass BlockScrollStrategy {\n    _viewportRuler;\n    _previousHTMLStyles = { top: '', left: '' };\n    _previousScrollPosition;\n    _isEnabled = false;\n    _document;\n    constructor(_viewportRuler, document) {\n        this._viewportRuler = _viewportRuler;\n        this._document = document;\n    }\n    /** Attaches this scroll strategy to an overlay. */\n    attach() { }\n    /** Blocks page-level scroll while the attached overlay is open. */\n    enable() {\n        if (this._canBeEnabled()) {\n            const root = this._document.documentElement;\n            this._previousScrollPosition = this._viewportRuler.getViewportScrollPosition();\n            // Cache the previous inline styles in case the user had set them.\n            this._previousHTMLStyles.left = root.style.left || '';\n            this._previousHTMLStyles.top = root.style.top || '';\n            // Note: we're using the `html` node, instead of the `body`, because the `body` may\n            // have the user agent margin, whereas the `html` is guaranteed not to have one.\n            root.style.left = coerceCssPixelValue(-this._previousScrollPosition.left);\n            root.style.top = coerceCssPixelValue(-this._previousScrollPosition.top);\n            root.classList.add('cdk-global-scrollblock');\n            this._isEnabled = true;\n        }\n    }\n    /** Unblocks page-level scroll while the attached overlay is open. */\n    disable() {\n        if (this._isEnabled) {\n            const html = this._document.documentElement;\n            const body = this._document.body;\n            const htmlStyle = html.style;\n            const bodyStyle = body.style;\n            const previousHtmlScrollBehavior = htmlStyle.scrollBehavior || '';\n            const previousBodyScrollBehavior = bodyStyle.scrollBehavior || '';\n            this._isEnabled = false;\n            htmlStyle.left = this._previousHTMLStyles.left;\n            htmlStyle.top = this._previousHTMLStyles.top;\n            html.classList.remove('cdk-global-scrollblock');\n            // Disable user-defined smooth scrolling temporarily while we restore the scroll position.\n            // See https://developer.mozilla.org/en-US/docs/Web/CSS/scroll-behavior\n            // Note that we don't mutate the property if the browser doesn't support `scroll-behavior`,\n            // because it can throw off feature detections in `supportsScrollBehavior` which\n            // checks for `'scrollBehavior' in documentElement.style`.\n            if (scrollBehaviorSupported) {\n                htmlStyle.scrollBehavior = bodyStyle.scrollBehavior = 'auto';\n            }\n            window.scroll(this._previousScrollPosition.left, this._previousScrollPosition.top);\n            if (scrollBehaviorSupported) {\n                htmlStyle.scrollBehavior = previousHtmlScrollBehavior;\n                bodyStyle.scrollBehavior = previousBodyScrollBehavior;\n            }\n        }\n    }\n    _canBeEnabled() {\n        // Since the scroll strategies can't be singletons, we have to use a global CSS class\n        // (`cdk-global-scrollblock`) to make sure that we don't try to disable global\n        // scrolling multiple times.\n        const html = this._document.documentElement;\n        if (html.classList.contains('cdk-global-scrollblock') || this._isEnabled) {\n            return false;\n        }\n        const rootElement = this._document.documentElement;\n        const viewport = this._viewportRuler.getViewportSize();\n        return rootElement.scrollHeight > viewport.height || rootElement.scrollWidth > viewport.width;\n    }\n}\n\n/**\n * Returns an error to be thrown when attempting to attach an already-attached scroll strategy.\n */\nfunction getMatScrollStrategyAlreadyAttachedError() {\n    return Error(`Scroll strategy has already been attached.`);\n}\n\n/**\n * Creates a scroll strategy that closes the overlay when the user starts to scroll.\n * @param injector Injector used to resolve dependencies of the scroll strategy.\n * @param config Configuration options for the scroll strategy.\n */\nfunction createCloseScrollStrategy(injector, config) {\n    return new CloseScrollStrategy(injector.get(ScrollDispatcher), injector.get(NgZone), injector.get(ViewportRuler), config);\n}\n/**\n * Strategy that will close the overlay as soon as the user starts scrolling.\n */\nclass CloseScrollStrategy {\n    _scrollDispatcher;\n    _ngZone;\n    _viewportRuler;\n    _config;\n    _scrollSubscription = null;\n    _overlayRef;\n    _initialScrollPosition;\n    constructor(_scrollDispatcher, _ngZone, _viewportRuler, _config) {\n        this._scrollDispatcher = _scrollDispatcher;\n        this._ngZone = _ngZone;\n        this._viewportRuler = _viewportRuler;\n        this._config = _config;\n    }\n    /** Attaches this scroll strategy to an overlay. */\n    attach(overlayRef) {\n        if (this._overlayRef && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            throw getMatScrollStrategyAlreadyAttachedError();\n        }\n        this._overlayRef = overlayRef;\n    }\n    /** Enables the closing of the attached overlay on scroll. */\n    enable() {\n        if (this._scrollSubscription) {\n            return;\n        }\n        const stream = this._scrollDispatcher.scrolled(0).pipe(filter(scrollable => {\n            return (!scrollable ||\n                !this._overlayRef.overlayElement.contains(scrollable.getElementRef().nativeElement));\n        }));\n        if (this._config && this._config.threshold && this._config.threshold > 1) {\n            this._initialScrollPosition = this._viewportRuler.getViewportScrollPosition().top;\n            this._scrollSubscription = stream.subscribe(() => {\n                const scrollPosition = this._viewportRuler.getViewportScrollPosition().top;\n                if (Math.abs(scrollPosition - this._initialScrollPosition) > this._config.threshold) {\n                    this._detach();\n                }\n                else {\n                    this._overlayRef.updatePosition();\n                }\n            });\n        }\n        else {\n            this._scrollSubscription = stream.subscribe(this._detach);\n        }\n    }\n    /** Disables the closing the attached overlay on scroll. */\n    disable() {\n        if (this._scrollSubscription) {\n            this._scrollSubscription.unsubscribe();\n            this._scrollSubscription = null;\n        }\n    }\n    detach() {\n        this.disable();\n        this._overlayRef = null;\n    }\n    /** Detaches the overlay ref and disables the scroll strategy. */\n    _detach = () => {\n        this.disable();\n        if (this._overlayRef.hasAttached()) {\n            this._ngZone.run(() => this._overlayRef.detach());\n        }\n    };\n}\n\n/** Creates a scroll strategy that does nothing. */\nfunction createNoopScrollStrategy() {\n    return new NoopScrollStrategy();\n}\n/** Scroll strategy that doesn't do anything. */\nclass NoopScrollStrategy {\n    /** Does nothing, as this scroll strategy is a no-op. */\n    enable() { }\n    /** Does nothing, as this scroll strategy is a no-op. */\n    disable() { }\n    /** Does nothing, as this scroll strategy is a no-op. */\n    attach() { }\n}\n\n/**\n * Gets whether an element is scrolled outside of view by any of its parent scrolling containers.\n * @param element Dimensions of the element (from getBoundingClientRect)\n * @param scrollContainers Dimensions of element's scrolling containers (from getBoundingClientRect)\n * @returns Whether the element is scrolled out of view\n * @docs-private\n */\nfunction isElementScrolledOutsideView(element, scrollContainers) {\n    return scrollContainers.some(containerBounds => {\n        const outsideAbove = element.bottom < containerBounds.top;\n        const outsideBelow = element.top > containerBounds.bottom;\n        const outsideLeft = element.right < containerBounds.left;\n        const outsideRight = element.left > containerBounds.right;\n        return outsideAbove || outsideBelow || outsideLeft || outsideRight;\n    });\n}\n/**\n * Gets whether an element is clipped by any of its scrolling containers.\n * @param element Dimensions of the element (from getBoundingClientRect)\n * @param scrollContainers Dimensions of element's scrolling containers (from getBoundingClientRect)\n * @returns Whether the element is clipped\n * @docs-private\n */\nfunction isElementClippedByScrolling(element, scrollContainers) {\n    return scrollContainers.some(scrollContainerRect => {\n        const clippedAbove = element.top < scrollContainerRect.top;\n        const clippedBelow = element.bottom > scrollContainerRect.bottom;\n        const clippedLeft = element.left < scrollContainerRect.left;\n        const clippedRight = element.right > scrollContainerRect.right;\n        return clippedAbove || clippedBelow || clippedLeft || clippedRight;\n    });\n}\n\n/**\n * Creates a scroll strategy that updates the overlay's position when the user scrolls.\n * @param injector Injector used to resolve dependencies of the scroll strategy.\n * @param config Configuration options for the scroll strategy.\n */\nfunction createRepositionScrollStrategy(injector, config) {\n    return new RepositionScrollStrategy(injector.get(ScrollDispatcher), injector.get(ViewportRuler), injector.get(NgZone), config);\n}\n/**\n * Strategy that will update the element position as the user is scrolling.\n */\nclass RepositionScrollStrategy {\n    _scrollDispatcher;\n    _viewportRuler;\n    _ngZone;\n    _config;\n    _scrollSubscription = null;\n    _overlayRef;\n    constructor(_scrollDispatcher, _viewportRuler, _ngZone, _config) {\n        this._scrollDispatcher = _scrollDispatcher;\n        this._viewportRuler = _viewportRuler;\n        this._ngZone = _ngZone;\n        this._config = _config;\n    }\n    /** Attaches this scroll strategy to an overlay. */\n    attach(overlayRef) {\n        if (this._overlayRef && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            throw getMatScrollStrategyAlreadyAttachedError();\n        }\n        this._overlayRef = overlayRef;\n    }\n    /** Enables repositioning of the attached overlay on scroll. */\n    enable() {\n        if (!this._scrollSubscription) {\n            const throttle = this._config ? this._config.scrollThrottle : 0;\n            this._scrollSubscription = this._scrollDispatcher.scrolled(throttle).subscribe(() => {\n                this._overlayRef.updatePosition();\n                // TODO(crisbeto): make `close` on by default once all components can handle it.\n                if (this._config && this._config.autoClose) {\n                    const overlayRect = this._overlayRef.overlayElement.getBoundingClientRect();\n                    const { width, height } = this._viewportRuler.getViewportSize();\n                    // TODO(crisbeto): include all ancestor scroll containers here once\n                    // we have a way of exposing the trigger element to the scroll strategy.\n                    const parentRects = [{ width, height, bottom: height, right: width, top: 0, left: 0 }];\n                    if (isElementScrolledOutsideView(overlayRect, parentRects)) {\n                        this.disable();\n                        this._ngZone.run(() => this._overlayRef.detach());\n                    }\n                }\n            });\n        }\n    }\n    /** Disables repositioning of the attached overlay on scroll. */\n    disable() {\n        if (this._scrollSubscription) {\n            this._scrollSubscription.unsubscribe();\n            this._scrollSubscription = null;\n        }\n    }\n    detach() {\n        this.disable();\n        this._overlayRef = null;\n    }\n}\n\n/**\n * Options for how an overlay will handle scrolling.\n *\n * Users can provide a custom value for `ScrollStrategyOptions` to replace the default\n * behaviors. This class primarily acts as a factory for ScrollStrategy instances.\n */\nclass ScrollStrategyOptions {\n    _injector = inject(Injector);\n    constructor() { }\n    /** Do nothing on scroll. */\n    noop = () => new NoopScrollStrategy();\n    /**\n     * Close the overlay as soon as the user scrolls.\n     * @param config Configuration to be used inside the scroll strategy.\n     */\n    close = (config) => createCloseScrollStrategy(this._injector, config);\n    /** Block scrolling. */\n    block = () => createBlockScrollStrategy(this._injector);\n    /**\n     * Update the overlay's position on scroll.\n     * @param config Configuration to be used inside the scroll strategy.\n     * Allows debouncing the reposition calls.\n     */\n    reposition = (config) => createRepositionScrollStrategy(this._injector, config);\n    static fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: ScrollStrategyOptions, deps: [], target: i0.FactoryTarget.Injectable });\n    static prov = i0.ngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: ScrollStrategyOptions, providedIn: 'root' });\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: ScrollStrategyOptions, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [] });\n\n/** Initial configuration used when creating an overlay. */\nclass OverlayConfig {\n    /** Strategy with which to position the overlay. */\n    positionStrategy;\n    /** Strategy to be used when handling scroll events while the overlay is open. */\n    scrollStrategy = new NoopScrollStrategy();\n    /** Custom class to add to the overlay pane. */\n    panelClass = '';\n    /** Whether the overlay has a backdrop. */\n    hasBackdrop = false;\n    /** Custom class to add to the backdrop */\n    backdropClass = 'cdk-overlay-dark-backdrop';\n    /** Whether to disable any built-in animations. */\n    disableAnimations;\n    /** The width of the overlay panel. If a number is provided, pixel units are assumed. */\n    width;\n    /** The height of the overlay panel. If a number is provided, pixel units are assumed. */\n    height;\n    /** The min-width of the overlay panel. If a number is provided, pixel units are assumed. */\n    minWidth;\n    /** The min-height of the overlay panel. If a number is provided, pixel units are assumed. */\n    minHeight;\n    /** The max-width of the overlay panel. If a number is provided, pixel units are assumed. */\n    maxWidth;\n    /** The max-height of the overlay panel. If a number is provided, pixel units are assumed. */\n    maxHeight;\n    /**\n     * Direction of the text in the overlay panel. If a `Directionality` instance\n     * is passed in, the overlay will handle changes to its value automatically.\n     */\n    direction;\n    /**\n     * Whether the overlay should be disposed of when the user goes backwards/forwards in history.\n     * Note that this usually doesn't include clicking on links (unless the user is using\n     * the `HashLocationStrategy`).\n     */\n    disposeOnNavigation = false;\n    constructor(config) {\n        if (config) {\n            // Use `Iterable` instead of `Array` because TypeScript, as of 3.6.3,\n            // loses the array generic type in the `for of`. But we *also* have to use `Array` because\n            // typescript won't iterate over an `Iterable` unless you compile with `--downlevelIteration`\n            const configKeys = Object.keys(config);\n            for (const key of configKeys) {\n                if (config[key] !== undefined) {\n                    // TypeScript, as of version 3.5, sees the left-hand-side of this expression\n                    // as \"I don't know *which* key this is, so the only valid value is the intersection\n                    // of all the possible values.\" In this case, that happens to be `undefined`. TypeScript\n                    // is not smart enough to see that the right-hand-side is actually an access of the same\n                    // exact type with the same exact key, meaning that the value type must be identical.\n                    // So we use `any` to work around this.\n                    this[key] = config[key];\n                }\n            }\n        }\n    }\n}\n\n/** The points of the origin element and the overlay element to connect. */\nclass ConnectionPositionPair {\n    offsetX;\n    offsetY;\n    panelClass;\n    /** X-axis attachment point for connected overlay origin. Can be 'start', 'end', or 'center'. */\n    originX;\n    /** Y-axis attachment point for connected overlay origin. Can be 'top', 'bottom', or 'center'. */\n    originY;\n    /** X-axis attachment point for connected overlay. Can be 'start', 'end', or 'center'. */\n    overlayX;\n    /** Y-axis attachment point for connected overlay. Can be 'top', 'bottom', or 'center'. */\n    overlayY;\n    constructor(origin, overlay, \n    /** Offset along the X axis. */\n    offsetX, \n    /** Offset along the Y axis. */\n    offsetY, \n    /** Class(es) to be applied to the panel while this position is active. */\n    panelClass) {\n        this.offsetX = offsetX;\n        this.offsetY = offsetY;\n        this.panelClass = panelClass;\n        this.originX = origin.originX;\n        this.originY = origin.originY;\n        this.overlayX = overlay.overlayX;\n        this.overlayY = overlay.overlayY;\n    }\n}\n/**\n * Set of properties regarding the position of the origin and overlay relative to the viewport\n * with respect to the containing Scrollable elements.\n *\n * The overlay and origin are clipped if any part of their bounding client rectangle exceeds the\n * bounds of any one of the strategy's Scrollable's bounding client rectangle.\n *\n * The overlay and origin are outside view if there is no overlap between their bounding client\n * rectangle and any one of the strategy's Scrollable's bounding client rectangle.\n *\n *       -----------                    -----------\n *       | outside |                    | clipped |\n *       |  view   |              --------------------------\n *       |         |              |     |         |        |\n *       ----------               |     -----------        |\n *  --------------------------    |                        |\n *  |                        |    |      Scrollable        |\n *  |                        |    |                        |\n *  |                        |     --------------------------\n *  |      Scrollable        |\n *  |                        |\n *  --------------------------\n *\n *  @docs-private\n */\nclass ScrollingVisibility {\n    isOriginClipped;\n    isOriginOutsideView;\n    isOverlayClipped;\n    isOverlayOutsideView;\n}\n/** The change event emitted by the strategy when a fallback position is used. */\nclass ConnectedOverlayPositionChange {\n    connectionPair;\n    scrollableViewProperties;\n    constructor(\n    /** The position used as a result of this change. */\n    connectionPair, \n    /** @docs-private */\n    scrollableViewProperties) {\n        this.connectionPair = connectionPair;\n        this.scrollableViewProperties = scrollableViewProperties;\n    }\n}\n/**\n * Validates whether a vertical position property matches the expected values.\n * @param property Name of the property being validated.\n * @param value Value of the property being validated.\n * @docs-private\n */\nfunction validateVerticalPosition(property, value) {\n    if (value !== 'top' && value !== 'bottom' && value !== 'center') {\n        throw Error(`ConnectedPosition: Invalid ${property} \"${value}\". ` +\n            `Expected \"top\", \"bottom\" or \"center\".`);\n    }\n}\n/**\n * Validates whether a horizontal position property matches the expected values.\n * @param property Name of the property being validated.\n * @param value Value of the property being validated.\n * @docs-private\n */\nfunction validateHorizontalPosition(property, value) {\n    if (value !== 'start' && value !== 'end' && value !== 'center') {\n        throw Error(`ConnectedPosition: Invalid ${property} \"${value}\". ` +\n            `Expected \"start\", \"end\" or \"center\".`);\n    }\n}\n\n/**\n * Service for dispatching events that land on the body to appropriate overlay ref,\n * if any. It maintains a list of attached overlays to determine best suited overlay based\n * on event target and order of overlay opens.\n */\nclass BaseOverlayDispatcher {\n    /** Currently attached overlays in the order they were attached. */\n    _attachedOverlays = [];\n    _document = inject(DOCUMENT);\n    _isAttached;\n    constructor() { }\n    ngOnDestroy() {\n        this.detach();\n    }\n    /** Add a new overlay to the list of attached overlay refs. */\n    add(overlayRef) {\n        // Ensure that we don't get the same overlay multiple times.\n        this.remove(overlayRef);\n        this._attachedOverlays.push(overlayRef);\n    }\n    /** Remove an overlay from the list of attached overlay refs. */\n    remove(overlayRef) {\n        const index = this._attachedOverlays.indexOf(overlayRef);\n        if (index > -1) {\n            this._attachedOverlays.splice(index, 1);\n        }\n        // Remove the global listener once there are no more overlays.\n        if (this._attachedOverlays.length === 0) {\n            this.detach();\n        }\n    }\n    static fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: BaseOverlayDispatcher, deps: [], target: i0.FactoryTarget.Injectable });\n    static prov = i0.ngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: BaseOverlayDispatcher, providedIn: 'root' });\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: BaseOverlayDispatcher, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [] });\n\n/**\n * Service for dispatching keyboard events that land on the body to appropriate overlay ref,\n * if any. It maintains a list of attached overlays to determine best suited overlay based\n * on event target and order of overlay opens.\n */\nclass OverlayKeyboardDispatcher extends BaseOverlayDispatcher {\n    _ngZone = inject(NgZone);\n    _renderer = inject(RendererFactory2).createRenderer(null, null);\n    _cleanupKeydown;\n    /** Add a new overlay to the list of attached overlay refs. */\n    add(overlayRef) {\n        super.add(overlayRef);\n        // Lazily start dispatcher once first overlay is added\n        if (!this._isAttached) {\n            this._ngZone.runOutsideAngular(() => {\n                this._cleanupKeydown = this._renderer.listen('body', 'keydown', this._keydownListener);\n            });\n            this._isAttached = true;\n        }\n    }\n    /** Detaches the global keyboard event listener. */\n    detach() {\n        if (this._isAttached) {\n            this._cleanupKeydown?.();\n            this._isAttached = false;\n        }\n    }\n    /** Keyboard event listener that will be attached to the body. */\n    _keydownListener = (event) => {\n        const overlays = this._attachedOverlays;\n        for (let i = overlays.length - 1; i > -1; i--) {\n            // Dispatch the keydown event to the top overlay which has subscribers to its keydown events.\n            // We want to target the most recent overlay, rather than trying to match where the event came\n            // from, because some components might open an overlay, but keep focus on a trigger element\n            // (e.g. for select and autocomplete). We skip overlays without keydown event subscriptions,\n            // because we don't want overlays that don't handle keyboard events to block the ones below\n            // them that do.\n            if (overlays[i]._keydownEvents.observers.length > 0) {\n                this._ngZone.run(() => overlays[i]._keydownEvents.next(event));\n                break;\n            }\n        }\n    };\n    static fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: OverlayKeyboardDispatcher, deps: null, target: i0.FactoryTarget.Injectable });\n    static prov = i0.ngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: OverlayKeyboardDispatcher, providedIn: 'root' });\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: OverlayKeyboardDispatcher, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }] });\n\n/**\n * Service for dispatching mouse click events that land on the body to appropriate overlay ref,\n * if any. It maintains a list of attached overlays to determine best suited overlay based\n * on event target and order of overlay opens.\n */\nclass OverlayOutsideClickDispatcher extends BaseOverlayDispatcher {\n    _platform = inject(Platform);\n    _ngZone = inject(NgZone);\n    _renderer = inject(RendererFactory2).createRenderer(null, null);\n    _cursorOriginalValue;\n    _cursorStyleIsSet = false;\n    _pointerDownEventTarget;\n    _cleanups;\n    /** Add a new overlay to the list of attached overlay refs. */\n    add(overlayRef) {\n        super.add(overlayRef);\n        // Safari on iOS does not generate click events for non-interactive\n        // elements. However, we want to receive a click for any element outside\n        // the overlay. We can force a \"clickable\" state by setting\n        // `cursor: pointer` on the document body. See:\n        // https://developer.mozilla.org/en-US/docs/Web/API/Element/click_event#Safari_Mobile\n        // https://developer.apple.com/library/archive/documentation/AppleApplications/Reference/SafariWebContent/HandlingEvents/HandlingEvents.html\n        if (!this._isAttached) {\n            const body = this._document.body;\n            const eventOptions = { capture: true };\n            const renderer = this._renderer;\n            this._cleanups = this._ngZone.runOutsideAngular(() => [\n                renderer.listen(body, 'pointerdown', this._pointerDownListener, eventOptions),\n                renderer.listen(body, 'click', this._clickListener, eventOptions),\n                renderer.listen(body, 'auxclick', this._clickListener, eventOptions),\n                renderer.listen(body, 'contextmenu', this._clickListener, eventOptions),\n            ]);\n            // click event is not fired on iOS. To make element \"clickable\" we are\n            // setting the cursor to pointer\n            if (this._platform.IOS && !this._cursorStyleIsSet) {\n                this._cursorOriginalValue = body.style.cursor;\n                body.style.cursor = 'pointer';\n                this._cursorStyleIsSet = true;\n            }\n            this._isAttached = true;\n        }\n    }\n    /** Detaches the global keyboard event listener. */\n    detach() {\n        if (this._isAttached) {\n            this._cleanups?.forEach(cleanup => cleanup());\n            this._cleanups = undefined;\n            if (this._platform.IOS && this._cursorStyleIsSet) {\n                this._document.body.style.cursor = this._cursorOriginalValue;\n                this._cursorStyleIsSet = false;\n            }\n            this._isAttached = false;\n        }\n    }\n    /** Store pointerdown event target to track origin of click. */\n    _pointerDownListener = (event) => {\n        this._pointerDownEventTarget = _getEventTarget(event);\n    };\n    /** Click event listener that will be attached to the body propagate phase. */\n    _clickListener = (event) => {\n        const target = _getEventTarget(event);\n        // In case of a click event, we want to check the origin of the click\n        // (e.g. in case where a user starts a click inside the overlay and\n        // releases the click outside of it).\n        // This is done by using the event target of the preceding pointerdown event.\n        // Every click event caused by a pointer device has a preceding pointerdown\n        // event, unless the click was programmatically triggered (e.g. in a unit test).\n        const origin = event.type === 'click' && this._pointerDownEventTarget\n            ? this._pointerDownEventTarget\n            : target;\n        // Reset the stored pointerdown event target, to avoid having it interfere\n        // in subsequent events.\n        this._pointerDownEventTarget = null;\n        // We copy the array because the original may be modified asynchronously if the\n        // outsidePointerEvents listener decides to detach overlays resulting in index errors inside\n        // the for loop.\n        const overlays = this._attachedOverlays.slice();\n        // Dispatch the mouse event to the top overlay which has subscribers to its mouse events.\n        // We want to target all overlays for which the click could be considered as outside click.\n        // As soon as we reach an overlay for which the click is not outside click we break off\n        // the loop.\n        for (let i = overlays.length - 1; i > -1; i--) {\n            const overlayRef = overlays[i];\n            if (overlayRef._outsidePointerEvents.observers.length < 1 || !overlayRef.hasAttached()) {\n                continue;\n            }\n            // If it's a click inside the overlay, just break - we should do nothing\n            // If it's an outside click (both origin and target of the click) dispatch the mouse event,\n            // and proceed with the next overlay\n            if (containsPierceShadowDom(overlayRef.overlayElement, target) ||\n                containsPierceShadowDom(overlayRef.overlayElement, origin)) {\n                break;\n            }\n            const outsidePointerEvents = overlayRef._outsidePointerEvents;\n            /** @breaking-change 14.0.0 _ngZone will be required. */\n            if (this._ngZone) {\n                this._ngZone.run(() => outsidePointerEvents.next(event));\n            }\n            else {\n                outsidePointerEvents.next(event);\n            }\n        }\n    };\n    static fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: OverlayOutsideClickDispatcher, deps: null, target: i0.FactoryTarget.Injectable });\n    static prov = i0.ngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: OverlayOutsideClickDispatcher, providedIn: 'root' });\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: OverlayOutsideClickDispatcher, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }] });\n/** Version of `Element.contains` that transcends shadow DOM boundaries. */\nfunction containsPierceShadowDom(parent, child) {\n    const supportsShadowRoot = typeof ShadowRoot !== 'undefined' && ShadowRoot;\n    let current = child;\n    while (current) {\n        if (current === parent) {\n            return true;\n        }\n        current =\n            supportsShadowRoot && current instanceof ShadowRoot ? current.host : current.parentNode;\n    }\n    return false;\n}\n\nclass _CdkOverlayStyleLoader {\n    static fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: _CdkOverlayStyleLoader, deps: [], target: i0.FactoryTarget.Component });\n    static cmp = i0.ngDeclareComponent({ minVersion: \"14.0.0\", version: \"20.2.0-next.2\", type: _CdkOverlayStyleLoader, isStandalone: true, selector: \"ng-component\", host: { attributes: { \"cdk-overlay-style-loader\": \"\" } }, ngImport: i0, template: '', isInline: true, styles: [\".cdk-overlay-container,.cdk-global-overlay-wrapper{pointer-events:none;top:0;left:0;height:100%;width:100%}.cdk-overlay-container{position:fixed}@layer cdk-overlay{.cdk-overlay-container{z-index:1000}}.cdk-overlay-container:empty{display:none}.cdk-global-overlay-wrapper{display:flex;position:absolute}@layer cdk-overlay{.cdk-global-overlay-wrapper{z-index:1000}}.cdk-overlay-pane{position:absolute;pointer-events:auto;box-sizing:border-box;display:flex;max-width:100%;max-height:100%}@layer cdk-overlay{.cdk-overlay-pane{z-index:1000}}.cdk-overlay-backdrop{position:absolute;top:0;bottom:0;left:0;right:0;pointer-events:auto;-webkit-tap-highlight-color:rgba(0,0,0,0);opacity:0;touch-action:manipulation}@layer cdk-overlay{.cdk-overlay-backdrop{z-index:1000;transition:opacity 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}}@media(prefers-reduced-motion){.cdk-overlay-backdrop{transition-duration:1ms}}.cdk-overlay-backdrop-showing{opacity:1}@media(forced-colors: active){.cdk-overlay-backdrop-showing{opacity:.6}}@layer cdk-overlay{.cdk-overlay-dark-backdrop{background:rgba(0,0,0,.32)}}.cdk-overlay-transparent-backdrop{transition:visibility 1ms linear,opacity 1ms linear;visibility:hidden;opacity:1}.cdk-overlay-transparent-backdrop.cdk-overlay-backdrop-showing,.cdk-high-contrast-active .cdk-overlay-transparent-backdrop{opacity:0;visibility:visible}.cdk-overlay-backdrop-noop-animation{transition:none}.cdk-overlay-connected-position-bounding-box{position:absolute;display:flex;flex-direction:column;min-width:1px;min-height:1px}@layer cdk-overlay{.cdk-overlay-connected-position-bounding-box{z-index:1000}}.cdk-global-scrollblock{position:fixed;width:100%;overflow-y:scroll}\\n\"], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None });\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: _CdkOverlayStyleLoader, decorators: [{\n            type: Component,\n            args: [{ template: '', changeDetection: ChangeDetectionStrategy.OnPush, encapsulation: ViewEncapsulation.None, host: { 'cdk-overlay-style-loader': '' }, styles: [\".cdk-overlay-container,.cdk-global-overlay-wrapper{pointer-events:none;top:0;left:0;height:100%;width:100%}.cdk-overlay-container{position:fixed}@layer cdk-overlay{.cdk-overlay-container{z-index:1000}}.cdk-overlay-container:empty{display:none}.cdk-global-overlay-wrapper{display:flex;position:absolute}@layer cdk-overlay{.cdk-global-overlay-wrapper{z-index:1000}}.cdk-overlay-pane{position:absolute;pointer-events:auto;box-sizing:border-box;display:flex;max-width:100%;max-height:100%}@layer cdk-overlay{.cdk-overlay-pane{z-index:1000}}.cdk-overlay-backdrop{position:absolute;top:0;bottom:0;left:0;right:0;pointer-events:auto;-webkit-tap-highlight-color:rgba(0,0,0,0);opacity:0;touch-action:manipulation}@layer cdk-overlay{.cdk-overlay-backdrop{z-index:1000;transition:opacity 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}}@media(prefers-reduced-motion){.cdk-overlay-backdrop{transition-duration:1ms}}.cdk-overlay-backdrop-showing{opacity:1}@media(forced-colors: active){.cdk-overlay-backdrop-showing{opacity:.6}}@layer cdk-overlay{.cdk-overlay-dark-backdrop{background:rgba(0,0,0,.32)}}.cdk-overlay-transparent-backdrop{transition:visibility 1ms linear,opacity 1ms linear;visibility:hidden;opacity:1}.cdk-overlay-transparent-backdrop.cdk-overlay-backdrop-showing,.cdk-high-contrast-active .cdk-overlay-transparent-backdrop{opacity:0;visibility:visible}.cdk-overlay-backdrop-noop-animation{transition:none}.cdk-overlay-connected-position-bounding-box{position:absolute;display:flex;flex-direction:column;min-width:1px;min-height:1px}@layer cdk-overlay{.cdk-overlay-connected-position-bounding-box{z-index:1000}}.cdk-global-scrollblock{position:fixed;width:100%;overflow-y:scroll}\\n\"] }]\n        }] });\n/** Container inside which all overlays will render. */\nclass OverlayContainer {\n    _platform = inject(Platform);\n    _containerElement;\n    _document = inject(DOCUMENT);\n    _styleLoader = inject(_CdkPrivateStyleLoader);\n    constructor() { }\n    ngOnDestroy() {\n        this._containerElement?.remove();\n    }\n    /**\n     * This method returns the overlay container element. It will lazily\n     * create the element the first time it is called to facilitate using\n     * the container in non-browser environments.\n     * @returns the container element\n     */\n    getContainerElement() {\n        this._loadStyles();\n        if (!this._containerElement) {\n            this._createContainer();\n        }\n        return this._containerElement;\n    }\n    /**\n     * Create the overlay container element, which is simply a div\n     * with the 'cdk-overlay-container' class on the document body.\n     */\n    _createContainer() {\n        const containerClass = 'cdk-overlay-container';\n        // TODO(crisbeto): remove the testing check once we have an overlay testing\n        // module or Angular starts tearing down the testing `NgModule`. See:\n        // https://github.com/angular/angular/issues/18831\n        if (this._platform.isBrowser || _isTestEnvironment()) {\n            const oppositePlatformContainers = this._document.querySelectorAll(`.${containerClass}[platform=\"server\"], ` + `.${containerClass}[platform=\"test\"]`);\n            // Remove any old containers from the opposite platform.\n            // This can happen when transitioning from the server to the client.\n            for (let i = 0; i < oppositePlatformContainers.length; i++) {\n                oppositePlatformContainers[i].remove();\n            }\n        }\n        const container = this._document.createElement('div');\n        container.classList.add(containerClass);\n        // A long time ago we kept adding new overlay containers whenever a new app was instantiated,\n        // but at some point we added logic which clears the duplicate ones in order to avoid leaks.\n        // The new logic was a little too aggressive since it was breaking some legitimate use cases.\n        // To mitigate the problem we made it so that only containers from a different platform are\n        // cleared, but the side-effect was that people started depending on the overly-aggressive\n        // logic to clean up their tests for them. Until we can introduce an overlay-specific testing\n        // module which does the cleanup, we try to detect that we're in a test environment and we\n        // always clear the container. See #17006.\n        // TODO(crisbeto): remove the test environment check once we have an overlay testing module.\n        if (_isTestEnvironment()) {\n            container.setAttribute('platform', 'test');\n        }\n        else if (!this._platform.isBrowser) {\n            container.setAttribute('platform', 'server');\n        }\n        this._document.body.appendChild(container);\n        this._containerElement = container;\n    }\n    /** Loads the structural styles necessary for the overlay to work. */\n    _loadStyles() {\n        this._styleLoader.load(_CdkOverlayStyleLoader);\n    }\n    static fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: OverlayContainer, deps: [], target: i0.FactoryTarget.Injectable });\n    static prov = i0.ngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: OverlayContainer, providedIn: 'root' });\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: OverlayContainer, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [] });\n\n/** Encapsulates the logic for attaching and detaching a backdrop. */\nclass BackdropRef {\n    _renderer;\n    _ngZone;\n    element;\n    _cleanupClick;\n    _cleanupTransitionEnd;\n    _fallbackTimeout;\n    constructor(document, _renderer, _ngZone, onClick) {\n        this._renderer = _renderer;\n        this._ngZone = _ngZone;\n        this.element = document.createElement('div');\n        this.element.classList.add('cdk-overlay-backdrop');\n        this._cleanupClick = _renderer.listen(this.element, 'click', onClick);\n    }\n    detach() {\n        this._ngZone.runOutsideAngular(() => {\n            const element = this.element;\n            clearTimeout(this._fallbackTimeout);\n            this._cleanupTransitionEnd?.();\n            this._cleanupTransitionEnd = this._renderer.listen(element, 'transitionend', this.dispose);\n            this._fallbackTimeout = setTimeout(this.dispose, 500);\n            // If the backdrop doesn't have a transition, the `transitionend` event won't fire.\n            // In this case we make it unclickable and we try to remove it after a delay.\n            element.style.pointerEvents = 'none';\n            element.classList.remove('cdk-overlay-backdrop-showing');\n        });\n    }\n    dispose = () => {\n        clearTimeout(this._fallbackTimeout);\n        this._cleanupClick?.();\n        this._cleanupTransitionEnd?.();\n        this._cleanupClick = this._cleanupTransitionEnd = this._fallbackTimeout = undefined;\n        this.element.remove();\n    };\n}\n\n/**\n * Reference to an overlay that has been created with the Overlay service.\n * Used to manipulate or dispose of said overlay.\n */\nclass OverlayRef {\n    _portalOutlet;\n    _host;\n    _pane;\n    _config;\n    _ngZone;\n    _keyboardDispatcher;\n    _document;\n    _location;\n    _outsideClickDispatcher;\n    _animationsDisabled;\n    _injector;\n    _renderer;\n    _backdropClick = new Subject();\n    _attachments = new Subject();\n    _detachments = new Subject();\n    _positionStrategy;\n    _scrollStrategy;\n    _locationChanges = Subscription.EMPTY;\n    _backdropRef = null;\n    _detachContentMutationObserver;\n    _detachContentAfterRenderRef;\n    /**\n     * Reference to the parent of the `_host` at the time it was detached. Used to restore\n     * the `_host` to its original position in the DOM when it gets re-attached.\n     */\n    _previousHostParent;\n    /** Stream of keydown events dispatched to this overlay. */\n    _keydownEvents = new Subject();\n    /** Stream of mouse outside events dispatched to this overlay. */\n    _outsidePointerEvents = new Subject();\n    /** Reference to the currently-running `afterNextRender` call. */\n    _afterNextRenderRef;\n    constructor(_portalOutlet, _host, _pane, _config, _ngZone, _keyboardDispatcher, _document, _location, _outsideClickDispatcher, _animationsDisabled = false, _injector, _renderer) {\n        this._portalOutlet = _portalOutlet;\n        this._host = _host;\n        this._pane = _pane;\n        this._config = _config;\n        this._ngZone = _ngZone;\n        this._keyboardDispatcher = _keyboardDispatcher;\n        this._document = _document;\n        this._location = _location;\n        this._outsideClickDispatcher = _outsideClickDispatcher;\n        this._animationsDisabled = _animationsDisabled;\n        this._injector = _injector;\n        this._renderer = _renderer;\n        if (_config.scrollStrategy) {\n            this._scrollStrategy = _config.scrollStrategy;\n            this._scrollStrategy.attach(this);\n        }\n        this._positionStrategy = _config.positionStrategy;\n    }\n    /** The overlay's HTML element */\n    get overlayElement() {\n        return this._pane;\n    }\n    /** The overlay's backdrop HTML element. */\n    get backdropElement() {\n        return this._backdropRef?.element || null;\n    }\n    /**\n     * Wrapper around the panel element. Can be used for advanced\n     * positioning where a wrapper with specific styling is\n     * required around the overlay pane.\n     */\n    get hostElement() {\n        return this._host;\n    }\n    /**\n     * Attaches content, given via a Portal, to the overlay.\n     * If the overlay is configured to have a backdrop, it will be created.\n     *\n     * @param portal Portal instance to which to attach the overlay.\n     * @returns The portal attachment result.\n     */\n    attach(portal) {\n        // Insert the host into the DOM before attaching the portal, otherwise\n        // the animations module will skip animations on repeat attachments.\n        if (!this._host.parentElement && this._previousHostParent) {\n            this._previousHostParent.appendChild(this._host);\n        }\n        const attachResult = this._portalOutlet.attach(portal);\n        if (this._positionStrategy) {\n            this._positionStrategy.attach(this);\n        }\n        this._updateStackingOrder();\n        this._updateElementSize();\n        this._updateElementDirection();\n        if (this._scrollStrategy) {\n            this._scrollStrategy.enable();\n        }\n        // We need to clean this up ourselves, because we're passing in an\n        // `EnvironmentInjector` below which won't ever be destroyed.\n        // Otherwise it causes some callbacks to be retained (see #29696).\n        this._afterNextRenderRef?.destroy();\n        // Update the position once the overlay is fully rendered before attempting to position it,\n        // as the position may depend on the size of the rendered content.\n        this._afterNextRenderRef = afterNextRender(() => {\n            // The overlay could've been detached before the callback executed.\n            if (this.hasAttached()) {\n                this.updatePosition();\n            }\n        }, { injector: this._injector });\n        // Enable pointer events for the overlay pane element.\n        this._togglePointerEvents(true);\n        if (this._config.hasBackdrop) {\n            this._attachBackdrop();\n        }\n        if (this._config.panelClass) {\n            this._toggleClasses(this._pane, this._config.panelClass, true);\n        }\n        // Only emit the `attachments` event once all other setup is done.\n        this._attachments.next();\n        this._completeDetachContent();\n        // Track this overlay by the keyboard dispatcher\n        this._keyboardDispatcher.add(this);\n        if (this._config.disposeOnNavigation) {\n            this._locationChanges = this._location.subscribe(() => this.dispose());\n        }\n        this._outsideClickDispatcher.add(this);\n        // TODO(crisbeto): the null check is here, because the portal outlet returns `any`.\n        // We should be guaranteed for the result to be `ComponentRef | EmbeddedViewRef`, but\n        // `instanceof EmbeddedViewRef` doesn't appear to work at the moment.\n        if (typeof attachResult?.onDestroy === 'function') {\n            // In most cases we control the portal and we know when it is being detached so that\n            // we can finish the disposal process. The exception is if the user passes in a custom\n            // `ViewContainerRef` that isn't destroyed through the overlay API. Note that we use\n            // `detach` here instead of `dispose`, because we don't know if the user intends to\n            // reattach the overlay at a later point. It also has the advantage of waiting for animations.\n            attachResult.onDestroy(() => {\n                if (this.hasAttached()) {\n                    // We have to delay the `detach` call, because detaching immediately prevents\n                    // other destroy hooks from running. This is likely a framework bug similar to\n                    // https://github.com/angular/angular/issues/46119\n                    this._ngZone.runOutsideAngular(() => Promise.resolve().then(() => this.detach()));\n                }\n            });\n        }\n        return attachResult;\n    }\n    /**\n     * Detaches an overlay from a portal.\n     * @returns The portal detachment result.\n     */\n    detach() {\n        if (!this.hasAttached()) {\n            return;\n        }\n        this.detachBackdrop();\n        // When the overlay is detached, the pane element should disable pointer events.\n        // This is necessary because otherwise the pane element will cover the page and disable\n        // pointer events therefore. Depends on the position strategy and the applied pane boundaries.\n        this._togglePointerEvents(false);\n        if (this._positionStrategy && this._positionStrategy.detach) {\n            this._positionStrategy.detach();\n        }\n        if (this._scrollStrategy) {\n            this._scrollStrategy.disable();\n        }\n        const detachmentResult = this._portalOutlet.detach();\n        // Only emit after everything is detached.\n        this._detachments.next();\n        this._completeDetachContent();\n        // Remove this overlay from keyboard dispatcher tracking.\n        this._keyboardDispatcher.remove(this);\n        // Keeping the host element in the DOM can cause scroll jank, because it still gets\n        // rendered, even though it's transparent and unclickable which is why we remove it.\n        this._detachContentWhenEmpty();\n        this._locationChanges.unsubscribe();\n        this._outsideClickDispatcher.remove(this);\n        return detachmentResult;\n    }\n    /** Cleans up the overlay from the DOM. */\n    dispose() {\n        const isAttached = this.hasAttached();\n        if (this._positionStrategy) {\n            this._positionStrategy.dispose();\n        }\n        this._disposeScrollStrategy();\n        this._backdropRef?.dispose();\n        this._locationChanges.unsubscribe();\n        this._keyboardDispatcher.remove(this);\n        this._portalOutlet.dispose();\n        this._attachments.complete();\n        this._backdropClick.complete();\n        this._keydownEvents.complete();\n        this._outsidePointerEvents.complete();\n        this._outsideClickDispatcher.remove(this);\n        this._host?.remove();\n        this._afterNextRenderRef?.destroy();\n        this._previousHostParent = this._pane = this._host = this._backdropRef = null;\n        if (isAttached) {\n            this._detachments.next();\n        }\n        this._detachments.complete();\n        this._completeDetachContent();\n    }\n    /** Whether the overlay has attached content. */\n    hasAttached() {\n        return this._portalOutlet.hasAttached();\n    }\n    /** Gets an observable that emits when the backdrop has been clicked. */\n    backdropClick() {\n        return this._backdropClick;\n    }\n    /** Gets an observable that emits when the overlay has been attached. */\n    attachments() {\n        return this._attachments;\n    }\n    /** Gets an observable that emits when the overlay has been detached. */\n    detachments() {\n        return this._detachments;\n    }\n    /** Gets an observable of keydown events targeted to this overlay. */\n    keydownEvents() {\n        return this._keydownEvents;\n    }\n    /** Gets an observable of pointer events targeted outside this overlay. */\n    outsidePointerEvents() {\n        return this._outsidePointerEvents;\n    }\n    /** Gets the current overlay configuration, which is immutable. */\n    getConfig() {\n        return this._config;\n    }\n    /** Updates the position of the overlay based on the position strategy. */\n    updatePosition() {\n        if (this._positionStrategy) {\n            this._positionStrategy.apply();\n        }\n    }\n    /** Switches to a new position strategy and updates the overlay position. */\n    updatePositionStrategy(strategy) {\n        if (strategy === this._positionStrategy) {\n            return;\n        }\n        if (this._positionStrategy) {\n            this._positionStrategy.dispose();\n        }\n        this._positionStrategy = strategy;\n        if (this.hasAttached()) {\n            strategy.attach(this);\n            this.updatePosition();\n        }\n    }\n    /** Update the size properties of the overlay. */\n    updateSize(sizeConfig) {\n        this._config = { ...this._config, ...sizeConfig };\n        this._updateElementSize();\n    }\n    /** Sets the LTR/RTL direction for the overlay. */\n    setDirection(dir) {\n        this._config = { ...this._config, direction: dir };\n        this._updateElementDirection();\n    }\n    /** Add a CSS class or an array of classes to the overlay pane. */\n    addPanelClass(classes) {\n        if (this._pane) {\n            this._toggleClasses(this._pane, classes, true);\n        }\n    }\n    /** Remove a CSS class or an array of classes from the overlay pane. */\n    removePanelClass(classes) {\n        if (this._pane) {\n            this._toggleClasses(this._pane, classes, false);\n        }\n    }\n    /**\n     * Returns the layout direction of the overlay panel.\n     */\n    getDirection() {\n        const direction = this._config.direction;\n        if (!direction) {\n            return 'ltr';\n        }\n        return typeof direction === 'string' ? direction : direction.value;\n    }\n    /** Switches to a new scroll strategy. */\n    updateScrollStrategy(strategy) {\n        if (strategy === this._scrollStrategy) {\n            return;\n        }\n        this._disposeScrollStrategy();\n        this._scrollStrategy = strategy;\n        if (this.hasAttached()) {\n            strategy.attach(this);\n            strategy.enable();\n        }\n    }\n    /** Updates the text direction of the overlay panel. */\n    _updateElementDirection() {\n        this._host.setAttribute('dir', this.getDirection());\n    }\n    /** Updates the size of the overlay element based on the overlay config. */\n    _updateElementSize() {\n        if (!this._pane) {\n            return;\n        }\n        const style = this._pane.style;\n        style.width = coerceCssPixelValue(this._config.width);\n        style.height = coerceCssPixelValue(this._config.height);\n        style.minWidth = coerceCssPixelValue(this._config.minWidth);\n        style.minHeight = coerceCssPixelValue(this._config.minHeight);\n        style.maxWidth = coerceCssPixelValue(this._config.maxWidth);\n        style.maxHeight = coerceCssPixelValue(this._config.maxHeight);\n    }\n    /** Toggles the pointer events for the overlay pane element. */\n    _togglePointerEvents(enablePointer) {\n        this._pane.style.pointerEvents = enablePointer ? '' : 'none';\n    }\n    /** Attaches a backdrop for this overlay. */\n    _attachBackdrop() {\n        const showingClass = 'cdk-overlay-backdrop-showing';\n        this._backdropRef?.dispose();\n        this._backdropRef = new BackdropRef(this._document, this._renderer, this._ngZone, event => {\n            this._backdropClick.next(event);\n        });\n        if (this._animationsDisabled) {\n            this._backdropRef.element.classList.add('cdk-overlay-backdrop-noop-animation');\n        }\n        if (this._config.backdropClass) {\n            this._toggleClasses(this._backdropRef.element, this._config.backdropClass, true);\n        }\n        // Insert the backdrop before the pane in the DOM order,\n        // in order to handle stacked overlays properly.\n        this._host.parentElement.insertBefore(this._backdropRef.element, this._host);\n        // Add class to fade-in the backdrop after one frame.\n        if (!this._animationsDisabled && typeof requestAnimationFrame !== 'undefined') {\n            this._ngZone.runOutsideAngular(() => {\n                requestAnimationFrame(() => this._backdropRef?.element.classList.add(showingClass));\n            });\n        }\n        else {\n            this._backdropRef.element.classList.add(showingClass);\n        }\n    }\n    /**\n     * Updates the stacking order of the element, moving it to the top if necessary.\n     * This is required in cases where one overlay was detached, while another one,\n     * that should be behind it, was destroyed. The next time both of them are opened,\n     * the stacking will be wrong, because the detached element's pane will still be\n     * in its original DOM position.\n     */\n    _updateStackingOrder() {\n        if (this._host.nextSibling) {\n            this._host.parentNode.appendChild(this._host);\n        }\n    }\n    /** Detaches the backdrop (if any) associated with the overlay. */\n    detachBackdrop() {\n        if (this._animationsDisabled) {\n            this._backdropRef?.dispose();\n            this._backdropRef = null;\n        }\n        else {\n            this._backdropRef?.detach();\n        }\n    }\n    /** Toggles a single CSS class or an array of classes on an element. */\n    _toggleClasses(element, cssClasses, isAdd) {\n        const classes = coerceArray(cssClasses || []).filter(c => !!c);\n        if (classes.length) {\n            isAdd ? element.classList.add(...classes) : element.classList.remove(...classes);\n        }\n    }\n    /** Detaches the overlay once the content finishes animating and is removed from the DOM. */\n    _detachContentWhenEmpty() {\n        let rethrow = false;\n        // Attempt to detach on the next render.\n        try {\n            this._detachContentAfterRenderRef = afterNextRender(() => {\n                // Rethrow if we encounter an actual error detaching.\n                rethrow = true;\n                this._detachContent();\n            }, {\n                injector: this._injector,\n            });\n        }\n        catch (e) {\n            if (rethrow) {\n                throw e;\n            }\n            // afterNextRender throws if the EnvironmentInjector is has already been destroyed.\n            // This may happen in tests that don't properly flush all async work.\n            // In order to avoid breaking those tests, we just detach immediately in this case.\n            this._detachContent();\n        }\n        // Otherwise wait until the content finishes animating out and detach.\n        if (globalThis.MutationObserver && this._pane) {\n            this._detachContentMutationObserver ||= new globalThis.MutationObserver(() => {\n                this._detachContent();\n            });\n            this._detachContentMutationObserver.observe(this._pane, { childList: true });\n        }\n    }\n    _detachContent() {\n        // Needs a couple of checks for the pane and host, because\n        // they may have been removed by the time the zone stabilizes.\n        if (!this._pane || !this._host || this._pane.children.length === 0) {\n            if (this._pane && this._config.panelClass) {\n                this._toggleClasses(this._pane, this._config.panelClass, false);\n            }\n            if (this._host && this._host.parentElement) {\n                this._previousHostParent = this._host.parentElement;\n                this._host.remove();\n            }\n            this._completeDetachContent();\n        }\n    }\n    _completeDetachContent() {\n        this._detachContentAfterRenderRef?.destroy();\n        this._detachContentAfterRenderRef = undefined;\n        this._detachContentMutationObserver?.disconnect();\n    }\n    /** Disposes of a scroll strategy. */\n    _disposeScrollStrategy() {\n        const scrollStrategy = this._scrollStrategy;\n        scrollStrategy?.disable();\n        scrollStrategy?.detach?.();\n    }\n}\n\n// TODO: refactor clipping detection into a separate thing (part of scrolling module)\n// TODO: doesn't handle both flexible width and height when it has to scroll along both axis.\n/** Class to be added to the overlay bounding box. */\nconst boundingBoxClass = 'cdk-overlay-connected-position-bounding-box';\n/** Regex used to split a string on its CSS units. */\nconst cssUnitPattern = /([A-Za-z%]+)$/;\n/**\n * Creates a flexible position strategy.\n * @param injector Injector used to resolve dependnecies for the position strategy.\n * @param origin Origin relative to which to position the overlay.\n */\nfunction createFlexibleConnectedPositionStrategy(injector, origin) {\n    return new FlexibleConnectedPositionStrategy(origin, injector.get(ViewportRuler), injector.get(DOCUMENT), injector.get(Platform), injector.get(OverlayContainer));\n}\n/**\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\n * implicit position relative some origin element. The relative position is defined in terms of\n * a point on the origin element that is connected to a point on the overlay element. For example,\n * a basic dropdown is connecting the bottom-left corner of the origin to the top-left corner\n * of the overlay.\n */\nclass FlexibleConnectedPositionStrategy {\n    _viewportRuler;\n    _document;\n    _platform;\n    _overlayContainer;\n    /** The overlay to which this strategy is attached. */\n    _overlayRef;\n    /** Whether we're performing the very first positioning of the overlay. */\n    _isInitialRender;\n    /** Last size used for the bounding box. Used to avoid resizing the overlay after open. */\n    _lastBoundingBoxSize = { width: 0, height: 0 };\n    /** Whether the overlay was pushed in a previous positioning. */\n    _isPushed = false;\n    /** Whether the overlay can be pushed on-screen on the initial open. */\n    _canPush = true;\n    /** Whether the overlay can grow via flexible width/height after the initial open. */\n    _growAfterOpen = false;\n    /** Whether the overlay's width and height can be constrained to fit within the viewport. */\n    _hasFlexibleDimensions = true;\n    /** Whether the overlay position is locked. */\n    _positionLocked = false;\n    /** Cached origin dimensions */\n    _originRect;\n    /** Cached overlay dimensions */\n    _overlayRect;\n    /** Cached viewport dimensions */\n    _viewportRect;\n    /** Cached container dimensions */\n    _containerRect;\n    /** Amount of space that must be maintained between the overlay and the edge of the viewport. */\n    _viewportMargin = 0;\n    /** The Scrollable containers used to check scrollable view properties on position change. */\n    _scrollables = [];\n    /** Ordered list of preferred positions, from most to least desirable. */\n    _preferredPositions = [];\n    /** The origin element against which the overlay will be positioned. */\n    _origin;\n    /** The overlay pane element. */\n    _pane;\n    /** Whether the strategy has been disposed of already. */\n    _isDisposed;\n    /**\n     * Parent element for the overlay panel used to constrain the overlay panel's size to fit\n     * within the viewport.\n     */\n    _boundingBox;\n    /** The last position to have been calculated as the best fit position. */\n    _lastPosition;\n    /** The last calculated scroll visibility. Only tracked  */\n    _lastScrollVisibility;\n    /** Subject that emits whenever the position changes. */\n    _positionChanges = new Subject();\n    /** Subscription to viewport size changes. */\n    _resizeSubscription = Subscription.EMPTY;\n    /** Default offset for the overlay along the x axis. */\n    _offsetX = 0;\n    /** Default offset for the overlay along the y axis. */\n    _offsetY = 0;\n    /** Selector to be used when finding the elements on which to set the transform origin. */\n    _transformOriginSelector;\n    /** Keeps track of the CSS classes that the position strategy has applied on the overlay panel. */\n    _appliedPanelClasses = [];\n    /** Amount by which the overlay was pushed in each axis during the last time it was positioned. */\n    _previousPushAmount;\n    /** Observable sequence of position changes. */\n    positionChanges = this._positionChanges;\n    /** Ordered list of preferred positions, from most to least desirable. */\n    get positions() {\n        return this._preferredPositions;\n    }\n    constructor(connectedTo, _viewportRuler, _document, _platform, _overlayContainer) {\n        this._viewportRuler = _viewportRuler;\n        this._document = _document;\n        this._platform = _platform;\n        this._overlayContainer = _overlayContainer;\n        this.setOrigin(connectedTo);\n    }\n    /** Attaches this position strategy to an overlay. */\n    attach(overlayRef) {\n        if (this._overlayRef &&\n            overlayRef !== this._overlayRef &&\n            (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            throw Error('This position strategy is already attached to an overlay');\n        }\n        this._validatePositions();\n        overlayRef.hostElement.classList.add(boundingBoxClass);\n        this._overlayRef = overlayRef;\n        this._boundingBox = overlayRef.hostElement;\n        this._pane = overlayRef.overlayElement;\n        this._isDisposed = false;\n        this._isInitialRender = true;\n        this._lastPosition = null;\n        this._resizeSubscription.unsubscribe();\n        this._resizeSubscription = this._viewportRuler.change().subscribe(() => {\n            // When the window is resized, we want to trigger the next reposition as if it\n            // was an initial render, in order for the strategy to pick a new optimal position,\n            // otherwise position locking will cause it to stay at the old one.\n            this._isInitialRender = true;\n            this.apply();\n        });\n    }\n    /**\n     * Updates the position of the overlay element, using whichever preferred position relative\n     * to the origin best fits on-screen.\n     *\n     * The selection of a position goes as follows:\n     *  - If any positions fit completely within the viewport as-is,\n     *      choose the first position that does so.\n     *  - If flexible dimensions are enabled and at least one satisfies the given minimum width/height,\n     *      choose the position with the greatest available size modified by the positions' weight.\n     *  - If pushing is enabled, take the position that went off-screen the least and push it\n     *      on-screen.\n     *  - If none of the previous criteria were met, use the position that goes off-screen the least.\n     * @docs-private\n     */\n    apply() {\n        // We shouldn't do anything if the strategy was disposed or we're on the server.\n        if (this._isDisposed || !this._platform.isBrowser) {\n            return;\n        }\n        // If the position has been applied already (e.g. when the overlay was opened) and the\n        // consumer opted into locking in the position, re-use the old position, in order to\n        // prevent the overlay from jumping around.\n        if (!this._isInitialRender && this._positionLocked && this._lastPosition) {\n            this.reapplyLastPosition();\n            return;\n        }\n        this._clearPanelClasses();\n        this._resetOverlayElementStyles();\n        this._resetBoundingBoxStyles();\n        // We need the bounding rects for the origin, the overlay and the container to determine how to position\n        // the overlay relative to the origin.\n        // We use the viewport rect to determine whether a position would go off-screen.\n        this._viewportRect = this._getNarrowedViewportRect();\n        this._originRect = this._getOriginRect();\n        this._overlayRect = this._pane.getBoundingClientRect();\n        this._containerRect = this._overlayContainer.getContainerElement().getBoundingClientRect();\n        const originRect = this._originRect;\n        const overlayRect = this._overlayRect;\n        const viewportRect = this._viewportRect;\n        const containerRect = this._containerRect;\n        // Positions where the overlay will fit with flexible dimensions.\n        const flexibleFits = [];\n        // Fallback if none of the preferred positions fit within the viewport.\n        let fallback;\n        // Go through each of the preferred positions looking for a good fit.\n        // If a good fit is found, it will be applied immediately.\n        for (let pos of this._preferredPositions) {\n            // Get the exact (x, y) coordinate for the point-of-origin on the origin element.\n            let originPoint = this._getOriginPoint(originRect, containerRect, pos);\n            // From that point-of-origin, get the exact (x, y) coordinate for the top-left corner of the\n            // overlay in this position. We use the top-left corner for calculations and later translate\n            // this into an appropriate (top, left, bottom, right) style.\n            let overlayPoint = this._getOverlayPoint(originPoint, overlayRect, pos);\n            // Calculate how well the overlay would fit into the viewport with this point.\n            let overlayFit = this._getOverlayFit(overlayPoint, overlayRect, viewportRect, pos);\n            // If the overlay, without any further work, fits into the viewport, use this position.\n            if (overlayFit.isCompletelyWithinViewport) {\n                this._isPushed = false;\n                this._applyPosition(pos, originPoint);\n                return;\n            }\n            // If the overlay has flexible dimensions, we can use this position\n            // so long as there's enough space for the minimum dimensions.\n            if (this._canFitWithFlexibleDimensions(overlayFit, overlayPoint, viewportRect)) {\n                // Save positions where the overlay will fit with flexible dimensions. We will use these\n                // if none of the positions fit *without* flexible dimensions.\n                flexibleFits.push({\n                    position: pos,\n                    origin: originPoint,\n                    overlayRect,\n                    boundingBoxRect: this._calculateBoundingBoxRect(originPoint, pos),\n                });\n                continue;\n            }\n            // If the current preferred position does not fit on the screen, remember the position\n            // if it has more visible area on-screen than we've seen and move onto the next preferred\n            // position.\n            if (!fallback || fallback.overlayFit.visibleArea < overlayFit.visibleArea) {\n                fallback = { overlayFit, overlayPoint, originPoint, position: pos, overlayRect };\n            }\n        }\n        // If there are any positions where the overlay would fit with flexible dimensions, choose the\n        // one that has the greatest area available modified by the position's weight\n        if (flexibleFits.length) {\n            let bestFit = null;\n            let bestScore = -1;\n            for (const fit of flexibleFits) {\n                const score = fit.boundingBoxRect.width * fit.boundingBoxRect.height * (fit.position.weight || 1);\n                if (score > bestScore) {\n                    bestScore = score;\n                    bestFit = fit;\n                }\n            }\n            this._isPushed = false;\n            this._applyPosition(bestFit.position, bestFit.origin);\n            return;\n        }\n        // When none of the preferred positions fit within the viewport, take the position\n        // that went off-screen the least and attempt to push it on-screen.\n        if (this._canPush) {\n            // TODO(jelbourn): after pushing, the opening \"direction\" of the overlay might not make sense.\n            this._isPushed = true;\n            this._applyPosition(fallback.position, fallback.originPoint);\n            return;\n        }\n        // All options for getting the overlay within the viewport have been exhausted, so go with the\n        // position that went off-screen the least.\n        this._applyPosition(fallback.position, fallback.originPoint);\n    }\n    detach() {\n        this._clearPanelClasses();\n        this._lastPosition = null;\n        this._previousPushAmount = null;\n        this._resizeSubscription.unsubscribe();\n    }\n    /** Cleanup after the element gets destroyed. */\n    dispose() {\n        if (this._isDisposed) {\n            return;\n        }\n        // We can't use `_resetBoundingBoxStyles` here, because it resets\n        // some properties to zero, rather than removing them.\n        if (this._boundingBox) {\n            extendStyles(this._boundingBox.style, {\n                top: '',\n                left: '',\n                right: '',\n                bottom: '',\n                height: '',\n                width: '',\n                alignItems: '',\n                justifyContent: '',\n            });\n        }\n        if (this._pane) {\n            this._resetOverlayElementStyles();\n        }\n        if (this._overlayRef) {\n            this._overlayRef.hostElement.classList.remove(boundingBoxClass);\n        }\n        this.detach();\n        this._positionChanges.complete();\n        this._overlayRef = this._boundingBox = null;\n        this._isDisposed = true;\n    }\n    /**\n     * This re-aligns the overlay element with the trigger in its last calculated position,\n     * even if a position higher in the \"preferred positions\" list would now fit. This\n     * allows one to re-align the panel without changing the orientation of the panel.\n     */\n    reapplyLastPosition() {\n        if (this._isDisposed || !this._platform.isBrowser) {\n            return;\n        }\n        const lastPosition = this._lastPosition;\n        if (lastPosition) {\n            this._originRect = this._getOriginRect();\n            this._overlayRect = this._pane.getBoundingClientRect();\n            this._viewportRect = this._getNarrowedViewportRect();\n            this._containerRect = this._overlayContainer.getContainerElement().getBoundingClientRect();\n            const originPoint = this._getOriginPoint(this._originRect, this._containerRect, lastPosition);\n            this._applyPosition(lastPosition, originPoint);\n        }\n        else {\n            this.apply();\n        }\n    }\n    /**\n     * Sets the list of Scrollable containers that host the origin element so that\n     * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every\n     * Scrollable must be an ancestor element of the strategy's origin element.\n     */\n    withScrollableContainers(scrollables) {\n        this._scrollables = scrollables;\n        return this;\n    }\n    /**\n     * Adds new preferred positions.\n     * @param positions List of positions options for this overlay.\n     */\n    withPositions(positions) {\n        this._preferredPositions = positions;\n        // If the last calculated position object isn't part of the positions anymore, clear\n        // it in order to avoid it being picked up if the consumer tries to re-apply.\n        if (positions.indexOf(this._lastPosition) === -1) {\n            this._lastPosition = null;\n        }\n        this._validatePositions();\n        return this;\n    }\n    /**\n     * Sets a minimum distance the overlay may be positioned to the edge of the viewport.\n     * @param margin Required margin between the overlay and the viewport edge in pixels.\n     */\n    withViewportMargin(margin) {\n        this._viewportMargin = margin;\n        return this;\n    }\n    /** Sets whether the overlay's width and height can be constrained to fit within the viewport. */\n    withFlexibleDimensions(flexibleDimensions = true) {\n        this._hasFlexibleDimensions = flexibleDimensions;\n        return this;\n    }\n    /** Sets whether the overlay can grow after the initial open via flexible width/height. */\n    withGrowAfterOpen(growAfterOpen = true) {\n        this._growAfterOpen = growAfterOpen;\n        return this;\n    }\n    /** Sets whether the overlay can be pushed on-screen if none of the provided positions fit. */\n    withPush(canPush = true) {\n        this._canPush = canPush;\n        return this;\n    }\n    /**\n     * Sets whether the overlay's position should be locked in after it is positioned\n     * initially. When an overlay is locked in, it won't attempt to reposition itself\n     * when the position is re-applied (e.g. when the user scrolls away).\n     * @param isLocked Whether the overlay should locked in.\n     */\n    withLockedPosition(isLocked = true) {\n        this._positionLocked = isLocked;\n        return this;\n    }\n    /**\n     * Sets the origin, relative to which to position the overlay.\n     * Using an element origin is useful for building components that need to be positioned\n     * relatively to a trigger (e.g. dropdown menus or tooltips), whereas using a point can be\n     * used for cases like contextual menus which open relative to the user's pointer.\n     * @param origin Reference to the new origin.\n     */\n    setOrigin(origin) {\n        this._origin = origin;\n        return this;\n    }\n    /**\n     * Sets the default offset for the overlay's connection point on the x-axis.\n     * @param offset New offset in the X axis.\n     */\n    withDefaultOffsetX(offset) {\n        this._offsetX = offset;\n        return this;\n    }\n    /**\n     * Sets the default offset for the overlay's connection point on the y-axis.\n     * @param offset New offset in the Y axis.\n     */\n    withDefaultOffsetY(offset) {\n        this._offsetY = offset;\n        return this;\n    }\n    /**\n     * Configures that the position strategy should set a `transform-origin` on some elements\n     * inside the overlay, depending on the current position that is being applied. This is\n     * useful for the cases where the origin of an animation can change depending on the\n     * alignment of the overlay.\n     * @param selector CSS selector that will be used to find the target\n     *    elements onto which to set the transform origin.\n     */\n    withTransformOriginOn(selector) {\n        this._transformOriginSelector = selector;\n        return this;\n    }\n    /**\n     * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.\n     */\n    _getOriginPoint(originRect, containerRect, pos) {\n        let x;\n        if (pos.originX == 'center') {\n            // Note: when centering we should always use the `left`\n            // offset, otherwise the position will be wrong in RTL.\n            x = originRect.left + originRect.width / 2;\n        }\n        else {\n            const startX = this._isRtl() ? originRect.right : originRect.left;\n            const endX = this._isRtl() ? originRect.left : originRect.right;\n            x = pos.originX == 'start' ? startX : endX;\n        }\n        // When zooming in Safari the container rectangle contains negative values for the position\n        // and we need to re-add them to the calculated coordinates.\n        if (containerRect.left < 0) {\n            x -= containerRect.left;\n        }\n        let y;\n        if (pos.originY == 'center') {\n            y = originRect.top + originRect.height / 2;\n        }\n        else {\n            y = pos.originY == 'top' ? originRect.top : originRect.bottom;\n        }\n        // Normally the containerRect's top value would be zero, however when the overlay is attached to an input\n        // (e.g. in an autocomplete), mobile browsers will shift everything in order to put the input in the middle\n        // of the screen and to make space for the virtual keyboard. We need to account for this offset,\n        // otherwise our positioning will be thrown off.\n        // Additionally, when zooming in Safari this fixes the vertical position.\n        if (containerRect.top < 0) {\n            y -= containerRect.top;\n        }\n        return { x, y };\n    }\n    /**\n     * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and\n     * origin point to which the overlay should be connected.\n     */\n    _getOverlayPoint(originPoint, overlayRect, pos) {\n        // Calculate the (overlayStartX, overlayStartY), the start of the\n        // potential overlay position relative to the origin point.\n        let overlayStartX;\n        if (pos.overlayX == 'center') {\n            overlayStartX = -overlayRect.width / 2;\n        }\n        else if (pos.overlayX === 'start') {\n            overlayStartX = this._isRtl() ? -overlayRect.width : 0;\n        }\n        else {\n            overlayStartX = this._isRtl() ? 0 : -overlayRect.width;\n        }\n        let overlayStartY;\n        if (pos.overlayY == 'center') {\n            overlayStartY = -overlayRect.height / 2;\n        }\n        else {\n            overlayStartY = pos.overlayY == 'top' ? 0 : -overlayRect.height;\n        }\n        // The (x, y) coordinates of the overlay.\n        return {\n            x: originPoint.x + overlayStartX,\n            y: originPoint.y + overlayStartY,\n        };\n    }\n    /** Gets how well an overlay at the given point will fit within the viewport. */\n    _getOverlayFit(point, rawOverlayRect, viewport, position) {\n        // Round the overlay rect when comparing against the\n        // viewport, because the viewport is always rounded.\n        const overlay = getRoundedBoundingClientRect(rawOverlayRect);\n        let { x, y } = point;\n        let offsetX = this._getOffset(position, 'x');\n        let offsetY = this._getOffset(position, 'y');\n        // Account for the offsets since they could push the overlay out of the viewport.\n        if (offsetX) {\n            x += offsetX;\n        }\n        if (offsetY) {\n            y += offsetY;\n        }\n        // How much the overlay would overflow at this position, on each side.\n        let leftOverflow = 0 - x;\n        let rightOverflow = x + overlay.width - viewport.width;\n        let topOverflow = 0 - y;\n        let bottomOverflow = y + overlay.height - viewport.height;\n        // Visible parts of the element on each axis.\n        let visibleWidth = this._subtractOverflows(overlay.width, leftOverflow, rightOverflow);\n        let visibleHeight = this._subtractOverflows(overlay.height, topOverflow, bottomOverflow);\n        let visibleArea = visibleWidth * visibleHeight;\n        return {\n            visibleArea,\n            isCompletelyWithinViewport: overlay.width * overlay.height === visibleArea,\n            fitsInViewportVertically: visibleHeight === overlay.height,\n            fitsInViewportHorizontally: visibleWidth == overlay.width,\n        };\n    }\n    /**\n     * Whether the overlay can fit within the viewport when it may resize either its width or height.\n     * @param fit How well the overlay fits in the viewport at some position.\n     * @param point The (x, y) coordinates of the overlay at some position.\n     * @param viewport The geometry of the viewport.\n     */\n    _canFitWithFlexibleDimensions(fit, point, viewport) {\n        if (this._hasFlexibleDimensions) {\n            const availableHeight = viewport.bottom - point.y;\n            const availableWidth = viewport.right - point.x;\n            const minHeight = getPixelValue(this._overlayRef.getConfig().minHeight);\n            const minWidth = getPixelValue(this._overlayRef.getConfig().minWidth);\n            const verticalFit = fit.fitsInViewportVertically || (minHeight != null && minHeight <= availableHeight);\n            const horizontalFit = fit.fitsInViewportHorizontally || (minWidth != null && minWidth <= availableWidth);\n            return verticalFit && horizontalFit;\n        }\n        return false;\n    }\n    /**\n     * Gets the point at which the overlay can be \"pushed\" on-screen. If the overlay is larger than\n     * the viewport, the top-left corner will be pushed on-screen (with overflow occurring on the\n     * right and bottom).\n     *\n     * @param start Starting point from which the overlay is pushed.\n     * @param rawOverlayRect Dimensions of the overlay.\n     * @param scrollPosition Current viewport scroll position.\n     * @returns The point at which to position the overlay after pushing. This is effectively a new\n     *     originPoint.\n     */\n    _pushOverlayOnScreen(start, rawOverlayRect, scrollPosition) {\n        // If the position is locked and we've pushed the overlay already, reuse the previous push\n        // amount, rather than pushing it again. If we were to continue pushing, the element would\n        // remain in the viewport, which goes against the expectations when position locking is enabled.\n        if (this._previousPushAmount && this._positionLocked) {\n            return {\n                x: start.x + this._previousPushAmount.x,\n                y: start.y + this._previousPushAmount.y,\n            };\n        }\n        // Round the overlay rect when comparing against the\n        // viewport, because the viewport is always rounded.\n        const overlay = getRoundedBoundingClientRect(rawOverlayRect);\n        const viewport = this._viewportRect;\n        // Determine how much the overlay goes outside the viewport on each\n        // side, which we'll use to decide which direction to push it.\n        const overflowRight = Math.max(start.x + overlay.width - viewport.width, 0);\n        const overflowBottom = Math.max(start.y + overlay.height - viewport.height, 0);\n        const overflowTop = Math.max(viewport.top - scrollPosition.top - start.y, 0);\n        const overflowLeft = Math.max(viewport.left - scrollPosition.left - start.x, 0);\n        // Amount by which to push the overlay in each axis such that it remains on-screen.\n        let pushX = 0;\n        let pushY = 0;\n        // If the overlay fits completely within the bounds of the viewport, push it from whichever\n        // direction is goes off-screen. Otherwise, push the top-left corner such that its in the\n        // viewport and allow for the trailing end of the overlay to go out of bounds.\n        if (overlay.width <= viewport.width) {\n            pushX = overflowLeft || -overflowRight;\n        }\n        else {\n            pushX = start.x < this._viewportMargin ? viewport.left - scrollPosition.left - start.x : 0;\n        }\n        if (overlay.height <= viewport.height) {\n            pushY = overflowTop || -overflowBottom;\n        }\n        else {\n            pushY = start.y < this._viewportMargin ? viewport.top - scrollPosition.top - start.y : 0;\n        }\n        this._previousPushAmount = { x: pushX, y: pushY };\n        return {\n            x: start.x + pushX,\n            y: start.y + pushY,\n        };\n    }\n    /**\n     * Applies a computed position to the overlay and emits a position change.\n     * @param position The position preference\n     * @param originPoint The point on the origin element where the overlay is connected.\n     */\n    _applyPosition(position, originPoint) {\n        this._setTransformOrigin(position);\n        this._setOverlayElementStyles(originPoint, position);\n        this._setBoundingBoxStyles(originPoint, position);\n        if (position.panelClass) {\n            this._addPanelClasses(position.panelClass);\n        }\n        // Notify that the position has been changed along with its change properties.\n        // We only emit if we've got any subscriptions, because the scroll visibility\n        // calculations can be somewhat expensive.\n        if (this._positionChanges.observers.length) {\n            const scrollVisibility = this._getScrollVisibility();\n            // We're recalculating on scroll, but we only want to emit if anything\n            // changed since downstream code might be hitting the `NgZone`.\n            if (position !== this._lastPosition ||\n                !this._lastScrollVisibility ||\n                !compareScrollVisibility(this._lastScrollVisibility, scrollVisibility)) {\n                const changeEvent = new ConnectedOverlayPositionChange(position, scrollVisibility);\n                this._positionChanges.next(changeEvent);\n            }\n            this._lastScrollVisibility = scrollVisibility;\n        }\n        // Save the last connected position in case the position needs to be re-calculated.\n        this._lastPosition = position;\n        this._isInitialRender = false;\n    }\n    /** Sets the transform origin based on the configured selector and the passed-in position.  */\n    _setTransformOrigin(position) {\n        if (!this._transformOriginSelector) {\n            return;\n        }\n        const elements = this._boundingBox.querySelectorAll(this._transformOriginSelector);\n        let xOrigin;\n        let yOrigin = position.overlayY;\n        if (position.overlayX === 'center') {\n            xOrigin = 'center';\n        }\n        else if (this._isRtl()) {\n            xOrigin = position.overlayX === 'start' ? 'right' : 'left';\n        }\n        else {\n            xOrigin = position.overlayX === 'start' ? 'left' : 'right';\n        }\n        for (let i = 0; i < elements.length; i++) {\n            elements[i].style.transformOrigin = `${xOrigin} ${yOrigin}`;\n        }\n    }\n    /**\n     * Gets the position and size of the overlay's sizing container.\n     *\n     * This method does no measuring and applies no styles so that we can cheaply compute the\n     * bounds for all positions and choose the best fit based on these results.\n     */\n    _calculateBoundingBoxRect(origin, position) {\n        const viewport = this._viewportRect;\n        const isRtl = this._isRtl();\n        let height, top, bottom;\n        if (position.overlayY === 'top') {\n            // Overlay is opening \"downward\" and thus is bound by the bottom viewport edge.\n            top = origin.y;\n            height = viewport.height - top + this._viewportMargin;\n        }\n        else if (position.overlayY === 'bottom') {\n            // Overlay is opening \"upward\" and thus is bound by the top viewport edge. We need to add\n            // the viewport margin back in, because the viewport rect is narrowed down to remove the\n            // margin, whereas the `origin` position is calculated based on its `DOMRect`.\n            bottom = viewport.height - origin.y + this._viewportMargin * 2;\n            height = viewport.height - bottom + this._viewportMargin;\n        }\n        else {\n            // If neither top nor bottom, it means that the overlay is vertically centered on the\n            // origin point. Note that we want the position relative to the viewport, rather than\n            // the page, which is why we don't use something like `viewport.bottom - origin.y` and\n            // `origin.y - viewport.top`.\n            const smallestDistanceToViewportEdge = Math.min(viewport.bottom - origin.y + viewport.top, origin.y);\n            const previousHeight = this._lastBoundingBoxSize.height;\n            height = smallestDistanceToViewportEdge * 2;\n            top = origin.y - smallestDistanceToViewportEdge;\n            if (height > previousHeight && !this._isInitialRender && !this._growAfterOpen) {\n                top = origin.y - previousHeight / 2;\n            }\n        }\n        // The overlay is opening 'right-ward' (the content flows to the right).\n        const isBoundedByRightViewportEdge = (position.overlayX === 'start' && !isRtl) || (position.overlayX === 'end' && isRtl);\n        // The overlay is opening 'left-ward' (the content flows to the left).\n        const isBoundedByLeftViewportEdge = (position.overlayX === 'end' && !isRtl) || (position.overlayX === 'start' && isRtl);\n        let width, left, right;\n        if (isBoundedByLeftViewportEdge) {\n            right = viewport.width - origin.x + this._viewportMargin * 2;\n            width = origin.x - this._viewportMargin;\n        }\n        else if (isBoundedByRightViewportEdge) {\n            left = origin.x;\n            width = viewport.right - origin.x;\n        }\n        else {\n            // If neither start nor end, it means that the overlay is horizontally centered on the\n            // origin point. Note that we want the position relative to the viewport, rather than\n            // the page, which is why we don't use something like `viewport.right - origin.x` and\n            // `origin.x - viewport.left`.\n            const smallestDistanceToViewportEdge = Math.min(viewport.right - origin.x + viewport.left, origin.x);\n            const previousWidth = this._lastBoundingBoxSize.width;\n            width = smallestDistanceToViewportEdge * 2;\n            left = origin.x - smallestDistanceToViewportEdge;\n            if (width > previousWidth && !this._isInitialRender && !this._growAfterOpen) {\n                left = origin.x - previousWidth / 2;\n            }\n        }\n        return { top: top, left: left, bottom: bottom, right: right, width, height };\n    }\n    /**\n     * Sets the position and size of the overlay's sizing wrapper. The wrapper is positioned on the\n     * origin's connection point and stretches to the bounds of the viewport.\n     *\n     * @param origin The point on the origin element where the overlay is connected.\n     * @param position The position preference\n     */\n    _setBoundingBoxStyles(origin, position) {\n        const boundingBoxRect = this._calculateBoundingBoxRect(origin, position);\n        // It's weird if the overlay *grows* while scrolling, so we take the last size into account\n        // when applying a new size.\n        if (!this._isInitialRender && !this._growAfterOpen) {\n            boundingBoxRect.height = Math.min(boundingBoxRect.height, this._lastBoundingBoxSize.height);\n            boundingBoxRect.width = Math.min(boundingBoxRect.width, this._lastBoundingBoxSize.width);\n        }\n        const styles = {};\n        if (this._hasExactPosition()) {\n            styles.top = styles.left = '0';\n            styles.bottom = styles.right = styles.maxHeight = styles.maxWidth = '';\n            styles.width = styles.height = '100%';\n        }\n        else {\n            const maxHeight = this._overlayRef.getConfig().maxHeight;\n            const maxWidth = this._overlayRef.getConfig().maxWidth;\n            styles.height = coerceCssPixelValue(boundingBoxRect.height);\n            styles.top = coerceCssPixelValue(boundingBoxRect.top);\n            styles.bottom = coerceCssPixelValue(boundingBoxRect.bottom);\n            styles.width = coerceCssPixelValue(boundingBoxRect.width);\n            styles.left = coerceCssPixelValue(boundingBoxRect.left);\n            styles.right = coerceCssPixelValue(boundingBoxRect.right);\n            // Push the pane content towards the proper direction.\n            if (position.overlayX === 'center') {\n                styles.alignItems = 'center';\n            }\n            else {\n                styles.alignItems = position.overlayX === 'end' ? 'flex-end' : 'flex-start';\n            }\n            if (position.overlayY === 'center') {\n                styles.justifyContent = 'center';\n            }\n            else {\n                styles.justifyContent = position.overlayY === 'bottom' ? 'flex-end' : 'flex-start';\n            }\n            if (maxHeight) {\n                styles.maxHeight = coerceCssPixelValue(maxHeight);\n            }\n            if (maxWidth) {\n                styles.maxWidth = coerceCssPixelValue(maxWidth);\n            }\n        }\n        this._lastBoundingBoxSize = boundingBoxRect;\n        extendStyles(this._boundingBox.style, styles);\n    }\n    /** Resets the styles for the bounding box so that a new positioning can be computed. */\n    _resetBoundingBoxStyles() {\n        extendStyles(this._boundingBox.style, {\n            top: '0',\n            left: '0',\n            right: '0',\n            bottom: '0',\n            height: '',\n            width: '',\n            alignItems: '',\n            justifyContent: '',\n        });\n    }\n    /** Resets the styles for the overlay pane so that a new positioning can be computed. */\n    _resetOverlayElementStyles() {\n        extendStyles(this._pane.style, {\n            top: '',\n            left: '',\n            bottom: '',\n            right: '',\n            position: '',\n            transform: '',\n        });\n    }\n    /** Sets positioning styles to the overlay element. */\n    _setOverlayElementStyles(originPoint, position) {\n        const styles = {};\n        const hasExactPosition = this._hasExactPosition();\n        const hasFlexibleDimensions = this._hasFlexibleDimensions;\n        const config = this._overlayRef.getConfig();\n        if (hasExactPosition) {\n            const scrollPosition = this._viewportRuler.getViewportScrollPosition();\n            extendStyles(styles, this._getExactOverlayY(position, originPoint, scrollPosition));\n            extendStyles(styles, this._getExactOverlayX(position, originPoint, scrollPosition));\n        }\n        else {\n            styles.position = 'static';\n        }\n        // Use a transform to apply the offsets. We do this because the `center` positions rely on\n        // being in the normal flex flow and setting a `top` / `left` at all will completely throw\n        // off the position. We also can't use margins, because they won't have an effect in some\n        // cases where the element doesn't have anything to \"push off of\". Finally, this works\n        // better both with flexible and non-flexible positioning.\n        let transformString = '';\n        let offsetX = this._getOffset(position, 'x');\n        let offsetY = this._getOffset(position, 'y');\n        if (offsetX) {\n            transformString += `translateX(${offsetX}px) `;\n        }\n        if (offsetY) {\n            transformString += `translateY(${offsetY}px)`;\n        }\n        styles.transform = transformString.trim();\n        // If a maxWidth or maxHeight is specified on the overlay, we remove them. We do this because\n        // we need these values to both be set to \"100%\" for the automatic flexible sizing to work.\n        // The maxHeight and maxWidth are set on the boundingBox in order to enforce the constraint.\n        // Note that this doesn't apply when we have an exact position, in which case we do want to\n        // apply them because they'll be cleared from the bounding box.\n        if (config.maxHeight) {\n            if (hasExactPosition) {\n                styles.maxHeight = coerceCssPixelValue(config.maxHeight);\n            }\n            else if (hasFlexibleDimensions) {\n                styles.maxHeight = '';\n            }\n        }\n        if (config.maxWidth) {\n            if (hasExactPosition) {\n                styles.maxWidth = coerceCssPixelValue(config.maxWidth);\n            }\n            else if (hasFlexibleDimensions) {\n                styles.maxWidth = '';\n            }\n        }\n        extendStyles(this._pane.style, styles);\n    }\n    /** Gets the exact top/bottom for the overlay when not using flexible sizing or when pushing. */\n    _getExactOverlayY(position, originPoint, scrollPosition) {\n        // Reset any existing styles. This is necessary in case the\n        // preferred position has changed since the last `apply`.\n        let styles = { top: '', bottom: '' };\n        let overlayPoint = this._getOverlayPoint(originPoint, this._overlayRect, position);\n        if (this._isPushed) {\n            overlayPoint = this._pushOverlayOnScreen(overlayPoint, this._overlayRect, scrollPosition);\n        }\n        // We want to set either `top` or `bottom` based on whether the overlay wants to appear\n        // above or below the origin and the direction in which the element will expand.\n        if (position.overlayY === 'bottom') {\n            // When using `bottom`, we adjust the y position such that it is the distance\n            // from the bottom of the viewport rather than the top.\n            const documentHeight = this._document.documentElement.clientHeight;\n            styles.bottom = `${documentHeight - (overlayPoint.y + this._overlayRect.height)}px`;\n        }\n        else {\n            styles.top = coerceCssPixelValue(overlayPoint.y);\n        }\n        return styles;\n    }\n    /** Gets the exact left/right for the overlay when not using flexible sizing or when pushing. */\n    _getExactOverlayX(position, originPoint, scrollPosition) {\n        // Reset any existing styles. This is necessary in case the preferred position has\n        // changed since the last `apply`.\n        let styles = { left: '', right: '' };\n        let overlayPoint = this._getOverlayPoint(originPoint, this._overlayRect, position);\n        if (this._isPushed) {\n            overlayPoint = this._pushOverlayOnScreen(overlayPoint, this._overlayRect, scrollPosition);\n        }\n        // We want to set either `left` or `right` based on whether the overlay wants to appear \"before\"\n        // or \"after\" the origin, which determines the direction in which the element will expand.\n        // For the horizontal axis, the meaning of \"before\" and \"after\" change based on whether the\n        // page is in RTL or LTR.\n        let horizontalStyleProperty;\n        if (this._isRtl()) {\n            horizontalStyleProperty = position.overlayX === 'end' ? 'left' : 'right';\n        }\n        else {\n            horizontalStyleProperty = position.overlayX === 'end' ? 'right' : 'left';\n        }\n        // When we're setting `right`, we adjust the x position such that it is the distance\n        // from the right edge of the viewport rather than the left edge.\n        if (horizontalStyleProperty === 'right') {\n            const documentWidth = this._document.documentElement.clientWidth;\n            styles.right = `${documentWidth - (overlayPoint.x + this._overlayRect.width)}px`;\n        }\n        else {\n            styles.left = coerceCssPixelValue(overlayPoint.x);\n        }\n        return styles;\n    }\n    /**\n     * Gets the view properties of the trigger and overlay, including whether they are clipped\n     * or completely outside the view of any of the strategy's scrollables.\n     */\n    _getScrollVisibility() {\n        // Note: needs fresh rects since the position could've changed.\n        const originBounds = this._getOriginRect();\n        const overlayBounds = this._pane.getBoundingClientRect();\n        // TODO(jelbourn): instead of needing all of the client rects for these scrolling containers\n        // every time, we should be able to use the scrollTop of the containers if the size of those\n        // containers hasn't changed.\n        const scrollContainerBounds = this._scrollables.map(scrollable => {\n            return scrollable.getElementRef().nativeElement.getBoundingClientRect();\n        });\n        return {\n            isOriginClipped: isElementClippedByScrolling(originBounds, scrollContainerBounds),\n            isOriginOutsideView: isElementScrolledOutsideView(originBounds, scrollContainerBounds),\n            isOverlayClipped: isElementClippedByScrolling(overlayBounds, scrollContainerBounds),\n            isOverlayOutsideView: isElementScrolledOutsideView(overlayBounds, scrollContainerBounds),\n        };\n    }\n    /** Subtracts the amount that an element is overflowing on an axis from its length. */\n    _subtractOverflows(length, ...overflows) {\n        return overflows.reduce((currentValue, currentOverflow) => {\n            return currentValue - Math.max(currentOverflow, 0);\n        }, length);\n    }\n    /** Narrows the given viewport rect by the current _viewportMargin. */\n    _getNarrowedViewportRect() {\n        // We recalculate the viewport rect here ourselves, rather than using the ViewportRuler,\n        // because we want to use the `clientWidth` and `clientHeight` as the base. The difference\n        // being that the client properties don't include the scrollbar, as opposed to `innerWidth`\n        // and `innerHeight` that do. This is necessary, because the overlay container uses\n        // 100% `width` and `height` which don't include the scrollbar either.\n        const width = this._document.documentElement.clientWidth;\n        const height = this._document.documentElement.clientHeight;\n        const scrollPosition = this._viewportRuler.getViewportScrollPosition();\n        return {\n            top: scrollPosition.top + this._viewportMargin,\n            left: scrollPosition.left + this._viewportMargin,\n            right: scrollPosition.left + width - this._viewportMargin,\n            bottom: scrollPosition.top + height - this._viewportMargin,\n            width: width - 2 * this._viewportMargin,\n            height: height - 2 * this._viewportMargin,\n        };\n    }\n    /** Whether the we're dealing with an RTL context */\n    _isRtl() {\n        return this._overlayRef.getDirection() === 'rtl';\n    }\n    /** Determines whether the overlay uses exact or flexible positioning. */\n    _hasExactPosition() {\n        return !this._hasFlexibleDimensions || this._isPushed;\n    }\n    /** Retrieves the offset of a position along the x or y axis. */\n    _getOffset(position, axis) {\n        if (axis === 'x') {\n            // We don't do something like `position['offset' + axis]` in\n            // order to avoid breaking minifiers that rename properties.\n            return position.offsetX == null ? this._offsetX : position.offsetX;\n        }\n        return position.offsetY == null ? this._offsetY : position.offsetY;\n    }\n    /** Validates that the current position match the expected values. */\n    _validatePositions() {\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            if (!this._preferredPositions.length) {\n                throw Error('FlexibleConnectedPositionStrategy: At least one position is required.');\n            }\n            // TODO(crisbeto): remove these once Angular's template type\n            // checking is advanced enough to catch these cases.\n            this._preferredPositions.forEach(pair => {\n                validateHorizontalPosition('originX', pair.originX);\n                validateVerticalPosition('originY', pair.originY);\n                validateHorizontalPosition('overlayX', pair.overlayX);\n                validateVerticalPosition('overlayY', pair.overlayY);\n            });\n        }\n    }\n    /** Adds a single CSS class or an array of classes on the overlay panel. */\n    _addPanelClasses(cssClasses) {\n        if (this._pane) {\n            coerceArray(cssClasses).forEach(cssClass => {\n                if (cssClass !== '' && this._appliedPanelClasses.indexOf(cssClass) === -1) {\n                    this._appliedPanelClasses.push(cssClass);\n                    this._pane.classList.add(cssClass);\n                }\n            });\n        }\n    }\n    /** Clears the classes that the position strategy has applied from the overlay panel. */\n    _clearPanelClasses() {\n        if (this._pane) {\n            this._appliedPanelClasses.forEach(cssClass => {\n                this._pane.classList.remove(cssClass);\n            });\n            this._appliedPanelClasses = [];\n        }\n    }\n    /** Returns the DOMRect of the current origin. */\n    _getOriginRect() {\n        const origin = this._origin;\n        if (origin instanceof ElementRef) {\n            return origin.nativeElement.getBoundingClientRect();\n        }\n        // Check for Element so SVG elements are also supported.\n        if (origin instanceof Element) {\n            return origin.getBoundingClientRect();\n        }\n        const width = origin.width || 0;\n        const height = origin.height || 0;\n        // If the origin is a point, return a client rect as if it was a 0x0 element at the point.\n        return {\n            top: origin.y,\n            bottom: origin.y + height,\n            left: origin.x,\n            right: origin.x + width,\n            height,\n            width,\n        };\n    }\n}\n/** Shallow-extends a stylesheet object with another stylesheet object. */\nfunction extendStyles(destination, source) {\n    for (let key in source) {\n        if (source.hasOwnProperty(key)) {\n            destination[key] = source[key];\n        }\n    }\n    return destination;\n}\n/**\n * Extracts the pixel value as a number from a value, if it's a number\n * or a CSS pixel string (e.g. `1337px`). Otherwise returns null.\n */\nfunction getPixelValue(input) {\n    if (typeof input !== 'number' && input != null) {\n        const [value, units] = input.split(cssUnitPattern);\n        return !units || units === 'px' ? parseFloat(value) : null;\n    }\n    return input || null;\n}\n/**\n * Gets a version of an element's bounding `DOMRect` where all the values are rounded down to\n * the nearest pixel. This allows us to account for the cases where there may be sub-pixel\n * deviations in the `DOMRect` returned by the browser (e.g. when zoomed in with a percentage\n * size, see #21350).\n */\nfunction getRoundedBoundingClientRect(clientRect) {\n    return {\n        top: Math.floor(clientRect.top),\n        right: Math.floor(clientRect.right),\n        bottom: Math.floor(clientRect.bottom),\n        left: Math.floor(clientRect.left),\n        width: Math.floor(clientRect.width),\n        height: Math.floor(clientRect.height),\n    };\n}\n/** Returns whether two `ScrollingVisibility` objects are identical. */\nfunction compareScrollVisibility(a, b) {\n    if (a === b) {\n        return true;\n    }\n    return (a.isOriginClipped === b.isOriginClipped &&\n        a.isOriginOutsideView === b.isOriginOutsideView &&\n        a.isOverlayClipped === b.isOverlayClipped &&\n        a.isOverlayOutsideView === b.isOverlayOutsideView);\n}\nconst STANDARD_DROPDOWN_BELOW_POSITIONS = [\n    { originX: 'start', originY: 'bottom', overlayX: 'start', overlayY: 'top' },\n    { originX: 'start', originY: 'top', overlayX: 'start', overlayY: 'bottom' },\n    { originX: 'end', originY: 'bottom', overlayX: 'end', overlayY: 'top' },\n    { originX: 'end', originY: 'top', overlayX: 'end', overlayY: 'bottom' },\n];\nconst STANDARD_DROPDOWN_ADJACENT_POSITIONS = [\n    { originX: 'end', originY: 'top', overlayX: 'start', overlayY: 'top' },\n    { originX: 'end', originY: 'bottom', overlayX: 'start', overlayY: 'bottom' },\n    { originX: 'start', originY: 'top', overlayX: 'end', overlayY: 'top' },\n    { originX: 'start', originY: 'bottom', overlayX: 'end', overlayY: 'bottom' },\n];\n\n/** Class to be added to the overlay pane wrapper. */\nconst wrapperClass = 'cdk-global-overlay-wrapper';\n/**\n * Creates a global position strategy.\n * @param injector Injector used to resolve dependencies for the strategy.\n */\nfunction createGlobalPositionStrategy(_injector) {\n    // Note: `injector` is unused, but we may need it in\n    // the future which would introduce a breaking change.\n    return new GlobalPositionStrategy();\n}\n/**\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\n * explicit position relative to the browser's viewport. We use flexbox, instead of\n * transforms, in order to avoid issues with subpixel rendering which can cause the\n * element to become blurry.\n */\nclass GlobalPositionStrategy {\n    /** The overlay to which this strategy is attached. */\n    _overlayRef;\n    _cssPosition = 'static';\n    _topOffset = '';\n    _bottomOffset = '';\n    _alignItems = '';\n    _xPosition = '';\n    _xOffset = '';\n    _width = '';\n    _height = '';\n    _isDisposed = false;\n    attach(overlayRef) {\n        const config = overlayRef.getConfig();\n        this._overlayRef = overlayRef;\n        if (this._width && !config.width) {\n            overlayRef.updateSize({ width: this._width });\n        }\n        if (this._height && !config.height) {\n            overlayRef.updateSize({ height: this._height });\n        }\n        overlayRef.hostElement.classList.add(wrapperClass);\n        this._isDisposed = false;\n    }\n    /**\n     * Sets the top position of the overlay. Clears any previously set vertical position.\n     * @param value New top offset.\n     */\n    top(value = '') {\n        this._bottomOffset = '';\n        this._topOffset = value;\n        this._alignItems = 'flex-start';\n        return this;\n    }\n    /**\n     * Sets the left position of the overlay. Clears any previously set horizontal position.\n     * @param value New left offset.\n     */\n    left(value = '') {\n        this._xOffset = value;\n        this._xPosition = 'left';\n        return this;\n    }\n    /**\n     * Sets the bottom position of the overlay. Clears any previously set vertical position.\n     * @param value New bottom offset.\n     */\n    bottom(value = '') {\n        this._topOffset = '';\n        this._bottomOffset = value;\n        this._alignItems = 'flex-end';\n        return this;\n    }\n    /**\n     * Sets the right position of the overlay. Clears any previously set horizontal position.\n     * @param value New right offset.\n     */\n    right(value = '') {\n        this._xOffset = value;\n        this._xPosition = 'right';\n        return this;\n    }\n    /**\n     * Sets the overlay to the start of the viewport, depending on the overlay direction.\n     * This will be to the left in LTR layouts and to the right in RTL.\n     * @param offset Offset from the edge of the screen.\n     */\n    start(value = '') {\n        this._xOffset = value;\n        this._xPosition = 'start';\n        return this;\n    }\n    /**\n     * Sets the overlay to the end of the viewport, depending on the overlay direction.\n     * This will be to the right in LTR layouts and to the left in RTL.\n     * @param offset Offset from the edge of the screen.\n     */\n    end(value = '') {\n        this._xOffset = value;\n        this._xPosition = 'end';\n        return this;\n    }\n    /**\n     * Sets the overlay width and clears any previously set width.\n     * @param value New width for the overlay\n     * @deprecated Pass the `width` through the `OverlayConfig`.\n     * @breaking-change 8.0.0\n     */\n    width(value = '') {\n        if (this._overlayRef) {\n            this._overlayRef.updateSize({ width: value });\n        }\n        else {\n            this._width = value;\n        }\n        return this;\n    }\n    /**\n     * Sets the overlay height and clears any previously set height.\n     * @param value New height for the overlay\n     * @deprecated Pass the `height` through the `OverlayConfig`.\n     * @breaking-change 8.0.0\n     */\n    height(value = '') {\n        if (this._overlayRef) {\n            this._overlayRef.updateSize({ height: value });\n        }\n        else {\n            this._height = value;\n        }\n        return this;\n    }\n    /**\n     * Centers the overlay horizontally with an optional offset.\n     * Clears any previously set horizontal position.\n     *\n     * @param offset Overlay offset from the horizontal center.\n     */\n    centerHorizontally(offset = '') {\n        this.left(offset);\n        this._xPosition = 'center';\n        return this;\n    }\n    /**\n     * Centers the overlay vertically with an optional offset.\n     * Clears any previously set vertical position.\n     *\n     * @param offset Overlay offset from the vertical center.\n     */\n    centerVertically(offset = '') {\n        this.top(offset);\n        this._alignItems = 'center';\n        return this;\n    }\n    /**\n     * Apply the position to the element.\n     * @docs-private\n     */\n    apply() {\n        // Since the overlay ref applies the strategy asynchronously, it could\n        // have been disposed before it ends up being applied. If that is the\n        // case, we shouldn't do anything.\n        if (!this._overlayRef || !this._overlayRef.hasAttached()) {\n            return;\n        }\n        const styles = this._overlayRef.overlayElement.style;\n        const parentStyles = this._overlayRef.hostElement.style;\n        const config = this._overlayRef.getConfig();\n        const { width, height, maxWidth, maxHeight } = config;\n        const shouldBeFlushHorizontally = (width === '100%' || width === '100vw') &&\n            (!maxWidth || maxWidth === '100%' || maxWidth === '100vw');\n        const shouldBeFlushVertically = (height === '100%' || height === '100vh') &&\n            (!maxHeight || maxHeight === '100%' || maxHeight === '100vh');\n        const xPosition = this._xPosition;\n        const xOffset = this._xOffset;\n        const isRtl = this._overlayRef.getConfig().direction === 'rtl';\n        let marginLeft = '';\n        let marginRight = '';\n        let justifyContent = '';\n        if (shouldBeFlushHorizontally) {\n            justifyContent = 'flex-start';\n        }\n        else if (xPosition === 'center') {\n            justifyContent = 'center';\n            if (isRtl) {\n                marginRight = xOffset;\n            }\n            else {\n                marginLeft = xOffset;\n            }\n        }\n        else if (isRtl) {\n            if (xPosition === 'left' || xPosition === 'end') {\n                justifyContent = 'flex-end';\n                marginLeft = xOffset;\n            }\n            else if (xPosition === 'right' || xPosition === 'start') {\n                justifyContent = 'flex-start';\n                marginRight = xOffset;\n            }\n        }\n        else if (xPosition === 'left' || xPosition === 'start') {\n            justifyContent = 'flex-start';\n            marginLeft = xOffset;\n        }\n        else if (xPosition === 'right' || xPosition === 'end') {\n            justifyContent = 'flex-end';\n            marginRight = xOffset;\n        }\n        styles.position = this._cssPosition;\n        styles.marginLeft = shouldBeFlushHorizontally ? '0' : marginLeft;\n        styles.marginTop = shouldBeFlushVertically ? '0' : this._topOffset;\n        styles.marginBottom = this._bottomOffset;\n        styles.marginRight = shouldBeFlushHorizontally ? '0' : marginRight;\n        parentStyles.justifyContent = justifyContent;\n        parentStyles.alignItems = shouldBeFlushVertically ? 'flex-start' : this._alignItems;\n    }\n    /**\n     * Cleans up the DOM changes from the position strategy.\n     * @docs-private\n     */\n    dispose() {\n        if (this._isDisposed || !this._overlayRef) {\n            return;\n        }\n        const styles = this._overlayRef.overlayElement.style;\n        const parent = this._overlayRef.hostElement;\n        const parentStyles = parent.style;\n        parent.classList.remove(wrapperClass);\n        parentStyles.justifyContent =\n            parentStyles.alignItems =\n                styles.marginTop =\n                    styles.marginBottom =\n                        styles.marginLeft =\n                            styles.marginRight =\n                                styles.position =\n                                    '';\n        this._overlayRef = null;\n        this._isDisposed = true;\n    }\n}\n\n/** Builder for overlay position strategy. */\nclass OverlayPositionBuilder {\n    _injector = inject(Injector);\n    constructor() { }\n    /**\n     * Creates a global position strategy.\n     */\n    global() {\n        return createGlobalPositionStrategy();\n    }\n    /**\n     * Creates a flexible position strategy.\n     * @param origin Origin relative to which to position the overlay.\n     */\n    flexibleConnectedTo(origin) {\n        return createFlexibleConnectedPositionStrategy(this._injector, origin);\n    }\n    static fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: OverlayPositionBuilder, deps: [], target: i0.FactoryTarget.Injectable });\n    static prov = i0.ngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: OverlayPositionBuilder, providedIn: 'root' });\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: OverlayPositionBuilder, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [] });\n\n/**\n * Creates an overlay.\n * @param injector Injector to use when resolving the overlay's dependencies.\n * @param config Configuration applied to the overlay.\n * @returns Reference to the created overlay.\n */\nfunction createOverlayRef(injector, config) {\n    // This is done in the overlay container as well, but we have it here\n    // since it's common to mock out the overlay container in tests.\n    injector.get(_CdkPrivateStyleLoader).load(_CdkOverlayStyleLoader);\n    const overlayContainer = injector.get(OverlayContainer);\n    const doc = injector.get(DOCUMENT);\n    const idGenerator = injector.get(_IdGenerator);\n    const appRef = injector.get(ApplicationRef);\n    const directionality = injector.get(Directionality);\n    const host = doc.createElement('div');\n    const pane = doc.createElement('div');\n    pane.id = idGenerator.getId('cdk-overlay-');\n    pane.classList.add('cdk-overlay-pane');\n    host.appendChild(pane);\n    overlayContainer.getContainerElement().appendChild(host);\n    const portalOutlet = new DomPortalOutlet(pane, appRef, injector);\n    const overlayConfig = new OverlayConfig(config);\n    const renderer = injector.get(Renderer2, null, { optional: true }) ||\n        injector.get(RendererFactory2).createRenderer(null, null);\n    overlayConfig.direction = overlayConfig.direction || directionality.value;\n    return new OverlayRef(portalOutlet, host, pane, overlayConfig, injector.get(NgZone), injector.get(OverlayKeyboardDispatcher), doc, injector.get(Location), injector.get(OverlayOutsideClickDispatcher), config?.disableAnimations ??\n        injector.get(ANIMATION_MODULE_TYPE, null, { optional: true }) === 'NoopAnimations', injector.get(EnvironmentInjector), renderer);\n}\n/**\n * Service to create Overlays. Overlays are dynamically added pieces of floating UI, meant to be\n * used as a low-level building block for other components. Dialogs, tooltips, menus,\n * selects, etc. can all be built using overlays. The service should primarily be used by authors\n * of re-usable components rather than developers building end-user applications.\n *\n * An overlay *is* a PortalOutlet, so any kind of Portal can be loaded into one.\n */\nclass Overlay {\n    scrollStrategies = inject(ScrollStrategyOptions);\n    _positionBuilder = inject(OverlayPositionBuilder);\n    _injector = inject(Injector);\n    constructor() { }\n    /**\n     * Creates an overlay.\n     * @param config Configuration applied to the overlay.\n     * @returns Reference to the created overlay.\n     */\n    create(config) {\n        return createOverlayRef(this._injector, config);\n    }\n    /**\n     * Gets a position builder that can be used, via fluent API,\n     * to construct and configure a position strategy.\n     * @returns An overlay position builder.\n     */\n    position() {\n        return this._positionBuilder;\n    }\n    static fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: Overlay, deps: [], target: i0.FactoryTarget.Injectable });\n    static prov = i0.ngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: Overlay, providedIn: 'root' });\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: Overlay, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: () => [] });\n\n/** Default set of positions for the overlay. Follows the behavior of a dropdown. */\nconst defaultPositionList = [\n    {\n        originX: 'start',\n        originY: 'bottom',\n        overlayX: 'start',\n        overlayY: 'top',\n    },\n    {\n        originX: 'start',\n        originY: 'top',\n        overlayX: 'start',\n        overlayY: 'bottom',\n    },\n    {\n        originX: 'end',\n        originY: 'top',\n        overlayX: 'end',\n        overlayY: 'bottom',\n    },\n    {\n        originX: 'end',\n        originY: 'bottom',\n        overlayX: 'end',\n        overlayY: 'top',\n    },\n];\n/** Injection token that determines the scroll handling while the connected overlay is open. */\nconst CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY = new InjectionToken('cdk-connected-overlay-scroll-strategy', {\n    providedIn: 'root',\n    factory: () => {\n        const injector = inject(Injector);\n        return () => createRepositionScrollStrategy(injector);\n    },\n});\n/**\n * Directive applied to an element to make it usable as an origin for an Overlay using a\n * ConnectedPositionStrategy.\n */\nclass CdkOverlayOrigin {\n    elementRef = inject(ElementRef);\n    constructor() { }\n    static fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: CdkOverlayOrigin, deps: [], target: i0.FactoryTarget.Directive });\n    static dir = i0.ngDeclareDirective({ minVersion: \"14.0.0\", version: \"20.2.0-next.2\", type: CdkOverlayOrigin, isStandalone: true, selector: \"[cdk-overlay-origin], [overlay-origin], [cdkOverlayOrigin]\", exportAs: [\"cdkOverlayOrigin\"], ngImport: i0 });\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: CdkOverlayOrigin, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[cdk-overlay-origin], [overlay-origin], [cdkOverlayOrigin]',\n                    exportAs: 'cdkOverlayOrigin',\n                }]\n        }], ctorParameters: () => [] });\n/**\n * Directive to facilitate declarative creation of an\n * Overlay using a FlexibleConnectedPositionStrategy.\n */\nclass CdkConnectedOverlay {\n    _dir = inject(Directionality, { optional: true });\n    _injector = inject(Injector);\n    _overlayRef;\n    _templatePortal;\n    _backdropSubscription = Subscription.EMPTY;\n    _attachSubscription = Subscription.EMPTY;\n    _detachSubscription = Subscription.EMPTY;\n    _positionSubscription = Subscription.EMPTY;\n    _offsetX;\n    _offsetY;\n    _position;\n    _scrollStrategyFactory = inject(CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY);\n    _disposeOnNavigation = false;\n    _ngZone = inject(NgZone);\n    /** Origin for the connected overlay. */\n    origin;\n    /** Registered connected position pairs. */\n    positions;\n    /**\n     * This input overrides the positions input if specified. It lets users pass\n     * in arbitrary positioning strategies.\n     */\n    positionStrategy;\n    /** The offset in pixels for the overlay connection point on the x-axis */\n    get offsetX() {\n        return this._offsetX;\n    }\n    set offsetX(offsetX) {\n        this._offsetX = offsetX;\n        if (this._position) {\n            this._updatePositionStrategy(this._position);\n        }\n    }\n    /** The offset in pixels for the overlay connection point on the y-axis */\n    get offsetY() {\n        return this._offsetY;\n    }\n    set offsetY(offsetY) {\n        this._offsetY = offsetY;\n        if (this._position) {\n            this._updatePositionStrategy(this._position);\n        }\n    }\n    /** The width of the overlay panel. */\n    width;\n    /** The height of the overlay panel. */\n    height;\n    /** The min width of the overlay panel. */\n    minWidth;\n    /** The min height of the overlay panel. */\n    minHeight;\n    /** The custom class to be set on the backdrop element. */\n    backdropClass;\n    /** The custom class to add to the overlay pane element. */\n    panelClass;\n    /** Margin between the overlay and the viewport edges. */\n    viewportMargin = 0;\n    /** Strategy to be used when handling scroll events while the overlay is open. */\n    scrollStrategy;\n    /** Whether the overlay is open. */\n    open = false;\n    /** Whether the overlay can be closed by user interaction. */\n    disableClose = false;\n    /** CSS selector which to set the transform origin. */\n    transformOriginSelector;\n    /** Whether or not the overlay should attach a backdrop. */\n    hasBackdrop = false;\n    /** Whether or not the overlay should be locked when scrolling. */\n    lockPosition = false;\n    /** Whether the overlay's width and height can be constrained to fit within the viewport. */\n    flexibleDimensions = false;\n    /** Whether the overlay can grow after the initial open when flexible positioning is turned on. */\n    growAfterOpen = false;\n    /** Whether the overlay can be pushed on-screen if none of the provided positions fit. */\n    push = false;\n    /** Whether the overlay should be disposed of when the user goes backwards/forwards in history. */\n    get disposeOnNavigation() {\n        return this._disposeOnNavigation;\n    }\n    set disposeOnNavigation(value) {\n        this._disposeOnNavigation = value;\n    }\n    /** Event emitted when the backdrop is clicked. */\n    backdropClick = new EventEmitter();\n    /** Event emitted when the position has changed. */\n    positionChange = new EventEmitter();\n    /** Event emitted when the overlay has been attached. */\n    attach = new EventEmitter();\n    /** Event emitted when the overlay has been detached. */\n    detach = new EventEmitter();\n    /** Emits when there are keyboard events that are targeted at the overlay. */\n    overlayKeydown = new EventEmitter();\n    /** Emits when there are mouse outside click events that are targeted at the overlay. */\n    overlayOutsideClick = new EventEmitter();\n    // TODO(jelbourn): inputs for size, scroll behavior, animation, etc.\n    constructor() {\n        const templateRef = inject(TemplateRef);\n        const viewContainerRef = inject(ViewContainerRef);\n        this._templatePortal = new TemplatePortal(templateRef, viewContainerRef);\n        this.scrollStrategy = this._scrollStrategyFactory();\n    }\n    /** The associated overlay reference. */\n    get overlayRef() {\n        return this._overlayRef;\n    }\n    /** The element's layout direction. */\n    get dir() {\n        return this._dir ? this._dir.value : 'ltr';\n    }\n    ngOnDestroy() {\n        this._attachSubscription.unsubscribe();\n        this._detachSubscription.unsubscribe();\n        this._backdropSubscription.unsubscribe();\n        this._positionSubscription.unsubscribe();\n        this._overlayRef?.dispose();\n    }\n    ngOnChanges(changes) {\n        if (this._position) {\n            this._updatePositionStrategy(this._position);\n            this._overlayRef?.updateSize({\n                width: this.width,\n                minWidth: this.minWidth,\n                height: this.height,\n                minHeight: this.minHeight,\n            });\n            if (changes['origin'] && this.open) {\n                this._position.apply();\n            }\n        }\n        if (changes['open']) {\n            this.open ? this.attachOverlay() : this.detachOverlay();\n        }\n    }\n    /** Creates an overlay */\n    _createOverlay() {\n        if (!this.positions || !this.positions.length) {\n            this.positions = defaultPositionList;\n        }\n        const overlayRef = (this._overlayRef = createOverlayRef(this._injector, this._buildConfig()));\n        this._attachSubscription = overlayRef.attachments().subscribe(() => this.attach.emit());\n        this._detachSubscription = overlayRef.detachments().subscribe(() => this.detach.emit());\n        overlayRef.keydownEvents().subscribe((event) => {\n            this.overlayKeydown.next(event);\n            if (event.keyCode === ESCAPE && !this.disableClose && !hasModifierKey(event)) {\n                event.preventDefault();\n                this.detachOverlay();\n            }\n        });\n        this._overlayRef.outsidePointerEvents().subscribe((event) => {\n            const origin = this._getOriginElement();\n            const target = _getEventTarget(event);\n            if (!origin || (origin !== target && !origin.contains(target))) {\n                this.overlayOutsideClick.next(event);\n            }\n        });\n    }\n    /** Builds the overlay config based on the directive's inputs */\n    _buildConfig() {\n        const positionStrategy = (this._position =\n            this.positionStrategy || this._createPositionStrategy());\n        const overlayConfig = new OverlayConfig({\n            direction: this._dir || 'ltr',\n            positionStrategy,\n            scrollStrategy: this.scrollStrategy,\n            hasBackdrop: this.hasBackdrop,\n            disposeOnNavigation: this.disposeOnNavigation,\n        });\n        if (this.width || this.width === 0) {\n            overlayConfig.width = this.width;\n        }\n        if (this.height || this.height === 0) {\n            overlayConfig.height = this.height;\n        }\n        if (this.minWidth || this.minWidth === 0) {\n            overlayConfig.minWidth = this.minWidth;\n        }\n        if (this.minHeight || this.minHeight === 0) {\n            overlayConfig.minHeight = this.minHeight;\n        }\n        if (this.backdropClass) {\n            overlayConfig.backdropClass = this.backdropClass;\n        }\n        if (this.panelClass) {\n            overlayConfig.panelClass = this.panelClass;\n        }\n        return overlayConfig;\n    }\n    /** Updates the state of a position strategy, based on the values of the directive inputs. */\n    _updatePositionStrategy(positionStrategy) {\n        const positions = this.positions.map(currentPosition => ({\n            originX: currentPosition.originX,\n            originY: currentPosition.originY,\n            overlayX: currentPosition.overlayX,\n            overlayY: currentPosition.overlayY,\n            offsetX: currentPosition.offsetX || this.offsetX,\n            offsetY: currentPosition.offsetY || this.offsetY,\n            panelClass: currentPosition.panelClass || undefined,\n        }));\n        return positionStrategy\n            .setOrigin(this._getOrigin())\n            .withPositions(positions)\n            .withFlexibleDimensions(this.flexibleDimensions)\n            .withPush(this.push)\n            .withGrowAfterOpen(this.growAfterOpen)\n            .withViewportMargin(this.viewportMargin)\n            .withLockedPosition(this.lockPosition)\n            .withTransformOriginOn(this.transformOriginSelector);\n    }\n    /** Returns the position strategy of the overlay to be set on the overlay config */\n    _createPositionStrategy() {\n        const strategy = createFlexibleConnectedPositionStrategy(this._injector, this._getOrigin());\n        this._updatePositionStrategy(strategy);\n        return strategy;\n    }\n    _getOrigin() {\n        if (this.origin instanceof CdkOverlayOrigin) {\n            return this.origin.elementRef;\n        }\n        else {\n            return this.origin;\n        }\n    }\n    _getOriginElement() {\n        if (this.origin instanceof CdkOverlayOrigin) {\n            return this.origin.elementRef.nativeElement;\n        }\n        if (this.origin instanceof ElementRef) {\n            return this.origin.nativeElement;\n        }\n        if (typeof Element !== 'undefined' && this.origin instanceof Element) {\n            return this.origin;\n        }\n        return null;\n    }\n    /** Attaches the overlay. */\n    attachOverlay() {\n        if (!this._overlayRef) {\n            this._createOverlay();\n        }\n        else {\n            // Update the overlay size, in case the directive's inputs have changed\n            this._overlayRef.getConfig().hasBackdrop = this.hasBackdrop;\n        }\n        if (!this._overlayRef.hasAttached()) {\n            this._overlayRef.attach(this._templatePortal);\n        }\n        if (this.hasBackdrop) {\n            this._backdropSubscription = this._overlayRef.backdropClick().subscribe(event => {\n                this.backdropClick.emit(event);\n            });\n        }\n        else {\n            this._backdropSubscription.unsubscribe();\n        }\n        this._positionSubscription.unsubscribe();\n        // Only subscribe to `positionChanges` if requested, because putting\n        // together all the information for it can be expensive.\n        if (this.positionChange.observers.length > 0) {\n            this._positionSubscription = this._position.positionChanges\n                .pipe(takeWhile(() => this.positionChange.observers.length > 0))\n                .subscribe(position => {\n                this._ngZone.run(() => this.positionChange.emit(position));\n                if (this.positionChange.observers.length === 0) {\n                    this._positionSubscription.unsubscribe();\n                }\n            });\n        }\n        this.open = true;\n    }\n    /** Detaches the overlay. */\n    detachOverlay() {\n        this._overlayRef?.detach();\n        this._backdropSubscription.unsubscribe();\n        this._positionSubscription.unsubscribe();\n        this.open = false;\n    }\n    static fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: CdkConnectedOverlay, deps: [], target: i0.FactoryTarget.Directive });\n    static dir = i0.ngDeclareDirective({ minVersion: \"16.1.0\", version: \"20.2.0-next.2\", type: CdkConnectedOverlay, isStandalone: true, selector: \"[cdk-connected-overlay], [connected-overlay], [cdkConnectedOverlay]\", inputs: { origin: [\"cdkConnectedOverlayOrigin\", \"origin\"], positions: [\"cdkConnectedOverlayPositions\", \"positions\"], positionStrategy: [\"cdkConnectedOverlayPositionStrategy\", \"positionStrategy\"], offsetX: [\"cdkConnectedOverlayOffsetX\", \"offsetX\"], offsetY: [\"cdkConnectedOverlayOffsetY\", \"offsetY\"], width: [\"cdkConnectedOverlayWidth\", \"width\"], height: [\"cdkConnectedOverlayHeight\", \"height\"], minWidth: [\"cdkConnectedOverlayMinWidth\", \"minWidth\"], minHeight: [\"cdkConnectedOverlayMinHeight\", \"minHeight\"], backdropClass: [\"cdkConnectedOverlayBackdropClass\", \"backdropClass\"], panelClass: [\"cdkConnectedOverlayPanelClass\", \"panelClass\"], viewportMargin: [\"cdkConnectedOverlayViewportMargin\", \"viewportMargin\"], scrollStrategy: [\"cdkConnectedOverlayScrollStrategy\", \"scrollStrategy\"], open: [\"cdkConnectedOverlayOpen\", \"open\"], disableClose: [\"cdkConnectedOverlayDisableClose\", \"disableClose\"], transformOriginSelector: [\"cdkConnectedOverlayTransformOriginOn\", \"transformOriginSelector\"], hasBackdrop: [\"cdkConnectedOverlayHasBackdrop\", \"hasBackdrop\", booleanAttribute], lockPosition: [\"cdkConnectedOverlayLockPosition\", \"lockPosition\", booleanAttribute], flexibleDimensions: [\"cdkConnectedOverlayFlexibleDimensions\", \"flexibleDimensions\", booleanAttribute], growAfterOpen: [\"cdkConnectedOverlayGrowAfterOpen\", \"growAfterOpen\", booleanAttribute], push: [\"cdkConnectedOverlayPush\", \"push\", booleanAttribute], disposeOnNavigation: [\"cdkConnectedOverlayDisposeOnNavigation\", \"disposeOnNavigation\", booleanAttribute] }, outputs: { backdropClick: \"backdropClick\", positionChange: \"positionChange\", attach: \"attach\", detach: \"detach\", overlayKeydown: \"overlayKeydown\", overlayOutsideClick: \"overlayOutsideClick\" }, exportAs: [\"cdkConnectedOverlay\"], usesOnChanges: true, ngImport: i0 });\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: CdkConnectedOverlay, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[cdk-connected-overlay], [connected-overlay], [cdkConnectedOverlay]',\n                    exportAs: 'cdkConnectedOverlay',\n                }]\n        }], ctorParameters: () => [], propDecorators: { origin: [{\n                type: Input,\n                args: ['cdkConnectedOverlayOrigin']\n            }], positions: [{\n                type: Input,\n                args: ['cdkConnectedOverlayPositions']\n            }], positionStrategy: [{\n                type: Input,\n                args: ['cdkConnectedOverlayPositionStrategy']\n            }], offsetX: [{\n                type: Input,\n                args: ['cdkConnectedOverlayOffsetX']\n            }], offsetY: [{\n                type: Input,\n                args: ['cdkConnectedOverlayOffsetY']\n            }], width: [{\n                type: Input,\n                args: ['cdkConnectedOverlayWidth']\n            }], height: [{\n                type: Input,\n                args: ['cdkConnectedOverlayHeight']\n            }], minWidth: [{\n                type: Input,\n                args: ['cdkConnectedOverlayMinWidth']\n            }], minHeight: [{\n                type: Input,\n                args: ['cdkConnectedOverlayMinHeight']\n            }], backdropClass: [{\n                type: Input,\n                args: ['cdkConnectedOverlayBackdropClass']\n            }], panelClass: [{\n                type: Input,\n                args: ['cdkConnectedOverlayPanelClass']\n            }], viewportMargin: [{\n                type: Input,\n                args: ['cdkConnectedOverlayViewportMargin']\n            }], scrollStrategy: [{\n                type: Input,\n                args: ['cdkConnectedOverlayScrollStrategy']\n            }], open: [{\n                type: Input,\n                args: ['cdkConnectedOverlayOpen']\n            }], disableClose: [{\n                type: Input,\n                args: ['cdkConnectedOverlayDisableClose']\n            }], transformOriginSelector: [{\n                type: Input,\n                args: ['cdkConnectedOverlayTransformOriginOn']\n            }], hasBackdrop: [{\n                type: Input,\n                args: [{ alias: 'cdkConnectedOverlayHasBackdrop', transform: booleanAttribute }]\n            }], lockPosition: [{\n                type: Input,\n                args: [{ alias: 'cdkConnectedOverlayLockPosition', transform: booleanAttribute }]\n            }], flexibleDimensions: [{\n                type: Input,\n                args: [{ alias: 'cdkConnectedOverlayFlexibleDimensions', transform: booleanAttribute }]\n            }], growAfterOpen: [{\n                type: Input,\n                args: [{ alias: 'cdkConnectedOverlayGrowAfterOpen', transform: booleanAttribute }]\n            }], push: [{\n                type: Input,\n                args: [{ alias: 'cdkConnectedOverlayPush', transform: booleanAttribute }]\n            }], disposeOnNavigation: [{\n                type: Input,\n                args: [{ alias: 'cdkConnectedOverlayDisposeOnNavigation', transform: booleanAttribute }]\n            }], backdropClick: [{\n                type: Output\n            }], positionChange: [{\n                type: Output\n            }], attach: [{\n                type: Output\n            }], detach: [{\n                type: Output\n            }], overlayKeydown: [{\n                type: Output\n            }], overlayOutsideClick: [{\n                type: Output\n            }] } });\n/**\n * @docs-private\n * @deprecated No longer used, will be removed.\n * @breaking-change 21.0.0\n */\nfunction CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay) {\n    const injector = inject(Injector);\n    return () => createRepositionScrollStrategy(injector);\n}\n/**\n * @docs-private\n * @deprecated No longer used, will be removed.\n * @breaking-change 21.0.0\n */\nconst CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER = {\n    provide: CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY,\n    useFactory: CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY,\n};\n\nclass OverlayModule {\n    static fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: OverlayModule, deps: [], target: i0.FactoryTarget.NgModule });\n    static mod = i0.ngDeclareNgModule({ minVersion: \"14.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: OverlayModule, imports: [BidiModule, PortalModule, ScrollingModule, CdkConnectedOverlay, CdkOverlayOrigin], exports: [CdkConnectedOverlay, CdkOverlayOrigin, ScrollingModule] });\n    static inj = i0.ngDeclareInjector({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: OverlayModule, providers: [Overlay, CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER], imports: [BidiModule, PortalModule, ScrollingModule, ScrollingModule] });\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: OverlayModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [BidiModule, PortalModule, ScrollingModule, CdkConnectedOverlay, CdkOverlayOrigin],\n                    exports: [CdkConnectedOverlay, CdkOverlayOrigin, ScrollingModule],\n                    providers: [Overlay, CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER],\n                }]\n        }] });\n\nexport { BlockScrollStrategy, CdkConnectedOverlay, CdkOverlayOrigin, CloseScrollStrategy, ConnectedOverlayPositionChange, ConnectionPositionPair, FlexibleConnectedPositionStrategy, GlobalPositionStrategy, NoopScrollStrategy, Overlay, OverlayConfig, OverlayContainer, OverlayKeyboardDispatcher, OverlayModule, OverlayOutsideClickDispatcher, OverlayPositionBuilder, OverlayRef, RepositionScrollStrategy, STANDARD_DROPDOWN_ADJACENT_POSITIONS, STANDARD_DROPDOWN_BELOW_POSITIONS, ScrollStrategyOptions, ScrollingVisibility, createBlockScrollStrategy, createCloseScrollStrategy, createFlexibleConnectedPositionStrategy, createGlobalPositionStrategy, createNoopScrollStrategy, createOverlayRef, createRepositionScrollStrategy, validateHorizontalPosition, validateVerticalPosition };\n","import { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function takeWhile(predicate, inclusive = false) {\n    return operate((source, subscriber) => {\n        let index = 0;\n        source.subscribe(createOperatorSubscriber(subscriber, (value) => {\n            const result = predicate(value, index++);\n            (result || inclusive) && subscriber.next(value);\n            !result && subscriber.complete();\n        }));\n    });\n}\n","let shadowDomIsSupported;\n/** Checks whether the user's browser support Shadow DOM. */\nfunction _supportsShadowDom() {\n    if (shadowDomIsSupported == null) {\n        const head = typeof document !== 'undefined' ? document.head : null;\n        shadowDomIsSupported = !!(head && (head.createShadowRoot || head.attachShadow));\n    }\n    return shadowDomIsSupported;\n}\n/** Gets the shadow root of an element, if supported and the element is inside the Shadow DOM. */\nfunction _getShadowRoot(element) {\n    if (_supportsShadowDom()) {\n        const rootNode = element.getRootNode ? element.getRootNode() : null;\n        // Note that this should be caught by `_supportsShadowDom`, but some\n        // teams have been able to hit this code path on unsupported browsers.\n        if (typeof ShadowRoot !== 'undefined' && ShadowRoot && rootNode instanceof ShadowRoot) {\n            return rootNode;\n        }\n    }\n    return null;\n}\n/**\n * Gets the currently-focused element on the page while\n * also piercing through Shadow DOM boundaries.\n */\nfunction _getFocusedElementPierceShadowDom() {\n    let activeElement = typeof document !== 'undefined' && document\n        ? document.activeElement\n        : null;\n    while (activeElement && activeElement.shadowRoot) {\n        const newActiveElement = activeElement.shadowRoot.activeElement;\n        if (newActiveElement === activeElement) {\n            break;\n        }\n        else {\n            activeElement = newActiveElement;\n        }\n    }\n    return activeElement;\n}\n/** Gets the target of an event while accounting for Shadow DOM. */\nfunction _getEventTarget(event) {\n    // If an event is bound outside the Shadow DOM, the `event.target` will\n    // point to the shadow root so we have to use `composedPath` instead.\n    return (event.composedPath ? event.composedPath()[0] : event.target);\n}\n\nexport { _getEventTarget, _getFocusedElementPierceShadowDom, _getShadowRoot, _supportsShadowDom };\n","import * as i0 from '@angular/core';\nimport { inject, Injector, EnvironmentInjector, ApplicationRef, createComponent, Injectable } from '@angular/core';\n\n/** Apps in which we've loaded styles. */\nconst appsWithLoaders = new WeakMap();\n/**\n * Service that loads structural styles dynamically\n * and ensures that they're only loaded once per app.\n */\nclass _CdkPrivateStyleLoader {\n    _appRef;\n    _injector = inject(Injector);\n    _environmentInjector = inject(EnvironmentInjector);\n    /**\n     * Loads a set of styles.\n     * @param loader Component which will be instantiated to load the styles.\n     */\n    load(loader) {\n        // Resolve the app ref lazily to avoid circular dependency errors if this is called too early.\n        const appRef = (this._appRef = this._appRef || this._injector.get(ApplicationRef));\n        let data = appsWithLoaders.get(appRef);\n        // If we haven't loaded for this app before, we have to initialize it.\n        if (!data) {\n            data = { loaders: new Set(), refs: [] };\n            appsWithLoaders.set(appRef, data);\n            // When the app is destroyed, we need to clean up all the related loaders.\n            appRef.onDestroy(() => {\n                appsWithLoaders.get(appRef)?.refs.forEach(ref => ref.destroy());\n                appsWithLoaders.delete(appRef);\n            });\n        }\n        // If the loader hasn't been loaded before, we need to instatiate it.\n        if (!data.loaders.has(loader)) {\n            data.loaders.add(loader);\n            data.refs.push(createComponent(loader, { environmentInjector: this._environmentInjector }));\n        }\n    }\n    static fac = i0.ngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: _CdkPrivateStyleLoader, deps: [], target: i0.FactoryTarget.Injectable });\n    static prov = i0.ngDeclareInjectable({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: _CdkPrivateStyleLoader, providedIn: 'root' });\n}\ni0.ngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: _CdkPrivateStyleLoader, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }] });\n\nexport { _CdkPrivateStyleLoader };\n","/** Gets whether the code is currently running in a test environment. */\nfunction _isTestEnvironment() {\n    // We can't use `declare const` because it causes conflicts inside Google with the real typings\n    // for these symbols and we can't read them off the global object, because they don't appear to\n    // be attached there for some runners like Jest.\n    // (see: https://github.com/angular/components/issues/23365#issuecomment-938146643)\n    return (\n    // @ts-ignore\n    (typeof __karma__ !== 'undefined' && !!__karma__) ||\n        // @ts-ignore\n        (typeof jasmine !== 'undefined' && !!jasmine) ||\n        // @ts-ignore\n        (typeof jest !== 'undefined' && !!jest) ||\n        // @ts-ignore\n        (typeof Mocha !== 'undefined' && !!Mocha));\n}\n\nexport { _isTestEnvironment };\n"],"x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9]}