{
  "version": 3,
  "sources": ["../../@ngrx/store-devtools/fesm2022/ngrx-store-devtools.mjs"],
  "sourcesContent": ["import * as i0 from '@angular/core';\nimport { InjectionToken, inject, NgZone, Injectable, Inject, makeEnvironmentProviders, NgModule } from '@angular/core';\nimport * as i2 from '@ngrx/store';\nimport { ActionsSubject, UPDATE, INIT, INITIAL_STATE, StateObservable, ReducerManagerDispatcher } from '@ngrx/store';\nimport { EMPTY, Observable, of, merge, queueScheduler, ReplaySubject } from 'rxjs';\nimport { share, filter, map, concatMap, timeout, debounceTime, catchError, take, takeUntil, switchMap, skip, observeOn, withLatestFrom, scan } from 'rxjs/operators';\nimport { toSignal } from '@angular/core/rxjs-interop';\nconst PERFORM_ACTION = 'PERFORM_ACTION';\nconst REFRESH = 'REFRESH';\nconst RESET = 'RESET';\nconst ROLLBACK = 'ROLLBACK';\nconst COMMIT = 'COMMIT';\nconst SWEEP = 'SWEEP';\nconst TOGGLE_ACTION = 'TOGGLE_ACTION';\nconst SET_ACTIONS_ACTIVE = 'SET_ACTIONS_ACTIVE';\nconst JUMP_TO_STATE = 'JUMP_TO_STATE';\nconst JUMP_TO_ACTION = 'JUMP_TO_ACTION';\nconst IMPORT_STATE = 'IMPORT_STATE';\nconst LOCK_CHANGES = 'LOCK_CHANGES';\nconst PAUSE_RECORDING = 'PAUSE_RECORDING';\nclass PerformAction {\n  constructor(action, timestamp) {\n    this.action = action;\n    this.timestamp = timestamp;\n    this.type = PERFORM_ACTION;\n    if (typeof action.type === 'undefined') {\n      throw new Error('Actions may not have an undefined \"type\" property. ' + 'Have you misspelled a constant?');\n    }\n  }\n}\nclass Refresh {\n  constructor() {\n    this.type = REFRESH;\n  }\n}\nclass Reset {\n  constructor(timestamp) {\n    this.timestamp = timestamp;\n    this.type = RESET;\n  }\n}\nclass Rollback {\n  constructor(timestamp) {\n    this.timestamp = timestamp;\n    this.type = ROLLBACK;\n  }\n}\nclass Commit {\n  constructor(timestamp) {\n    this.timestamp = timestamp;\n    this.type = COMMIT;\n  }\n}\nclass Sweep {\n  constructor() {\n    this.type = SWEEP;\n  }\n}\nclass ToggleAction {\n  constructor(id) {\n    this.id = id;\n    this.type = TOGGLE_ACTION;\n  }\n}\nclass SetActionsActive {\n  constructor(start, end, active = true) {\n    this.start = start;\n    this.end = end;\n    this.active = active;\n    this.type = SET_ACTIONS_ACTIVE;\n  }\n}\nclass JumpToState {\n  constructor(index) {\n    this.index = index;\n    this.type = JUMP_TO_STATE;\n  }\n}\nclass JumpToAction {\n  constructor(actionId) {\n    this.actionId = actionId;\n    this.type = JUMP_TO_ACTION;\n  }\n}\nclass ImportState {\n  constructor(nextLiftedState) {\n    this.nextLiftedState = nextLiftedState;\n    this.type = IMPORT_STATE;\n  }\n}\nclass LockChanges {\n  constructor(status) {\n    this.status = status;\n    this.type = LOCK_CHANGES;\n  }\n}\nclass PauseRecording {\n  constructor(status) {\n    this.status = status;\n    this.type = PAUSE_RECORDING;\n  }\n}\n\n/**\n * Chrome extension documentation\n * @see https://github.com/reduxjs/redux-devtools/blob/main/extension/docs/API/Arguments.md\n * Firefox extension documentation\n * @see https://github.com/zalmoxisus/redux-devtools-extension/blob/master/docs/API/Arguments.md\n */\nclass StoreDevtoolsConfig {\n  constructor() {\n    /**\n     * Maximum allowed actions to be stored in the history tree (default: `false`)\n     */\n    this.maxAge = false;\n  }\n}\nconst STORE_DEVTOOLS_CONFIG = /*#__PURE__*/new InjectionToken('@ngrx/store-devtools Options');\n/**\n * Used to provide a `StoreDevtoolsConfig` for the store-devtools.\n */\nconst INITIAL_OPTIONS = /*#__PURE__*/new InjectionToken('@ngrx/store-devtools Initial Config');\nfunction noMonitor() {\n  return null;\n}\nconst DEFAULT_NAME = 'NgRx Store DevTools';\nfunction createConfig(optionsInput) {\n  const DEFAULT_OPTIONS = {\n    maxAge: false,\n    monitor: noMonitor,\n    actionSanitizer: undefined,\n    stateSanitizer: undefined,\n    name: DEFAULT_NAME,\n    serialize: false,\n    logOnly: false,\n    autoPause: false,\n    trace: false,\n    traceLimit: 75,\n    // Add all features explicitly. This prevent buggy behavior for\n    // options like \"lock\" which might otherwise not show up.\n    features: {\n      pause: true,\n      // Start/pause recording of dispatched actions\n      lock: true,\n      // Lock/unlock dispatching actions and side effects\n      persist: true,\n      // Persist states on page reloading\n      export: true,\n      // Export history of actions in a file\n      import: 'custom',\n      // Import history of actions from a file\n      jump: true,\n      // Jump back and forth (time travelling)\n      skip: true,\n      // Skip (cancel) actions\n      reorder: true,\n      // Drag and drop actions in the history list\n      dispatch: true,\n      // Dispatch custom actions or action creators\n      test: true // Generate tests for the selected actions\n    },\n    connectInZone: false\n  };\n  const options = typeof optionsInput === 'function' ? optionsInput() : optionsInput;\n  const logOnly = options.logOnly ? {\n    pause: true,\n    export: true,\n    test: true\n  } : false;\n  const features = options.features || logOnly || DEFAULT_OPTIONS.features;\n  if (features.import === true) {\n    features.import = 'custom';\n  }\n  const config = Object.assign({}, DEFAULT_OPTIONS, {\n    features\n  }, options);\n  if (config.maxAge && config.maxAge < 2) {\n    throw new Error(`Devtools 'maxAge' cannot be less than 2, got ${config.maxAge}`);\n  }\n  return config;\n}\nfunction difference(first, second) {\n  return first.filter(item => second.indexOf(item) < 0);\n}\n/**\n * Provides an app's view into the state of the lifted store.\n */\nfunction unliftState(liftedState) {\n  const {\n    computedStates,\n    currentStateIndex\n  } = liftedState;\n  // At start up NgRx dispatches init actions,\n  // When these init actions are being filtered out by the predicate or safe/block list options\n  // we don't have a complete computed states yet.\n  // At this point it could happen that we're out of bounds, when this happens we fall back to the last known state\n  if (currentStateIndex >= computedStates.length) {\n    const {\n      state\n    } = computedStates[computedStates.length - 1];\n    return state;\n  }\n  const {\n    state\n  } = computedStates[currentStateIndex];\n  return state;\n}\nfunction unliftAction(liftedState) {\n  return liftedState.actionsById[liftedState.nextActionId - 1];\n}\n/**\n * Lifts an app's action into an action on the lifted store.\n */\nfunction liftAction(action) {\n  return new PerformAction(action, +Date.now());\n}\n/**\n * Sanitizes given actions with given function.\n */\nfunction sanitizeActions(actionSanitizer, actions) {\n  return Object.keys(actions).reduce((sanitizedActions, actionIdx) => {\n    const idx = Number(actionIdx);\n    sanitizedActions[idx] = sanitizeAction(actionSanitizer, actions[idx], idx);\n    return sanitizedActions;\n  }, {});\n}\n/**\n * Sanitizes given action with given function.\n */\nfunction sanitizeAction(actionSanitizer, action, actionIdx) {\n  return {\n    ...action,\n    action: actionSanitizer(action.action, actionIdx)\n  };\n}\n/**\n * Sanitizes given states with given function.\n */\nfunction sanitizeStates(stateSanitizer, states) {\n  return states.map((computedState, idx) => ({\n    state: sanitizeState(stateSanitizer, computedState.state, idx),\n    error: computedState.error\n  }));\n}\n/**\n * Sanitizes given state with given function.\n */\nfunction sanitizeState(stateSanitizer, state, stateIdx) {\n  return stateSanitizer(state, stateIdx);\n}\n/**\n * Read the config and tell if actions should be filtered\n */\nfunction shouldFilterActions(config) {\n  return config.predicate || config.actionsSafelist || config.actionsBlocklist;\n}\n/**\n * Return a full filtered lifted state\n */\nfunction filterLiftedState(liftedState, predicate, safelist, blocklist) {\n  const filteredStagedActionIds = [];\n  const filteredActionsById = {};\n  const filteredComputedStates = [];\n  liftedState.stagedActionIds.forEach((id, idx) => {\n    const liftedAction = liftedState.actionsById[id];\n    if (!liftedAction) return;\n    if (idx && isActionFiltered(liftedState.computedStates[idx], liftedAction, predicate, safelist, blocklist)) {\n      return;\n    }\n    filteredActionsById[id] = liftedAction;\n    filteredStagedActionIds.push(id);\n    filteredComputedStates.push(liftedState.computedStates[idx]);\n  });\n  return {\n    ...liftedState,\n    stagedActionIds: filteredStagedActionIds,\n    actionsById: filteredActionsById,\n    computedStates: filteredComputedStates\n  };\n}\n/**\n * Return true is the action should be ignored\n */\nfunction isActionFiltered(state, action, predicate, safelist, blockedlist) {\n  const predicateMatch = predicate && !predicate(state, action.action);\n  const safelistMatch = safelist && !action.action.type.match(safelist.map(s => escapeRegExp(s)).join('|'));\n  const blocklistMatch = blockedlist && action.action.type.match(blockedlist.map(s => escapeRegExp(s)).join('|'));\n  return predicateMatch || safelistMatch || blocklistMatch;\n}\n/**\n * Return string with escaped RegExp special characters\n * https://stackoverflow.com/a/6969486/1337347\n */\nfunction escapeRegExp(s) {\n  return s.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\nfunction injectZoneConfig(connectInZone) {\n  const ngZone = connectInZone ? inject(NgZone) : null;\n  return {\n    ngZone,\n    connectInZone\n  };\n}\nlet DevtoolsDispatcher = /*#__PURE__*/(() => {\n  class DevtoolsDispatcher extends ActionsSubject {\n    /** @nocollapse */static {\n      this.\u0275fac = /* @__PURE__ */(() => {\n        let \u0275DevtoolsDispatcher_BaseFactory;\n        return function DevtoolsDispatcher_Factory(__ngFactoryType__) {\n          return (\u0275DevtoolsDispatcher_BaseFactory || (\u0275DevtoolsDispatcher_BaseFactory = i0.\u0275\u0275getInheritedFactory(DevtoolsDispatcher)))(__ngFactoryType__ || DevtoolsDispatcher);\n        };\n      })();\n    }\n    /** @nocollapse */\n    static {\n      this.\u0275prov = /* @__PURE__ */i0.\u0275\u0275defineInjectable({\n        token: DevtoolsDispatcher,\n        factory: DevtoolsDispatcher.\u0275fac\n      });\n    }\n  }\n  return DevtoolsDispatcher;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst ExtensionActionTypes = {\n  START: 'START',\n  DISPATCH: 'DISPATCH',\n  STOP: 'STOP',\n  ACTION: 'ACTION'\n};\nconst REDUX_DEVTOOLS_EXTENSION = /*#__PURE__*/new InjectionToken('@ngrx/store-devtools Redux Devtools Extension');\nlet DevtoolsExtension = /*#__PURE__*/(() => {\n  class DevtoolsExtension {\n    constructor(devtoolsExtension, config, dispatcher) {\n      this.config = config;\n      this.dispatcher = dispatcher;\n      this.zoneConfig = injectZoneConfig(this.config.connectInZone);\n      this.devtoolsExtension = devtoolsExtension;\n      this.createActionStreams();\n    }\n    notify(action, state) {\n      if (!this.devtoolsExtension) {\n        return;\n      }\n      // Check to see if the action requires a full update of the liftedState.\n      // If it is a simple action generated by the user's app and the recording\n      // is not locked/paused, only send the action and the current state (fast).\n      //\n      // A full liftedState update (slow: serializes the entire liftedState) is\n      // only required when:\n      //   a) redux-devtools-extension fires the @@Init action (ignored by\n      //      @ngrx/store-devtools)\n      //   b) an action is generated by an @ngrx module (e.g. @ngrx/effects/init\n      //      or @ngrx/store/update-reducers)\n      //   c) the state has been recomputed due to time-traveling\n      //   d) any action that is not a PerformAction to err on the side of\n      //      caution.\n      if (action.type === PERFORM_ACTION) {\n        if (state.isLocked || state.isPaused) {\n          return;\n        }\n        const currentState = unliftState(state);\n        if (shouldFilterActions(this.config) && isActionFiltered(currentState, action, this.config.predicate, this.config.actionsSafelist, this.config.actionsBlocklist)) {\n          return;\n        }\n        const sanitizedState = this.config.stateSanitizer ? sanitizeState(this.config.stateSanitizer, currentState, state.currentStateIndex) : currentState;\n        const sanitizedAction = this.config.actionSanitizer ? sanitizeAction(this.config.actionSanitizer, action, state.nextActionId) : action;\n        this.sendToReduxDevtools(() => this.extensionConnection.send(sanitizedAction, sanitizedState));\n      } else {\n        // Requires full state update\n        const sanitizedLiftedState = {\n          ...state,\n          stagedActionIds: state.stagedActionIds,\n          actionsById: this.config.actionSanitizer ? sanitizeActions(this.config.actionSanitizer, state.actionsById) : state.actionsById,\n          computedStates: this.config.stateSanitizer ? sanitizeStates(this.config.stateSanitizer, state.computedStates) : state.computedStates\n        };\n        this.sendToReduxDevtools(() => this.devtoolsExtension.send(null, sanitizedLiftedState, this.getExtensionConfig(this.config)));\n      }\n    }\n    createChangesObservable() {\n      if (!this.devtoolsExtension) {\n        return EMPTY;\n      }\n      return new Observable(subscriber => {\n        const connection = this.zoneConfig.connectInZone ?\n        // To reduce change detection cycles, we need to run the `connect` method\n        // outside of the Angular zone. The `connect` method adds a `message`\n        // event listener to communicate with an extension using `window.postMessage`\n        // and handle message events.\n        this.zoneConfig.ngZone.runOutsideAngular(() => this.devtoolsExtension.connect(this.getExtensionConfig(this.config))) : this.devtoolsExtension.connect(this.getExtensionConfig(this.config));\n        this.extensionConnection = connection;\n        connection.init();\n        connection.subscribe(change => subscriber.next(change));\n        return connection.unsubscribe;\n      });\n    }\n    createActionStreams() {\n      // Listens to all changes\n      const changes$ = this.createChangesObservable().pipe(share());\n      // Listen for the start action\n      const start$ = changes$.pipe(filter(change => change.type === ExtensionActionTypes.START));\n      // Listen for the stop action\n      const stop$ = changes$.pipe(filter(change => change.type === ExtensionActionTypes.STOP));\n      // Listen for lifted actions\n      const liftedActions$ = changes$.pipe(filter(change => change.type === ExtensionActionTypes.DISPATCH), map(change => this.unwrapAction(change.payload)), concatMap(action => {\n        if (action.type === IMPORT_STATE) {\n          // State imports may happen in two situations:\n          // 1. Explicitly by user\n          // 2. User activated the \"persist state accross reloads\" option\n          //    and now the state is imported during reload.\n          // Because of option 2, we need to give possible\n          // lazy loaded reducers time to instantiate.\n          // As soon as there is no UPDATE action within 1 second,\n          // it is assumed that all reducers are loaded.\n          return this.dispatcher.pipe(filter(action => action.type === UPDATE), timeout(1000), debounceTime(1000), map(() => action), catchError(() => of(action)), take(1));\n        } else {\n          return of(action);\n        }\n      }));\n      // Listen for unlifted actions\n      const actions$ = changes$.pipe(filter(change => change.type === ExtensionActionTypes.ACTION), map(change => this.unwrapAction(change.payload)));\n      const actionsUntilStop$ = actions$.pipe(takeUntil(stop$));\n      const liftedUntilStop$ = liftedActions$.pipe(takeUntil(stop$));\n      this.start$ = start$.pipe(takeUntil(stop$));\n      // Only take the action sources between the start/stop events\n      this.actions$ = this.start$.pipe(switchMap(() => actionsUntilStop$));\n      this.liftedActions$ = this.start$.pipe(switchMap(() => liftedUntilStop$));\n    }\n    unwrapAction(action) {\n      // indirect eval according to https://esbuild.github.io/content-types/#direct-eval\n      return typeof action === 'string' ? (0, eval)(`(${action})`) : action;\n    }\n    getExtensionConfig(config) {\n      const extensionOptions = {\n        name: config.name,\n        features: config.features,\n        serialize: config.serialize,\n        autoPause: config.autoPause ?? false,\n        trace: config.trace ?? false,\n        traceLimit: config.traceLimit ?? 75\n        // The action/state sanitizers are not added to the config\n        // because sanitation is done in this class already.\n        // It is done before sending it to the devtools extension for consistency:\n        // - If we call extensionConnection.send(...),\n        //   the extension would call the sanitizers.\n        // - If we call devtoolsExtension.send(...) (aka full state update),\n        //   the extension would NOT call the sanitizers, so we have to do it ourselves.\n      };\n      if (config.maxAge !== false /* support === 0 */) {\n        extensionOptions.maxAge = config.maxAge;\n      }\n      return extensionOptions;\n    }\n    sendToReduxDevtools(send) {\n      try {\n        send();\n      } catch (err) {\n        console.warn('@ngrx/store-devtools: something went wrong inside the redux devtools', err);\n      }\n    }\n    /** @nocollapse */\n    static {\n      this.\u0275fac = function DevtoolsExtension_Factory(__ngFactoryType__) {\n        return new (__ngFactoryType__ || DevtoolsExtension)(i0.\u0275\u0275inject(REDUX_DEVTOOLS_EXTENSION), i0.\u0275\u0275inject(STORE_DEVTOOLS_CONFIG), i0.\u0275\u0275inject(DevtoolsDispatcher));\n      };\n    }\n    /** @nocollapse */\n    static {\n      this.\u0275prov = /* @__PURE__ */i0.\u0275\u0275defineInjectable({\n        token: DevtoolsExtension,\n        factory: DevtoolsExtension.\u0275fac\n      });\n    }\n  }\n  return DevtoolsExtension;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst INIT_ACTION = {\n  type: INIT\n};\nconst RECOMPUTE = '@ngrx/store-devtools/recompute';\nconst RECOMPUTE_ACTION = {\n  type: RECOMPUTE\n};\n/**\n * Computes the next entry in the log by applying an action.\n */\nfunction computeNextEntry(reducer, action, state, error, errorHandler) {\n  if (error) {\n    return {\n      state,\n      error: 'Interrupted by an error up the chain'\n    };\n  }\n  let nextState = state;\n  let nextError;\n  try {\n    nextState = reducer(state, action);\n  } catch (err) {\n    nextError = err.toString();\n    errorHandler.handleError(err);\n  }\n  return {\n    state: nextState,\n    error: nextError\n  };\n}\n/**\n * Runs the reducer on invalidated actions to get a fresh computation log.\n */\nfunction recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused) {\n  // Optimization: exit early and return the same reference\n  // if we know nothing could have changed.\n  if (minInvalidatedStateIndex >= computedStates.length && computedStates.length === stagedActionIds.length) {\n    return computedStates;\n  }\n  const nextComputedStates = computedStates.slice(0, minInvalidatedStateIndex);\n  // If the recording is paused, recompute all states up until the pause state,\n  // else recompute all states.\n  const lastIncludedActionId = stagedActionIds.length - (isPaused ? 1 : 0);\n  for (let i = minInvalidatedStateIndex; i < lastIncludedActionId; i++) {\n    const actionId = stagedActionIds[i];\n    const action = actionsById[actionId].action;\n    const previousEntry = nextComputedStates[i - 1];\n    const previousState = previousEntry ? previousEntry.state : committedState;\n    const previousError = previousEntry ? previousEntry.error : undefined;\n    const shouldSkip = skippedActionIds.indexOf(actionId) > -1;\n    const entry = shouldSkip ? previousEntry : computeNextEntry(reducer, action, previousState, previousError, errorHandler);\n    nextComputedStates.push(entry);\n  }\n  // If the recording is paused, the last state will not be recomputed,\n  // because it's essentially not part of the state history.\n  if (isPaused) {\n    nextComputedStates.push(computedStates[computedStates.length - 1]);\n  }\n  return nextComputedStates;\n}\nfunction liftInitialState(initialCommittedState, monitorReducer) {\n  return {\n    monitorState: monitorReducer(undefined, {}),\n    nextActionId: 1,\n    actionsById: {\n      0: liftAction(INIT_ACTION)\n    },\n    stagedActionIds: [0],\n    skippedActionIds: [],\n    committedState: initialCommittedState,\n    currentStateIndex: 0,\n    computedStates: [],\n    isLocked: false,\n    isPaused: false\n  };\n}\n/**\n * Creates a history state reducer from an app's reducer.\n */\nfunction liftReducerWith(initialCommittedState, initialLiftedState, errorHandler, monitorReducer, options = {}) {\n  /**\n   * Manages how the history actions modify the history state.\n   */\n  return reducer => (liftedState, liftedAction) => {\n    let {\n      monitorState,\n      actionsById,\n      nextActionId,\n      stagedActionIds,\n      skippedActionIds,\n      committedState,\n      currentStateIndex,\n      computedStates,\n      isLocked,\n      isPaused\n    } = liftedState || initialLiftedState;\n    if (!liftedState) {\n      // Prevent mutating initialLiftedState\n      actionsById = Object.create(actionsById);\n    }\n    function commitExcessActions(n) {\n      // Auto-commits n-number of excess actions.\n      let excess = n;\n      let idsToDelete = stagedActionIds.slice(1, excess + 1);\n      for (let i = 0; i < idsToDelete.length; i++) {\n        if (computedStates[i + 1].error) {\n          // Stop if error is found. Commit actions up to error.\n          excess = i;\n          idsToDelete = stagedActionIds.slice(1, excess + 1);\n          break;\n        } else {\n          delete actionsById[idsToDelete[i]];\n        }\n      }\n      skippedActionIds = skippedActionIds.filter(id => idsToDelete.indexOf(id) === -1);\n      stagedActionIds = [0, ...stagedActionIds.slice(excess + 1)];\n      committedState = computedStates[excess].state;\n      computedStates = computedStates.slice(excess);\n      currentStateIndex = currentStateIndex > excess ? currentStateIndex - excess : 0;\n    }\n    function commitChanges() {\n      // Consider the last committed state the new starting point.\n      // Squash any staged actions into a single committed state.\n      actionsById = {\n        0: liftAction(INIT_ACTION)\n      };\n      nextActionId = 1;\n      stagedActionIds = [0];\n      skippedActionIds = [];\n      committedState = computedStates[currentStateIndex].state;\n      currentStateIndex = 0;\n      computedStates = [];\n    }\n    // By default, aggressively recompute every state whatever happens.\n    // This has O(n) performance, so we'll override this to a sensible\n    // value whenever we feel like we don't have to recompute the states.\n    let minInvalidatedStateIndex = 0;\n    switch (liftedAction.type) {\n      case LOCK_CHANGES:\n        {\n          isLocked = liftedAction.status;\n          minInvalidatedStateIndex = Infinity;\n          break;\n        }\n      case PAUSE_RECORDING:\n        {\n          isPaused = liftedAction.status;\n          if (isPaused) {\n            // Add a pause action to signal the devtools-user the recording is paused.\n            // The corresponding state will be overwritten on each update to always contain\n            // the latest state (see Actions.PERFORM_ACTION).\n            stagedActionIds = [...stagedActionIds, nextActionId];\n            actionsById[nextActionId] = new PerformAction({\n              type: '@ngrx/devtools/pause'\n            }, +Date.now());\n            nextActionId++;\n            minInvalidatedStateIndex = stagedActionIds.length - 1;\n            computedStates = computedStates.concat(computedStates[computedStates.length - 1]);\n            if (currentStateIndex === stagedActionIds.length - 2) {\n              currentStateIndex++;\n            }\n            minInvalidatedStateIndex = Infinity;\n          } else {\n            commitChanges();\n          }\n          break;\n        }\n      case RESET:\n        {\n          // Get back to the state the store was created with.\n          actionsById = {\n            0: liftAction(INIT_ACTION)\n          };\n          nextActionId = 1;\n          stagedActionIds = [0];\n          skippedActionIds = [];\n          committedState = initialCommittedState;\n          currentStateIndex = 0;\n          computedStates = [];\n          break;\n        }\n      case COMMIT:\n        {\n          commitChanges();\n          break;\n        }\n      case ROLLBACK:\n        {\n          // Forget about any staged actions.\n          // Start again from the last committed state.\n          actionsById = {\n            0: liftAction(INIT_ACTION)\n          };\n          nextActionId = 1;\n          stagedActionIds = [0];\n          skippedActionIds = [];\n          currentStateIndex = 0;\n          computedStates = [];\n          break;\n        }\n      case TOGGLE_ACTION:\n        {\n          // Toggle whether an action with given ID is skipped.\n          // Being skipped means it is a no-op during the computation.\n          const {\n            id: actionId\n          } = liftedAction;\n          const index = skippedActionIds.indexOf(actionId);\n          if (index === -1) {\n            skippedActionIds = [actionId, ...skippedActionIds];\n          } else {\n            skippedActionIds = skippedActionIds.filter(id => id !== actionId);\n          }\n          // Optimization: we know history before this action hasn't changed\n          minInvalidatedStateIndex = stagedActionIds.indexOf(actionId);\n          break;\n        }\n      case SET_ACTIONS_ACTIVE:\n        {\n          // Toggle whether an action with given ID is skipped.\n          // Being skipped means it is a no-op during the computation.\n          const {\n            start,\n            end,\n            active\n          } = liftedAction;\n          const actionIds = [];\n          for (let i = start; i < end; i++) actionIds.push(i);\n          if (active) {\n            skippedActionIds = difference(skippedActionIds, actionIds);\n          } else {\n            skippedActionIds = [...skippedActionIds, ...actionIds];\n          }\n          // Optimization: we know history before this action hasn't changed\n          minInvalidatedStateIndex = stagedActionIds.indexOf(start);\n          break;\n        }\n      case JUMP_TO_STATE:\n        {\n          // Without recomputing anything, move the pointer that tell us\n          // which state is considered the current one. Useful for sliders.\n          currentStateIndex = liftedAction.index;\n          // Optimization: we know the history has not changed.\n          minInvalidatedStateIndex = Infinity;\n          break;\n        }\n      case JUMP_TO_ACTION:\n        {\n          // Jumps to a corresponding state to a specific action.\n          // Useful when filtering actions.\n          const index = stagedActionIds.indexOf(liftedAction.actionId);\n          if (index !== -1) currentStateIndex = index;\n          minInvalidatedStateIndex = Infinity;\n          break;\n        }\n      case SWEEP:\n        {\n          // Forget any actions that are currently being skipped.\n          stagedActionIds = difference(stagedActionIds, skippedActionIds);\n          skippedActionIds = [];\n          currentStateIndex = Math.min(currentStateIndex, stagedActionIds.length - 1);\n          break;\n        }\n      case PERFORM_ACTION:\n        {\n          // Ignore action and return state as is if recording is locked\n          if (isLocked) {\n            return liftedState || initialLiftedState;\n          }\n          if (isPaused || liftedState && isActionFiltered(liftedState.computedStates[currentStateIndex], liftedAction, options.predicate, options.actionsSafelist, options.actionsBlocklist)) {\n            // If recording is paused or if the action should be ignored, overwrite the last state\n            // (corresponds to the pause action) and keep everything else as is.\n            // This way, the app gets the new current state while the devtools\n            // do not record another action.\n            const lastState = computedStates[computedStates.length - 1];\n            computedStates = [...computedStates.slice(0, -1), computeNextEntry(reducer, liftedAction.action, lastState.state, lastState.error, errorHandler)];\n            minInvalidatedStateIndex = Infinity;\n            break;\n          }\n          // Auto-commit as new actions come in.\n          if (options.maxAge && stagedActionIds.length === options.maxAge) {\n            commitExcessActions(1);\n          }\n          if (currentStateIndex === stagedActionIds.length - 1) {\n            currentStateIndex++;\n          }\n          const actionId = nextActionId++;\n          // Mutation! This is the hottest path, and we optimize on purpose.\n          // It is safe because we set a new key in a cache dictionary.\n          actionsById[actionId] = liftedAction;\n          stagedActionIds = [...stagedActionIds, actionId];\n          // Optimization: we know that only the new action needs computing.\n          minInvalidatedStateIndex = stagedActionIds.length - 1;\n          break;\n        }\n      case IMPORT_STATE:\n        {\n          // Completely replace everything.\n          ({\n            monitorState,\n            actionsById,\n            nextActionId,\n            stagedActionIds,\n            skippedActionIds,\n            committedState,\n            currentStateIndex,\n            computedStates,\n            isLocked,\n            isPaused\n          } = liftedAction.nextLiftedState);\n          break;\n        }\n      case INIT:\n        {\n          // Always recompute states on hot reload and init.\n          minInvalidatedStateIndex = 0;\n          if (options.maxAge && stagedActionIds.length > options.maxAge) {\n            // States must be recomputed before committing excess.\n            computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused);\n            commitExcessActions(stagedActionIds.length - options.maxAge);\n            // Avoid double computation.\n            minInvalidatedStateIndex = Infinity;\n          }\n          break;\n        }\n      case UPDATE:\n        {\n          const stateHasErrors = computedStates.filter(state => state.error).length > 0;\n          if (stateHasErrors) {\n            // Recompute all states\n            minInvalidatedStateIndex = 0;\n            if (options.maxAge && stagedActionIds.length > options.maxAge) {\n              // States must be recomputed before committing excess.\n              computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused);\n              commitExcessActions(stagedActionIds.length - options.maxAge);\n              // Avoid double computation.\n              minInvalidatedStateIndex = Infinity;\n            }\n          } else {\n            // If not paused/locked, add a new action to signal devtools-user\n            // that there was a reducer update.\n            if (!isPaused && !isLocked) {\n              if (currentStateIndex === stagedActionIds.length - 1) {\n                currentStateIndex++;\n              }\n              // Add a new action to only recompute state\n              const actionId = nextActionId++;\n              actionsById[actionId] = new PerformAction(liftedAction, +Date.now());\n              stagedActionIds = [...stagedActionIds, actionId];\n              minInvalidatedStateIndex = stagedActionIds.length - 1;\n              computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused);\n            }\n            // Recompute state history with latest reducer and update action\n            computedStates = computedStates.map(cmp => ({\n              ...cmp,\n              state: reducer(cmp.state, RECOMPUTE_ACTION)\n            }));\n            currentStateIndex = stagedActionIds.length - 1;\n            if (options.maxAge && stagedActionIds.length > options.maxAge) {\n              commitExcessActions(stagedActionIds.length - options.maxAge);\n            }\n            // Avoid double computation.\n            minInvalidatedStateIndex = Infinity;\n          }\n          break;\n        }\n      default:\n        {\n          // If the action is not recognized, it's a monitor action.\n          // Optimization: a monitor action can't change history.\n          minInvalidatedStateIndex = Infinity;\n          break;\n        }\n    }\n    computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused);\n    monitorState = monitorReducer(monitorState, liftedAction);\n    return {\n      monitorState,\n      actionsById,\n      nextActionId,\n      stagedActionIds,\n      skippedActionIds,\n      committedState,\n      currentStateIndex,\n      computedStates,\n      isLocked,\n      isPaused\n    };\n  };\n}\nlet StoreDevtools = /*#__PURE__*/(() => {\n  class StoreDevtools {\n    constructor(dispatcher, actions$, reducers$, extension, scannedActions, errorHandler, initialState, config) {\n      const liftedInitialState = liftInitialState(initialState, config.monitor);\n      const liftReducer = liftReducerWith(initialState, liftedInitialState, errorHandler, config.monitor, config);\n      const liftedAction$ = merge(merge(actions$.asObservable().pipe(skip(1)), extension.actions$).pipe(map(liftAction)), dispatcher, extension.liftedActions$).pipe(observeOn(queueScheduler));\n      const liftedReducer$ = reducers$.pipe(map(liftReducer));\n      const zoneConfig = injectZoneConfig(config.connectInZone);\n      const liftedStateSubject = new ReplaySubject(1);\n      this.liftedStateSubscription = liftedAction$.pipe(withLatestFrom(liftedReducer$),\n      // The extension would post messages back outside of the Angular zone\n      // because we call `connect()` wrapped with `runOutsideAngular`. We run change\n      // detection only once at the end after all the required asynchronous tasks have\n      // been processed (for instance, `setInterval` scheduled by the `timeout` operator).\n      // We have to re-enter the Angular zone before the `scan` since it runs the reducer\n      // which must be run within the Angular zone.\n      emitInZone(zoneConfig), scan(({\n        state: liftedState\n      }, [action, reducer]) => {\n        let reducedLiftedState = reducer(liftedState, action);\n        // On full state update\n        // If we have actions filters, we must filter completely our lifted state to be sync with the extension\n        if (action.type !== PERFORM_ACTION && shouldFilterActions(config)) {\n          reducedLiftedState = filterLiftedState(reducedLiftedState, config.predicate, config.actionsSafelist, config.actionsBlocklist);\n        }\n        // Extension should be sent the sanitized lifted state\n        extension.notify(action, reducedLiftedState);\n        return {\n          state: reducedLiftedState,\n          action\n        };\n      }, {\n        state: liftedInitialState,\n        action: null\n      })).subscribe(({\n        state,\n        action\n      }) => {\n        liftedStateSubject.next(state);\n        if (action.type === PERFORM_ACTION) {\n          const unliftedAction = action.action;\n          scannedActions.next(unliftedAction);\n        }\n      });\n      this.extensionStartSubscription = extension.start$.pipe(emitInZone(zoneConfig)).subscribe(() => {\n        this.refresh();\n      });\n      const liftedState$ = liftedStateSubject.asObservable();\n      const state$ = liftedState$.pipe(map(unliftState));\n      Object.defineProperty(state$, 'state', {\n        value: toSignal(state$, {\n          manualCleanup: true,\n          requireSync: true\n        })\n      });\n      this.dispatcher = dispatcher;\n      this.liftedState = liftedState$;\n      this.state = state$;\n    }\n    ngOnDestroy() {\n      // Even though the store devtools plugin is recommended to be\n      // used only in development mode, it can still cause a memory leak\n      // in microfrontend applications that are being created and destroyed\n      // multiple times during development. This results in excessive memory\n      // consumption, as it prevents entire apps from being garbage collected.\n      this.liftedStateSubscription.unsubscribe();\n      this.extensionStartSubscription.unsubscribe();\n    }\n    dispatch(action) {\n      this.dispatcher.next(action);\n    }\n    next(action) {\n      this.dispatcher.next(action);\n    }\n    error(error) {}\n    complete() {}\n    performAction(action) {\n      this.dispatch(new PerformAction(action, +Date.now()));\n    }\n    refresh() {\n      this.dispatch(new Refresh());\n    }\n    reset() {\n      this.dispatch(new Reset(+Date.now()));\n    }\n    rollback() {\n      this.dispatch(new Rollback(+Date.now()));\n    }\n    commit() {\n      this.dispatch(new Commit(+Date.now()));\n    }\n    sweep() {\n      this.dispatch(new Sweep());\n    }\n    toggleAction(id) {\n      this.dispatch(new ToggleAction(id));\n    }\n    jumpToAction(actionId) {\n      this.dispatch(new JumpToAction(actionId));\n    }\n    jumpToState(index) {\n      this.dispatch(new JumpToState(index));\n    }\n    importState(nextLiftedState) {\n      this.dispatch(new ImportState(nextLiftedState));\n    }\n    lockChanges(status) {\n      this.dispatch(new LockChanges(status));\n    }\n    pauseRecording(status) {\n      this.dispatch(new PauseRecording(status));\n    }\n    /** @nocollapse */\n    static {\n      this.\u0275fac = function StoreDevtools_Factory(__ngFactoryType__) {\n        return new (__ngFactoryType__ || StoreDevtools)(i0.\u0275\u0275inject(DevtoolsDispatcher), i0.\u0275\u0275inject(i2.ActionsSubject), i0.\u0275\u0275inject(i2.ReducerObservable), i0.\u0275\u0275inject(DevtoolsExtension), i0.\u0275\u0275inject(i2.ScannedActionsSubject), i0.\u0275\u0275inject(i0.ErrorHandler), i0.\u0275\u0275inject(INITIAL_STATE), i0.\u0275\u0275inject(STORE_DEVTOOLS_CONFIG));\n      };\n    }\n    /** @nocollapse */\n    static {\n      this.\u0275prov = /* @__PURE__ */i0.\u0275\u0275defineInjectable({\n        token: StoreDevtools,\n        factory: StoreDevtools.\u0275fac\n      });\n    }\n  }\n  return StoreDevtools;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * If the devtools extension is connected out of the Angular zone,\n * this operator will emit all events within the zone.\n */\nfunction emitInZone({\n  ngZone,\n  connectInZone\n}) {\n  return source => connectInZone ? new Observable(subscriber => source.subscribe({\n    next: value => ngZone.run(() => subscriber.next(value)),\n    error: error => ngZone.run(() => subscriber.error(error)),\n    complete: () => ngZone.run(() => subscriber.complete())\n  })) : source;\n}\nconst IS_EXTENSION_OR_MONITOR_PRESENT = /*#__PURE__*/new InjectionToken('@ngrx/store-devtools Is Devtools Extension or Monitor Present');\nfunction createIsExtensionOrMonitorPresent(extension, config) {\n  return Boolean(extension) || config.monitor !== noMonitor;\n}\nfunction createReduxDevtoolsExtension() {\n  const extensionKey = '__REDUX_DEVTOOLS_EXTENSION__';\n  if (typeof window === 'object' && typeof window[extensionKey] !== 'undefined') {\n    return window[extensionKey];\n  } else {\n    return null;\n  }\n}\nfunction createStateObservable(devtools) {\n  return devtools.state;\n}\n/**\n * Provides developer tools and instrumentation for `Store`.\n *\n * @usageNotes\n *\n * ```ts\n * bootstrapApplication(AppComponent, {\n *   providers: [\n *     provideStoreDevtools({\n *       maxAge: 25,\n *       logOnly: !isDevMode(),\n *     }),\n *   ],\n * });\n * ```\n */\nfunction provideStoreDevtools(options = {}) {\n  return makeEnvironmentProviders([DevtoolsExtension, DevtoolsDispatcher, StoreDevtools, {\n    provide: INITIAL_OPTIONS,\n    useValue: options\n  }, {\n    provide: IS_EXTENSION_OR_MONITOR_PRESENT,\n    deps: [REDUX_DEVTOOLS_EXTENSION, STORE_DEVTOOLS_CONFIG],\n    useFactory: createIsExtensionOrMonitorPresent\n  }, {\n    provide: REDUX_DEVTOOLS_EXTENSION,\n    useFactory: createReduxDevtoolsExtension\n  }, {\n    provide: STORE_DEVTOOLS_CONFIG,\n    deps: [INITIAL_OPTIONS],\n    useFactory: createConfig\n  }, {\n    provide: StateObservable,\n    deps: [StoreDevtools],\n    useFactory: createStateObservable\n  }, {\n    provide: ReducerManagerDispatcher,\n    useExisting: DevtoolsDispatcher\n  }]);\n}\nlet StoreDevtoolsModule = /*#__PURE__*/(() => {\n  class StoreDevtoolsModule {\n    static instrument(options = {}) {\n      return {\n        ngModule: StoreDevtoolsModule,\n        providers: [provideStoreDevtools(options)]\n      };\n    }\n    /** @nocollapse */\n    static {\n      this.\u0275fac = function StoreDevtoolsModule_Factory(__ngFactoryType__) {\n        return new (__ngFactoryType__ || StoreDevtoolsModule)();\n      };\n    }\n    /** @nocollapse */\n    static {\n      this.\u0275mod = /* @__PURE__ */i0.\u0275\u0275defineNgModule({\n        type: StoreDevtoolsModule\n      });\n    }\n    /** @nocollapse */\n    static {\n      this.\u0275inj = /* @__PURE__ */i0.\u0275\u0275defineInjector({});\n    }\n  }\n  return StoreDevtoolsModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * DO NOT EDIT\n *\n * This file is automatically generated at build\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { INITIAL_OPTIONS, RECOMPUTE, REDUX_DEVTOOLS_EXTENSION, StoreDevtools, StoreDevtoolsConfig, StoreDevtoolsModule, provideStoreDevtools };\n"],
  "mappings": "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",
  "names": ["i0", "InjectionToken", "inject", "NgZone", "makeEnvironmentProviders", "i2", "ActionsSubject", "UPDATE", "INIT", "INITIAL_STATE", "StateObservable", "ReducerManagerDispatcher", "EMPTY", "Observable", "of", "merge", "queueScheduler", "ReplaySubject", "share", "filter", "map", "concatMap", "timeout", "debounceTime", "catchError", "take", "takeUntil", "switchMap", "skip", "observeOn", "withLatestFrom", "scan", "toSignal", "PERFORM_ACTION", "REFRESH", "RESET", "ROLLBACK", "COMMIT", "SWEEP", "TOGGLE_ACTION", "SET_ACTIONS_ACTIVE", "JUMP_TO_STATE", "JUMP_TO_ACTION", "IMPORT_STATE", "LOCK_CHANGES", "PAUSE_RECORDING", "PerformAction", "action", "timestamp", "Refresh", "Reset", "Rollback", "Commit", "Sweep", "ToggleAction", "id", "JumpToState", "index", "JUMP_TO_STATE", "JumpToAction", "actionId", "JUMP_TO_ACTION", "ImportState", "nextLiftedState", "IMPORT_STATE", "LockChanges", "status", "LOCK_CHANGES", "PauseRecording", "PAUSE_RECORDING", "StoreDevtoolsConfig", "STORE_DEVTOOLS_CONFIG", "InjectionToken", "INITIAL_OPTIONS", "noMonitor", "DEFAULT_NAME", "createConfig", "optionsInput", "DEFAULT_OPTIONS", "options", "logOnly", "features", "config", "difference", "first", "second", "item", "unliftState", "liftedState", "computedStates", "currentStateIndex", "state", "liftAction", "action", "PerformAction", "sanitizeActions", "actionSanitizer", "actions", "sanitizedActions", "actionIdx", "idx", "sanitizeAction", "__spreadProps", "__spreadValues", "sanitizeStates", "stateSanitizer", "states", "computedState", "sanitizeState", "state", "stateIdx", "shouldFilterActions", "config", "filterLiftedState", "liftedState", "predicate", "safelist", "blocklist", "filteredStagedActionIds", "filteredActionsById", "filteredComputedStates", "id", "liftedAction", "isActionFiltered", "blockedlist", "predicateMatch", "safelistMatch", "s", "escapeRegExp", "blocklistMatch", "injectZoneConfig", "connectInZone", "inject", "NgZone", "DevtoolsDispatcher", "ActionsSubject", "\u0275DevtoolsDispatcher_BaseFactory", "__ngFactoryType__", "ExtensionActionTypes", "REDUX_DEVTOOLS_EXTENSION", "InjectionToken", "DevtoolsExtension", "devtoolsExtension", "dispatcher", "PERFORM_ACTION", "currentState", "unliftState", "sanitizedState", "sanitizedAction", "sanitizedLiftedState", "Observable", "subscriber", "connection", "change", "EMPTY", "changes$", "share", "start$", "filter", "stop$", "liftedActions$", "map", "concatMap", "IMPORT_STATE", "UPDATE", "timeout", "debounceTime", "catchError", "of", "take", "actionsUntilStop$", "takeUntil", "liftedUntilStop$", "switchMap", "extensionOptions", "send", "err", "STORE_DEVTOOLS_CONFIG", "INIT_ACTION", "INIT", "RECOMPUTE", "RECOMPUTE_ACTION", "computeNextEntry", "reducer", "error", "errorHandler", "nextState", "nextError", "recomputeStates", "computedStates", "minInvalidatedStateIndex", "committedState", "actionsById", "stagedActionIds", "skippedActionIds", "isPaused", "nextComputedStates", "lastIncludedActionId", "i", "actionId", "previousEntry", "previousState", "previousError", "entry", "liftInitialState", "initialCommittedState", "monitorReducer", "liftReducerWith", "initialLiftedState", "options", "monitorState", "nextActionId", "currentStateIndex", "isLocked", "commitExcessActions", "n", "excess", "idsToDelete", "commitChanges", "LOCK_CHANGES", "PAUSE_RECORDING", "RESET", "COMMIT", "ROLLBACK", "TOGGLE_ACTION", "SET_ACTIONS_ACTIVE", "start", "end", "active", "actionIds", "difference", "JUMP_TO_STATE", "JUMP_TO_ACTION", "index", "SWEEP", "lastState", "cmp", "StoreDevtools", "actions$", "reducers$", "extension", "scannedActions", "initialState", "liftedInitialState", "liftReducer", "liftedAction$", "merge", "skip", "observeOn", "queueScheduler", "liftedReducer$", "zoneConfig", "liftedStateSubject", "ReplaySubject", "withLatestFrom", "emitInZone", "scan", "reducedLiftedState", "unliftedAction", "liftedState$", "state$", "toSignal", "Refresh", "Reset", "Rollback", "Commit", "Sweep", "ToggleAction", "JumpToAction", "JumpToState", "nextLiftedState", "ImportState", "status", "LockChanges", "PauseRecording", "INITIAL_STATE", "ngZone", "source", "value", "IS_EXTENSION_OR_MONITOR_PRESENT", "createIsExtensionOrMonitorPresent", "noMonitor", "createReduxDevtoolsExtension", "extensionKey", "createStateObservable", "devtools", "provideStoreDevtools", "makeEnvironmentProviders", "INITIAL_OPTIONS", "createConfig", "StateObservable", "ReducerManagerDispatcher", "StoreDevtoolsModule"]
}
