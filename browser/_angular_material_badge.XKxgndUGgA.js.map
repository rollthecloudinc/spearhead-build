{
  "version": 3,
  "sources": ["../../@angular/material/fesm2022/badge.mjs"],
  "sourcesContent": ["import { AriaDescriber, _IdGenerator, InteractivityChecker, A11yModule } from '@angular/cdk/a11y';\nimport * as i0 from '@angular/core';\nimport { Component, ViewEncapsulation, ChangeDetectionStrategy, inject, NgZone, ElementRef, Renderer2, DOCUMENT, HOST_TAG_NAME, booleanAttribute, Directive, Input, NgModule } from '@angular/core';\nimport { _CdkPrivateStyleLoader, _VisuallyHiddenLoader } from '@angular/cdk/private';\nimport { _animationsDisabled } from './animation.mjs';\nimport { MatCommonModule } from './common-module.mjs';\nimport '@angular/cdk/layout';\nimport '@angular/cdk/bidi';\nconst BADGE_CONTENT_CLASS = 'mat-badge-content';\n/**\n * Component used to load the structural styles of the badge.\n * @docs-private\n */\nlet _MatBadgeStyleLoader = /*#__PURE__*/(() => {\n  class _MatBadgeStyleLoader {\n    static \u0275fac = function _MatBadgeStyleLoader_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || _MatBadgeStyleLoader)();\n    };\n    static \u0275cmp = /* @__PURE__ */i0.\u0275\u0275defineComponent({\n      type: _MatBadgeStyleLoader,\n      selectors: [[\"ng-component\"]],\n      decls: 0,\n      vars: 0,\n      template: function _MatBadgeStyleLoader_Template(rf, ctx) {},\n      styles: [\".mat-badge{position:relative}.mat-badge.mat-badge{overflow:visible}.mat-badge-content{position:absolute;text-align:center;display:inline-block;transition:transform 200ms ease-in-out;transform:scale(0.6);overflow:hidden;white-space:nowrap;text-overflow:ellipsis;box-sizing:border-box;pointer-events:none;background-color:var(--mat-badge-background-color, var(--mat-sys-error));color:var(--mat-badge-text-color, var(--mat-sys-on-error));font-family:var(--mat-badge-text-font, var(--mat-sys-label-small-font));font-weight:var(--mat-badge-text-weight, var(--mat-sys-label-small-weight));border-radius:var(--mat-badge-container-shape, var(--mat-sys-corner-full))}.mat-badge-above .mat-badge-content{bottom:100%}.mat-badge-below .mat-badge-content{top:100%}.mat-badge-before .mat-badge-content{right:100%}[dir=rtl] .mat-badge-before .mat-badge-content{right:auto;left:100%}.mat-badge-after .mat-badge-content{left:100%}[dir=rtl] .mat-badge-after .mat-badge-content{left:auto;right:100%}@media(forced-colors: active){.mat-badge-content{outline:solid 1px;border-radius:0}}.mat-badge-disabled .mat-badge-content{background-color:var(--mat-badge-disabled-state-background-color, color-mix(in srgb, var(--mat-sys-error) 38%, transparent));color:var(--mat-badge-disabled-state-text-color, var(--mat-sys-on-error))}.mat-badge-hidden .mat-badge-content{display:none}.ng-animate-disabled .mat-badge-content,.mat-badge-content._mat-animation-noopable{transition:none}.mat-badge-content.mat-badge-active{transform:none}.mat-badge-small .mat-badge-content{width:var(--mat-badge-legacy-small-size-container-size, unset);height:var(--mat-badge-legacy-small-size-container-size, unset);min-width:var(--mat-badge-small-size-container-size, 6px);min-height:var(--mat-badge-small-size-container-size, 6px);line-height:var(--mat-badge-small-size-line-height, 6px);padding:var(--mat-badge-small-size-container-padding, 0);font-size:var(--mat-badge-small-size-text-size, 0);margin:var(--mat-badge-small-size-container-offset, -6px 0)}.mat-badge-small.mat-badge-overlap .mat-badge-content{margin:var(--mat-badge-small-size-container-overlap-offset, -6px)}.mat-badge-medium .mat-badge-content{width:var(--mat-badge-legacy-container-size, unset);height:var(--mat-badge-legacy-container-size, unset);min-width:var(--mat-badge-container-size, 16px);min-height:var(--mat-badge-container-size, 16px);line-height:var(--mat-badge-line-height, 16px);padding:var(--mat-badge-container-padding, 0 4px);font-size:var(--mat-badge-text-size, var(--mat-sys-label-small-size));margin:var(--mat-badge-container-offset, -12px 0)}.mat-badge-medium.mat-badge-overlap .mat-badge-content{margin:var(--mat-badge-container-overlap-offset, -12px)}.mat-badge-large .mat-badge-content{width:var(--mat-badge-legacy-large-size-container-size, unset);height:var(--mat-badge-legacy-large-size-container-size, unset);min-width:var(--mat-badge-large-size-container-size, 16px);min-height:var(--mat-badge-large-size-container-size, 16px);line-height:var(--mat-badge-large-size-line-height, 16px);padding:var(--mat-badge-large-size-container-padding, 0 4px);font-size:var(--mat-badge-large-size-text-size, var(--mat-sys-label-small-size));margin:var(--mat-badge-large-size-container-offset, -12px 0)}.mat-badge-large.mat-badge-overlap .mat-badge-content{margin:var(--mat-badge-large-size-container-overlap-offset, -12px)}\\n\"],\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n  return _MatBadgeStyleLoader;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** Directive to display a text badge. */\nlet MatBadge = /*#__PURE__*/(() => {\n  class MatBadge {\n    _ngZone = inject(NgZone);\n    _elementRef = inject(ElementRef);\n    _ariaDescriber = inject(AriaDescriber);\n    _renderer = inject(Renderer2);\n    _animationsDisabled = _animationsDisabled();\n    _idGenerator = inject(_IdGenerator);\n    /**\n     * Theme color of the badge. This API is supported in M2 themes only, it\n     * has no effect in M3 themes. For color customization in M3, see https://material.angular.dev/components/badge/styling.\n     *\n     * For information on applying color variants in M3, see\n     * https://material.angular.dev/guide/material-2-theming#optional-add-backwards-compatibility-styles-for-color-variants\n     */\n    get color() {\n      return this._color;\n    }\n    set color(value) {\n      this._setColor(value);\n      this._color = value;\n    }\n    _color = 'primary';\n    /** Whether the badge should overlap its contents or not */\n    overlap = true;\n    /** Whether the badge is disabled. */\n    disabled;\n    /**\n     * Position the badge should reside.\n     * Accepts any combination of 'above'|'below' and 'before'|'after'\n     */\n    position = 'above after';\n    /** The content for the badge */\n    get content() {\n      return this._content;\n    }\n    set content(newContent) {\n      this._updateRenderedContent(newContent);\n    }\n    _content;\n    /** Message used to describe the decorated element via aria-describedby */\n    get description() {\n      return this._description;\n    }\n    set description(newDescription) {\n      this._updateDescription(newDescription);\n    }\n    _description;\n    /** Size of the badge. Can be 'small', 'medium', or 'large'. */\n    size = 'medium';\n    /** Whether the badge is hidden. */\n    hidden;\n    /** Visible badge element. */\n    _badgeElement;\n    /** Inline badge description. Used when the badge is applied to non-interactive host elements. */\n    _inlineBadgeDescription;\n    /** Whether the OnInit lifecycle hook has run yet */\n    _isInitialized = false;\n    /** InteractivityChecker to determine if the badge host is focusable. */\n    _interactivityChecker = inject(InteractivityChecker);\n    _document = inject(DOCUMENT);\n    constructor() {\n      const styleLoader = inject(_CdkPrivateStyleLoader);\n      styleLoader.load(_MatBadgeStyleLoader);\n      styleLoader.load(_VisuallyHiddenLoader);\n      if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        const nativeElement = this._elementRef.nativeElement;\n        if (nativeElement.nodeType !== nativeElement.ELEMENT_NODE) {\n          throw Error('matBadge must be attached to an element node.');\n        }\n        const tagName = inject(HOST_TAG_NAME);\n        // Heads-up for developers to avoid putting matBadge on <mat-icon>\n        // as it is aria-hidden by default docs mention this at:\n        // https://material.angular.dev/components/badge/overview#accessibility\n        if (tagName.toLowerCase() === 'mat-icon' && nativeElement.getAttribute('aria-hidden') === 'true') {\n          console.warn(`Detected a matBadge on an \"aria-hidden\" \"<mat-icon>\". ` + `Consider setting aria-hidden=\"false\" in order to surface the information assistive technology.` + `\\n${nativeElement.outerHTML}`);\n        }\n      }\n    }\n    /** Whether the badge is above the host or not */\n    isAbove() {\n      return this.position.indexOf('below') === -1;\n    }\n    /** Whether the badge is after the host or not */\n    isAfter() {\n      return this.position.indexOf('before') === -1;\n    }\n    /**\n     * Gets the element into which the badge's content is being rendered. Undefined if the element\n     * hasn't been created (e.g. if the badge doesn't have content).\n     */\n    getBadgeElement() {\n      return this._badgeElement;\n    }\n    ngOnInit() {\n      // We may have server-side rendered badge that we need to clear.\n      // We need to do this in ngOnInit because the full content of the component\n      // on which the badge is attached won't necessarily be in the DOM until this point.\n      this._clearExistingBadges();\n      if (this.content && !this._badgeElement) {\n        this._badgeElement = this._createBadgeElement();\n        this._updateRenderedContent(this.content);\n      }\n      this._isInitialized = true;\n    }\n    ngOnDestroy() {\n      // ViewEngine only: when creating a badge through the Renderer, Angular remembers its index.\n      // We have to destroy it ourselves, otherwise it'll be retained in memory.\n      if (this._renderer.destroyNode) {\n        this._renderer.destroyNode(this._badgeElement);\n        this._inlineBadgeDescription?.remove();\n      }\n      this._ariaDescriber.removeDescription(this._elementRef.nativeElement, this.description);\n    }\n    /** Gets whether the badge's host element is interactive. */\n    _isHostInteractive() {\n      // Ignore visibility since it requires an expensive style caluclation.\n      return this._interactivityChecker.isFocusable(this._elementRef.nativeElement, {\n        ignoreVisibility: true\n      });\n    }\n    /** Creates the badge element */\n    _createBadgeElement() {\n      const badgeElement = this._renderer.createElement('span');\n      const activeClass = 'mat-badge-active';\n      badgeElement.setAttribute('id', this._idGenerator.getId('mat-badge-content-'));\n      // The badge is aria-hidden because we don't want it to appear in the page's navigation\n      // flow. Instead, we use the badge to describe the decorated element with aria-describedby.\n      badgeElement.setAttribute('aria-hidden', 'true');\n      badgeElement.classList.add(BADGE_CONTENT_CLASS);\n      if (this._animationsDisabled) {\n        badgeElement.classList.add('_mat-animation-noopable');\n      }\n      this._elementRef.nativeElement.appendChild(badgeElement);\n      // animate in after insertion\n      if (typeof requestAnimationFrame === 'function' && !this._animationsDisabled) {\n        this._ngZone.runOutsideAngular(() => {\n          requestAnimationFrame(() => {\n            badgeElement.classList.add(activeClass);\n          });\n        });\n      } else {\n        badgeElement.classList.add(activeClass);\n      }\n      return badgeElement;\n    }\n    /** Update the text content of the badge element in the DOM, creating the element if necessary. */\n    _updateRenderedContent(newContent) {\n      const newContentNormalized = `${newContent ?? ''}`.trim();\n      // Don't create the badge element if the directive isn't initialized because we want to\n      // append the badge element to the *end* of the host element's content for backwards\n      // compatibility.\n      if (this._isInitialized && newContentNormalized && !this._badgeElement) {\n        this._badgeElement = this._createBadgeElement();\n      }\n      if (this._badgeElement) {\n        this._badgeElement.textContent = newContentNormalized;\n      }\n      this._content = newContentNormalized;\n    }\n    /** Updates the host element's aria description via AriaDescriber. */\n    _updateDescription(newDescription) {\n      // Always start by removing the aria-describedby; we will add a new one if necessary.\n      this._ariaDescriber.removeDescription(this._elementRef.nativeElement, this.description);\n      // NOTE: We only check whether the host is interactive here, which happens during\n      // when then badge content changes. It is possible that the host changes\n      // interactivity status separate from one of these. However, watching the interactivity\n      // status of the host would require a `MutationObserver`, which is likely more code + overhead\n      // than it's worth; from usages inside Google, we see that the vats majority of badges either\n      // never change interactivity, or also set `matBadgeHidden` based on the same condition.\n      if (!newDescription || this._isHostInteractive()) {\n        this._removeInlineDescription();\n      }\n      this._description = newDescription;\n      // We don't add `aria-describedby` for non-interactive hosts elements because we\n      // instead insert the description inline.\n      if (this._isHostInteractive()) {\n        this._ariaDescriber.describe(this._elementRef.nativeElement, newDescription);\n      } else {\n        this._updateInlineDescription();\n      }\n    }\n    _updateInlineDescription() {\n      // Create the inline description element if it doesn't exist\n      if (!this._inlineBadgeDescription) {\n        this._inlineBadgeDescription = this._document.createElement('span');\n        this._inlineBadgeDescription.classList.add('cdk-visually-hidden');\n      }\n      this._inlineBadgeDescription.textContent = this.description;\n      this._badgeElement?.appendChild(this._inlineBadgeDescription);\n    }\n    _removeInlineDescription() {\n      this._inlineBadgeDescription?.remove();\n      this._inlineBadgeDescription = undefined;\n    }\n    /** Adds css theme class given the color to the component host */\n    _setColor(colorPalette) {\n      const classList = this._elementRef.nativeElement.classList;\n      classList.remove(`mat-badge-${this._color}`);\n      if (colorPalette) {\n        classList.add(`mat-badge-${colorPalette}`);\n      }\n    }\n    /** Clears any existing badges that might be left over from server-side rendering. */\n    _clearExistingBadges() {\n      // Only check direct children of this host element in order to avoid deleting\n      // any badges that might exist in descendant elements.\n      const badges = this._elementRef.nativeElement.querySelectorAll(`:scope > .${BADGE_CONTENT_CLASS}`);\n      for (const badgeElement of Array.from(badges)) {\n        if (badgeElement !== this._badgeElement) {\n          badgeElement.remove();\n        }\n      }\n    }\n    static \u0275fac = function MatBadge_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatBadge)();\n    };\n    static \u0275dir = /* @__PURE__ */i0.\u0275\u0275defineDirective({\n      type: MatBadge,\n      selectors: [[\"\", \"matBadge\", \"\"]],\n      hostAttrs: [1, \"mat-badge\"],\n      hostVars: 20,\n      hostBindings: function MatBadge_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.\u0275\u0275classProp(\"mat-badge-overlap\", ctx.overlap)(\"mat-badge-above\", ctx.isAbove())(\"mat-badge-below\", !ctx.isAbove())(\"mat-badge-before\", !ctx.isAfter())(\"mat-badge-after\", ctx.isAfter())(\"mat-badge-small\", ctx.size === \"small\")(\"mat-badge-medium\", ctx.size === \"medium\")(\"mat-badge-large\", ctx.size === \"large\")(\"mat-badge-hidden\", ctx.hidden || !ctx.content)(\"mat-badge-disabled\", ctx.disabled);\n        }\n      },\n      inputs: {\n        color: [0, \"matBadgeColor\", \"color\"],\n        overlap: [2, \"matBadgeOverlap\", \"overlap\", booleanAttribute],\n        disabled: [2, \"matBadgeDisabled\", \"disabled\", booleanAttribute],\n        position: [0, \"matBadgePosition\", \"position\"],\n        content: [0, \"matBadge\", \"content\"],\n        description: [0, \"matBadgeDescription\", \"description\"],\n        size: [0, \"matBadgeSize\", \"size\"],\n        hidden: [2, \"matBadgeHidden\", \"hidden\", booleanAttribute]\n      }\n    });\n  }\n  return MatBadge;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet MatBadgeModule = /*#__PURE__*/(() => {\n  class MatBadgeModule {\n    static \u0275fac = function MatBadgeModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatBadgeModule)();\n    };\n    static \u0275mod = /* @__PURE__ */i0.\u0275\u0275defineNgModule({\n      type: MatBadgeModule\n    });\n    static \u0275inj = /* @__PURE__ */i0.\u0275\u0275defineInjector({\n      imports: [A11yModule, MatCommonModule, MatCommonModule]\n    });\n  }\n  return MatBadgeModule;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nexport { MatBadge, MatBadgeModule };\n"],
  "mappings": "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",
  "names": ["AriaDescriber", "_IdGenerator", "InteractivityChecker", "A11yModule", "i0", "inject", "NgZone", "ElementRef", "Renderer2", "DOCUMENT", "booleanAttribute", "_CdkPrivateStyleLoader", "_VisuallyHiddenLoader", "BADGE_CONTENT_CLASS", "_MatBadgeStyleLoader", "__ngFactoryType__", "rf", "ctx", "MatBadge", "inject", "NgZone", "ElementRef", "AriaDescriber", "Renderer2", "_animationsDisabled", "_IdGenerator", "value", "newContent", "newDescription", "InteractivityChecker", "DOCUMENT", "styleLoader", "_CdkPrivateStyleLoader", "_VisuallyHiddenLoader", "badgeElement", "activeClass", "newContentNormalized", "colorPalette", "classList", "badges", "booleanAttribute", "MatBadgeModule", "A11yModule", "MatCommonModule"]
}
