{
  "version": 3,
  "sources": ["../../@angular/material/fesm2022/slider.mjs"],
  "sourcesContent": ["import { Directionality } from '@angular/cdk/bidi';\nimport { Platform } from '@angular/cdk/platform';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, inject, ChangeDetectorRef, NgZone, Renderer2, ElementRef, Component, ChangeDetectionStrategy, ViewEncapsulation, Input, ViewChild, booleanAttribute, numberAttribute, ViewChildren, ContentChild, ContentChildren, forwardRef, EventEmitter, signal, Directive, Output, NgModule } from '@angular/core';\nimport { RippleState, MatRipple, MAT_RIPPLE_GLOBAL_OPTIONS } from './ripple.mjs';\nimport { _CdkPrivateStyleLoader } from '@angular/cdk/private';\nimport { _animationsDisabled } from './animation.mjs';\nimport { _StructuralStylesLoader } from './structural-styles.mjs';\nimport { NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { Subject } from 'rxjs';\nimport { MatCommonModule } from './common-module.mjs';\nimport { MatRippleModule } from './ripple-module.mjs';\nimport '@angular/cdk/a11y';\nimport '@angular/cdk/coercion';\nimport '@angular/cdk/layout';\n\n/**\n * Thumb types: range slider has two thumbs (START, END) whereas single point\n * slider only has one thumb (END).\n */\nconst _c0 = [\"knob\"];\nconst _c1 = [\"valueIndicatorContainer\"];\nfunction MatSliderVisualThumb_Conditional_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.\u0275\u0275elementStart(0, \"div\", 2, 1)(2, \"div\", 5)(3, \"span\", 6);\n    i0.\u0275\u0275text(4);\n    i0.\u0275\u0275elementEnd()()();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.\u0275\u0275nextContext();\n    i0.\u0275\u0275advance(4);\n    i0.\u0275\u0275textInterpolate(ctx_r0.valueIndicatorText);\n  }\n}\nconst _c2 = [\"trackActive\"];\nconst _c3 = [\"*\"];\nfunction MatSlider_Conditional_6_Conditional_2_For_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.\u0275\u0275element(0, \"div\");\n  }\n  if (rf & 2) {\n    const tickMark_r1 = ctx.$implicit;\n    const \u0275$index_14_r2 = ctx.$index;\n    const ctx_r2 = i0.\u0275\u0275nextContext(3);\n    i0.\u0275\u0275classMap(tickMark_r1 === 0 ? \"mdc-slider__tick-mark--active\" : \"mdc-slider__tick-mark--inactive\");\n    i0.\u0275\u0275styleProp(\"transform\", ctx_r2._calcTickMarkTransform(\u0275$index_14_r2));\n  }\n}\nfunction MatSlider_Conditional_6_Conditional_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.\u0275\u0275repeaterCreate(0, MatSlider_Conditional_6_Conditional_2_For_1_Template, 1, 4, \"div\", 8, i0.\u0275\u0275repeaterTrackByIndex);\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.\u0275\u0275nextContext(2);\n    i0.\u0275\u0275repeater(ctx_r2._tickMarks);\n  }\n}\nfunction MatSlider_Conditional_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.\u0275\u0275elementStart(0, \"div\", 6, 1);\n    i0.\u0275\u0275conditionalCreate(2, MatSlider_Conditional_6_Conditional_2_Template, 2, 0);\n    i0.\u0275\u0275elementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.\u0275\u0275nextContext();\n    i0.\u0275\u0275advance(2);\n    i0.\u0275\u0275conditional(ctx_r2._cachedWidth ? 2 : -1);\n  }\n}\nfunction MatSlider_Conditional_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.\u0275\u0275element(0, \"mat-slider-visual-thumb\", 7);\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.\u0275\u0275nextContext();\n    i0.\u0275\u0275property(\"discrete\", ctx_r2.discrete)(\"thumbPosition\", 1)(\"valueIndicatorText\", ctx_r2.startValueIndicatorText);\n  }\n}\nvar _MatThumb = /*#__PURE__*/function (_MatThumb) {\n  _MatThumb[_MatThumb[\"START\"] = 1] = \"START\";\n  _MatThumb[_MatThumb[\"END\"] = 2] = \"END\";\n  return _MatThumb;\n}(_MatThumb || {});\n/** Tick mark enum, for discrete sliders. */\nvar _MatTickMark = /*#__PURE__*/function (_MatTickMark) {\n  _MatTickMark[_MatTickMark[\"ACTIVE\"] = 0] = \"ACTIVE\";\n  _MatTickMark[_MatTickMark[\"INACTIVE\"] = 1] = \"INACTIVE\";\n  return _MatTickMark;\n}(_MatTickMark || {});\n/**\n * Injection token that can be used for a `MatSlider` to provide itself as a\n * parent to the `MatSliderThumb` and `MatSliderRangeThumb`.\n * Used primarily to avoid circular imports.\n * @docs-private\n */\nconst MAT_SLIDER = /*#__PURE__*/new InjectionToken('_MatSlider');\n/**\n * Injection token that can be used to query for a `MatSliderThumb`.\n * Used primarily to avoid circular imports.\n * @docs-private\n */\nconst MAT_SLIDER_THUMB = /*#__PURE__*/new InjectionToken('_MatSliderThumb');\n/**\n * Injection token that can be used to query for a `MatSliderRangeThumb`.\n * Used primarily to avoid circular imports.\n * @docs-private\n */\nconst MAT_SLIDER_RANGE_THUMB = /*#__PURE__*/new InjectionToken('_MatSliderRangeThumb');\n/**\n * Injection token that can be used to query for a `MatSliderVisualThumb`.\n * Used primarily to avoid circular imports.\n * @docs-private\n */\nconst MAT_SLIDER_VISUAL_THUMB = /*#__PURE__*/new InjectionToken('_MatSliderVisualThumb');\n/**\n * A simple change event emitted by the MatSlider component.\n * @deprecated Use event bindings directly on the MatSliderThumbs for `change` and `input` events. See https://v17.material.angular.dev/guide/mdc-migration for information about migrating.\n * @breaking-change 17.0.0\n */\nclass MatSliderChange {\n  /** The MatSliderThumb that was interacted with. */\n  source;\n  /** The MatSlider that was interacted with. */\n  parent;\n  /** The new value of the source slider. */\n  value;\n}\n\n/**\n * The visual slider thumb.\n *\n * Handles the slider thumb ripple states (hover, focus, and active),\n * and displaying the value tooltip on discrete sliders.\n * @docs-private\n */\nlet MatSliderVisualThumb = /*#__PURE__*/(() => {\n  class MatSliderVisualThumb {\n    _cdr = inject(ChangeDetectorRef);\n    _ngZone = inject(NgZone);\n    _slider = inject(MAT_SLIDER);\n    _renderer = inject(Renderer2);\n    _listenerCleanups;\n    /** Whether the slider displays a numeric value label upon pressing the thumb. */\n    discrete;\n    /** Indicates which slider thumb this input corresponds to. */\n    thumbPosition;\n    /** The display value of the slider thumb. */\n    valueIndicatorText;\n    /** The MatRipple for this slider thumb. */\n    _ripple;\n    /** The slider thumb knob. */\n    _knob;\n    /** The slider thumb value indicator container. */\n    _valueIndicatorContainer;\n    /** The slider input corresponding to this slider thumb. */\n    _sliderInput;\n    /** The native html element of the slider input corresponding to this thumb. */\n    _sliderInputEl;\n    /** The RippleRef for the slider thumbs hover state. */\n    _hoverRippleRef;\n    /** The RippleRef for the slider thumbs focus state. */\n    _focusRippleRef;\n    /** The RippleRef for the slider thumbs active state. */\n    _activeRippleRef;\n    /** Whether the slider thumb is currently being hovered. */\n    _isHovered = false;\n    /** Whether the slider thumb is currently being pressed. */\n    _isActive = false;\n    /** Whether the value indicator tooltip is visible. */\n    _isValueIndicatorVisible = false;\n    /** The host native HTML input element. */\n    _hostElement = inject(ElementRef).nativeElement;\n    _platform = inject(Platform);\n    constructor() {}\n    ngAfterViewInit() {\n      const sliderInput = this._slider._getInput(this.thumbPosition);\n      // No-op if the slider isn't configured properly. `MatSlider` will\n      // throw an error instructing the user how to set up the slider.\n      if (!sliderInput) {\n        return;\n      }\n      this._ripple.radius = 24;\n      this._sliderInput = sliderInput;\n      this._sliderInputEl = this._sliderInput._hostElement;\n      // These listeners don't update any data bindings so we bind them outside\n      // of the NgZone to prevent Angular from needlessly running change detection.\n      this._ngZone.runOutsideAngular(() => {\n        const input = this._sliderInputEl;\n        const renderer = this._renderer;\n        this._listenerCleanups = [renderer.listen(input, 'pointermove', this._onPointerMove), renderer.listen(input, 'pointerdown', this._onDragStart), renderer.listen(input, 'pointerup', this._onDragEnd), renderer.listen(input, 'pointerleave', this._onMouseLeave), renderer.listen(input, 'focus', this._onFocus), renderer.listen(input, 'blur', this._onBlur)];\n      });\n    }\n    ngOnDestroy() {\n      this._listenerCleanups?.forEach(cleanup => cleanup());\n    }\n    _onPointerMove = event => {\n      if (this._sliderInput._isFocused) {\n        return;\n      }\n      const rect = this._hostElement.getBoundingClientRect();\n      const isHovered = this._slider._isCursorOnSliderThumb(event, rect);\n      this._isHovered = isHovered;\n      if (isHovered) {\n        this._showHoverRipple();\n      } else {\n        this._hideRipple(this._hoverRippleRef);\n      }\n    };\n    _onMouseLeave = () => {\n      this._isHovered = false;\n      this._hideRipple(this._hoverRippleRef);\n    };\n    _onFocus = () => {\n      // We don't want to show the hover ripple on top of the focus ripple.\n      // Happen when the users cursor is over a thumb and then the user tabs to it.\n      this._hideRipple(this._hoverRippleRef);\n      this._showFocusRipple();\n      this._hostElement.classList.add('mdc-slider__thumb--focused');\n    };\n    _onBlur = () => {\n      // Happens when the user tabs away while still dragging a thumb.\n      if (!this._isActive) {\n        this._hideRipple(this._focusRippleRef);\n      }\n      // Happens when the user tabs away from a thumb but their cursor is still over it.\n      if (this._isHovered) {\n        this._showHoverRipple();\n      }\n      this._hostElement.classList.remove('mdc-slider__thumb--focused');\n    };\n    _onDragStart = event => {\n      if (event.button !== 0) {\n        return;\n      }\n      this._isActive = true;\n      this._showActiveRipple();\n    };\n    _onDragEnd = () => {\n      this._isActive = false;\n      this._hideRipple(this._activeRippleRef);\n      // Happens when the user starts dragging a thumb, tabs away, and then stops dragging.\n      if (!this._sliderInput._isFocused) {\n        this._hideRipple(this._focusRippleRef);\n      }\n      // On Safari we need to immediately re-show the hover ripple because\n      // sliders do not retain focus from pointer events on that platform.\n      if (this._platform.SAFARI) {\n        this._showHoverRipple();\n      }\n    };\n    /** Handles displaying the hover ripple. */\n    _showHoverRipple() {\n      if (!this._isShowingRipple(this._hoverRippleRef)) {\n        this._hoverRippleRef = this._showRipple({\n          enterDuration: 0,\n          exitDuration: 0\n        });\n        this._hoverRippleRef?.element.classList.add('mat-mdc-slider-hover-ripple');\n      }\n    }\n    /** Handles displaying the focus ripple. */\n    _showFocusRipple() {\n      // Show the focus ripple event if noop animations are enabled.\n      if (!this._isShowingRipple(this._focusRippleRef)) {\n        this._focusRippleRef = this._showRipple({\n          enterDuration: 0,\n          exitDuration: 0\n        }, true);\n        this._focusRippleRef?.element.classList.add('mat-mdc-slider-focus-ripple');\n      }\n    }\n    /** Handles displaying the active ripple. */\n    _showActiveRipple() {\n      if (!this._isShowingRipple(this._activeRippleRef)) {\n        this._activeRippleRef = this._showRipple({\n          enterDuration: 225,\n          exitDuration: 400\n        });\n        this._activeRippleRef?.element.classList.add('mat-mdc-slider-active-ripple');\n      }\n    }\n    /** Whether the given rippleRef is currently fading in or visible. */\n    _isShowingRipple(rippleRef) {\n      return rippleRef?.state === RippleState.FADING_IN || rippleRef?.state === RippleState.VISIBLE;\n    }\n    /** Manually launches the slider thumb ripple using the specified ripple animation config. */\n    _showRipple(animation, ignoreGlobalRippleConfig) {\n      if (this._slider.disabled) {\n        return;\n      }\n      this._showValueIndicator();\n      if (this._slider._isRange) {\n        const sibling = this._slider._getThumb(this.thumbPosition === _MatThumb.START ? _MatThumb.END : _MatThumb.START);\n        sibling._showValueIndicator();\n      }\n      if (this._slider._globalRippleOptions?.disabled && !ignoreGlobalRippleConfig) {\n        return;\n      }\n      return this._ripple.launch({\n        animation: this._slider._noopAnimations ? {\n          enterDuration: 0,\n          exitDuration: 0\n        } : animation,\n        centered: true,\n        persistent: true\n      });\n    }\n    /**\n     * Fades out the given ripple.\n     * Also hides the value indicator if no ripple is showing.\n     */\n    _hideRipple(rippleRef) {\n      rippleRef?.fadeOut();\n      if (this._isShowingAnyRipple()) {\n        return;\n      }\n      if (!this._slider._isRange) {\n        this._hideValueIndicator();\n      }\n      const sibling = this._getSibling();\n      if (!sibling._isShowingAnyRipple()) {\n        this._hideValueIndicator();\n        sibling._hideValueIndicator();\n      }\n    }\n    /** Shows the value indicator ui. */\n    _showValueIndicator() {\n      this._hostElement.classList.add('mdc-slider__thumb--with-indicator');\n    }\n    /** Hides the value indicator ui. */\n    _hideValueIndicator() {\n      this._hostElement.classList.remove('mdc-slider__thumb--with-indicator');\n    }\n    _getSibling() {\n      return this._slider._getThumb(this.thumbPosition === _MatThumb.START ? _MatThumb.END : _MatThumb.START);\n    }\n    /** Gets the value indicator container's native HTML element. */\n    _getValueIndicatorContainer() {\n      return this._valueIndicatorContainer?.nativeElement;\n    }\n    /** Gets the native HTML element of the slider thumb knob. */\n    _getKnob() {\n      return this._knob.nativeElement;\n    }\n    _isShowingAnyRipple() {\n      return this._isShowingRipple(this._hoverRippleRef) || this._isShowingRipple(this._focusRippleRef) || this._isShowingRipple(this._activeRippleRef);\n    }\n    static \u0275fac = function MatSliderVisualThumb_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatSliderVisualThumb)();\n    };\n    static \u0275cmp = /* @__PURE__ */i0.\u0275\u0275defineComponent({\n      type: MatSliderVisualThumb,\n      selectors: [[\"mat-slider-visual-thumb\"]],\n      viewQuery: function MatSliderVisualThumb_Query(rf, ctx) {\n        if (rf & 1) {\n          i0.\u0275\u0275viewQuery(MatRipple, 5);\n          i0.\u0275\u0275viewQuery(_c0, 5);\n          i0.\u0275\u0275viewQuery(_c1, 5);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.\u0275\u0275queryRefresh(_t = i0.\u0275\u0275loadQuery()) && (ctx._ripple = _t.first);\n          i0.\u0275\u0275queryRefresh(_t = i0.\u0275\u0275loadQuery()) && (ctx._knob = _t.first);\n          i0.\u0275\u0275queryRefresh(_t = i0.\u0275\u0275loadQuery()) && (ctx._valueIndicatorContainer = _t.first);\n        }\n      },\n      hostAttrs: [1, \"mdc-slider__thumb\", \"mat-mdc-slider-visual-thumb\"],\n      inputs: {\n        discrete: \"discrete\",\n        thumbPosition: \"thumbPosition\",\n        valueIndicatorText: \"valueIndicatorText\"\n      },\n      features: [i0.\u0275\u0275ProvidersFeature([{\n        provide: MAT_SLIDER_VISUAL_THUMB,\n        useExisting: MatSliderVisualThumb\n      }])],\n      decls: 4,\n      vars: 2,\n      consts: [[\"knob\", \"\"], [\"valueIndicatorContainer\", \"\"], [1, \"mdc-slider__value-indicator-container\"], [1, \"mdc-slider__thumb-knob\"], [\"matRipple\", \"\", 1, \"mat-focus-indicator\", 3, \"matRippleDisabled\"], [1, \"mdc-slider__value-indicator\"], [1, \"mdc-slider__value-indicator-text\"]],\n      template: function MatSliderVisualThumb_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.\u0275\u0275conditionalCreate(0, MatSliderVisualThumb_Conditional_0_Template, 5, 1, \"div\", 2);\n          i0.\u0275\u0275element(1, \"div\", 3, 0)(3, \"div\", 4);\n        }\n        if (rf & 2) {\n          i0.\u0275\u0275conditional(ctx.discrete ? 0 : -1);\n          i0.\u0275\u0275advance(3);\n          i0.\u0275\u0275property(\"matRippleDisabled\", true);\n        }\n      },\n      dependencies: [MatRipple],\n      styles: [\".mat-mdc-slider-visual-thumb .mat-ripple{height:100%;width:100%}.mat-mdc-slider .mdc-slider__tick-marks{justify-content:start}.mat-mdc-slider .mdc-slider__tick-marks .mdc-slider__tick-mark--active,.mat-mdc-slider .mdc-slider__tick-marks .mdc-slider__tick-mark--inactive{position:absolute;left:2px}\\n\"],\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n  return MatSliderVisualThumb;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n// TODO(wagnermaciel): maybe handle the following edge case:\n// 1. start dragging discrete slider\n// 2. tab to disable checkbox\n// 3. without ending drag, disable the slider\n/**\n * Allows users to select from a range of values by moving the slider thumb. It is similar in\n * behavior to the native `<input type=\"range\">` element.\n */\nlet MatSlider = /*#__PURE__*/(() => {\n  class MatSlider {\n    _ngZone = inject(NgZone);\n    _cdr = inject(ChangeDetectorRef);\n    _elementRef = inject(ElementRef);\n    _dir = inject(Directionality, {\n      optional: true\n    });\n    _globalRippleOptions = inject(MAT_RIPPLE_GLOBAL_OPTIONS, {\n      optional: true\n    });\n    /** The active portion of the slider track. */\n    _trackActive;\n    /** The slider thumb(s). */\n    _thumbs;\n    /** The sliders hidden range input(s). */\n    _input;\n    /** The sliders hidden range input(s). */\n    _inputs;\n    /** Whether the slider is disabled. */\n    get disabled() {\n      return this._disabled;\n    }\n    set disabled(v) {\n      this._disabled = v;\n      const endInput = this._getInput(_MatThumb.END);\n      const startInput = this._getInput(_MatThumb.START);\n      if (endInput) {\n        endInput.disabled = this._disabled;\n      }\n      if (startInput) {\n        startInput.disabled = this._disabled;\n      }\n    }\n    _disabled = false;\n    /** Whether the slider displays a numeric value label upon pressing the thumb. */\n    get discrete() {\n      return this._discrete;\n    }\n    set discrete(v) {\n      this._discrete = v;\n      this._updateValueIndicatorUIs();\n    }\n    _discrete = false;\n    /** Whether the slider displays tick marks along the slider track. */\n    get showTickMarks() {\n      return this._showTickMarks;\n    }\n    set showTickMarks(value) {\n      this._showTickMarks = value;\n      if (this._hasViewInitialized) {\n        this._updateTickMarkUI();\n        this._updateTickMarkTrackUI();\n      }\n    }\n    _showTickMarks = false;\n    /** The minimum value that the slider can have. */\n    get min() {\n      return this._min;\n    }\n    set min(v) {\n      const min = v === undefined || v === null || isNaN(v) ? this._min : v;\n      if (this._min !== min) {\n        this._updateMin(min);\n      }\n    }\n    _min = 0;\n    /**\n     * Theme color of the slider. This API is supported in M2 themes only, it\n     * has no effect in M3 themes. For color customization in M3, see https://material.angular.dev/components/slider/styling.\n     *\n     * For information on applying color variants in M3, see\n     * https://material.angular.dev/guide/material-2-theming#optional-add-backwards-compatibility-styles-for-color-variants\n     */\n    color;\n    /** Whether ripples are disabled in the slider. */\n    disableRipple = false;\n    _updateMin(min) {\n      const prevMin = this._min;\n      this._min = min;\n      this._isRange ? this._updateMinRange({\n        old: prevMin,\n        new: min\n      }) : this._updateMinNonRange(min);\n      this._onMinMaxOrStepChange();\n    }\n    _updateMinRange(min) {\n      const endInput = this._getInput(_MatThumb.END);\n      const startInput = this._getInput(_MatThumb.START);\n      const oldEndValue = endInput.value;\n      const oldStartValue = startInput.value;\n      startInput.min = min.new;\n      endInput.min = Math.max(min.new, startInput.value);\n      startInput.max = Math.min(endInput.max, endInput.value);\n      startInput._updateWidthInactive();\n      endInput._updateWidthInactive();\n      min.new < min.old ? this._onTranslateXChangeBySideEffect(endInput, startInput) : this._onTranslateXChangeBySideEffect(startInput, endInput);\n      if (oldEndValue !== endInput.value) {\n        this._onValueChange(endInput);\n      }\n      if (oldStartValue !== startInput.value) {\n        this._onValueChange(startInput);\n      }\n    }\n    _updateMinNonRange(min) {\n      const input = this._getInput(_MatThumb.END);\n      if (input) {\n        const oldValue = input.value;\n        input.min = min;\n        input._updateThumbUIByValue();\n        this._updateTrackUI(input);\n        if (oldValue !== input.value) {\n          this._onValueChange(input);\n        }\n      }\n    }\n    /** The maximum value that the slider can have. */\n    get max() {\n      return this._max;\n    }\n    set max(v) {\n      const max = v === undefined || v === null || isNaN(v) ? this._max : v;\n      if (this._max !== max) {\n        this._updateMax(max);\n      }\n    }\n    _max = 100;\n    _updateMax(max) {\n      const prevMax = this._max;\n      this._max = max;\n      this._isRange ? this._updateMaxRange({\n        old: prevMax,\n        new: max\n      }) : this._updateMaxNonRange(max);\n      this._onMinMaxOrStepChange();\n    }\n    _updateMaxRange(max) {\n      const endInput = this._getInput(_MatThumb.END);\n      const startInput = this._getInput(_MatThumb.START);\n      const oldEndValue = endInput.value;\n      const oldStartValue = startInput.value;\n      endInput.max = max.new;\n      startInput.max = Math.min(max.new, endInput.value);\n      endInput.min = startInput.value;\n      endInput._updateWidthInactive();\n      startInput._updateWidthInactive();\n      max.new > max.old ? this._onTranslateXChangeBySideEffect(startInput, endInput) : this._onTranslateXChangeBySideEffect(endInput, startInput);\n      if (oldEndValue !== endInput.value) {\n        this._onValueChange(endInput);\n      }\n      if (oldStartValue !== startInput.value) {\n        this._onValueChange(startInput);\n      }\n    }\n    _updateMaxNonRange(max) {\n      const input = this._getInput(_MatThumb.END);\n      if (input) {\n        const oldValue = input.value;\n        input.max = max;\n        input._updateThumbUIByValue();\n        this._updateTrackUI(input);\n        if (oldValue !== input.value) {\n          this._onValueChange(input);\n        }\n      }\n    }\n    /** The values at which the thumb will snap. */\n    get step() {\n      return this._step;\n    }\n    set step(v) {\n      const step = isNaN(v) ? this._step : v;\n      if (this._step !== step) {\n        this._updateStep(step);\n      }\n    }\n    _step = 1;\n    _updateStep(step) {\n      this._step = step;\n      this._isRange ? this._updateStepRange() : this._updateStepNonRange();\n      this._onMinMaxOrStepChange();\n    }\n    _updateStepRange() {\n      const endInput = this._getInput(_MatThumb.END);\n      const startInput = this._getInput(_MatThumb.START);\n      const oldEndValue = endInput.value;\n      const oldStartValue = startInput.value;\n      const prevStartValue = startInput.value;\n      endInput.min = this._min;\n      startInput.max = this._max;\n      endInput.step = this._step;\n      startInput.step = this._step;\n      if (this._platform.SAFARI) {\n        endInput.value = endInput.value;\n        startInput.value = startInput.value;\n      }\n      endInput.min = Math.max(this._min, startInput.value);\n      startInput.max = Math.min(this._max, endInput.value);\n      startInput._updateWidthInactive();\n      endInput._updateWidthInactive();\n      endInput.value < prevStartValue ? this._onTranslateXChangeBySideEffect(startInput, endInput) : this._onTranslateXChangeBySideEffect(endInput, startInput);\n      if (oldEndValue !== endInput.value) {\n        this._onValueChange(endInput);\n      }\n      if (oldStartValue !== startInput.value) {\n        this._onValueChange(startInput);\n      }\n    }\n    _updateStepNonRange() {\n      const input = this._getInput(_MatThumb.END);\n      if (input) {\n        const oldValue = input.value;\n        input.step = this._step;\n        if (this._platform.SAFARI) {\n          input.value = input.value;\n        }\n        input._updateThumbUIByValue();\n        if (oldValue !== input.value) {\n          this._onValueChange(input);\n        }\n      }\n    }\n    /**\n     * Function that will be used to format the value before it is displayed\n     * in the thumb label. Can be used to format very large number in order\n     * for them to fit into the slider thumb.\n     */\n    displayWith = value => `${value}`;\n    /** Used to keep track of & render the active & inactive tick marks on the slider track. */\n    _tickMarks;\n    /** Whether animations have been disabled. */\n    _noopAnimations = _animationsDisabled();\n    /** Subscription to changes to the directionality (LTR / RTL) context for the application. */\n    _dirChangeSubscription;\n    /** Observer used to monitor size changes in the slider. */\n    _resizeObserver;\n    // Stored dimensions to avoid calling getBoundingClientRect redundantly.\n    _cachedWidth;\n    _cachedLeft;\n    _rippleRadius = 24;\n    // The value indicator tooltip text for the visual slider thumb(s).\n    /** @docs-private */\n    startValueIndicatorText = '';\n    /** @docs-private */\n    endValueIndicatorText = '';\n    // Used to control the translateX of the visual slider thumb(s).\n    _endThumbTransform;\n    _startThumbTransform;\n    _isRange = false;\n    /** Whether the slider is rtl. */\n    _isRtl = false;\n    _hasViewInitialized = false;\n    /**\n     * The width of the tick mark track.\n     * The tick mark track width is different from full track width\n     */\n    _tickMarkTrackWidth = 0;\n    _hasAnimation = false;\n    _resizeTimer = null;\n    _platform = inject(Platform);\n    constructor() {\n      inject(_CdkPrivateStyleLoader).load(_StructuralStylesLoader);\n      if (this._dir) {\n        this._dirChangeSubscription = this._dir.change.subscribe(() => this._onDirChange());\n        this._isRtl = this._dir.value === 'rtl';\n      }\n    }\n    /** The radius of the native slider's knob. AFAIK there is no way to avoid hardcoding this. */\n    _knobRadius = 8;\n    _inputPadding;\n    ngAfterViewInit() {\n      if (this._platform.isBrowser) {\n        this._updateDimensions();\n      }\n      const eInput = this._getInput(_MatThumb.END);\n      const sInput = this._getInput(_MatThumb.START);\n      this._isRange = !!eInput && !!sInput;\n      this._cdr.detectChanges();\n      if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        _validateInputs(this._isRange, this._getInput(_MatThumb.END), this._getInput(_MatThumb.START));\n      }\n      const thumb = this._getThumb(_MatThumb.END);\n      this._rippleRadius = thumb._ripple.radius;\n      this._inputPadding = this._rippleRadius - this._knobRadius;\n      this._isRange ? this._initUIRange(eInput, sInput) : this._initUINonRange(eInput);\n      this._updateTrackUI(eInput);\n      this._updateTickMarkUI();\n      this._updateTickMarkTrackUI();\n      this._observeHostResize();\n      this._cdr.detectChanges();\n    }\n    _initUINonRange(eInput) {\n      eInput.initProps();\n      eInput.initUI();\n      this._updateValueIndicatorUI(eInput);\n      this._hasViewInitialized = true;\n      eInput._updateThumbUIByValue();\n    }\n    _initUIRange(eInput, sInput) {\n      eInput.initProps();\n      eInput.initUI();\n      sInput.initProps();\n      sInput.initUI();\n      eInput._updateMinMax();\n      sInput._updateMinMax();\n      eInput._updateStaticStyles();\n      sInput._updateStaticStyles();\n      this._updateValueIndicatorUIs();\n      this._hasViewInitialized = true;\n      eInput._updateThumbUIByValue();\n      sInput._updateThumbUIByValue();\n    }\n    ngOnDestroy() {\n      this._dirChangeSubscription.unsubscribe();\n      this._resizeObserver?.disconnect();\n      this._resizeObserver = null;\n    }\n    /** Handles updating the slider ui after a dir change. */\n    _onDirChange() {\n      this._isRtl = this._dir?.value === 'rtl';\n      this._isRange ? this._onDirChangeRange() : this._onDirChangeNonRange();\n      this._updateTickMarkUI();\n    }\n    _onDirChangeRange() {\n      const endInput = this._getInput(_MatThumb.END);\n      const startInput = this._getInput(_MatThumb.START);\n      endInput._setIsLeftThumb();\n      startInput._setIsLeftThumb();\n      endInput.translateX = endInput._calcTranslateXByValue();\n      startInput.translateX = startInput._calcTranslateXByValue();\n      endInput._updateStaticStyles();\n      startInput._updateStaticStyles();\n      endInput._updateWidthInactive();\n      startInput._updateWidthInactive();\n      endInput._updateThumbUIByValue();\n      startInput._updateThumbUIByValue();\n    }\n    _onDirChangeNonRange() {\n      const input = this._getInput(_MatThumb.END);\n      input._updateThumbUIByValue();\n    }\n    /** Starts observing and updating the slider if the host changes its size. */\n    _observeHostResize() {\n      if (typeof ResizeObserver === 'undefined' || !ResizeObserver) {\n        return;\n      }\n      this._ngZone.runOutsideAngular(() => {\n        this._resizeObserver = new ResizeObserver(() => {\n          if (this._isActive()) {\n            return;\n          }\n          if (this._resizeTimer) {\n            clearTimeout(this._resizeTimer);\n          }\n          this._onResize();\n        });\n        this._resizeObserver.observe(this._elementRef.nativeElement);\n      });\n    }\n    /** Whether any of the thumbs are currently active. */\n    _isActive() {\n      return this._getThumb(_MatThumb.START)._isActive || this._getThumb(_MatThumb.END)._isActive;\n    }\n    _getValue(thumbPosition = _MatThumb.END) {\n      const input = this._getInput(thumbPosition);\n      if (!input) {\n        return this.min;\n      }\n      return input.value;\n    }\n    _skipUpdate() {\n      return !!(this._getInput(_MatThumb.START)?._skipUIUpdate || this._getInput(_MatThumb.END)?._skipUIUpdate);\n    }\n    /** Stores the slider dimensions. */\n    _updateDimensions() {\n      this._cachedWidth = this._elementRef.nativeElement.offsetWidth;\n      this._cachedLeft = this._elementRef.nativeElement.getBoundingClientRect().left;\n    }\n    /** Sets the styles for the active portion of the track. */\n    _setTrackActiveStyles(styles) {\n      const trackStyle = this._trackActive.nativeElement.style;\n      trackStyle.left = styles.left;\n      trackStyle.right = styles.right;\n      trackStyle.transformOrigin = styles.transformOrigin;\n      trackStyle.transform = styles.transform;\n    }\n    /** Returns the translateX positioning for a tick mark based on it's index. */\n    _calcTickMarkTransform(index) {\n      // TODO(wagnermaciel): See if we can avoid doing this and just using flex to position these.\n      const offset = index * (this._tickMarkTrackWidth / (this._tickMarks.length - 1));\n      const translateX = this._isRtl ? this._cachedWidth - 6 - offset : offset;\n      return `translateX(${translateX}px`;\n    }\n    // Handlers for updating the slider ui.\n    _onTranslateXChange(source) {\n      if (!this._hasViewInitialized) {\n        return;\n      }\n      this._updateThumbUI(source);\n      this._updateTrackUI(source);\n      this._updateOverlappingThumbUI(source);\n    }\n    _onTranslateXChangeBySideEffect(input1, input2) {\n      if (!this._hasViewInitialized) {\n        return;\n      }\n      input1._updateThumbUIByValue();\n      input2._updateThumbUIByValue();\n    }\n    _onValueChange(source) {\n      if (!this._hasViewInitialized) {\n        return;\n      }\n      this._updateValueIndicatorUI(source);\n      this._updateTickMarkUI();\n      this._cdr.detectChanges();\n    }\n    _onMinMaxOrStepChange() {\n      if (!this._hasViewInitialized) {\n        return;\n      }\n      this._updateTickMarkUI();\n      this._updateTickMarkTrackUI();\n      this._cdr.markForCheck();\n    }\n    _onResize() {\n      if (!this._hasViewInitialized) {\n        return;\n      }\n      this._updateDimensions();\n      if (this._isRange) {\n        const eInput = this._getInput(_MatThumb.END);\n        const sInput = this._getInput(_MatThumb.START);\n        eInput._updateThumbUIByValue();\n        sInput._updateThumbUIByValue();\n        eInput._updateStaticStyles();\n        sInput._updateStaticStyles();\n        eInput._updateMinMax();\n        sInput._updateMinMax();\n        eInput._updateWidthInactive();\n        sInput._updateWidthInactive();\n      } else {\n        const eInput = this._getInput(_MatThumb.END);\n        if (eInput) {\n          eInput._updateThumbUIByValue();\n        }\n      }\n      this._updateTickMarkUI();\n      this._updateTickMarkTrackUI();\n      this._cdr.detectChanges();\n    }\n    /** Whether or not the slider thumbs overlap. */\n    _thumbsOverlap = false;\n    /** Returns true if the slider knobs are overlapping one another. */\n    _areThumbsOverlapping() {\n      const startInput = this._getInput(_MatThumb.START);\n      const endInput = this._getInput(_MatThumb.END);\n      if (!startInput || !endInput) {\n        return false;\n      }\n      return endInput.translateX - startInput.translateX < 20;\n    }\n    /**\n     * Updates the class names of overlapping slider thumbs so\n     * that the current active thumb is styled to be on \"top\".\n     */\n    _updateOverlappingThumbClassNames(source) {\n      const sibling = source.getSibling();\n      const sourceThumb = this._getThumb(source.thumbPosition);\n      const siblingThumb = this._getThumb(sibling.thumbPosition);\n      siblingThumb._hostElement.classList.remove('mdc-slider__thumb--top');\n      sourceThumb._hostElement.classList.toggle('mdc-slider__thumb--top', this._thumbsOverlap);\n    }\n    /** Updates the UI of slider thumbs when they begin or stop overlapping. */\n    _updateOverlappingThumbUI(source) {\n      if (!this._isRange || this._skipUpdate()) {\n        return;\n      }\n      if (this._thumbsOverlap !== this._areThumbsOverlapping()) {\n        this._thumbsOverlap = !this._thumbsOverlap;\n        this._updateOverlappingThumbClassNames(source);\n      }\n    }\n    // _MatThumb styles update conditions\n    //\n    // 1. TranslateX, resize, or dir change\n    //    - Reason: The thumb styles need to be updated according to the new translateX.\n    // 2. Min, max, or step\n    //    - Reason: The value may have silently changed.\n    /** Updates the translateX of the given thumb. */\n    _updateThumbUI(source) {\n      if (this._skipUpdate()) {\n        return;\n      }\n      const thumb = this._getThumb(source.thumbPosition === _MatThumb.END ? _MatThumb.END : _MatThumb.START);\n      thumb._hostElement.style.transform = `translateX(${source.translateX}px)`;\n    }\n    // Value indicator text update conditions\n    //\n    // 1. Value\n    //    - Reason: The value displayed needs to be updated.\n    // 2. Min, max, or step\n    //    - Reason: The value may have silently changed.\n    /** Updates the value indicator tooltip ui for the given thumb. */\n    _updateValueIndicatorUI(source) {\n      if (this._skipUpdate()) {\n        return;\n      }\n      const valuetext = this.displayWith(source.value);\n      this._hasViewInitialized ? source._valuetext.set(valuetext) : source._hostElement.setAttribute('aria-valuetext', valuetext);\n      if (this.discrete) {\n        source.thumbPosition === _MatThumb.START ? this.startValueIndicatorText = valuetext : this.endValueIndicatorText = valuetext;\n        const visualThumb = this._getThumb(source.thumbPosition);\n        valuetext.length < 3 ? visualThumb._hostElement.classList.add('mdc-slider__thumb--short-value') : visualThumb._hostElement.classList.remove('mdc-slider__thumb--short-value');\n      }\n    }\n    /** Updates all value indicator UIs in the slider. */\n    _updateValueIndicatorUIs() {\n      const eInput = this._getInput(_MatThumb.END);\n      const sInput = this._getInput(_MatThumb.START);\n      if (eInput) {\n        this._updateValueIndicatorUI(eInput);\n      }\n      if (sInput) {\n        this._updateValueIndicatorUI(sInput);\n      }\n    }\n    // Update Tick Mark Track Width\n    //\n    // 1. Min, max, or step\n    //    - Reason: The maximum reachable value may have changed.\n    //    - Side note: The maximum reachable value is different from the maximum value set by the\n    //      user. For example, a slider with [min: 5, max: 100, step: 10] would have a maximum\n    //      reachable value of 95.\n    // 2. Resize\n    //    - Reason: The position for the maximum reachable value needs to be recalculated.\n    /** Updates the width of the tick mark track. */\n    _updateTickMarkTrackUI() {\n      if (!this.showTickMarks || this._skipUpdate()) {\n        return;\n      }\n      const step = this._step && this._step > 0 ? this._step : 1;\n      const maxValue = Math.floor(this.max / step) * step;\n      const percentage = (maxValue - this.min) / (this.max - this.min);\n      this._tickMarkTrackWidth = (this._cachedWidth - 6) * percentage;\n    }\n    // Track active update conditions\n    //\n    // 1. TranslateX\n    //    - Reason: The track active should line up with the new thumb position.\n    // 2. Min or max\n    //    - Reason #1: The 'active' percentage needs to be recalculated.\n    //    - Reason #2: The value may have silently changed.\n    // 3. Step\n    //    - Reason: The value may have silently changed causing the thumb(s) to shift.\n    // 4. Dir change\n    //    - Reason: The track active will need to be updated according to the new thumb position(s).\n    // 5. Resize\n    //    - Reason: The total width the 'active' tracks translateX is based on has changed.\n    /** Updates the scale on the active portion of the track. */\n    _updateTrackUI(source) {\n      if (this._skipUpdate()) {\n        return;\n      }\n      this._isRange ? this._updateTrackUIRange(source) : this._updateTrackUINonRange(source);\n    }\n    _updateTrackUIRange(source) {\n      const sibling = source.getSibling();\n      if (!sibling || !this._cachedWidth) {\n        return;\n      }\n      const activePercentage = Math.abs(sibling.translateX - source.translateX) / this._cachedWidth;\n      if (source._isLeftThumb && this._cachedWidth) {\n        this._setTrackActiveStyles({\n          left: 'auto',\n          right: `${this._cachedWidth - sibling.translateX}px`,\n          transformOrigin: 'right',\n          transform: `scaleX(${activePercentage})`\n        });\n      } else {\n        this._setTrackActiveStyles({\n          left: `${sibling.translateX}px`,\n          right: 'auto',\n          transformOrigin: 'left',\n          transform: `scaleX(${activePercentage})`\n        });\n      }\n    }\n    _updateTrackUINonRange(source) {\n      this._isRtl ? this._setTrackActiveStyles({\n        left: 'auto',\n        right: '0px',\n        transformOrigin: 'right',\n        transform: `scaleX(${1 - source.fillPercentage})`\n      }) : this._setTrackActiveStyles({\n        left: '0px',\n        right: 'auto',\n        transformOrigin: 'left',\n        transform: `scaleX(${source.fillPercentage})`\n      });\n    }\n    // Tick mark update conditions\n    //\n    // 1. Value\n    //    - Reason: a tick mark which was once active might now be inactive or vice versa.\n    // 2. Min, max, or step\n    //    - Reason #1: the number of tick marks may have changed.\n    //    - Reason #2: The value may have silently changed.\n    /** Updates the dots along the slider track. */\n    _updateTickMarkUI() {\n      if (!this.showTickMarks || this.step === undefined || this.min === undefined || this.max === undefined) {\n        return;\n      }\n      const step = this.step > 0 ? this.step : 1;\n      this._isRange ? this._updateTickMarkUIRange(step) : this._updateTickMarkUINonRange(step);\n    }\n    _updateTickMarkUINonRange(step) {\n      const value = this._getValue();\n      let numActive = Math.max(Math.round((value - this.min) / step), 0) + 1;\n      let numInactive = Math.max(Math.round((this.max - value) / step), 0) - 1;\n      this._isRtl ? numActive++ : numInactive++;\n      this._tickMarks = Array(numActive).fill(_MatTickMark.ACTIVE).concat(Array(numInactive).fill(_MatTickMark.INACTIVE));\n    }\n    _updateTickMarkUIRange(step) {\n      const endValue = this._getValue();\n      const startValue = this._getValue(_MatThumb.START);\n      const numInactiveBeforeStartThumb = Math.max(Math.round((startValue - this.min) / step), 0);\n      const numActive = Math.max(Math.round((endValue - startValue) / step) + 1, 0);\n      const numInactiveAfterEndThumb = Math.max(Math.round((this.max - endValue) / step), 0);\n      this._tickMarks = Array(numInactiveBeforeStartThumb).fill(_MatTickMark.INACTIVE).concat(Array(numActive).fill(_MatTickMark.ACTIVE), Array(numInactiveAfterEndThumb).fill(_MatTickMark.INACTIVE));\n    }\n    /** Gets the slider thumb input of the given thumb position. */\n    _getInput(thumbPosition) {\n      if (thumbPosition === _MatThumb.END && this._input) {\n        return this._input;\n      }\n      if (this._inputs?.length) {\n        return thumbPosition === _MatThumb.START ? this._inputs.first : this._inputs.last;\n      }\n      return;\n    }\n    /** Gets the slider thumb HTML input element of the given thumb position. */\n    _getThumb(thumbPosition) {\n      return thumbPosition === _MatThumb.END ? this._thumbs?.last : this._thumbs?.first;\n    }\n    _setTransition(withAnimation) {\n      this._hasAnimation = !this._platform.IOS && withAnimation && !this._noopAnimations;\n      this._elementRef.nativeElement.classList.toggle('mat-mdc-slider-with-animation', this._hasAnimation);\n    }\n    /** Whether the given pointer event occurred within the bounds of the slider pointer's DOM Rect. */\n    _isCursorOnSliderThumb(event, rect) {\n      const radius = rect.width / 2;\n      const centerX = rect.x + radius;\n      const centerY = rect.y + radius;\n      const dx = event.clientX - centerX;\n      const dy = event.clientY - centerY;\n      return Math.pow(dx, 2) + Math.pow(dy, 2) < Math.pow(radius, 2);\n    }\n    static \u0275fac = function MatSlider_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatSlider)();\n    };\n    static \u0275cmp = /* @__PURE__ */i0.\u0275\u0275defineComponent({\n      type: MatSlider,\n      selectors: [[\"mat-slider\"]],\n      contentQueries: function MatSlider_ContentQueries(rf, ctx, dirIndex) {\n        if (rf & 1) {\n          i0.\u0275\u0275contentQuery(dirIndex, MAT_SLIDER_THUMB, 5);\n          i0.\u0275\u0275contentQuery(dirIndex, MAT_SLIDER_RANGE_THUMB, 4);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.\u0275\u0275queryRefresh(_t = i0.\u0275\u0275loadQuery()) && (ctx._input = _t.first);\n          i0.\u0275\u0275queryRefresh(_t = i0.\u0275\u0275loadQuery()) && (ctx._inputs = _t);\n        }\n      },\n      viewQuery: function MatSlider_Query(rf, ctx) {\n        if (rf & 1) {\n          i0.\u0275\u0275viewQuery(_c2, 5);\n          i0.\u0275\u0275viewQuery(MAT_SLIDER_VISUAL_THUMB, 5);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.\u0275\u0275queryRefresh(_t = i0.\u0275\u0275loadQuery()) && (ctx._trackActive = _t.first);\n          i0.\u0275\u0275queryRefresh(_t = i0.\u0275\u0275loadQuery()) && (ctx._thumbs = _t);\n        }\n      },\n      hostAttrs: [1, \"mat-mdc-slider\", \"mdc-slider\"],\n      hostVars: 12,\n      hostBindings: function MatSlider_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.\u0275\u0275classMap(\"mat-\" + (ctx.color || \"primary\"));\n          i0.\u0275\u0275classProp(\"mdc-slider--range\", ctx._isRange)(\"mdc-slider--disabled\", ctx.disabled)(\"mdc-slider--discrete\", ctx.discrete)(\"mdc-slider--tick-marks\", ctx.showTickMarks)(\"_mat-animation-noopable\", ctx._noopAnimations);\n        }\n      },\n      inputs: {\n        disabled: [2, \"disabled\", \"disabled\", booleanAttribute],\n        discrete: [2, \"discrete\", \"discrete\", booleanAttribute],\n        showTickMarks: [2, \"showTickMarks\", \"showTickMarks\", booleanAttribute],\n        min: [2, \"min\", \"min\", numberAttribute],\n        color: \"color\",\n        disableRipple: [2, \"disableRipple\", \"disableRipple\", booleanAttribute],\n        max: [2, \"max\", \"max\", numberAttribute],\n        step: [2, \"step\", \"step\", numberAttribute],\n        displayWith: \"displayWith\"\n      },\n      exportAs: [\"matSlider\"],\n      features: [i0.\u0275\u0275ProvidersFeature([{\n        provide: MAT_SLIDER,\n        useExisting: MatSlider\n      }])],\n      ngContentSelectors: _c3,\n      decls: 9,\n      vars: 5,\n      consts: [[\"trackActive\", \"\"], [\"tickMarkContainer\", \"\"], [1, \"mdc-slider__track\"], [1, \"mdc-slider__track--inactive\"], [1, \"mdc-slider__track--active\"], [1, \"mdc-slider__track--active_fill\"], [1, \"mdc-slider__tick-marks\"], [3, \"discrete\", \"thumbPosition\", \"valueIndicatorText\"], [3, \"class\", \"transform\"]],\n      template: function MatSlider_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.\u0275\u0275projectionDef();\n          i0.\u0275\u0275projection(0);\n          i0.\u0275\u0275elementStart(1, \"div\", 2);\n          i0.\u0275\u0275element(2, \"div\", 3);\n          i0.\u0275\u0275elementStart(3, \"div\", 4);\n          i0.\u0275\u0275element(4, \"div\", 5, 0);\n          i0.\u0275\u0275elementEnd();\n          i0.\u0275\u0275conditionalCreate(6, MatSlider_Conditional_6_Template, 3, 1, \"div\", 6);\n          i0.\u0275\u0275elementEnd();\n          i0.\u0275\u0275conditionalCreate(7, MatSlider_Conditional_7_Template, 1, 3, \"mat-slider-visual-thumb\", 7);\n          i0.\u0275\u0275element(8, \"mat-slider-visual-thumb\", 7);\n        }\n        if (rf & 2) {\n          i0.\u0275\u0275advance(6);\n          i0.\u0275\u0275conditional(ctx.showTickMarks ? 6 : -1);\n          i0.\u0275\u0275advance();\n          i0.\u0275\u0275conditional(ctx._isRange ? 7 : -1);\n          i0.\u0275\u0275advance();\n          i0.\u0275\u0275property(\"discrete\", ctx.discrete)(\"thumbPosition\", 2)(\"valueIndicatorText\", ctx.endValueIndicatorText);\n        }\n      },\n      dependencies: [MatSliderVisualThumb],\n      styles: [\".mdc-slider__track{position:absolute;top:50%;transform:translateY(-50%);width:100%;pointer-events:none;height:var(--mat-slider-inactive-track-height, 4px)}.mdc-slider__track--active,.mdc-slider__track--inactive{display:flex;height:100%;position:absolute;width:100%}.mdc-slider__track--active{overflow:hidden;border-radius:var(--mat-slider-active-track-shape, var(--mat-sys-corner-full));height:var(--mat-slider-active-track-height, 4px);top:calc((var(--mat-slider-inactive-track-height, 4px) - var(--mat-slider-active-track-height, 4px))/2)}.mdc-slider__track--active_fill{border-top-style:solid;box-sizing:border-box;height:100%;width:100%;position:relative;transform-origin:left;transition:transform 80ms ease;border-color:var(--mat-slider-active-track-color, var(--mat-sys-primary));border-top-width:var(--mat-slider-active-track-height, 4px)}.mdc-slider--disabled .mdc-slider__track--active_fill{border-color:var(--mat-slider-disabled-active-track-color, var(--mat-sys-on-surface))}[dir=rtl] .mdc-slider__track--active_fill{-webkit-transform-origin:right;transform-origin:right}.mdc-slider__track--inactive{left:0;top:0;opacity:.24;background-color:var(--mat-slider-inactive-track-color, var(--mat-sys-surface-variant));height:var(--mat-slider-inactive-track-height, 4px);border-radius:var(--mat-slider-inactive-track-shape, var(--mat-sys-corner-full))}.mdc-slider--disabled .mdc-slider__track--inactive{background-color:var(--mat-slider-disabled-inactive-track-color, var(--mat-sys-on-surface));opacity:.24}.mdc-slider__track--inactive::before{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:1px solid rgba(0,0,0,0);border-radius:inherit;content:\\\"\\\";pointer-events:none}@media(forced-colors: active){.mdc-slider__track--inactive::before{border-color:CanvasText}}.mdc-slider__value-indicator-container{bottom:44px;left:50%;pointer-events:none;position:absolute;transform:var(--mat-slider-value-indicator-container-transform, translateX(-50%) rotate(-45deg))}.mdc-slider__thumb--with-indicator .mdc-slider__value-indicator-container{pointer-events:auto}.mdc-slider__value-indicator{display:flex;align-items:center;transform:scale(0);transform-origin:var(--mat-slider-value-indicator-transform-origin, 0 28px);transition:transform 100ms cubic-bezier(0.4, 0, 1, 1);word-break:normal;background-color:var(--mat-slider-label-container-color, var(--mat-sys-primary));color:var(--mat-slider-label-label-text-color, var(--mat-sys-on-primary));width:var(--mat-slider-value-indicator-width, 28px);height:var(--mat-slider-value-indicator-height, 28px);padding:var(--mat-slider-value-indicator-padding, 0);opacity:var(--mat-slider-value-indicator-opacity, 1);border-radius:var(--mat-slider-value-indicator-border-radius, 50% 50% 50% 0)}.mdc-slider__thumb--with-indicator .mdc-slider__value-indicator{transition:transform 100ms cubic-bezier(0, 0, 0.2, 1);transform:scale(1)}.mdc-slider__value-indicator::before{border-left:6px solid rgba(0,0,0,0);border-right:6px solid rgba(0,0,0,0);border-top:6px solid;bottom:-5px;content:\\\"\\\";height:0;left:50%;position:absolute;transform:translateX(-50%);width:0;display:var(--mat-slider-value-indicator-caret-display, none);border-top-color:var(--mat-slider-label-container-color, var(--mat-sys-primary))}.mdc-slider__value-indicator::after{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:1px solid rgba(0,0,0,0);border-radius:inherit;content:\\\"\\\";pointer-events:none}@media(forced-colors: active){.mdc-slider__value-indicator::after{border-color:CanvasText}}.mdc-slider__value-indicator-text{text-align:center;width:var(--mat-slider-value-indicator-width, 28px);transform:var(--mat-slider-value-indicator-text-transform, rotate(45deg));font-family:var(--mat-slider-label-label-text-font, var(--mat-sys-label-medium-font));font-size:var(--mat-slider-label-label-text-size, var(--mat-sys-label-medium-size));font-weight:var(--mat-slider-label-label-text-weight, var(--mat-sys-label-medium-weight));line-height:var(--mat-slider-label-label-text-line-height, var(--mat-sys-label-medium-line-height));letter-spacing:var(--mat-slider-label-label-text-tracking, var(--mat-sys-label-medium-tracking))}.mdc-slider__thumb{-webkit-user-select:none;user-select:none;display:flex;left:-24px;outline:none;position:absolute;height:48px;width:48px;pointer-events:none}.mdc-slider--discrete .mdc-slider__thumb{transition:transform 80ms ease}.mdc-slider--disabled .mdc-slider__thumb{pointer-events:none}.mdc-slider__thumb--top{z-index:1}.mdc-slider__thumb-knob{position:absolute;box-sizing:border-box;left:50%;top:50%;transform:translate(-50%, -50%);border-style:solid;width:var(--mat-slider-handle-width, 20px);height:var(--mat-slider-handle-height, 20px);border-width:calc(var(--mat-slider-handle-height, 20px)/2) calc(var(--mat-slider-handle-width, 20px)/2);box-shadow:var(--mat-slider-handle-elevation, var(--mat-sys-level1));background-color:var(--mat-slider-handle-color, var(--mat-sys-primary));border-color:var(--mat-slider-handle-color, var(--mat-sys-primary));border-radius:var(--mat-slider-handle-shape, var(--mat-sys-corner-full))}.mdc-slider__thumb:hover .mdc-slider__thumb-knob{background-color:var(--mat-slider-hover-handle-color, var(--mat-sys-primary));border-color:var(--mat-slider-hover-handle-color, var(--mat-sys-primary))}.mdc-slider__thumb--focused .mdc-slider__thumb-knob{background-color:var(--mat-slider-focus-handle-color, var(--mat-sys-primary));border-color:var(--mat-slider-focus-handle-color, var(--mat-sys-primary))}.mdc-slider--disabled .mdc-slider__thumb-knob{background-color:var(--mat-slider-disabled-handle-color, var(--mat-sys-on-surface));border-color:var(--mat-slider-disabled-handle-color, var(--mat-sys-on-surface))}.mdc-slider__thumb--top .mdc-slider__thumb-knob,.mdc-slider__thumb--top.mdc-slider__thumb:hover .mdc-slider__thumb-knob,.mdc-slider__thumb--top.mdc-slider__thumb--focused .mdc-slider__thumb-knob{border:solid 1px #fff;box-sizing:content-box;border-color:var(--mat-slider-with-overlap-handle-outline-color, var(--mat-sys-on-primary));border-width:var(--mat-slider-with-overlap-handle-outline-width, 1px)}.mdc-slider__tick-marks{align-items:center;box-sizing:border-box;display:flex;height:100%;justify-content:space-between;padding:0 1px;position:absolute;width:100%}.mdc-slider__tick-mark--active,.mdc-slider__tick-mark--inactive{width:var(--mat-slider-with-tick-marks-container-size, 2px);height:var(--mat-slider-with-tick-marks-container-size, 2px);border-radius:var(--mat-slider-with-tick-marks-container-shape, var(--mat-sys-corner-full))}.mdc-slider__tick-mark--inactive{opacity:var(--mat-slider-with-tick-marks-inactive-container-opacity, 0.38);background-color:var(--mat-slider-with-tick-marks-inactive-container-color, var(--mat-sys-on-surface-variant))}.mdc-slider--disabled .mdc-slider__tick-mark--inactive{opacity:var(--mat-slider-with-tick-marks-inactive-container-opacity, 0.38);background-color:var(--mat-slider-with-tick-marks-disabled-container-color, var(--mat-sys-on-surface))}.mdc-slider__tick-mark--active{opacity:var(--mat-slider-with-tick-marks-active-container-opacity, 0.38);background-color:var(--mat-slider-with-tick-marks-active-container-color, var(--mat-sys-on-primary))}.mdc-slider__input{cursor:pointer;left:2px;margin:0;height:44px;opacity:0;position:absolute;top:2px;width:44px;box-sizing:content-box}.mdc-slider__input.mat-mdc-slider-input-no-pointer-events{pointer-events:none}.mdc-slider__input.mat-slider__right-input{left:auto;right:0}.mat-mdc-slider{display:inline-block;box-sizing:border-box;outline:none;vertical-align:middle;cursor:pointer;height:48px;margin:0 8px;position:relative;touch-action:pan-y;width:auto;min-width:112px;-webkit-tap-highlight-color:rgba(0,0,0,0)}.mat-mdc-slider.mdc-slider--disabled{cursor:auto;opacity:.38}.mat-mdc-slider.mdc-slider--disabled .mdc-slider__input{cursor:auto}.mat-mdc-slider .mdc-slider__thumb,.mat-mdc-slider .mdc-slider__track--active_fill{transition-duration:0ms}.mat-mdc-slider.mat-mdc-slider-with-animation .mdc-slider__thumb,.mat-mdc-slider.mat-mdc-slider-with-animation .mdc-slider__track--active_fill{transition-duration:80ms}.mat-mdc-slider.mdc-slider--discrete .mdc-slider__thumb,.mat-mdc-slider.mdc-slider--discrete .mdc-slider__track--active_fill{transition-duration:0ms}.mat-mdc-slider.mat-mdc-slider-with-animation .mdc-slider__thumb,.mat-mdc-slider.mat-mdc-slider-with-animation .mdc-slider__track--active_fill{transition-duration:80ms}.mat-mdc-slider .mat-ripple .mat-ripple-element{background-color:var(--mat-slider-ripple-color, var(--mat-sys-primary))}.mat-mdc-slider .mat-ripple .mat-mdc-slider-hover-ripple{background-color:var(--mat-slider-hover-state-layer-color, color-mix(in srgb, var(--mat-sys-primary) 5%, transparent))}.mat-mdc-slider .mat-ripple .mat-mdc-slider-focus-ripple,.mat-mdc-slider .mat-ripple .mat-mdc-slider-active-ripple{background-color:var(--mat-slider-focus-state-layer-color, color-mix(in srgb, var(--mat-sys-primary) 20%, transparent))}.mat-mdc-slider._mat-animation-noopable.mdc-slider--discrete .mdc-slider__thumb,.mat-mdc-slider._mat-animation-noopable.mdc-slider--discrete .mdc-slider__track--active_fill,.mat-mdc-slider._mat-animation-noopable .mdc-slider__value-indicator{transition:none}.mat-mdc-slider .mat-focus-indicator::before{border-radius:50%}.mdc-slider__thumb--focused .mat-focus-indicator::before{content:\\\"\\\"}\\n\"],\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n  return MatSlider;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** Ensures that there is not an invalid configuration for the slider thumb inputs. */\nfunction _validateInputs(isRange, endInputElement, startInputElement) {\n  const startValid = !isRange || startInputElement?._hostElement.hasAttribute('matSliderStartThumb');\n  const endValid = endInputElement?._hostElement.hasAttribute(isRange ? 'matSliderEndThumb' : 'matSliderThumb');\n  if (!startValid || !endValid) {\n    _throwInvalidInputConfigurationError();\n  }\n}\nfunction _throwInvalidInputConfigurationError() {\n  throw Error(`Invalid slider thumb input configuration!\n\n   Valid configurations are as follows:\n\n     <mat-slider>\n       <input matSliderThumb>\n     </mat-slider>\n\n     or\n\n     <mat-slider>\n       <input matSliderStartThumb>\n       <input matSliderEndThumb>\n     </mat-slider>\n   `);\n}\n\n/**\n * Provider that allows the slider thumb to register as a ControlValueAccessor.\n * @docs-private\n */\nconst MAT_SLIDER_THUMB_VALUE_ACCESSOR = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: /*#__PURE__*/forwardRef(() => MatSliderThumb),\n  multi: true\n};\n/**\n * Provider that allows the range slider thumb to register as a ControlValueAccessor.\n * @docs-private\n */\nconst MAT_SLIDER_RANGE_THUMB_VALUE_ACCESSOR = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: /*#__PURE__*/forwardRef(() => MatSliderRangeThumb),\n  multi: true\n};\n/**\n * Directive that adds slider-specific behaviors to an input element inside `<mat-slider>`.\n * Up to two may be placed inside of a `<mat-slider>`.\n *\n * If one is used, the selector `matSliderThumb` must be used, and the outcome will be a normal\n * slider. If two are used, the selectors `matSliderStartThumb` and `matSliderEndThumb` must be\n * used, and the outcome will be a range slider with two slider thumbs.\n */\nlet MatSliderThumb = /*#__PURE__*/(() => {\n  class MatSliderThumb {\n    _ngZone = inject(NgZone);\n    _elementRef = inject(ElementRef);\n    _cdr = inject(ChangeDetectorRef);\n    _slider = inject(MAT_SLIDER);\n    _platform = inject(Platform);\n    _listenerCleanups;\n    get value() {\n      return numberAttribute(this._hostElement.value, 0);\n    }\n    set value(value) {\n      if (value === null) {\n        value = this._getDefaultValue();\n      }\n      value = isNaN(value) ? 0 : value;\n      const stringValue = value + '';\n      if (!this._hasSetInitialValue) {\n        this._initialValue = stringValue;\n        return;\n      }\n      if (this._isActive) {\n        return;\n      }\n      this._setValue(stringValue);\n    }\n    /**\n     * Handles programmatic value setting. This has been split out to\n     * allow the range thumb to override it and add additional necessary logic.\n     */\n    _setValue(value) {\n      this._hostElement.value = value;\n      this._updateThumbUIByValue();\n      this._slider._onValueChange(this);\n      this._cdr.detectChanges();\n      this._slider._cdr.markForCheck();\n    }\n    /** Event emitted when the `value` is changed. */\n    valueChange = new EventEmitter();\n    /** Event emitted when the slider thumb starts being dragged. */\n    dragStart = new EventEmitter();\n    /** Event emitted when the slider thumb stops being dragged. */\n    dragEnd = new EventEmitter();\n    /**\n     * The current translateX in px of the slider visual thumb.\n     * @docs-private\n     */\n    get translateX() {\n      if (this._slider.min >= this._slider.max) {\n        this._translateX = this._tickMarkOffset;\n        return this._translateX;\n      }\n      if (this._translateX === undefined) {\n        this._translateX = this._calcTranslateXByValue();\n      }\n      return this._translateX;\n    }\n    set translateX(v) {\n      this._translateX = v;\n    }\n    _translateX;\n    /**\n     * Indicates whether this thumb is the start or end thumb.\n     * @docs-private\n     */\n    thumbPosition = _MatThumb.END;\n    /** @docs-private */\n    get min() {\n      return numberAttribute(this._hostElement.min, 0);\n    }\n    set min(v) {\n      this._hostElement.min = v + '';\n      this._cdr.detectChanges();\n    }\n    /** @docs-private */\n    get max() {\n      return numberAttribute(this._hostElement.max, 0);\n    }\n    set max(v) {\n      this._hostElement.max = v + '';\n      this._cdr.detectChanges();\n    }\n    get step() {\n      return numberAttribute(this._hostElement.step, 0);\n    }\n    set step(v) {\n      this._hostElement.step = v + '';\n      this._cdr.detectChanges();\n    }\n    /** @docs-private */\n    get disabled() {\n      return booleanAttribute(this._hostElement.disabled);\n    }\n    set disabled(v) {\n      this._hostElement.disabled = v;\n      this._cdr.detectChanges();\n      if (this._slider.disabled !== this.disabled) {\n        this._slider.disabled = this.disabled;\n      }\n    }\n    /** The percentage of the slider that coincides with the value. */\n    get percentage() {\n      if (this._slider.min >= this._slider.max) {\n        return this._slider._isRtl ? 1 : 0;\n      }\n      return (this.value - this._slider.min) / (this._slider.max - this._slider.min);\n    }\n    /** @docs-private */\n    get fillPercentage() {\n      if (!this._slider._cachedWidth) {\n        return this._slider._isRtl ? 1 : 0;\n      }\n      if (this._translateX === 0) {\n        return 0;\n      }\n      return this.translateX / this._slider._cachedWidth;\n    }\n    /** The host native HTML input element. */\n    _hostElement = this._elementRef.nativeElement;\n    /** The aria-valuetext string representation of the input's value. */\n    _valuetext = signal('', ...(ngDevMode ? [{\n      debugName: \"_valuetext\"\n    }] : []));\n    /** The radius of a native html slider's knob. */\n    _knobRadius = 8;\n    /** The distance in px from the start of the slider track to the first tick mark. */\n    _tickMarkOffset = 3;\n    /** Whether user's cursor is currently in a mouse down state on the input. */\n    _isActive = false;\n    /** Whether the input is currently focused (either by tab or after clicking). */\n    _isFocused = false;\n    /** Used to relay updates to _isFocused to the slider visual thumbs. */\n    _setIsFocused(v) {\n      this._isFocused = v;\n    }\n    /**\n     * Whether the initial value has been set.\n     * This exists because the initial value cannot be immediately set because the min and max\n     * must first be relayed from the parent MatSlider component, which can only happen later\n     * in the component lifecycle.\n     */\n    _hasSetInitialValue = false;\n    /** The stored initial value. */\n    _initialValue;\n    /** Defined when a user is using a form control to manage slider value & validation. */\n    _formControl;\n    /** Emits when the component is destroyed. */\n    _destroyed = new Subject();\n    /**\n     * Indicates whether UI updates should be skipped.\n     *\n     * This flag is used to avoid flickering\n     * when correcting values on pointer up/down.\n     */\n    _skipUIUpdate = false;\n    /** Callback called when the slider input value changes. */\n    _onChangeFn;\n    /** Callback called when the slider input has been touched. */\n    _onTouchedFn = () => {};\n    /**\n     * Whether the NgModel has been initialized.\n     *\n     * This flag is used to ignore ghost null calls to\n     * writeValue which can break slider initialization.\n     *\n     * See https://github.com/angular/angular/issues/14988.\n     */\n    _isControlInitialized = false;\n    constructor() {\n      const renderer = inject(Renderer2);\n      this._ngZone.runOutsideAngular(() => {\n        this._listenerCleanups = [renderer.listen(this._hostElement, 'pointerdown', this._onPointerDown.bind(this)), renderer.listen(this._hostElement, 'pointermove', this._onPointerMove.bind(this)), renderer.listen(this._hostElement, 'pointerup', this._onPointerUp.bind(this))];\n      });\n    }\n    ngOnDestroy() {\n      this._listenerCleanups.forEach(cleanup => cleanup());\n      this._destroyed.next();\n      this._destroyed.complete();\n      this.dragStart.complete();\n      this.dragEnd.complete();\n    }\n    /** @docs-private */\n    initProps() {\n      this._updateWidthInactive();\n      // If this or the parent slider is disabled, just make everything disabled.\n      if (this.disabled !== this._slider.disabled) {\n        // The MatSlider setter for disabled will relay this and disable both inputs.\n        this._slider.disabled = true;\n      }\n      this.step = this._slider.step;\n      this.min = this._slider.min;\n      this.max = this._slider.max;\n      this._initValue();\n    }\n    /** @docs-private */\n    initUI() {\n      this._updateThumbUIByValue();\n    }\n    _initValue() {\n      this._hasSetInitialValue = true;\n      if (this._initialValue === undefined) {\n        this.value = this._getDefaultValue();\n      } else {\n        this._hostElement.value = this._initialValue;\n        this._updateThumbUIByValue();\n        this._slider._onValueChange(this);\n        this._cdr.detectChanges();\n      }\n    }\n    _getDefaultValue() {\n      return this.min;\n    }\n    _onBlur() {\n      this._setIsFocused(false);\n      this._onTouchedFn();\n    }\n    _onFocus() {\n      this._slider._setTransition(false);\n      this._slider._updateTrackUI(this);\n      this._setIsFocused(true);\n    }\n    _onChange() {\n      this.valueChange.emit(this.value);\n      // only used to handle the edge case where user\n      // mousedown on the slider then uses arrow keys.\n      if (this._isActive) {\n        this._updateThumbUIByValue({\n          withAnimation: true\n        });\n      }\n    }\n    _onInput() {\n      this._onChangeFn?.(this.value);\n      // handles arrowing and updating the value when\n      // a step is defined.\n      if (this._slider.step || !this._isActive) {\n        this._updateThumbUIByValue({\n          withAnimation: true\n        });\n      }\n      this._slider._onValueChange(this);\n    }\n    _onNgControlValueChange() {\n      // only used to handle when the value change\n      // originates outside of the slider.\n      if (!this._isActive || !this._isFocused) {\n        this._slider._onValueChange(this);\n        this._updateThumbUIByValue();\n      }\n      this._slider.disabled = this._formControl.disabled;\n    }\n    _onPointerDown(event) {\n      if (this.disabled || event.button !== 0) {\n        return;\n      }\n      // On IOS, dragging only works if the pointer down happens on the\n      // slider thumb and the slider does not receive focus from pointer events.\n      if (this._platform.IOS) {\n        const isCursorOnSliderThumb = this._slider._isCursorOnSliderThumb(event, this._slider._getThumb(this.thumbPosition)._hostElement.getBoundingClientRect());\n        this._isActive = isCursorOnSliderThumb;\n        this._updateWidthActive();\n        this._slider._updateDimensions();\n        return;\n      }\n      this._isActive = true;\n      this._setIsFocused(true);\n      this._updateWidthActive();\n      this._slider._updateDimensions();\n      // Does nothing if a step is defined because we\n      // want the value to snap to the values on input.\n      if (!this._slider.step) {\n        this._updateThumbUIByPointerEvent(event, {\n          withAnimation: true\n        });\n      }\n      if (!this.disabled) {\n        this._handleValueCorrection(event);\n        this.dragStart.emit({\n          source: this,\n          parent: this._slider,\n          value: this.value\n        });\n      }\n    }\n    /**\n     * Corrects the value of the slider on pointer up/down.\n     *\n     * Called on pointer down and up because the value is set based\n     * on the inactive width instead of the active width.\n     */\n    _handleValueCorrection(event) {\n      // Don't update the UI with the current value! The value on pointerdown\n      // and pointerup is calculated in the split second before the input(s)\n      // resize. See _updateWidthInactive() and _updateWidthActive() for more\n      // details.\n      this._skipUIUpdate = true;\n      // Note that this function gets triggered before the actual value of the\n      // slider is updated. This means if we were to set the value here, it\n      // would immediately be overwritten. Using setTimeout ensures the setting\n      // of the value happens after the value has been updated by the\n      // pointerdown event.\n      setTimeout(() => {\n        this._skipUIUpdate = false;\n        this._fixValue(event);\n      }, 0);\n    }\n    /** Corrects the value of the slider based on the pointer event's position. */\n    _fixValue(event) {\n      const xPos = event.clientX - this._slider._cachedLeft;\n      const width = this._slider._cachedWidth;\n      const step = this._slider.step === 0 ? 1 : this._slider.step;\n      const numSteps = Math.floor((this._slider.max - this._slider.min) / step);\n      const percentage = this._slider._isRtl ? 1 - xPos / width : xPos / width;\n      // To ensure the percentage is rounded to the necessary number of decimals.\n      const fixedPercentage = Math.round(percentage * numSteps) / numSteps;\n      const impreciseValue = fixedPercentage * (this._slider.max - this._slider.min) + this._slider.min;\n      const value = Math.round(impreciseValue / step) * step;\n      const prevValue = this.value;\n      if (value === prevValue) {\n        // Because we prevented UI updates, if it turns out that the race\n        // condition didn't happen and the value is already correct, we\n        // have to apply the ui updates now.\n        this._slider._onValueChange(this);\n        this._slider.step > 0 ? this._updateThumbUIByValue() : this._updateThumbUIByPointerEvent(event, {\n          withAnimation: this._slider._hasAnimation\n        });\n        return;\n      }\n      this.value = value;\n      this.valueChange.emit(this.value);\n      this._onChangeFn?.(this.value);\n      this._slider._onValueChange(this);\n      this._slider.step > 0 ? this._updateThumbUIByValue() : this._updateThumbUIByPointerEvent(event, {\n        withAnimation: this._slider._hasAnimation\n      });\n    }\n    _onPointerMove(event) {\n      // Again, does nothing if a step is defined because\n      // we want the value to snap to the values on input.\n      if (!this._slider.step && this._isActive) {\n        this._updateThumbUIByPointerEvent(event);\n      }\n    }\n    _onPointerUp() {\n      if (this._isActive) {\n        this._isActive = false;\n        if (this._platform.SAFARI) {\n          this._setIsFocused(false);\n        }\n        this.dragEnd.emit({\n          source: this,\n          parent: this._slider,\n          value: this.value\n        });\n        // This setTimeout is to prevent the pointerup from triggering a value\n        // change on the input based on the inactive width. It's not clear why\n        // but for some reason on IOS this race condition is even more common so\n        // the timeout needs to be increased.\n        setTimeout(() => this._updateWidthInactive(), this._platform.IOS ? 10 : 0);\n      }\n    }\n    _clamp(v) {\n      const min = this._tickMarkOffset;\n      const max = this._slider._cachedWidth - this._tickMarkOffset;\n      return Math.max(Math.min(v, max), min);\n    }\n    _calcTranslateXByValue() {\n      if (this._slider._isRtl) {\n        return (1 - this.percentage) * (this._slider._cachedWidth - this._tickMarkOffset * 2) + this._tickMarkOffset;\n      }\n      return this.percentage * (this._slider._cachedWidth - this._tickMarkOffset * 2) + this._tickMarkOffset;\n    }\n    _calcTranslateXByPointerEvent(event) {\n      return event.clientX - this._slider._cachedLeft;\n    }\n    /**\n     * Used to set the slider width to the correct\n     * dimensions while the user is dragging.\n     */\n    _updateWidthActive() {}\n    /**\n     * Sets the slider input to disproportionate dimensions to allow for touch\n     * events to be captured on touch devices.\n     */\n    _updateWidthInactive() {\n      this._hostElement.style.padding = `0 ${this._slider._inputPadding}px`;\n      this._hostElement.style.width = `calc(100% + ${this._slider._inputPadding - this._tickMarkOffset * 2}px)`;\n      this._hostElement.style.left = `-${this._slider._rippleRadius - this._tickMarkOffset}px`;\n    }\n    _updateThumbUIByValue(options) {\n      this.translateX = this._clamp(this._calcTranslateXByValue());\n      this._updateThumbUI(options);\n    }\n    _updateThumbUIByPointerEvent(event, options) {\n      this.translateX = this._clamp(this._calcTranslateXByPointerEvent(event));\n      this._updateThumbUI(options);\n    }\n    _updateThumbUI(options) {\n      this._slider._setTransition(!!options?.withAnimation);\n      this._slider._onTranslateXChange(this);\n    }\n    /**\n     * Sets the input's value.\n     * @param value The new value of the input\n     * @docs-private\n     */\n    writeValue(value) {\n      if (this._isControlInitialized || value !== null) {\n        this.value = value;\n      }\n    }\n    /**\n     * Registers a callback to be invoked when the input's value changes from user input.\n     * @param fn The callback to register\n     * @docs-private\n     */\n    registerOnChange(fn) {\n      this._onChangeFn = fn;\n      this._isControlInitialized = true;\n    }\n    /**\n     * Registers a callback to be invoked when the input is blurred by the user.\n     * @param fn The callback to register\n     * @docs-private\n     */\n    registerOnTouched(fn) {\n      this._onTouchedFn = fn;\n    }\n    /**\n     * Sets the disabled state of the slider.\n     * @param isDisabled The new disabled state\n     * @docs-private\n     */\n    setDisabledState(isDisabled) {\n      this.disabled = isDisabled;\n    }\n    focus() {\n      this._hostElement.focus();\n    }\n    blur() {\n      this._hostElement.blur();\n    }\n    static \u0275fac = function MatSliderThumb_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatSliderThumb)();\n    };\n    static \u0275dir = /* @__PURE__ */i0.\u0275\u0275defineDirective({\n      type: MatSliderThumb,\n      selectors: [[\"input\", \"matSliderThumb\", \"\"]],\n      hostAttrs: [\"type\", \"range\", 1, \"mdc-slider__input\"],\n      hostVars: 1,\n      hostBindings: function MatSliderThumb_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.\u0275\u0275listener(\"change\", function MatSliderThumb_change_HostBindingHandler() {\n            return ctx._onChange();\n          })(\"input\", function MatSliderThumb_input_HostBindingHandler() {\n            return ctx._onInput();\n          })(\"blur\", function MatSliderThumb_blur_HostBindingHandler() {\n            return ctx._onBlur();\n          })(\"focus\", function MatSliderThumb_focus_HostBindingHandler() {\n            return ctx._onFocus();\n          });\n        }\n        if (rf & 2) {\n          i0.\u0275\u0275attribute(\"aria-valuetext\", ctx._valuetext());\n        }\n      },\n      inputs: {\n        value: [2, \"value\", \"value\", numberAttribute]\n      },\n      outputs: {\n        valueChange: \"valueChange\",\n        dragStart: \"dragStart\",\n        dragEnd: \"dragEnd\"\n      },\n      exportAs: [\"matSliderThumb\"],\n      features: [i0.\u0275\u0275ProvidersFeature([MAT_SLIDER_THUMB_VALUE_ACCESSOR, {\n        provide: MAT_SLIDER_THUMB,\n        useExisting: MatSliderThumb\n      }])]\n    });\n  }\n  return MatSliderThumb;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet MatSliderRangeThumb = /*#__PURE__*/(() => {\n  class MatSliderRangeThumb extends MatSliderThumb {\n    _cdr = inject(ChangeDetectorRef);\n    /** @docs-private */\n    getSibling() {\n      if (!this._sibling) {\n        this._sibling = this._slider._getInput(this._isEndThumb ? _MatThumb.START : _MatThumb.END);\n      }\n      return this._sibling;\n    }\n    _sibling;\n    /**\n     * Returns the minimum translateX position allowed for this slider input's visual thumb.\n     * @docs-private\n     */\n    getMinPos() {\n      const sibling = this.getSibling();\n      if (!this._isLeftThumb && sibling) {\n        return sibling.translateX;\n      }\n      return this._tickMarkOffset;\n    }\n    /**\n     * Returns the maximum translateX position allowed for this slider input's visual thumb.\n     * @docs-private\n     */\n    getMaxPos() {\n      const sibling = this.getSibling();\n      if (this._isLeftThumb && sibling) {\n        return sibling.translateX;\n      }\n      return this._slider._cachedWidth - this._tickMarkOffset;\n    }\n    _setIsLeftThumb() {\n      this._isLeftThumb = this._isEndThumb && this._slider._isRtl || !this._isEndThumb && !this._slider._isRtl;\n    }\n    /** Whether this slider corresponds to the input on the left hand side. */\n    _isLeftThumb;\n    /** Whether this slider corresponds to the input with greater value. */\n    _isEndThumb;\n    constructor() {\n      super();\n      this._isEndThumb = this._hostElement.hasAttribute('matSliderEndThumb');\n      this._setIsLeftThumb();\n      this.thumbPosition = this._isEndThumb ? _MatThumb.END : _MatThumb.START;\n    }\n    _getDefaultValue() {\n      return this._isEndThumb && this._slider._isRange ? this.max : this.min;\n    }\n    _onInput() {\n      super._onInput();\n      this._updateSibling();\n      if (!this._isActive) {\n        this._updateWidthInactive();\n      }\n    }\n    _onNgControlValueChange() {\n      super._onNgControlValueChange();\n      this.getSibling()?._updateMinMax();\n    }\n    _onPointerDown(event) {\n      if (this.disabled || event.button !== 0) {\n        return;\n      }\n      if (this._sibling) {\n        this._sibling._updateWidthActive();\n        this._sibling._hostElement.classList.add('mat-mdc-slider-input-no-pointer-events');\n      }\n      super._onPointerDown(event);\n    }\n    _onPointerUp() {\n      super._onPointerUp();\n      if (this._sibling) {\n        setTimeout(() => {\n          this._sibling._updateWidthInactive();\n          this._sibling._hostElement.classList.remove('mat-mdc-slider-input-no-pointer-events');\n        });\n      }\n    }\n    _onPointerMove(event) {\n      super._onPointerMove(event);\n      if (!this._slider.step && this._isActive) {\n        this._updateSibling();\n      }\n    }\n    _fixValue(event) {\n      super._fixValue(event);\n      this._sibling?._updateMinMax();\n    }\n    _clamp(v) {\n      return Math.max(Math.min(v, this.getMaxPos()), this.getMinPos());\n    }\n    _updateMinMax() {\n      const sibling = this.getSibling();\n      if (!sibling) {\n        return;\n      }\n      if (this._isEndThumb) {\n        this.min = Math.max(this._slider.min, sibling.value);\n        this.max = this._slider.max;\n      } else {\n        this.min = this._slider.min;\n        this.max = Math.min(this._slider.max, sibling.value);\n      }\n    }\n    _updateWidthActive() {\n      const minWidth = this._slider._rippleRadius * 2 - this._slider._inputPadding * 2;\n      const maxWidth = this._slider._cachedWidth + this._slider._inputPadding - minWidth - this._tickMarkOffset * 2;\n      const percentage = this._slider.min < this._slider.max ? (this.max - this.min) / (this._slider.max - this._slider.min) : 1;\n      const width = maxWidth * percentage + minWidth;\n      this._hostElement.style.width = `${width}px`;\n      this._hostElement.style.padding = `0 ${this._slider._inputPadding}px`;\n    }\n    _updateWidthInactive() {\n      const sibling = this.getSibling();\n      if (!sibling) {\n        return;\n      }\n      const maxWidth = this._slider._cachedWidth - this._tickMarkOffset * 2;\n      const midValue = this._isEndThumb ? this.value - (this.value - sibling.value) / 2 : this.value + (sibling.value - this.value) / 2;\n      const _percentage = this._isEndThumb ? (this.max - midValue) / (this._slider.max - this._slider.min) : (midValue - this.min) / (this._slider.max - this._slider.min);\n      const percentage = this._slider.min < this._slider.max ? _percentage : 1;\n      // Extend the native input width by the radius of the ripple\n      let ripplePadding = this._slider._rippleRadius;\n      // If one of the inputs is maximally sized (the value of both thumbs is\n      // equal to the min or max), make that input take up all of the width and\n      // make the other unselectable.\n      if (percentage === 1) {\n        ripplePadding = 48;\n      } else if (percentage === 0) {\n        ripplePadding = 0;\n      }\n      const width = maxWidth * percentage + ripplePadding;\n      this._hostElement.style.width = `${width}px`;\n      this._hostElement.style.padding = '0px';\n      if (this._isLeftThumb) {\n        this._hostElement.style.left = `-${this._slider._rippleRadius - this._tickMarkOffset}px`;\n        this._hostElement.style.right = 'auto';\n      } else {\n        this._hostElement.style.left = 'auto';\n        this._hostElement.style.right = `-${this._slider._rippleRadius - this._tickMarkOffset}px`;\n      }\n    }\n    _updateStaticStyles() {\n      this._hostElement.classList.toggle('mat-slider__right-input', !this._isLeftThumb);\n    }\n    _updateSibling() {\n      const sibling = this.getSibling();\n      if (!sibling) {\n        return;\n      }\n      sibling._updateMinMax();\n      if (this._isActive) {\n        sibling._updateWidthActive();\n      } else {\n        sibling._updateWidthInactive();\n      }\n    }\n    /**\n     * Sets the input's value.\n     * @param value The new value of the input\n     * @docs-private\n     */\n    writeValue(value) {\n      if (this._isControlInitialized || value !== null) {\n        this.value = value;\n        this._updateWidthInactive();\n        this._updateSibling();\n      }\n    }\n    _setValue(value) {\n      super._setValue(value);\n      this._updateWidthInactive();\n      this._updateSibling();\n    }\n    static \u0275fac = function MatSliderRangeThumb_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatSliderRangeThumb)();\n    };\n    static \u0275dir = /* @__PURE__ */i0.\u0275\u0275defineDirective({\n      type: MatSliderRangeThumb,\n      selectors: [[\"input\", \"matSliderStartThumb\", \"\"], [\"input\", \"matSliderEndThumb\", \"\"]],\n      exportAs: [\"matSliderRangeThumb\"],\n      features: [i0.\u0275\u0275ProvidersFeature([MAT_SLIDER_RANGE_THUMB_VALUE_ACCESSOR, {\n        provide: MAT_SLIDER_RANGE_THUMB,\n        useExisting: MatSliderRangeThumb\n      }]), i0.\u0275\u0275InheritDefinitionFeature]\n    });\n  }\n  return MatSliderRangeThumb;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet MatSliderModule = /*#__PURE__*/(() => {\n  class MatSliderModule {\n    static \u0275fac = function MatSliderModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatSliderModule)();\n    };\n    static \u0275mod = /* @__PURE__ */i0.\u0275\u0275defineNgModule({\n      type: MatSliderModule\n    });\n    static \u0275inj = /* @__PURE__ */i0.\u0275\u0275defineInjector({\n      imports: [MatCommonModule, MatRippleModule]\n    });\n  }\n  return MatSliderModule;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nexport { MatSlider, MatSliderChange, MatSliderModule, MatSliderRangeThumb, MatSliderThumb, MatSliderVisualThumb };\n"],
  "mappings": "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",
  "names": ["Directionality", "Platform", "i0", "InjectionToken", "inject", "ChangeDetectorRef", "NgZone", "Renderer2", "ElementRef", "booleanAttribute", "numberAttribute", "forwardRef", "EventEmitter", "signal", "_CdkPrivateStyleLoader", "NG_VALUE_ACCESSOR", "Subject", "_c0", "_c1", "MatSliderVisualThumb_Conditional_0_Template", "rf", "ctx", "ctx_r0", "_c2", "_c3", "MatSlider_Conditional_6_Conditional_2_For_1_Template", "tickMark_r1", "\u0275$index_14_r2", "ctx_r2", "MatSlider_Conditional_6_Conditional_2_Template", "MatSlider_Conditional_6_Template", "MatSlider_Conditional_7_Template", "_MatThumb", "_MatTickMark", "MAT_SLIDER", "InjectionToken", "MAT_SLIDER_THUMB", "MAT_SLIDER_RANGE_THUMB", "MAT_SLIDER_VISUAL_THUMB", "MatSliderChange", "MatSliderVisualThumb", "inject", "ChangeDetectorRef", "NgZone", "Renderer2", "ElementRef", "Platform", "sliderInput", "input", "renderer", "cleanup", "event", "rect", "isHovered", "rippleRef", "RippleState", "animation", "ignoreGlobalRippleConfig", "sibling", "__ngFactoryType__", "MatRipple", "_t", "MatSlider", "Directionality", "MAT_RIPPLE_GLOBAL_OPTIONS", "v", "endInput", "startInput", "value", "min", "prevMin", "oldEndValue", "oldStartValue", "oldValue", "max", "prevMax", "step", "prevStartValue", "_animationsDisabled", "_CdkPrivateStyleLoader", "_StructuralStylesLoader", "eInput", "sInput", "thumb", "thumbPosition", "styles", "trackStyle", "index", "offset", "source", "input1", "input2", "sourceThumb", "valuetext", "visualThumb", "percentage", "activePercentage", "numActive", "numInactive", "endValue", "startValue", "numInactiveBeforeStartThumb", "numInactiveAfterEndThumb", "withAnimation", "radius", "centerX", "centerY", "dx", "dy", "dirIndex", "booleanAttribute", "numberAttribute", "MAT_SLIDER_THUMB_VALUE_ACCESSOR", "NG_VALUE_ACCESSOR", "forwardRef", "MatSliderThumb", "MAT_SLIDER_RANGE_THUMB_VALUE_ACCESSOR", "MatSliderRangeThumb", "inject", "NgZone", "ElementRef", "ChangeDetectorRef", "MAT_SLIDER", "Platform", "numberAttribute", "value", "stringValue", "EventEmitter", "v", "_MatThumb", "booleanAttribute", "signal", "Subject", "renderer", "Renderer2", "cleanup", "event", "isCursorOnSliderThumb", "xPos", "width", "step", "numSteps", "percentage", "impreciseValue", "prevValue", "min", "max", "options", "fn", "isDisabled", "__ngFactoryType__", "rf", "ctx", "MAT_SLIDER_THUMB", "sibling", "minWidth", "maxWidth", "midValue", "_percentage", "ripplePadding", "MAT_SLIDER_RANGE_THUMB", "MatSliderModule", "MatCommonModule", "MatRippleModule"]
}
