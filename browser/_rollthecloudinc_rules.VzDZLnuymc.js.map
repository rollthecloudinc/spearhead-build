{
  "version": 3,
  "sources": ["../../@rollthecloudinc/rules/fesm2022/rollthecloudinc-rules.mjs"],
  "sourcesContent": ["import * as i0 from '@angular/core';\nimport { NgModule, Injectable } from '@angular/core';\nimport { AttributeTypes } from '@rollthecloudinc/attributes';\nimport * as jre from 'json-rules-engine';\nimport { Observable } from 'rxjs';\nimport { take, map, tap, switchMap } from 'rxjs/operators';\nimport * as uuid from 'uuid';\nimport * as i2 from '@rollthecloudinc/context';\nlet RulesModule = /*#__PURE__*/(() => {\n  class RulesModule {\n    static {\n      this.\u0275fac = function RulesModule_Factory(__ngFactoryType__) {\n        return new (__ngFactoryType__ || RulesModule)();\n      };\n    }\n    static {\n      this.\u0275mod = /* @__PURE__ */i0.\u0275\u0275defineNgModule({\n        type: RulesModule\n      });\n    }\n    static {\n      this.\u0275inj = /* @__PURE__ */i0.\u0275\u0275defineInjector({});\n    }\n  }\n  return RulesModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet RulesParserService = /*#__PURE__*/(() => {\n  class RulesParserService {\n    constructor() {\n      this.operatorsMap = new Map([['=', 'equal'], ['!=', 'notEqual']]);\n    }\n    buildFields(obj, prefix = '') {\n      const fields = new Map();\n      this.genericFields(obj, fields, prefix, 0);\n      return fields;\n    }\n    attributeFields(settings, fields, prefix, level) {\n      settings.forEach((s, i) => {\n        if (s.name !== 'widget') {\n          for (const prop in s) {\n            if (s.type === AttributeTypes.Complex || prop === 'attributes' && s.attributes && s.attributes.length > 0) {\n              if (s.type === AttributeTypes.Complex) {\n                this.attributeFields(s.attributes, fields, `${prefix}`, level + 1);\n              } else {\n                this.attributeFields(s.attributes, fields, `${prefix}.${s.name}`, level + 1);\n              }\n            } else if (prop !== 'attributes') {\n              if (prop === s.name) {\n                // fields.set(`${prefix}.${prop}`, { name: `${prefix}.${prop}`, type: this.resolveAttributeType(s[prop].type), defaultValue: s[prop] });\n                fields.set(`${prefix}.${prop}`, {\n                  name: `${prefix}.${prop}`,\n                  type: this.resolveAttributeType(s.type),\n                  defaultValue: s[prop]\n                });\n              } else {\n                // fields.set(`${prefix}.${s.name}.${prop}`, { name: `${prefix}.${s.name}.${prop}`, type: this.resolveAttributeType(s[prop].type), defaultValue: s[prop] });\n                fields.set(`${prefix}.${s.name}.${prop}`, {\n                  name: `${prefix}.${s.name}.${prop}`,\n                  type: this.resolveAttributeType(s.type),\n                  defaultValue: s[prop]\n                });\n              }\n            }\n          }\n        }\n      });\n    }\n    genericFields(obj, fields, prefix, level) {\n      for (const prop in obj) {\n        const type = typeof obj[prop];\n        if (type !== 'object') {\n          fields.set(`${prefix}.${prop}`, {\n            name: `${prefix}.${prop}`,\n            type: this.resolveNativeType(type),\n            defaultValue: obj[prop]\n          });\n        } else if (Array.isArray(obj[prop]) && prop === 'attributes') {\n          this.attributeFields(obj[prop], fields, `${prefix}.${prop}`, level + 1);\n        } else if (Array.isArray(obj[prop])) {\n          var len = obj[prop].length;\n          for (let i = 0; i < len; i++) {\n            this.genericFields(obj[prop][i], fields, `${prefix}.${prop}.${i}`, level + 1);\n          }\n        } else {\n          this.genericFields(obj[prop], fields, `${prefix}.${prop}`, level + 1);\n        }\n      }\n    }\n    /**\n     * Changes commited on 9/12/2021 have potential to break older panel pages that\n     * use context. Although I believe that originally this only worked for one level. Now\n     * it works for nested rules. I also can't recall why the field split was limited\n     * to only 2 items. That might hav just been laziness or there might have been a valid reason for it.\n     * I don't know why that be done instead of using indexOf to make sure the full path is included.\n     */\n    toEngineRule(rule, level = 0) {\n      const conditions = [];\n      if (rule.rules === undefined || !Array.isArray(rule.rules)) {\n        // const [ fact, path ] = (rule as any).field.split('.', 2);\n        const firstDot = rule.field.indexOf('.');\n        const fact = rule.field.substr(0, firstDot);\n        const path = rule.field.substr(firstDot + 1);\n        conditions.push({\n          fact,\n          path: `$.${path}`,\n          operator: this.operatorsMap.get(rule.operator),\n          value: rule.value\n        });\n        return new jre.Rule({\n          conditions: {\n            all: conditions\n          },\n          event: level === 0 ? {\n            type: 'visible'\n          } : undefined\n        });\n      } else {\n        const len = rule.rules.length;\n        for (let i = 0; i < len; i++) {\n          if ('field' in rule.rules[i] && (rule.condition === undefined || rule.condition === null || rule.condition === '')) {\n            // const [ fact, path ] = (rule.rules[i] as NgRule).field.split('.', 2);\n            const firstDot = rule.rules[i].field.indexOf('.');\n            const fact = rule.rules[i].field.substr(0, firstDot);\n            const path = rule.rules[i].field.substr(firstDot + 1);\n            conditions.push({\n              fact,\n              path: `$.${path}`,\n              operator: this.operatorsMap.get(rule.rules[i].operator),\n              value: rule.rules[i].value\n            });\n          } else {\n            const nestedRule = this.toEngineRule(rule.rules[i], level + 1);\n            conditions.push(nestedRule.conditions);\n          }\n        }\n        if (rule.condition === 'and') {\n          return new jre.Rule({\n            conditions: {\n              all: conditions\n            },\n            event: level === 0 ? {\n              type: 'visible'\n            } : undefined\n          });\n        } else {\n          return new jre.Rule({\n            conditions: {\n              any: conditions\n            },\n            event: level === 0 ? {\n              type: 'visible'\n            } : undefined\n          });\n        }\n      }\n    }\n    extractConditions(ngRule, level = 0) {\n      const rule = this.toEngineRule(ngRule);\n      return [...(rule.conditions.any !== undefined ? rule.conditions.any : []), ...(rule.conditions.all !== undefined ? rule.conditions.all : [])];\n    }\n    resolveNativeType(type) {\n      switch (type) {\n        case 'number':\n          return 'number';\n        case 'boolean':\n          return 'boolean';\n        case 'string':\n        default:\n          return 'string';\n      }\n    }\n    resolveAttributeType(type) {\n      switch (type) {\n        case AttributeTypes.Float:\n        case AttributeTypes.Number:\n          return 'number';\n        case AttributeTypes.Bool:\n          return 'boolean';\n        case AttributeTypes.Text:\n        default:\n          return 'string';\n      }\n    }\n    static {\n      this.\u0275fac = function RulesParserService_Factory(__ngFactoryType__) {\n        return new (__ngFactoryType__ || RulesParserService)();\n      };\n    }\n    static {\n      this.\u0275prov = /* @__PURE__ */i0.\u0275\u0275defineInjectable({\n        token: RulesParserService,\n        factory: RulesParserService.\u0275fac,\n        providedIn: 'root'\n      });\n    }\n  }\n  return RulesParserService;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n// import { Rule } from 'json-rules-engine'\nlet RulesResolverService = /*#__PURE__*/(() => {\n  class RulesResolverService {\n    constructor(rulesParser, inlineContextResolver) {\n      this.rulesParser = rulesParser;\n      this.inlineContextResolver = inlineContextResolver;\n    }\n    evaluate(ngRule, contexts = []) {\n      return this.inlineContextResolver.resolveMerged(contexts, `rules:${uuid.v4()}`).pipe(take(1), map(facts => [{\n        ...facts\n      }, new jre.Engine()]), tap(([_, engine]) => {\n        const rule = this.rulesParser.toEngineRule(ngRule);\n        engine.addRule(rule);\n      }), switchMap(([facts, engine]) => new Observable(obs => {\n        engine.run(facts).then(res => {\n          obs.next(res.events.findIndex(e => e.type === 'visible') > -1);\n          obs.complete();\n        });\n      })));\n      // A bit easier to debug using breakpoints.\n      /*return new Observable<boolean>(obs => {\n        const name = `rules:${uuid.v4()}`;\n        this.inlineContextResolver.resolveMerged(contexts, name).pipe(\n          take(1),\n          map(facts => [{ ...facts }, new Engine()]),\n          tap(([facts, engine]) => {\n            const rule = this.rulesParser.toEngineRule(ngRule);\n            engine.addRule(new Rule({\n              ...rule,\n              onSuccess: () => {\n                obs.next(true);\n                obs.complete();\n              },\n              onFailure: () => {\n                obs.next(false);\n                obs.complete();\n              },\n              name\n            }));\n            engine.run(facts).then(() => {\n              console.log('facts ran!');\n            });;\n          })\n        ).subscribe(() => {\n          console.log(`subscription complete for rule ${name}`);\n        });\n      });*/\n    }\n    static {\n      this.\u0275fac = function RulesResolverService_Factory(__ngFactoryType__) {\n        return new (__ngFactoryType__ || RulesResolverService)(i0.\u0275\u0275inject(RulesParserService), i0.\u0275\u0275inject(i2.InlineContextResolverService));\n      };\n    }\n    static {\n      this.\u0275prov = /* @__PURE__ */i0.\u0275\u0275defineInjectable({\n        token: RulesResolverService,\n        factory: RulesResolverService.\u0275fac,\n        providedIn: 'root'\n      });\n    }\n  }\n  return RulesResolverService;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/*\n * Public API Surface of rules\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { RulesModule, RulesParserService, RulesResolverService };\n"],
  "mappings": "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",
  "names": ["jre", "i0", "AttributeTypes", "Observable", "take", "map", "tap", "switchMap", "i2", "RulesModule", "__ngFactoryType__", "RulesParserService", "obj", "prefix", "fields", "settings", "level", "s", "i", "prop", "AttributeTypes", "type", "len", "rule", "conditions", "firstDot", "fact", "path", "nestedRule", "ngRule", "RulesResolverService", "rulesParser", "inlineContextResolver", "contexts", "v4_default", "take", "map", "facts", "__spreadValues", "tap", "_", "engine", "switchMap", "Observable", "obs", "res", "e"]
}
