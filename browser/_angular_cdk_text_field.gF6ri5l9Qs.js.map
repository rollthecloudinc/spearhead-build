{
  "version": 3,
  "sources": ["../../@angular/cdk/fesm2022/text-field.mjs"],
  "sourcesContent": ["import * as i0 from '@angular/core';\nimport { Component, ChangeDetectionStrategy, ViewEncapsulation, inject, NgZone, RendererFactory2, Injectable, ElementRef, EventEmitter, Directive, Output, Renderer2, DOCUMENT, booleanAttribute, Input, NgModule } from '@angular/core';\nimport { EMPTY, Subject } from 'rxjs';\nimport { Platform } from './platform2.mjs';\nimport { _CdkPrivateStyleLoader } from './style-loader.mjs';\nimport { coerceElement, coerceNumberProperty } from './element.mjs';\nimport { auditTime } from 'rxjs/operators';\nimport '@angular/common';\n\n/** Component used to load the structural styles of the text field. */\nlet _CdkTextFieldStyleLoader = /*#__PURE__*/(() => {\n  class _CdkTextFieldStyleLoader {\n    static \u0275fac = function _CdkTextFieldStyleLoader_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || _CdkTextFieldStyleLoader)();\n    };\n    static \u0275cmp = /* @__PURE__ */i0.\u0275\u0275defineComponent({\n      type: _CdkTextFieldStyleLoader,\n      selectors: [[\"ng-component\"]],\n      hostAttrs: [\"cdk-text-field-style-loader\", \"\"],\n      decls: 0,\n      vars: 0,\n      template: function _CdkTextFieldStyleLoader_Template(rf, ctx) {},\n      styles: [\"textarea.cdk-textarea-autosize{resize:none}textarea.cdk-textarea-autosize-measuring{padding:2px 0 !important;box-sizing:content-box !important;height:auto !important;overflow:hidden !important}textarea.cdk-textarea-autosize-measuring-firefox{padding:2px 0 !important;box-sizing:content-box !important;height:0 !important}@keyframes cdk-text-field-autofill-start{/*!*/}@keyframes cdk-text-field-autofill-end{/*!*/}.cdk-text-field-autofill-monitored:-webkit-autofill{animation:cdk-text-field-autofill-start 0s 1ms}.cdk-text-field-autofill-monitored:not(:-webkit-autofill){animation:cdk-text-field-autofill-end 0s 1ms}\\n\"],\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n  return _CdkTextFieldStyleLoader;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/** Options to pass to the animationstart listener. */\nconst listenerOptions = {\n  passive: true\n};\n/**\n * An injectable service that can be used to monitor the autofill state of an input.\n * Based on the following blog post:\n * https://medium.com/@brunn/detecting-autofilled-fields-in-javascript-aed598d25da7\n */\nlet AutofillMonitor = /*#__PURE__*/(() => {\n  class AutofillMonitor {\n    _platform = inject(Platform);\n    _ngZone = inject(NgZone);\n    _renderer = inject(RendererFactory2).createRenderer(null, null);\n    _styleLoader = inject(_CdkPrivateStyleLoader);\n    _monitoredElements = new Map();\n    constructor() {}\n    monitor(elementOrRef) {\n      if (!this._platform.isBrowser) {\n        return EMPTY;\n      }\n      this._styleLoader.load(_CdkTextFieldStyleLoader);\n      const element = coerceElement(elementOrRef);\n      const info = this._monitoredElements.get(element);\n      if (info) {\n        return info.subject;\n      }\n      const subject = new Subject();\n      const cssClass = 'cdk-text-field-autofilled';\n      const listener = event => {\n        // Animation events fire on initial element render, we check for the presence of the autofill\n        // CSS class to make sure this is a real change in state, not just the initial render before\n        // we fire off events.\n        if (event.animationName === 'cdk-text-field-autofill-start' && !element.classList.contains(cssClass)) {\n          element.classList.add(cssClass);\n          this._ngZone.run(() => subject.next({\n            target: event.target,\n            isAutofilled: true\n          }));\n        } else if (event.animationName === 'cdk-text-field-autofill-end' && element.classList.contains(cssClass)) {\n          element.classList.remove(cssClass);\n          this._ngZone.run(() => subject.next({\n            target: event.target,\n            isAutofilled: false\n          }));\n        }\n      };\n      const unlisten = this._ngZone.runOutsideAngular(() => {\n        element.classList.add('cdk-text-field-autofill-monitored');\n        return this._renderer.listen(element, 'animationstart', listener, listenerOptions);\n      });\n      this._monitoredElements.set(element, {\n        subject,\n        unlisten\n      });\n      return subject;\n    }\n    stopMonitoring(elementOrRef) {\n      const element = coerceElement(elementOrRef);\n      const info = this._monitoredElements.get(element);\n      if (info) {\n        info.unlisten();\n        info.subject.complete();\n        element.classList.remove('cdk-text-field-autofill-monitored');\n        element.classList.remove('cdk-text-field-autofilled');\n        this._monitoredElements.delete(element);\n      }\n    }\n    ngOnDestroy() {\n      this._monitoredElements.forEach((_info, element) => this.stopMonitoring(element));\n    }\n    static \u0275fac = function AutofillMonitor_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || AutofillMonitor)();\n    };\n    static \u0275prov = /* @__PURE__ */i0.\u0275\u0275defineInjectable({\n      token: AutofillMonitor,\n      factory: AutofillMonitor.\u0275fac,\n      providedIn: 'root'\n    });\n  }\n  return AutofillMonitor;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** A directive that can be used to monitor the autofill state of an input. */\nlet CdkAutofill = /*#__PURE__*/(() => {\n  class CdkAutofill {\n    _elementRef = inject(ElementRef);\n    _autofillMonitor = inject(AutofillMonitor);\n    /** Emits when the autofill state of the element changes. */\n    cdkAutofill = new EventEmitter();\n    constructor() {}\n    ngOnInit() {\n      this._autofillMonitor.monitor(this._elementRef).subscribe(event => this.cdkAutofill.emit(event));\n    }\n    ngOnDestroy() {\n      this._autofillMonitor.stopMonitoring(this._elementRef);\n    }\n    static \u0275fac = function CdkAutofill_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkAutofill)();\n    };\n    static \u0275dir = /* @__PURE__ */i0.\u0275\u0275defineDirective({\n      type: CdkAutofill,\n      selectors: [[\"\", \"cdkAutofill\", \"\"]],\n      outputs: {\n        cdkAutofill: \"cdkAutofill\"\n      }\n    });\n  }\n  return CdkAutofill;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/** Directive to automatically resize a textarea to fit its content. */\nlet CdkTextareaAutosize = /*#__PURE__*/(() => {\n  class CdkTextareaAutosize {\n    _elementRef = inject(ElementRef);\n    _platform = inject(Platform);\n    _ngZone = inject(NgZone);\n    _renderer = inject(Renderer2);\n    _resizeEvents = new Subject();\n    /** Keep track of the previous textarea value to avoid resizing when the value hasn't changed. */\n    _previousValue;\n    _initialHeight;\n    _destroyed = new Subject();\n    _listenerCleanups;\n    _minRows;\n    _maxRows;\n    _enabled = true;\n    /**\n     * Value of minRows as of last resize. If the minRows has decreased, the\n     * height of the textarea needs to be recomputed to reflect the new minimum. The maxHeight\n     * does not have the same problem because it does not affect the textarea's scrollHeight.\n     */\n    _previousMinRows = -1;\n    _textareaElement;\n    /** Minimum amount of rows in the textarea. */\n    get minRows() {\n      return this._minRows;\n    }\n    set minRows(value) {\n      this._minRows = coerceNumberProperty(value);\n      this._setMinHeight();\n    }\n    /** Maximum amount of rows in the textarea. */\n    get maxRows() {\n      return this._maxRows;\n    }\n    set maxRows(value) {\n      this._maxRows = coerceNumberProperty(value);\n      this._setMaxHeight();\n    }\n    /** Whether autosizing is enabled or not */\n    get enabled() {\n      return this._enabled;\n    }\n    set enabled(value) {\n      // Only act if the actual value changed. This specifically helps to not run\n      // resizeToFitContent too early (i.e. before ngAfterViewInit)\n      if (this._enabled !== value) {\n        (this._enabled = value) ? this.resizeToFitContent(true) : this.reset();\n      }\n    }\n    get placeholder() {\n      return this._textareaElement.placeholder;\n    }\n    set placeholder(value) {\n      this._cachedPlaceholderHeight = undefined;\n      if (value) {\n        this._textareaElement.setAttribute('placeholder', value);\n      } else {\n        this._textareaElement.removeAttribute('placeholder');\n      }\n      this._cacheTextareaPlaceholderHeight();\n    }\n    /** Cached height of a textarea with a single row. */\n    _cachedLineHeight;\n    /** Cached height of a textarea with only the placeholder. */\n    _cachedPlaceholderHeight;\n    /** Used to reference correct document/window */\n    _document = inject(DOCUMENT);\n    _hasFocus;\n    _isViewInited = false;\n    constructor() {\n      const styleLoader = inject(_CdkPrivateStyleLoader);\n      styleLoader.load(_CdkTextFieldStyleLoader);\n      this._textareaElement = this._elementRef.nativeElement;\n    }\n    /** Sets the minimum height of the textarea as determined by minRows. */\n    _setMinHeight() {\n      const minHeight = this.minRows && this._cachedLineHeight ? `${this.minRows * this._cachedLineHeight}px` : null;\n      if (minHeight) {\n        this._textareaElement.style.minHeight = minHeight;\n      }\n    }\n    /** Sets the maximum height of the textarea as determined by maxRows. */\n    _setMaxHeight() {\n      const maxHeight = this.maxRows && this._cachedLineHeight ? `${this.maxRows * this._cachedLineHeight}px` : null;\n      if (maxHeight) {\n        this._textareaElement.style.maxHeight = maxHeight;\n      }\n    }\n    ngAfterViewInit() {\n      if (this._platform.isBrowser) {\n        // Remember the height which we started with in case autosizing is disabled\n        this._initialHeight = this._textareaElement.style.height;\n        this.resizeToFitContent();\n        this._ngZone.runOutsideAngular(() => {\n          this._listenerCleanups = [this._renderer.listen('window', 'resize', () => this._resizeEvents.next()), this._renderer.listen(this._textareaElement, 'focus', this._handleFocusEvent), this._renderer.listen(this._textareaElement, 'blur', this._handleFocusEvent)];\n          this._resizeEvents.pipe(auditTime(16)).subscribe(() => {\n            // Clear the cached heights since the styles can change\n            // when the window is resized (e.g. by media queries).\n            this._cachedLineHeight = this._cachedPlaceholderHeight = undefined;\n            this.resizeToFitContent(true);\n          });\n        });\n        this._isViewInited = true;\n        this.resizeToFitContent(true);\n      }\n    }\n    ngOnDestroy() {\n      this._listenerCleanups?.forEach(cleanup => cleanup());\n      this._resizeEvents.complete();\n      this._destroyed.next();\n      this._destroyed.complete();\n    }\n    /**\n     * Cache the height of a single-row textarea if it has not already been cached.\n     *\n     * We need to know how large a single \"row\" of a textarea is in order to apply minRows and\n     * maxRows. For the initial version, we will assume that the height of a single line in the\n     * textarea does not ever change.\n     */\n    _cacheTextareaLineHeight() {\n      if (this._cachedLineHeight) {\n        return;\n      }\n      // Use a clone element because we have to override some styles.\n      const textareaClone = this._textareaElement.cloneNode(false);\n      const cloneStyles = textareaClone.style;\n      textareaClone.rows = 1;\n      // Use `position: absolute` so that this doesn't cause a browser layout and use\n      // `visibility: hidden` so that nothing is rendered. Clear any other styles that\n      // would affect the height.\n      cloneStyles.position = 'absolute';\n      cloneStyles.visibility = 'hidden';\n      cloneStyles.border = 'none';\n      cloneStyles.padding = '0';\n      cloneStyles.height = '';\n      cloneStyles.minHeight = '';\n      cloneStyles.maxHeight = '';\n      // App styles might be messing with the height through the positioning properties.\n      cloneStyles.top = cloneStyles.bottom = cloneStyles.left = cloneStyles.right = 'auto';\n      // In Firefox it happens that textarea elements are always bigger than the specified amount\n      // of rows. This is because Firefox tries to add extra space for the horizontal scrollbar.\n      // As a workaround that removes the extra space for the scrollbar, we can just set overflow\n      // to hidden. This ensures that there is no invalid calculation of the line height.\n      // See Firefox bug report: https://bugzilla.mozilla.org/show_bug.cgi?id=33654\n      cloneStyles.overflow = 'hidden';\n      this._textareaElement.parentNode.appendChild(textareaClone);\n      this._cachedLineHeight = textareaClone.clientHeight;\n      textareaClone.remove();\n      // Min and max heights have to be re-calculated if the cached line height changes\n      this._setMinHeight();\n      this._setMaxHeight();\n    }\n    _measureScrollHeight() {\n      const element = this._textareaElement;\n      const previousMargin = element.style.marginBottom || '';\n      const isFirefox = this._platform.FIREFOX;\n      const needsMarginFiller = isFirefox && this._hasFocus;\n      const measuringClass = isFirefox ? 'cdk-textarea-autosize-measuring-firefox' : 'cdk-textarea-autosize-measuring';\n      // In some cases the page might move around while we're measuring the `textarea` on Firefox. We\n      // work around it by assigning a temporary margin with the same height as the `textarea` so that\n      // it occupies the same amount of space. See #23233.\n      if (needsMarginFiller) {\n        element.style.marginBottom = `${element.clientHeight}px`;\n      }\n      // Reset the textarea height to auto in order to shrink back to its default size.\n      // Also temporarily force overflow:hidden, so scroll bars do not interfere with calculations.\n      element.classList.add(measuringClass);\n      // The measuring class includes a 2px padding to workaround an issue with Chrome,\n      // so we account for that extra space here by subtracting 4 (2px top + 2px bottom).\n      const scrollHeight = element.scrollHeight - 4;\n      element.classList.remove(measuringClass);\n      if (needsMarginFiller) {\n        element.style.marginBottom = previousMargin;\n      }\n      return scrollHeight;\n    }\n    _cacheTextareaPlaceholderHeight() {\n      if (!this._isViewInited || this._cachedPlaceholderHeight != undefined) {\n        return;\n      }\n      if (!this.placeholder) {\n        this._cachedPlaceholderHeight = 0;\n        return;\n      }\n      const value = this._textareaElement.value;\n      this._textareaElement.value = this._textareaElement.placeholder;\n      this._cachedPlaceholderHeight = this._measureScrollHeight();\n      this._textareaElement.value = value;\n    }\n    /** Handles `focus` and `blur` events. */\n    _handleFocusEvent = event => {\n      this._hasFocus = event.type === 'focus';\n    };\n    ngDoCheck() {\n      if (this._platform.isBrowser) {\n        this.resizeToFitContent();\n      }\n    }\n    /**\n     * Resize the textarea to fit its content.\n     * @param force Whether to force a height recalculation. By default the height will be\n     *    recalculated only if the value changed since the last call.\n     */\n    resizeToFitContent(force = false) {\n      // If autosizing is disabled, just skip everything else\n      if (!this._enabled) {\n        return;\n      }\n      this._cacheTextareaLineHeight();\n      this._cacheTextareaPlaceholderHeight();\n      // If we haven't determined the line-height yet, we know we're still hidden and there's no point\n      // in checking the height of the textarea.\n      if (!this._cachedLineHeight) {\n        return;\n      }\n      const textarea = this._elementRef.nativeElement;\n      const value = textarea.value;\n      // Only resize if the value or minRows have changed since these calculations can be expensive.\n      if (!force && this._minRows === this._previousMinRows && value === this._previousValue) {\n        return;\n      }\n      const scrollHeight = this._measureScrollHeight();\n      const height = Math.max(scrollHeight, this._cachedPlaceholderHeight || 0);\n      // Use the scrollHeight to know how large the textarea *would* be if fit its entire value.\n      textarea.style.height = `${height}px`;\n      this._ngZone.runOutsideAngular(() => {\n        if (typeof requestAnimationFrame !== 'undefined') {\n          requestAnimationFrame(() => this._scrollToCaretPosition(textarea));\n        } else {\n          setTimeout(() => this._scrollToCaretPosition(textarea));\n        }\n      });\n      this._previousValue = value;\n      this._previousMinRows = this._minRows;\n    }\n    /**\n     * Resets the textarea to its original size\n     */\n    reset() {\n      // Do not try to change the textarea, if the initialHeight has not been determined yet\n      // This might potentially remove styles when reset() is called before ngAfterViewInit\n      if (this._initialHeight !== undefined) {\n        this._textareaElement.style.height = this._initialHeight;\n      }\n    }\n    _noopInputHandler() {\n      // no-op handler that ensures we're running change detection on input events.\n    }\n    /**\n     * Scrolls a textarea to the caret position. On Firefox resizing the textarea will\n     * prevent it from scrolling to the caret position. We need to re-set the selection\n     * in order for it to scroll to the proper position.\n     */\n    _scrollToCaretPosition(textarea) {\n      const {\n        selectionStart,\n        selectionEnd\n      } = textarea;\n      // IE will throw an \"Unspecified error\" if we try to set the selection range after the\n      // element has been removed from the DOM. Assert that the directive hasn't been destroyed\n      // between the time we requested the animation frame and when it was executed.\n      // Also note that we have to assert that the textarea is focused before we set the\n      // selection range. Setting the selection range on a non-focused textarea will cause\n      // it to receive focus on IE and Edge.\n      if (!this._destroyed.isStopped && this._hasFocus) {\n        textarea.setSelectionRange(selectionStart, selectionEnd);\n      }\n    }\n    static \u0275fac = function CdkTextareaAutosize_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkTextareaAutosize)();\n    };\n    static \u0275dir = /* @__PURE__ */i0.\u0275\u0275defineDirective({\n      type: CdkTextareaAutosize,\n      selectors: [[\"textarea\", \"cdkTextareaAutosize\", \"\"]],\n      hostAttrs: [\"rows\", \"1\", 1, \"cdk-textarea-autosize\"],\n      hostBindings: function CdkTextareaAutosize_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.\u0275\u0275listener(\"input\", function CdkTextareaAutosize_input_HostBindingHandler() {\n            return ctx._noopInputHandler();\n          });\n        }\n      },\n      inputs: {\n        minRows: [0, \"cdkAutosizeMinRows\", \"minRows\"],\n        maxRows: [0, \"cdkAutosizeMaxRows\", \"maxRows\"],\n        enabled: [2, \"cdkTextareaAutosize\", \"enabled\", booleanAttribute],\n        placeholder: \"placeholder\"\n      },\n      exportAs: [\"cdkTextareaAutosize\"]\n    });\n  }\n  return CdkTextareaAutosize;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet TextFieldModule = /*#__PURE__*/(() => {\n  class TextFieldModule {\n    static \u0275fac = function TextFieldModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || TextFieldModule)();\n    };\n    static \u0275mod = /* @__PURE__ */i0.\u0275\u0275defineNgModule({\n      type: TextFieldModule\n    });\n    static \u0275inj = /* @__PURE__ */i0.\u0275\u0275defineInjector({});\n  }\n  return TextFieldModule;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nexport { AutofillMonitor, CdkAutofill, CdkTextareaAutosize, TextFieldModule };\n"],
  "mappings": "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",
  "names": ["i0", "inject", "NgZone", "RendererFactory2", "ElementRef", "EventEmitter", "Renderer2", "DOCUMENT", "booleanAttribute", "EMPTY", "Subject", "auditTime", "_CdkTextFieldStyleLoader", "__ngFactoryType__", "rf", "ctx", "listenerOptions", "AutofillMonitor", "inject", "Platform", "NgZone", "RendererFactory2", "_CdkPrivateStyleLoader", "elementOrRef", "EMPTY", "element", "coerceElement", "info", "subject", "Subject", "cssClass", "listener", "event", "unlisten", "_info", "CdkAutofill", "ElementRef", "EventEmitter", "CdkTextareaAutosize", "Renderer2", "value", "coerceNumberProperty", "DOCUMENT", "minHeight", "maxHeight", "cleanup", "textareaClone", "cloneStyles", "previousMargin", "isFirefox", "needsMarginFiller", "measuringClass", "scrollHeight", "force", "textarea", "height", "selectionStart", "selectionEnd", "booleanAttribute", "TextFieldModule"]
}
