{
  "version": 3,
  "sources": ["../../@angular/cdk/fesm2022/recycle-view-repeater-strategy.mjs"],
  "sourcesContent": ["import { isObservable, of } from 'rxjs';\nimport { DataSource } from './data-source.mjs';\nimport { InjectionToken } from '@angular/core';\n\n/** DataSource wrapper for a native array. */\nclass ArrayDataSource extends DataSource {\n  _data;\n  constructor(_data) {\n    super();\n    this._data = _data;\n  }\n  connect() {\n    return isObservable(this._data) ? this._data : of(this._data);\n  }\n  disconnect() {}\n}\n\n/** Indicates how a view was changed by a `_ViewRepeater`. */\nvar _ViewRepeaterOperation = /*#__PURE__*/function (_ViewRepeaterOperation) {\n  /** The content of an existing view was replaced with another item. */\n  _ViewRepeaterOperation[_ViewRepeaterOperation[\"REPLACED\"] = 0] = \"REPLACED\";\n  /** A new view was created with `createEmbeddedView`. */\n  _ViewRepeaterOperation[_ViewRepeaterOperation[\"INSERTED\"] = 1] = \"INSERTED\";\n  /** The position of a view changed, but the content remains the same. */\n  _ViewRepeaterOperation[_ViewRepeaterOperation[\"MOVED\"] = 2] = \"MOVED\";\n  /** A view was detached from the view container. */\n  _ViewRepeaterOperation[_ViewRepeaterOperation[\"REMOVED\"] = 3] = \"REMOVED\";\n  return _ViewRepeaterOperation;\n}(_ViewRepeaterOperation || {});\n/**\n * Injection token for `_ViewRepeater`. This token is for use by Angular Material only.\n * @docs-private\n */\nconst _VIEW_REPEATER_STRATEGY = /*#__PURE__*/new InjectionToken('_ViewRepeater');\n\n/**\n * A repeater that caches views when they are removed from a\n * `ViewContainerRef`. When new items are inserted into the container,\n * the repeater will reuse one of the cached views instead of creating a new\n * embedded view. Recycling cached views reduces the quantity of expensive DOM\n * inserts.\n *\n * @template T The type for the embedded view's $implicit property.\n * @template R The type for the item in each IterableDiffer change record.\n * @template C The type for the context passed to each embedded view.\n */\nclass _RecycleViewRepeaterStrategy {\n  /**\n   * The size of the cache used to store unused views.\n   * Setting the cache size to `0` will disable caching. Defaults to 20 views.\n   */\n  viewCacheSize = 20;\n  /**\n   * View cache that stores embedded view instances that have been previously stamped out,\n   * but don't are not currently rendered. The view repeater will reuse these views rather than\n   * creating brand new ones.\n   *\n   * TODO(michaeljamesparsons) Investigate whether using a linked list would improve performance.\n   */\n  _viewCache = [];\n  /** Apply changes to the DOM. */\n  applyChanges(changes, viewContainerRef, itemContextFactory, itemValueResolver, itemViewChanged) {\n    // Rearrange the views to put them in the right location.\n    changes.forEachOperation((record, adjustedPreviousIndex, currentIndex) => {\n      let view;\n      let operation;\n      if (record.previousIndex == null) {\n        // Item added.\n        const viewArgsFactory = () => itemContextFactory(record, adjustedPreviousIndex, currentIndex);\n        view = this._insertView(viewArgsFactory, currentIndex, viewContainerRef, itemValueResolver(record));\n        operation = view ? _ViewRepeaterOperation.INSERTED : _ViewRepeaterOperation.REPLACED;\n      } else if (currentIndex == null) {\n        // Item removed.\n        this._detachAndCacheView(adjustedPreviousIndex, viewContainerRef);\n        operation = _ViewRepeaterOperation.REMOVED;\n      } else {\n        // Item moved.\n        view = this._moveView(adjustedPreviousIndex, currentIndex, viewContainerRef, itemValueResolver(record));\n        operation = _ViewRepeaterOperation.MOVED;\n      }\n      if (itemViewChanged) {\n        itemViewChanged({\n          context: view?.context,\n          operation,\n          record\n        });\n      }\n    });\n  }\n  detach() {\n    for (const view of this._viewCache) {\n      view.destroy();\n    }\n    this._viewCache = [];\n  }\n  /**\n   * Inserts a view for a new item, either from the cache or by creating a new\n   * one. Returns `undefined` if the item was inserted into a cached view.\n   */\n  _insertView(viewArgsFactory, currentIndex, viewContainerRef, value) {\n    const cachedView = this._insertViewFromCache(currentIndex, viewContainerRef);\n    if (cachedView) {\n      cachedView.context.$implicit = value;\n      return undefined;\n    }\n    const viewArgs = viewArgsFactory();\n    return viewContainerRef.createEmbeddedView(viewArgs.templateRef, viewArgs.context, viewArgs.index);\n  }\n  /** Detaches the view at the given index and inserts into the view cache. */\n  _detachAndCacheView(index, viewContainerRef) {\n    const detachedView = viewContainerRef.detach(index);\n    this._maybeCacheView(detachedView, viewContainerRef);\n  }\n  /** Moves view at the previous index to the current index. */\n  _moveView(adjustedPreviousIndex, currentIndex, viewContainerRef, value) {\n    const view = viewContainerRef.get(adjustedPreviousIndex);\n    viewContainerRef.move(view, currentIndex);\n    view.context.$implicit = value;\n    return view;\n  }\n  /**\n   * Cache the given detached view. If the cache is full, the view will be\n   * destroyed.\n   */\n  _maybeCacheView(view, viewContainerRef) {\n    if (this._viewCache.length < this.viewCacheSize) {\n      this._viewCache.push(view);\n    } else {\n      const index = viewContainerRef.indexOf(view);\n      // The host component could remove views from the container outside of\n      // the view repeater. It's unlikely this will occur, but just in case,\n      // destroy the view on its own, otherwise destroy it through the\n      // container to ensure that all the references are removed.\n      if (index === -1) {\n        view.destroy();\n      } else {\n        viewContainerRef.remove(index);\n      }\n    }\n  }\n  /** Inserts a recycled view from the cache at the given index. */\n  _insertViewFromCache(index, viewContainerRef) {\n    const cachedView = this._viewCache.pop();\n    if (cachedView) {\n      viewContainerRef.insert(cachedView, index);\n    }\n    return cachedView || null;\n  }\n}\nexport { ArrayDataSource, _RecycleViewRepeaterStrategy, _VIEW_REPEATER_STRATEGY, _ViewRepeaterOperation };\n"],
  "mappings": "wCAAA,OAAS,gBAAAA,EAAc,MAAAC,MAAU,OAEjC,OAAS,kBAAAC,MAAsB,gBAG/B,IAAMC,EAAN,cAA8BC,CAAW,CACvC,MACA,YAAYC,EAAO,CACjB,MAAM,EACN,KAAK,MAAQA,CACf,CACA,SAAU,CACR,OAAOC,EAAa,KAAK,KAAK,EAAI,KAAK,MAAQC,EAAG,KAAK,KAAK,CAC9D,CACA,YAAa,CAAC,CAChB,EAGIC,GAAsC,SAAUA,EAAwB,CAE1E,OAAAA,EAAuBA,EAAuB,SAAc,CAAC,EAAI,WAEjEA,EAAuBA,EAAuB,SAAc,CAAC,EAAI,WAEjEA,EAAuBA,EAAuB,MAAW,CAAC,EAAI,QAE9DA,EAAuBA,EAAuB,QAAa,CAAC,EAAI,UACzDA,CACT,GAAEA,GAA0B,CAAC,CAAC,EAKxBC,EAAuC,IAAIP,EAAe,eAAe,EAazEQ,EAAN,KAAmC,CAKjC,cAAgB,GAQhB,WAAa,CAAC,EAEd,aAAaC,EAASC,EAAkBC,EAAoBC,EAAmBC,EAAiB,CAE9FJ,EAAQ,iBAAiB,CAACK,EAAQC,EAAuBC,IAAiB,CACxE,IAAIC,EACAC,EACJ,GAAIJ,EAAO,eAAiB,KAAM,CAEhC,IAAMK,EAAkB,IAAMR,EAAmBG,EAAQC,EAAuBC,CAAY,EAC5FC,EAAO,KAAK,YAAYE,EAAiBH,EAAcN,EAAkBE,EAAkBE,CAAM,CAAC,EAClGI,EAAYD,EAAOX,EAAuB,SAAWA,EAAuB,QAC9E,MAAWU,GAAgB,MAEzB,KAAK,oBAAoBD,EAAuBL,CAAgB,EAChEQ,EAAYZ,EAAuB,UAGnCW,EAAO,KAAK,UAAUF,EAAuBC,EAAcN,EAAkBE,EAAkBE,CAAM,CAAC,EACtGI,EAAYZ,EAAuB,OAEjCO,GACFA,EAAgB,CACd,QAASI,GAAM,QACf,UAAAC,EACA,OAAAJ,CACF,CAAC,CAEL,CAAC,CACH,CACA,QAAS,CACP,QAAWG,KAAQ,KAAK,WACtBA,EAAK,QAAQ,EAEf,KAAK,WAAa,CAAC,CACrB,CAKA,YAAYE,EAAiBH,EAAcN,EAAkBU,EAAO,CAClE,IAAMC,EAAa,KAAK,qBAAqBL,EAAcN,CAAgB,EAC3E,GAAIW,EAAY,CACdA,EAAW,QAAQ,UAAYD,EAC/B,MACF,CACA,IAAME,EAAWH,EAAgB,EACjC,OAAOT,EAAiB,mBAAmBY,EAAS,YAAaA,EAAS,QAASA,EAAS,KAAK,CACnG,CAEA,oBAAoBC,EAAOb,EAAkB,CAC3C,IAAMc,EAAed,EAAiB,OAAOa,CAAK,EAClD,KAAK,gBAAgBC,EAAcd,CAAgB,CACrD,CAEA,UAAUK,EAAuBC,EAAcN,EAAkBU,EAAO,CACtE,IAAMH,EAAOP,EAAiB,IAAIK,CAAqB,EACvD,OAAAL,EAAiB,KAAKO,EAAMD,CAAY,EACxCC,EAAK,QAAQ,UAAYG,EAClBH,CACT,CAKA,gBAAgBA,EAAMP,EAAkB,CACtC,GAAI,KAAK,WAAW,OAAS,KAAK,cAChC,KAAK,WAAW,KAAKO,CAAI,MACpB,CACL,IAAMM,EAAQb,EAAiB,QAAQO,CAAI,EAKvCM,IAAU,GACZN,EAAK,QAAQ,EAEbP,EAAiB,OAAOa,CAAK,CAEjC,CACF,CAEA,qBAAqBA,EAAOb,EAAkB,CAC5C,IAAMW,EAAa,KAAK,WAAW,IAAI,EACvC,OAAIA,GACFX,EAAiB,OAAOW,EAAYE,CAAK,EAEpCF,GAAc,IACvB,CACF",
  "names": ["isObservable", "of", "InjectionToken", "ArrayDataSource", "DataSource", "_data", "isObservable", "of", "_ViewRepeaterOperation", "_VIEW_REPEATER_STRATEGY", "_RecycleViewRepeaterStrategy", "changes", "viewContainerRef", "itemContextFactory", "itemValueResolver", "itemViewChanged", "record", "adjustedPreviousIndex", "currentIndex", "view", "operation", "viewArgsFactory", "value", "cachedView", "viewArgs", "index", "detachedView"]
}
