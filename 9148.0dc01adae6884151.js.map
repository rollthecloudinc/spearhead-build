{"version":3,"file":"9148.0dc01adae6884151.js","mappings":"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","names":["parseCache","set","element","actionMap","MOUSE_SPECIAL_EVENT_TYPES","CAPTURE_EVENT_TYPES","isCaptureEventType","eventType","indexOf","removeEventListener","info","handler","passive","capture","detachEvent","concat","isMac","navigator","test","userAgent","isIos","EventContractContainer","_createClass","_classCallCheck","this","_defineProperty","key","value","getHandler","style","cursor","handlerInfos","push","addEventListener","i","length","getEventType","eventInfo","setEventType","getEvent","event","setEvent","getTargetElement","targetElement","setTargetElement","getContainer","eic","getAction","eia","setAction","actionName","actionElement","unsetAction","undefined","getActionElement","actionInfo","setIsReplay","replay","eirp","getResolved","eir","setResolved","resolved","cloneEventInfo","timeStamp","eiack","EventInfoWrapper","container","setContainer","getTimestamp","timestamp","setTimestamp","action","name","getIsReplay","EMPTY_ACTION_MAP","REGEXP_SEMICOLON","ActionResolver","_ref","arguments","_ref$syntheticMouseEv","syntheticMouseEventSupport","_ref$clickModSupport","clickModSupport","isModifiedClickEvent","e","metaKey","ctrlKey","isMiddleClick","which","button","shiftKey","a11yClickSupport","updateEventInfoForA11yClick","populateAction","parentNode","getParentNode","currentTarget","nodeType","Node","ELEMENT_NODE","populateActionOnElement","preventDefaultForA11yClick","isMouseSpecialEvent","type","related","relatedTarget","contains","copiedEvent","createMouseSpecialEvent","target","copy","property","srcElement","bubbles","_originalEvent","owner","_parentNode$host","nodeName","host","parseActions","populateClickOnlyAction","get","jsactionAttribute","getAttribute","Attribute","JSACTION","getParsed","text","values","split","idx","colon","hasColon","substr","trim","setParsed","parsed","Restriction","I_AM_THE_JSACTION_FRAMEWORK","Dispatcher","dispatchDelegate","_ref2","actionResolver","eventReplayer","_this$actionResolver","_this$actionResolver2","eventInfoWrapper","resolveEventType","resolveAction","shouldPreventDefaultBeforeDispatching","tagName","preventDefault","returnValue","scheduleEventInfoWrapperReplay","_this","replayEventInfoWrappers","eventReplayScheduled","Promise","resolve","then","PROPAGATION_STOPPED_SYMBOL","Symbol","for","EventDispatcher","_this2","dispatcher","dispatchToDelegate","dispatch","prepareEventForReplay","originalPreventDefault","bind","patchEventInstance","Error","prepareEventForBubbling","originalStopPropagation","stopPropagation","prepareEventForDispatch","propagationStopped","resolveParentAction","_eventInfoWrapper$get","configurable","_ref3$configurable","Object","defineProperty","removeEventListeners","eventTypes","earlyEventHandler","EventContract","containerManager","createEventInfoFromParameters","isReplay","a11yClickKey","Date","now","handleEventInfo","_this$queuedEventInfo","queuedEventInfos","prefixedEventType","_this3","eventHandlers","MOUSE_SPECIAL_SUPPORT","eventHandler","handleEvent","browserEventType","getBrowserEventType","browserEventTypeToExtraEventTypes","earlyJsactionData","window","_ejsa","replayEarlyEventInfos","q","removeAllEventListeners","c","et","h","etc","earlyEventInfos","earlyEventInfo","getEventTypesForBrowserEventType","j","apply","_toConsumableArray","_this$containerManage","cleanUp","restriction","ecrd","_this$queuedEventInfo2","clearAppScopedEarlyEventContract","appId","dataContainer","_ejsas","REQUIRED_UNSET_VALUE","INPUT_SIGNAL_NODE","__webpack_require__","_objectSpread","SIGNAL_NODE","transformFn","applyValueToInputSignal","node","signalSetFn","createInputSignal","initialValue","options","create","inputValueFn","producerAccessed","RuntimeError","transform","SIGNAL","HostAttributeToken","attributeName","__injectAttribute","HOST_TAG_NAME","InjectionToken","inputFunction","opts","__NG_ELEMENT_ID__","flags","tNode","getCurrentTNode","ngDevMode","input","required","inputRequiredFunction","viewChildFn","locator","createSingleResultOptionalQuerySignalFn","viewChildRequiredFn","createSingleResultRequiredQuerySignalFn","viewChild","contentChildFn","contentChildRequiredFn","moduleBootstrapImpl","contentChild","PLATFORM_DESTROY_LISTENERS","ENABLE_ROOT_COMPONENT_BOOTSTRAP","isApplicationBootstrapConfig","config","moduleRef","bootstrap","envInjector","r3Injector","injector","ngZone","NgZone","run","resolveInjectorInitializers","onErrorSubscription","exceptionHandler","INTERNAL_APPLICATION_ERROR_HANDLER","runOutsideAngular","onError","subscribe","next","destroyListener","destroy","onPlatformDestroyListeners","platformInjector","add","onDestroy","unsubscribe","delete","remove","allPlatformModules","_callAndReportToErrorHandler","errorHandler","callback","result","isPromise","catch","pendingTasks","PendingTasksInternal","taskId","initStatus","ApplicationInitStatus","runInitializers","donePromise","_moduleBootstrapImpl","localeId","LOCALE_ID","DEFAULT_LOCALE_ID","setLocaleId","ApplicationRef","appRef","rootComponent","finally","setModuleBootstrapImpl","_moduleDoBootstrap","_bootstrapComponents","forEach","f","instance","ngDoBootstrap","PlatformRef","_PlatformRef","_injector","moduleFactory","scheduleInRootZone","ignoreChangesOutsideZone","allAppProviders","internalProvideZoneChangeDetection","ngZoneFactory","getNgZone","getNgZoneOptions","eventCoalescing","ngZoneEventCoalescing","runCoalescing","ngZoneRunCoalescing","provide","ChangeDetectionScheduler","useExisting","ChangeDetectionSchedulerImpl","errorHandlerEnvironmentInitializer","createNgModuleRefWithProviders","moduleType","_modules","_this4","optionsReducer","compileNgModuleFactory","NgModuleFactory","bootstrapModuleFactory","_destroyListeners","_destroyed","slice","module","listener","destroyListeners","clear","__ngFactoryType__","__inject","Injector","__defineInjectable","token","factory","fac","providedIn","_platformInjector","createPlatformFactory","parentPlatformFactory","providers","desc","marker","extraProviders","platform","getPlatform","_parentPlatformFactor","platformProviders","useValue","createPlatform","publishDefaultGlobalUtils","publishSignalConfiguration","runPlatformInitializers","createPlatformInjector","assertPlatform","INJECTOR_SCOPE","Set","_platformInjector$get","_platformInjector2","inits","PLATFORM_INITIALIZER","runInInjectionContext","init","isDevMode","enableProdMode","ChangeDetectorRef","injectChangeDetectorRef","createViewRef","lView","isPipe","isComponentHost","componentView","getComponentLViewByIndex","index","ViewRef$1","DECLARATION_COMPONENT_VIEW","getLView","DefaultIterableDifferFactory","obj","isListLikeIterable","trackByFn","DefaultIterableDiffer","trackByIdentity","item","_trackByFn","fn","record","_itHead","_next","nextIt","nextRemove","_removalsHead","addRemoveOffset","moveOffsets","currentIndex","getPreviousIndex","adjPreviousIndex","_nextRemoved","previousIndex","localMovePreviousIndex","localCurrentIndex","offset","_previousItHead","_nextPrevious","_additionsHead","_nextAdded","_movesHead","_nextMoved","_identityChangesHead","_nextIdentityChange","collection","check","_this5","_reset","itemTrackBy","mayBeDirty","Array","isArray","is","trackById","_verifyReinsertion","_addIdentityChange","_mismatch","iterateListLike","_truncate","isDirty","_additionsTail","_movesTail","_removalsTail","_identityChangesTail","previousRecord","_itTail","_prev","_remove","_unlinkedRecords","_reinsertAfter","_linkedRecords","_moveAfter","_addAfter","IterableChangeRecord_","reinsertRecord","_addToMoves","nextRecord","_addToRemovals","_unlink","prevRecord","prev","_prevRemoved","_insertAfter","_DuplicateMap","put","toIndex","_DuplicateItemRecordList","_head","_tail","_nextDup","_prevDup","atOrAfterIndex","Map","duplicates","map","recordList","size","moveOffset","DefaultKeyValueDifferFactory","isJsObject","DefaultKeyValueDiffer","_changesHead","_mapHead","_previousMapHead","_nextChanged","_this6","insertBefore","_appendAfter","_forEach","_maybeAddToChanges","_getOrCreateRecordForKey","_insertBeforeOrAppend","_records","previousValue","currentValue","_changesTail","before","has","KeyValueChangeRecord_","_addToAdditions","newValue","_addToChanges","keys","k","defaultIterableDiffersFactory","IterableDiffers","factories","iterable","find","supports","parent","copied","useFactory","inject","optional","skipSelf","_IterableDiffers","defaultKeyValueDiffersFactory","KeyValueDiffers","kv","_KeyValueDiffers","platformCore","ApplicationModule","_ApplicationModule","__defineNgModule","__defineInjector","internalCreateApplication","appProviders","platformRef","profiler","_platformRef$injector","createOrReusePlatformInjector","EnvironmentNgModuleRefAdapter","debugName","runEnvironmentInitializers","reject","appsWithEventReplay","WeakSet","EAGER_CONTENT_LISTENERS_KEY","blockEventQueue","shouldEnableEventReplay","IS_EVENT_REPLAY_ENABLED","EVENT_REPLAY_ENABLED_DEFAULT","withEventReplay","isEnabled","_window$_ejsas","APP_ID","performanceMarkFeature","ENVIRONMENT_INITIALIZER","jsActionMap","JSACTION_BLOCK_ELEMENT_MAP","enableStashEventListenerImpl","clearStashFn","setStashFn","rEl","eventName","listenerFn","sharedStashFunction","sharedMapFunction","multi","APP_BOOTSTRAP_LISTENER","whenStable","_jsActionMap$get","destroyed","eventContractDetails","JSACTION_EVENT_CONTRACT","initEventReplay","removeListeners","eventContract","isIncrementalHydrationEnabled","eventDelegation","_step2","_iterator2","_createForOfIteratorHelper","s","n","done","addEvent","err","_step3","_iterator3","eventInfos","getAppScopedQueuedEventInfos","_dataContainer$_ejsas","getQueuedEventInfos","_earlyJsactionData$q","invokeRegisteredReplayListeners","blockName","DEFER_BLOCK_SSR_ID_ATTRIBUTE","hydrateAndInvokeBlockListeners","triggerHydrationFromBlockName","replayQueuedBlockEvents","eventPhase","REPLAY","invokeListeners","registerDispatcher$1","registerDispatcher","hydratedBlocks","queue","hydrated","_step4","_iterator4","_step4$value","isHydrationSupportEnabled","isI18nHydrationRuntimeSupportEnabled","isIncrementalHydrationRuntimeSupportEnabled","withDomHydration","IS_HYDRATION_DOM_REUSE_ENABLED","transferState","TransferState","NGH_DATA_KEY","setIsI18nHydrationSupportEnabled","verifySsrContentsIntegrity","getDocument","enableHydrationRuntimeSupport","enableRetrieveHydrationInfoImpl","enableLocateOrCreateElementNodeImpl","enableLocateOrCreateTextNodeImpl","enableLocateOrCreateElementContainerNodeImpl","enableLocateOrCreateContainerAnchorImpl","enableLocateOrCreateContainerRefImpl","enableFindMatchingDehydratedViewImpl","enableApplyRootElementTransformImpl","PRESERVE_HOST_CONTENT","whenStableWithTimeout","cleanupDehydratedViews","makeEnvironmentProviders","withI18nSupport","IS_I18N_HYDRATION_ENABLED","enableI18nHydrationRuntimeSupport","enableLocateOrCreateI18nNodeImpl","enablePrepareI18nBlockForHydrationImpl","enableClaimDehydratedIcuCaseImpl","withIncrementalHydration","IS_INCREMENTAL_HYDRATION_ENABLED","DEHYDRATED_BLOCK_REGISTRY","useClass","DehydratedBlockRegistry","enableIncrementalHydrationRuntimeSupport","enableRetrieveDeferBlockDataImpl","doc","deferBlockData","processBlockData","commentsByBlockId","gatherDeferBlocksCommentNodes","body","processAndInitTriggers","appendDeferBlocksToJSActionMap","booleanAttribute","numberAttribute","fallbackValue","NaN","isNaN","parseFloat","Number","NOT_SET","EMPTY_CLEANUP_SET","AFTER_RENDER_PHASE_EFFECT_NODE","consumerIsAlwaysLive","consumerAllowSignalWrites","cleanup","consumerMarkedDirty","sequence","impl","executing","lastPhase","phase","erroredOrDestroyed","scheduler","notify","phaseFn","dirty","signal","consumerPollProducersForChange","_this$cleanup","_step12","_iterator12","cleanupFn","_this$cleanup2","args","registerCleanupFn","prevConsumer","consumerBeforeComputation","userFn","consumerAfterComputation","equal","version","AfterRenderEffectSequence","_AfterRenderSequence","effectHooks","view","_this7","snapshot","_callSuper","DestroyRef","_step13","_iterator13","AFTER_RENDER_PHASES","_loop","effectHook","_node$cleanup","nodes","hooks","_inherits","_superPropGet","_step14","_iterator14","_node$cleanup2","_step15","_iterator15","consumerDestroy","AfterRenderSequence","afterRenderEffect","callbackOrSpec","_options$injector","_manager$impl","manager","AfterRenderManager","tracing","TracingService","AfterRenderImpl","spec","mixedReadWrite","viewContext","ViewContext","earlyRead","write","read","register","createComponent","component","componentDef","getComponentDef","elementInjector","getNullInjector","ComponentFactory","projectableNodes","hostElement","environmentInjector","directives","bindings","reflectComponentType","selector","componentType","inputs","outputs","ngContentSelectors","isStandalone","standalone","isSignal","signals"],"ignoreList":[],"sourceRoot":"webpack:///","sources":["./node_modules/@angular/core/fesm2022/primitives/event-dispatch.mjs","./node_modules/@angular/core/fesm2022/core.mjs"],"sourcesContent":["/**\n * @license Angular v20.3.6\n * (c) 2010-2025 Google LLC. https://angular.dev/\n * License: MIT\n */\n\nimport { Attribute } from '../attribute.mjs';\n\n/** All properties that are used by jsaction. */\nconst Property = {\n    /**\n     * The parsed value of the jsaction attribute is stored in this\n     * property on the DOM node. The parsed value is an Object. The\n     * property names of the object are the events; the values are the\n     * names of the actions. This property is attached even on nodes\n     * that don't have a jsaction attribute as an optimization, because\n     * property lookup is faster than attribute access.\n     */\n    JSACTION: '__jsaction',\n    /**\n     * The owner property references an a logical owner for a DOM node. JSAction\n     * will follow this reference instead of parentNode when traversing the DOM\n     * to find jsaction attributes. This allows overlaying a logical structure\n     * over a document where the DOM structure can't reflect that structure.\n     */\n    OWNER: '__owner',\n};\n\n/**\n * Map from jsaction annotation to a parsed map from event name to action name.\n */\nconst parseCache = {};\n/**\n * Reads the jsaction parser cache from the given DOM Element.\n */\nfunction get(element) {\n    return element[Property.JSACTION];\n}\n/**\n * Reads the jsaction parser cache for the given DOM element. If no cache is yet present,\n * creates an empty one.\n */\nfunction getDefaulted(element) {\n    const cache = get(element) ?? {};\n    set(element, cache);\n    return cache;\n}\n/**\n * Writes the jsaction parser cache to the given DOM Element.\n */\nfunction set(element, actionMap) {\n    element[Property.JSACTION] = actionMap;\n}\n/**\n * Looks up the parsed action map from the source jsaction attribute value.\n *\n * @param text Unparsed jsaction attribute value.\n * @return Parsed jsaction attribute value, if already present in the cache.\n */\nfunction getParsed(text) {\n    return parseCache[text];\n}\n/**\n * Inserts the parse result for the given source jsaction value into the cache.\n *\n * @param text Unparsed jsaction attribute value.\n * @param parsed Attribute value parsed into the action map.\n */\nfunction setParsed(text, parsed) {\n    parseCache[text] = parsed;\n}\n\n/*\n * Names of events that are special to jsaction. These are not all\n * event types that are legal to use in either HTML or the addEvent()\n * API, but these are the ones that are treated specially. All other\n * DOM events can be used in either addEvent() or in the value of the\n * jsaction attribute. Beware of browser specific events or events\n * that don't bubble though: If they are not mentioned here, then\n * event contract doesn't work around their peculiarities.\n */\nconst EventType = {\n    /**\n     * Mouse middle click, introduced in Chrome 55 and not yet supported on\n     * other browsers.\n     */\n    AUXCLICK: 'auxclick',\n    /**\n     * The change event fired by browsers when the `value` attribute of input,\n     * select, and textarea elements are changed.\n     */\n    CHANGE: 'change',\n    /**\n     * The click event. In addEvent() refers to all click events, in the\n     * jsaction attribute it refers to the unmodified click and Enter/Space\n     * keypress events.  In the latter case, a jsaction click will be triggered,\n     * for accessibility reasons.  See clickmod and clickonly, below.\n     */\n    CLICK: 'click',\n    /**\n     * Specifies the jsaction for a modified click event (i.e. a mouse\n     * click with the modifier key Cmd/Ctrl pressed). This event isn't\n     * separately enabled in addEvent(), because in the DOM, it's just a\n     * click event.\n     */\n    CLICKMOD: 'clickmod',\n    /**\n     * Specifies the jsaction for a click-only event.  Click-only doesn't take\n     * into account the case where an element with focus receives an Enter/Space\n     * keypress.  This event isn't separately enabled in addEvent().\n     */\n    CLICKONLY: 'clickonly',\n    /**\n     * The dblclick event.\n     */\n    DBLCLICK: 'dblclick',\n    /**\n     * Focus doesn't bubble, but you can use it in addEvent() and\n     * jsaction anyway. EventContract does the right thing under the\n     * hood.\n     */\n    FOCUS: 'focus',\n    /**\n     * This event only exists in IE. For addEvent() and jsaction, use\n     * focus instead; EventContract does the right thing even though\n     * focus doesn't bubble.\n     */\n    FOCUSIN: 'focusin',\n    /**\n     * Analog to focus.\n     */\n    BLUR: 'blur',\n    /**\n     * Analog to focusin.\n     */\n    FOCUSOUT: 'focusout',\n    /**\n     * Submit doesn't bubble, so it cannot be used with event\n     * contract. However, the browser helpfully fires a click event on\n     * the submit button of a form (even if the form is not submitted by\n     * a click on the submit button). So you should handle click on the\n     * submit button instead.\n     */\n    SUBMIT: 'submit',\n    /**\n     * The keydown event. In addEvent() and non-click jsaction it represents the\n     * regular DOM keydown event. It represents click actions in non-Gecko\n     * browsers.\n     */\n    KEYDOWN: 'keydown',\n    /**\n     * The keypress event. In addEvent() and non-click jsaction it represents the\n     * regular DOM keypress event. It represents click actions in Gecko browsers.\n     */\n    KEYPRESS: 'keypress',\n    /**\n     * The keyup event. In addEvent() and non-click jsaction it represents the\n     * regular DOM keyup event. It represents click actions in non-Gecko\n     * browsers.\n     */\n    KEYUP: 'keyup',\n    /**\n     * The mouseup event. Can either be used directly or used implicitly to\n     * capture mouseup events. In addEvent(), it represents a regular DOM\n     * mouseup event.\n     */\n    MOUSEUP: 'mouseup',\n    /**\n     * The mousedown event. Can either be used directly or used implicitly to\n     * capture mouseenter events. In addEvent(), it represents a regular DOM\n     * mouseover event.\n     */\n    MOUSEDOWN: 'mousedown',\n    /**\n     * The mouseover event. Can either be used directly or used implicitly to\n     * capture mouseenter events. In addEvent(), it represents a regular DOM\n     * mouseover event.\n     */\n    MOUSEOVER: 'mouseover',\n    /**\n     * The mouseout event. Can either be used directly or used implicitly to\n     * capture mouseover events. In addEvent(), it represents a regular DOM\n     * mouseout event.\n     */\n    MOUSEOUT: 'mouseout',\n    /**\n     * The mouseenter event. Does not bubble and fires individually on each\n     * element being entered within a DOM tree.\n     */\n    MOUSEENTER: 'mouseenter',\n    /**\n     * The mouseleave event. Does not bubble and fires individually on each\n     * element being entered within a DOM tree.\n     */\n    MOUSELEAVE: 'mouseleave',\n    /**\n     * The mousemove event.\n     */\n    MOUSEMOVE: 'mousemove',\n    /**\n     * The pointerup event. Can either be used directly or used implicitly to\n     * capture pointerup events. In addEvent(), it represents a regular DOM\n     * pointerup event.\n     */\n    POINTERUP: 'pointerup',\n    /**\n     * The pointerdown event. Can either be used directly or used implicitly to\n     * capture pointerenter events. In addEvent(), it represents a regular DOM\n     * mouseover event.\n     */\n    POINTERDOWN: 'pointerdown',\n    /**\n     * The pointerover event. Can either be used directly or used implicitly to\n     * capture pointerenter events. In addEvent(), it represents a regular DOM\n     * pointerover event.\n     */\n    POINTEROVER: 'pointerover',\n    /**\n     * The pointerout event. Can either be used directly or used implicitly to\n     * capture pointerover events. In addEvent(), it represents a regular DOM\n     * pointerout event.\n     */\n    POINTEROUT: 'pointerout',\n    /**\n     * The pointerenter event. Does not bubble and fires individually on each\n     * element being entered within a DOM tree.\n     */\n    POINTERENTER: 'pointerenter',\n    /**\n     * The pointerleave event. Does not bubble and fires individually on each\n     * element being entered within a DOM tree.\n     */\n    POINTERLEAVE: 'pointerleave',\n    /**\n     * The pointermove event.\n     */\n    POINTERMOVE: 'pointermove',\n    /**\n     * The pointercancel event.\n     */\n    POINTERCANCEL: 'pointercancel',\n    /**\n     * The gotpointercapture event is fired when\n     * Element.setPointerCapture(pointerId) is called on a mouse input, or\n     * implicitly when a touch input begins.\n     */\n    GOTPOINTERCAPTURE: 'gotpointercapture',\n    /**\n     * The lostpointercapture event is fired when\n     * Element.releasePointerCapture(pointerId) is called, or implicitly after a\n     * touch input ends.\n     */\n    LOSTPOINTERCAPTURE: 'lostpointercapture',\n    /**\n     * The error event. The error event doesn't bubble, but you can use it in\n     * addEvent() and jsaction anyway. EventContract does the right thing under\n     * the hood (except in IE8 which does not use error events).\n     */\n    ERROR: 'error',\n    /**\n     * The load event. The load event doesn't bubble, but you can use it in\n     * addEvent() and jsaction anyway. EventContract does the right thing\n     * under the hood.\n     */\n    LOAD: 'load',\n    /**\n     * The unload event.\n     */\n    UNLOAD: 'unload',\n    /**\n     * The touchstart event. Bubbles, will only ever fire in browsers with\n     * touch support.\n     */\n    TOUCHSTART: 'touchstart',\n    /**\n     * The touchend event. Bubbles, will only ever fire in browsers with\n     * touch support.\n     */\n    TOUCHEND: 'touchend',\n    /**\n     * The touchmove event. Bubbles, will only ever fire in browsers with\n     * touch support.\n     */\n    TOUCHMOVE: 'touchmove',\n    /**\n     * The input event.\n     */\n    INPUT: 'input',\n    /**\n     * The scroll event.\n     */\n    SCROLL: 'scroll',\n    /**\n     * The toggle event. The toggle event doesn't bubble, but you can use it in\n     * addEvent() and jsaction anyway. EventContract does the right thing\n     * under the hood.\n     */\n    TOGGLE: 'toggle',\n    /**\n     * A custom event. The actual custom event type is declared as the 'type'\n     * field in the event details. Supported in Firefox 6+, IE 9+, and all Chrome\n     * versions.\n     *\n     * This is an internal name. Users should use jsaction's fireCustomEvent to\n     * fire custom events instead of relying on this type to create them.\n     */\n    CUSTOM: '_custom',\n};\n/** All event types that do not bubble or capture and need a polyfill. */\nconst MOUSE_SPECIAL_EVENT_TYPES = [\n    EventType.MOUSEENTER,\n    EventType.MOUSELEAVE,\n    'pointerenter',\n    'pointerleave',\n];\n/** All event types that are registered in the bubble phase. */\nconst BUBBLE_EVENT_TYPES = [\n    EventType.CLICK,\n    EventType.DBLCLICK,\n    EventType.FOCUSIN,\n    EventType.FOCUSOUT,\n    EventType.KEYDOWN,\n    EventType.KEYUP,\n    EventType.KEYPRESS,\n    EventType.MOUSEOVER,\n    EventType.MOUSEOUT,\n    EventType.SUBMIT,\n    EventType.TOUCHSTART,\n    EventType.TOUCHEND,\n    EventType.TOUCHMOVE,\n    'touchcancel',\n    'auxclick',\n    'change',\n    'compositionstart',\n    'compositionupdate',\n    'compositionend',\n    'beforeinput',\n    'input',\n    'select',\n    'copy',\n    'cut',\n    'paste',\n    'mousedown',\n    'mouseup',\n    'wheel',\n    'contextmenu',\n    'dragover',\n    'dragenter',\n    'dragleave',\n    'drop',\n    'dragstart',\n    'dragend',\n    'pointerdown',\n    'pointermove',\n    'pointerup',\n    'pointercancel',\n    'pointerover',\n    'pointerout',\n    'gotpointercapture',\n    'lostpointercapture',\n    // Video events.\n    'ended',\n    'loadedmetadata',\n    // Page visibility events.\n    'pagehide',\n    'pageshow',\n    'visibilitychange',\n    // Content visibility events.\n    'beforematch',\n];\n/** All event types that are registered in the capture phase. */\nconst CAPTURE_EVENT_TYPES = [\n    EventType.FOCUS,\n    EventType.BLUR,\n    EventType.ERROR,\n    EventType.LOAD,\n    EventType.TOGGLE,\n];\n/**\n * Whether or not an event type should be registered in the capture phase.\n * @param eventType\n * @returns bool\n */\nconst isCaptureEventType = (eventType) => CAPTURE_EVENT_TYPES.indexOf(eventType) >= 0;\n/** All event types that are registered early.  */\nconst EARLY_EVENT_TYPES = BUBBLE_EVENT_TYPES.concat(CAPTURE_EVENT_TYPES);\n/**\n * Whether or not an event type is registered in the early contract.\n */\nconst isEarlyEventType = (eventType) => EARLY_EVENT_TYPES.indexOf(eventType) >= 0;\n\n/**\n * Gets a browser event type, if it would differ from the JSAction event type.\n */\nfunction getBrowserEventType(eventType) {\n    // Mouseenter and mouseleave events are not handled directly because they\n    // are not available everywhere. In browsers where they are available, they\n    // don't bubble and aren't visible at the container boundary. Instead, we\n    // synthesize the mouseenter and mouseleave events from mouseover and\n    // mouseout events, respectively. Cf. eventcontract.js.\n    if (eventType === EventType.MOUSEENTER) {\n        return EventType.MOUSEOVER;\n    }\n    else if (eventType === EventType.MOUSELEAVE) {\n        return EventType.MOUSEOUT;\n    }\n    else if (eventType === EventType.POINTERENTER) {\n        return EventType.POINTEROVER;\n    }\n    else if (eventType === EventType.POINTERLEAVE) {\n        return EventType.POINTEROUT;\n    }\n    return eventType;\n}\n/**\n * Registers the event handler function with the given DOM element for\n * the given event type.\n *\n * @param element The element.\n * @param eventType The event type.\n * @param handler The handler function to install.\n * @param passive A boolean value that, if `true`, indicates that the function\n *     specified by `handler` will never call `preventDefault()`.\n * @return Information needed to uninstall the event handler eventually.\n */\nfunction addEventListener(element, eventType, handler, passive) {\n    // All event handlers are registered in the bubbling\n    // phase.\n    //\n    // All browsers support focus and blur, but these events only are propagated\n    // in the capture phase. Very legacy browsers do not support focusin or\n    // focusout.\n    //\n    // It would be a bad idea to register all event handlers in the\n    // capture phase because then regular onclick handlers would not be\n    // executed at all on events that trigger a jsaction. That's not\n    // entirely what we want, at least for now.\n    //\n    // Error and load events (i.e. on images) do not bubble so they are also\n    // handled in the capture phase.\n    let capture = false;\n    if (isCaptureEventType(eventType)) {\n        capture = true;\n    }\n    const options = typeof passive === 'boolean' ? { capture, passive } : capture;\n    element.addEventListener(eventType, handler, options);\n    return { eventType, handler, capture, passive };\n}\n/**\n * Removes the event handler for the given event from the element.\n * the given event type.\n *\n * @param element The element.\n * @param info The information needed to deregister the handler, as returned by\n *     addEventListener(), above.\n */\nfunction removeEventListener(element, info) {\n    if (element.removeEventListener) {\n        // It's worth noting that some browser releases have been inconsistent on this, and unless\n        // you have specific reasons otherwise, it's probably wise to use the same values used for\n        // the call to addEventListener() when calling removeEventListener().\n        const options = typeof info.passive === 'boolean' ? { capture: info.capture } : info.capture;\n        element.removeEventListener(info.eventType, info.handler, options);\n        // `detachEvent` is an old DOM API.\n    }\n    else if (element.detachEvent) {\n        // `detachEvent` is an old DOM API.\n        element.detachEvent(`on${info.eventType}`, info.handler);\n    }\n}\n/**\n * Prevents the default action of an event.\n * @param e The event to prevent the default action for.\n */\nfunction preventDefault(e) {\n    e.preventDefault ? e.preventDefault() : (e.returnValue = false);\n}\n/**\n * Whether we are on a Mac. Not pulling in useragent just for this.\n */\nlet isMac = typeof navigator !== 'undefined' && /Macintosh/.test(navigator.userAgent);\n/**\n * Determines and returns whether the given event (which is assumed to be a\n * click event) is a middle click.\n * NOTE: There is not a consistent way to identify middle click\n * http://www.unixpapa.com/js/mouse.html\n */\nfunction isMiddleClick(e) {\n    return (\n    // `which` is an old DOM API.\n    e.which === 2 ||\n        // `which` is an old DOM API.\n        (e.which == null &&\n            // `button` is an old DOM API.\n            e.button === 4) // middle click for IE\n    );\n}\n/**\n * Determines and returns whether the given event (which is assumed\n * to be a click event) is modified. A middle click is considered a modified\n * click to retain the default browser action, which opens a link in a new tab.\n * @param e The event.\n * @return Whether the given event is modified.\n */\nfunction isModifiedClickEvent(e) {\n    return (\n    // `metaKey` is an old DOM API.\n    (isMac && e.metaKey) ||\n        // `ctrlKey` is an old DOM API.\n        (!isMac && e.ctrlKey) ||\n        isMiddleClick(e) ||\n        // `shiftKey` is an old DOM API.\n        e.shiftKey);\n}\n/**\n * Determines whether the event corresponds to a non-bubbling mouse\n * event type (mouseenter, mouseleave, pointerenter, and pointerleave).\n *\n * During mouseover (mouseenter) and pointerover (pointerenter), the\n * relatedTarget is the element being entered from. During mouseout (mouseleave)\n * and pointerout (pointerleave), the relatedTarget is the element being exited\n * to.\n *\n * In both cases, if relatedTarget is outside target, then the corresponding\n * special event has occurred, otherwise it hasn't.\n *\n * @param e The mouseover/mouseout event.\n * @param type The type of the mouse special event.\n * @param element The element on which the jsaction for the\n *     mouseenter/mouseleave event is defined.\n * @return True if the event is a mouseenter/mouseleave event.\n */\nfunction isMouseSpecialEvent(e, type, element) {\n    // `relatedTarget` is an old DOM API.\n    const related = e.relatedTarget;\n    return (((e.type === EventType.MOUSEOVER && type === EventType.MOUSEENTER) ||\n        (e.type === EventType.MOUSEOUT && type === EventType.MOUSELEAVE) ||\n        (e.type === EventType.POINTEROVER && type === EventType.POINTERENTER) ||\n        (e.type === EventType.POINTEROUT && type === EventType.POINTERLEAVE)) &&\n        (!related || (related !== element && !element.contains(related))));\n}\n/**\n * Creates a new EventLike object for a mouseenter/mouseleave event that's\n * derived from the original corresponding mouseover/mouseout event.\n * @param e The event.\n * @param target The element on which the jsaction for the mouseenter/mouseleave\n *     event is defined.\n * @return A modified event-like object copied from the event object passed into\n *     this function.\n */\nfunction createMouseSpecialEvent(e, target) {\n    // We have to create a copy of the event object because we need to mutate\n    // its fields. We do this for the special mouse events because the event\n    // target needs to be retargeted to the action element rather than the real\n    // element (since we are simulating the special mouse events with mouseover/\n    // mouseout).\n    //\n    // Since we're making a copy anyways, we might as well attempt to convert\n    // this event into a pseudo-real mouseenter/mouseleave event by adjusting\n    // its type.\n    //\n    const copy = {};\n    for (const property in e) {\n        if (property === 'srcElement' || property === 'target') {\n            continue;\n        }\n        const key = property;\n        // Making a copy requires iterating through all properties of `Event`.\n        const value = e[key];\n        if (typeof value === 'function') {\n            continue;\n        }\n        // Value should be the expected type, but the value of `key` is not known\n        // statically.\n        copy[key] = value;\n    }\n    if (e.type === EventType.MOUSEOVER) {\n        copy['type'] = EventType.MOUSEENTER;\n    }\n    else if (e.type === EventType.MOUSEOUT) {\n        copy['type'] = EventType.MOUSELEAVE;\n    }\n    else if (e.type === EventType.POINTEROVER) {\n        copy['type'] = EventType.POINTERENTER;\n    }\n    else {\n        copy['type'] = EventType.POINTERLEAVE;\n    }\n    copy['target'] = copy['srcElement'] = target;\n    copy['bubbles'] = false;\n    copy['_originalEvent'] = e;\n    return copy;\n}\n\n/**\n * Whether the user agent is running on iOS.\n */\nconst isIos = typeof navigator !== 'undefined' && /iPhone|iPad|iPod/.test(navigator.userAgent);\n/**\n * A class representing a container node and all the event handlers\n * installed on it. Used so that handlers can be cleaned up if the\n * container is removed from the contract.\n */\nclass EventContractContainer {\n    element;\n    /**\n     * Array of event handlers and their corresponding event types that are\n     * installed on this container.\n     *\n     */\n    handlerInfos = [];\n    /**\n     * @param element The container Element.\n     */\n    constructor(element) {\n        this.element = element;\n    }\n    /**\n     * Installs the provided installer on the element owned by this container,\n     * and maintains a reference to resulting handler in order to remove it\n     * later if desired.\n     */\n    addEventListener(eventType, getHandler, passive) {\n        // In iOS, event bubbling doesn't happen automatically in any DOM element,\n        // unless it has an onclick attribute or DOM event handler attached to it.\n        // This breaks JsAction in some cases. See \"Making Elements Clickable\"\n        // section at http://goo.gl/2VoGnB.\n        //\n        // A workaround for this issue is to change the CSS cursor style to 'pointer'\n        // for the container element, which magically turns on event bubbling. This\n        // solution is described in the comments section at http://goo.gl/6pEO1z.\n        //\n        // We use a navigator.userAgent check here as this problem is present both\n        // on Mobile Safari and thin WebKit wrappers, such as Chrome for iOS.\n        if (isIos) {\n            this.element.style.cursor = 'pointer';\n        }\n        this.handlerInfos.push(addEventListener(this.element, eventType, getHandler(this.element), passive));\n    }\n    /**\n     * Removes all the handlers installed on this container.\n     */\n    cleanUp() {\n        for (let i = 0; i < this.handlerInfos.length; i++) {\n            removeEventListener(this.element, this.handlerInfos[i]);\n        }\n        this.handlerInfos = [];\n    }\n}\n\nconst Char = {\n    /**\n     * The separator between the namespace and the action name in the\n     * jsaction attribute value.\n     */\n    NAMESPACE_ACTION_SEPARATOR: '.',\n    /**\n     * The separator between the event name and action in the jsaction\n     * attribute value.\n     */\n    EVENT_ACTION_SEPARATOR: ':',\n};\n\n/** Added for readability when accessing stable property names. */\nfunction getEventType(eventInfo) {\n    return eventInfo.eventType;\n}\n/** Added for readability when accessing stable property names. */\nfunction setEventType(eventInfo, eventType) {\n    eventInfo.eventType = eventType;\n}\n/** Added for readability when accessing stable property names. */\nfunction getEvent(eventInfo) {\n    return eventInfo.event;\n}\n/** Added for readability when accessing stable property names. */\nfunction setEvent(eventInfo, event) {\n    eventInfo.event = event;\n}\n/** Added for readability when accessing stable property names. */\nfunction getTargetElement(eventInfo) {\n    return eventInfo.targetElement;\n}\n/** Added for readability when accessing stable property names. */\nfunction setTargetElement(eventInfo, targetElement) {\n    eventInfo.targetElement = targetElement;\n}\n/** Added for readability when accessing stable property names. */\nfunction getContainer(eventInfo) {\n    return eventInfo.eic;\n}\n/** Added for readability when accessing stable property names. */\nfunction setContainer(eventInfo, container) {\n    eventInfo.eic = container;\n}\n/** Added for readability when accessing stable property names. */\nfunction getTimestamp(eventInfo) {\n    return eventInfo.timeStamp;\n}\n/** Added for readability when accessing stable property names. */\nfunction setTimestamp(eventInfo, timestamp) {\n    eventInfo.timeStamp = timestamp;\n}\n/** Added for readability when accessing stable property names. */\nfunction getAction(eventInfo) {\n    return eventInfo.eia;\n}\n/** Added for readability when accessing stable property names. */\nfunction setAction(eventInfo, actionName, actionElement) {\n    eventInfo.eia = [actionName, actionElement];\n}\n/** Added for readability when accessing stable property names. */\nfunction unsetAction(eventInfo) {\n    eventInfo.eia = undefined;\n}\n/** Added for readability when accessing stable property names. */\nfunction getActionElement(actionInfo) {\n    return actionInfo[1];\n}\n/** Added for readability when accessing stable property names. */\nfunction getIsReplay(eventInfo) {\n    return eventInfo.eirp;\n}\n/** Added for readability when accessing stable property names. */\nfunction setIsReplay(eventInfo, replay) {\n    eventInfo.eirp = replay;\n}\n/** Added for readability when accessing stable property names. */\nfunction getResolved(eventInfo) {\n    return eventInfo.eir;\n}\n/** Added for readability when accessing stable property names. */\nfunction setResolved(eventInfo, resolved) {\n    eventInfo.eir = resolved;\n}\n/** Clones an `EventInfo` */\nfunction cloneEventInfo(eventInfo) {\n    return {\n        eventType: eventInfo.eventType,\n        event: eventInfo.event,\n        targetElement: eventInfo.targetElement,\n        eic: eventInfo.eic,\n        eia: eventInfo.eia,\n        timeStamp: eventInfo.timeStamp,\n        eirp: eventInfo.eirp,\n        eiack: eventInfo.eiack,\n        eir: eventInfo.eir,\n    };\n}\n/**\n * Utility function for creating an `EventInfo`.\n *\n * This can be used from code-size sensitive compilation units, as taking\n * parameters vs. an `Object` literal reduces code size.\n */\nfunction createEventInfoFromParameters(eventType, event, targetElement, container, timestamp, action, isReplay, a11yClickKey) {\n    return {\n        eventType,\n        event,\n        targetElement,\n        eic: container,\n        timeStamp: timestamp,\n        eia: action,\n        eirp: isReplay,\n        eiack: a11yClickKey,\n    };\n}\n/**\n * Utility class around an `EventInfo`.\n *\n * This should be used in compilation units that are less sensitive to code\n * size.\n */\nclass EventInfoWrapper {\n    eventInfo;\n    constructor(eventInfo) {\n        this.eventInfo = eventInfo;\n    }\n    getEventType() {\n        return getEventType(this.eventInfo);\n    }\n    setEventType(eventType) {\n        setEventType(this.eventInfo, eventType);\n    }\n    getEvent() {\n        return getEvent(this.eventInfo);\n    }\n    setEvent(event) {\n        setEvent(this.eventInfo, event);\n    }\n    getTargetElement() {\n        return getTargetElement(this.eventInfo);\n    }\n    setTargetElement(targetElement) {\n        setTargetElement(this.eventInfo, targetElement);\n    }\n    getContainer() {\n        return getContainer(this.eventInfo);\n    }\n    setContainer(container) {\n        setContainer(this.eventInfo, container);\n    }\n    getTimestamp() {\n        return getTimestamp(this.eventInfo);\n    }\n    setTimestamp(timestamp) {\n        setTimestamp(this.eventInfo, timestamp);\n    }\n    getAction() {\n        const action = getAction(this.eventInfo);\n        if (!action)\n            return undefined;\n        return {\n            name: action[0],\n            element: action[1],\n        };\n    }\n    setAction(action) {\n        if (!action) {\n            unsetAction(this.eventInfo);\n            return;\n        }\n        setAction(this.eventInfo, action.name, action.element);\n    }\n    getIsReplay() {\n        return getIsReplay(this.eventInfo);\n    }\n    setIsReplay(replay) {\n        setIsReplay(this.eventInfo, replay);\n    }\n    getResolved() {\n        return getResolved(this.eventInfo);\n    }\n    setResolved(resolved) {\n        setResolved(this.eventInfo, resolved);\n    }\n    clone() {\n        return new EventInfoWrapper(cloneEventInfo(this.eventInfo));\n    }\n}\n\n/**\n * Since maps from event to action are immutable we can use a single map\n * to represent the empty map.\n */\nconst EMPTY_ACTION_MAP = {};\n/**\n * This regular expression matches a semicolon.\n */\nconst REGEXP_SEMICOLON = /\\s*;\\s*/;\n/** If no event type is defined, defaults to `click`. */\nconst DEFAULT_EVENT_TYPE = EventType.CLICK;\n/** Resolves actions for Events. */\nclass ActionResolver {\n    a11yClickSupport = false;\n    clickModSupport = true;\n    syntheticMouseEventSupport;\n    updateEventInfoForA11yClick = undefined;\n    preventDefaultForA11yClick = undefined;\n    populateClickOnlyAction = undefined;\n    constructor({ syntheticMouseEventSupport = false, clickModSupport = true, } = {}) {\n        this.syntheticMouseEventSupport = syntheticMouseEventSupport;\n        this.clickModSupport = clickModSupport;\n    }\n    resolveEventType(eventInfo) {\n        // We distinguish modified and plain clicks in order to support the\n        // default browser behavior of modified clicks on links; usually to\n        // open the URL of the link in new tab or new window on ctrl/cmd\n        // click. A DOM 'click' event is mapped to the jsaction 'click'\n        // event iff there is no modifier present on the event. If there is\n        // a modifier, it's mapped to 'clickmod' instead.\n        //\n        // It's allowed to omit the event in the jsaction attribute. In that\n        // case, 'click' is assumed. Thus the following two are equivalent:\n        //\n        //   <a href=\"someurl\" jsaction=\"gna.fu\">\n        //   <a href=\"someurl\" jsaction=\"click:gna.fu\">\n        //\n        // For unmodified clicks, EventContract invokes the jsaction\n        // 'gna.fu'. For modified clicks, EventContract won't find a\n        // suitable action and leave the event to be handled by the\n        // browser.\n        //\n        // In order to also invoke a jsaction handler for a modifier click,\n        // 'clickmod' needs to be used:\n        //\n        //   <a href=\"someurl\" jsaction=\"clickmod:gna.fu\">\n        //\n        // EventContract invokes the jsaction 'gna.fu' for modified\n        // clicks. Unmodified clicks are left to the browser.\n        //\n        // In order to set up the event contract to handle both clickonly and\n        // clickmod, only addEvent(EventType.CLICK) is necessary.\n        //\n        // In order to set up the event contract to handle click,\n        // addEvent() is necessary for CLICK, KEYDOWN, and KEYPRESS event types.  If\n        // a11y click support is enabled, addEvent() will set up the appropriate key\n        // event handler automatically.\n        if (this.clickModSupport &&\n            getEventType(eventInfo) === EventType.CLICK &&\n            isModifiedClickEvent(getEvent(eventInfo))) {\n            setEventType(eventInfo, EventType.CLICKMOD);\n        }\n        else if (this.a11yClickSupport) {\n            this.updateEventInfoForA11yClick(eventInfo);\n        }\n    }\n    resolveAction(eventInfo) {\n        if (getResolved(eventInfo)) {\n            return;\n        }\n        this.populateAction(eventInfo, getTargetElement(eventInfo));\n        setResolved(eventInfo, true);\n    }\n    resolveParentAction(eventInfo) {\n        const action = getAction(eventInfo);\n        const actionElement = action && getActionElement(action);\n        unsetAction(eventInfo);\n        const parentNode = actionElement && this.getParentNode(actionElement);\n        if (!parentNode) {\n            return;\n        }\n        this.populateAction(eventInfo, parentNode);\n    }\n    /**\n     * Searches for a jsaction that the DOM event maps to and creates an\n     * object containing event information used for dispatching by\n     * jsaction.Dispatcher. This method populates the `action` and `actionElement`\n     * fields of the EventInfo object passed in by finding the first\n     * jsaction attribute above the target Node of the event, and below\n     * the container Node, that specifies a jsaction for the event\n     * type. If no such jsaction is found, then action is undefined.\n     *\n     * @param eventInfo `EventInfo` to set `action` and `actionElement` if an\n     *    action is found on any `Element` in the path of the `Event`.\n     */\n    populateAction(eventInfo, currentTarget) {\n        let actionElement = currentTarget;\n        while (actionElement && actionElement !== getContainer(eventInfo)) {\n            if (actionElement.nodeType === Node.ELEMENT_NODE) {\n                this.populateActionOnElement(actionElement, eventInfo);\n            }\n            if (getAction(eventInfo)) {\n                // An event is handled by at most one jsaction. Thus we stop at the\n                // first matching jsaction specified in a jsaction attribute up the\n                // ancestor chain of the event target node.\n                break;\n            }\n            actionElement = this.getParentNode(actionElement);\n        }\n        const action = getAction(eventInfo);\n        if (!action) {\n            // No action found.\n            return;\n        }\n        if (this.a11yClickSupport) {\n            this.preventDefaultForA11yClick(eventInfo);\n        }\n        // We attempt to handle the mouseenter/mouseleave events here by\n        // detecting whether the mouseover/mouseout events correspond to\n        // entering/leaving an element.\n        if (this.syntheticMouseEventSupport) {\n            if (getEventType(eventInfo) === EventType.MOUSEENTER ||\n                getEventType(eventInfo) === EventType.MOUSELEAVE ||\n                getEventType(eventInfo) === EventType.POINTERENTER ||\n                getEventType(eventInfo) === EventType.POINTERLEAVE) {\n                // We attempt to handle the mouseenter/mouseleave events here by\n                // detecting whether the mouseover/mouseout events correspond to\n                // entering/leaving an element.\n                if (isMouseSpecialEvent(getEvent(eventInfo), getEventType(eventInfo), getActionElement(action))) {\n                    // If both mouseover/mouseout and mouseenter/mouseleave events are\n                    // enabled, two separate handlers for mouseover/mouseout are\n                    // registered. Both handlers will see the same event instance\n                    // so we create a copy to avoid interfering with the dispatching of\n                    // the mouseover/mouseout event.\n                    const copiedEvent = createMouseSpecialEvent(getEvent(eventInfo), getActionElement(action));\n                    setEvent(eventInfo, copiedEvent);\n                    // Since the mouseenter/mouseleave events do not bubble, the target\n                    // of the event is technically the `actionElement` (the node with the\n                    // `jsaction` attribute)\n                    setTargetElement(eventInfo, getActionElement(action));\n                }\n                else {\n                    unsetAction(eventInfo);\n                }\n            }\n        }\n    }\n    /**\n     * Walk to the parent node, unless the node has a different owner in\n     * which case we walk to the owner. Attempt to walk to host of a\n     * shadow root if needed.\n     */\n    getParentNode(element) {\n        const owner = element[Property.OWNER];\n        if (owner) {\n            return owner;\n        }\n        const parentNode = element.parentNode;\n        if (parentNode?.nodeName === '#document-fragment') {\n            return parentNode?.host ?? null;\n        }\n        return parentNode;\n    }\n    /**\n     * Accesses the jsaction map on a node and retrieves the name of the\n     * action the given event is mapped to, if any. It parses the\n     * attribute value and stores it in a property on the node for\n     * subsequent retrieval without re-parsing and re-accessing the\n     * attribute.\n     *\n     * @param actionElement The DOM node to retrieve the jsaction map from.\n     * @param eventInfo `EventInfo` to set `action` and `actionElement` if an\n     *    action is found on the `actionElement`.\n     */\n    populateActionOnElement(actionElement, eventInfo) {\n        const actionMap = this.parseActions(actionElement);\n        const actionName = actionMap[getEventType(eventInfo)];\n        if (actionName !== undefined) {\n            setAction(eventInfo, actionName, actionElement);\n        }\n        if (this.a11yClickSupport) {\n            this.populateClickOnlyAction(actionElement, eventInfo, actionMap);\n        }\n    }\n    /**\n     * Parses and caches an element's jsaction element into a map.\n     *\n     * This is primarily for internal use.\n     *\n     * @param actionElement The DOM node to retrieve the jsaction map from.\n     * @return Map from event to qualified name of the jsaction bound to it.\n     */\n    parseActions(actionElement) {\n        let actionMap = get(actionElement);\n        if (!actionMap) {\n            const jsactionAttribute = actionElement.getAttribute(Attribute.JSACTION);\n            if (!jsactionAttribute) {\n                actionMap = EMPTY_ACTION_MAP;\n                set(actionElement, actionMap);\n            }\n            else {\n                actionMap = getParsed(jsactionAttribute);\n                if (!actionMap) {\n                    actionMap = {};\n                    const values = jsactionAttribute.split(REGEXP_SEMICOLON);\n                    for (let idx = 0; idx < values.length; idx++) {\n                        const value = values[idx];\n                        if (!value) {\n                            continue;\n                        }\n                        const colon = value.indexOf(Char.EVENT_ACTION_SEPARATOR);\n                        const hasColon = colon !== -1;\n                        const type = hasColon ? value.substr(0, colon).trim() : DEFAULT_EVENT_TYPE;\n                        const action = hasColon ? value.substr(colon + 1).trim() : value;\n                        actionMap[type] = action;\n                    }\n                    setParsed(jsactionAttribute, actionMap);\n                }\n                set(actionElement, actionMap);\n            }\n        }\n        return actionMap;\n    }\n    addA11yClickSupport(updateEventInfoForA11yClick, preventDefaultForA11yClick, populateClickOnlyAction) {\n        this.a11yClickSupport = true;\n        this.updateEventInfoForA11yClick = updateEventInfoForA11yClick;\n        this.preventDefaultForA11yClick = preventDefaultForA11yClick;\n        this.populateClickOnlyAction = populateClickOnlyAction;\n    }\n}\n\n/**\n * @fileoverview An enum to control who can call certain jsaction APIs.\n */\nvar Restriction;\n(function (Restriction) {\n    Restriction[Restriction[\"I_AM_THE_JSACTION_FRAMEWORK\"] = 0] = \"I_AM_THE_JSACTION_FRAMEWORK\";\n})(Restriction || (Restriction = {}));\n\n/**\n * Receives a DOM event, determines the jsaction associated with the source\n * element of the DOM event, and invokes the handler associated with the\n * jsaction.\n */\nclass Dispatcher {\n    dispatchDelegate;\n    // The ActionResolver to use to resolve actions.\n    actionResolver;\n    /** The replayer function to be called when there are queued events. */\n    eventReplayer;\n    /** Whether the event replay is scheduled. */\n    eventReplayScheduled = false;\n    /** The queue of events. */\n    replayEventInfoWrappers = [];\n    /**\n     * Options are:\n     *   - `eventReplayer`: When the event contract dispatches replay events\n     *      to the Dispatcher, the Dispatcher collects them and in the next tick\n     *      dispatches them to the `eventReplayer`. Defaults to dispatching to `dispatchDelegate`.\n     * @param dispatchDelegate A function that should handle dispatching an `EventInfoWrapper` to handlers.\n     */\n    constructor(dispatchDelegate, { actionResolver, eventReplayer, } = {}) {\n        this.dispatchDelegate = dispatchDelegate;\n        this.actionResolver = actionResolver;\n        this.eventReplayer = eventReplayer;\n    }\n    /**\n     * Receives an event or the event queue from the EventContract. The event\n     * queue is copied and it attempts to replay.\n     * If event info is passed in it looks for an action handler that can handle\n     * the given event.  If there is no handler registered queues the event and\n     * checks if a loader is registered for the given namespace. If so, calls it.\n     *\n     * Alternatively, if in global dispatch mode, calls all registered global\n     * handlers for the appropriate event type.\n     *\n     * The three functionalities of this call are deliberately not split into\n     * three methods (and then declared as an abstract interface), because the\n     * interface is used by EventContract, which lives in a different jsbinary.\n     * Therefore the interface between the three is defined entirely in terms that\n     * are invariant under jscompiler processing (Function and Array, as opposed\n     * to a custom type with method names).\n     *\n     * @param eventInfo The info for the event that triggered this call or the\n     *     queue of events from EventContract.\n     */\n    dispatch(eventInfo) {\n        const eventInfoWrapper = new EventInfoWrapper(eventInfo);\n        this.actionResolver?.resolveEventType(eventInfo);\n        this.actionResolver?.resolveAction(eventInfo);\n        const action = eventInfoWrapper.getAction();\n        if (action && shouldPreventDefaultBeforeDispatching(action.element, eventInfoWrapper)) {\n            preventDefault(eventInfoWrapper.getEvent());\n        }\n        if (this.eventReplayer && eventInfoWrapper.getIsReplay()) {\n            this.scheduleEventInfoWrapperReplay(eventInfoWrapper);\n            return;\n        }\n        this.dispatchDelegate(eventInfoWrapper);\n    }\n    /**\n     * Schedules an `EventInfoWrapper` for replay. The replaying will happen in its own\n     * stack once the current flow cedes control. This is done to mimic\n     * browser event handling.\n     */\n    scheduleEventInfoWrapperReplay(eventInfoWrapper) {\n        this.replayEventInfoWrappers.push(eventInfoWrapper);\n        if (this.eventReplayScheduled) {\n            return;\n        }\n        this.eventReplayScheduled = true;\n        Promise.resolve().then(() => {\n            this.eventReplayScheduled = false;\n            this.eventReplayer(this.replayEventInfoWrappers);\n        });\n    }\n}\n/**\n * Returns true if the default action of this event should be prevented before\n * this event is dispatched.\n */\nfunction shouldPreventDefaultBeforeDispatching(actionElement, eventInfoWrapper) {\n    // Prevent browser from following <a> node links if a jsaction is present\n    // and we are dispatching the action now. Note that the targetElement may be\n    // a child of an anchor that has a jsaction attached. For that reason, we\n    // need to check the actionElement rather than the targetElement.\n    return (actionElement.tagName === 'A' &&\n        (eventInfoWrapper.getEventType() === EventType.CLICK ||\n            eventInfoWrapper.getEventType() === EventType.CLICKMOD));\n}\n\n/** An internal symbol used to indicate whether propagation should be stopped or not. */\nconst PROPAGATION_STOPPED_SYMBOL = \n/* @__PURE__ */ Symbol.for('propagationStopped');\n/** Extra event phases beyond what the browser provides. */\nconst EventPhase = {\n    REPLAY: 101,\n};\nconst PREVENT_DEFAULT_ERROR_MESSAGE_DETAILS = ' Because event replay occurs after browser dispatch, `preventDefault` would have no ' +\n    'effect. You can check whether an event is being replayed by accessing the event phase: ' +\n    '`event.eventPhase === EventPhase.REPLAY`.';\nconst PREVENT_DEFAULT_ERROR_MESSAGE = `\\`preventDefault\\` called during event replay.`;\nconst COMPOSED_PATH_ERROR_MESSAGE_DETAILS = ' Because event replay occurs after browser ' +\n    'dispatch, `composedPath()` will be empty. Iterate parent nodes from `event.target` or ' +\n    '`event.currentTarget` if you need to check elements in the event path.';\nconst COMPOSED_PATH_ERROR_MESSAGE = `\\`composedPath\\` called during event replay.`;\n/**\n * A dispatcher that uses browser-based `Event` semantics, for example bubbling, `stopPropagation`,\n * `currentTarget`, etc.\n */\nclass EventDispatcher {\n    dispatchDelegate;\n    clickModSupport;\n    actionResolver;\n    dispatcher;\n    constructor(dispatchDelegate, clickModSupport = true) {\n        this.dispatchDelegate = dispatchDelegate;\n        this.clickModSupport = clickModSupport;\n        this.actionResolver = new ActionResolver({ clickModSupport });\n        this.dispatcher = new Dispatcher((eventInfoWrapper) => {\n            this.dispatchToDelegate(eventInfoWrapper);\n        }, {\n            actionResolver: this.actionResolver,\n        });\n    }\n    /**\n     * The entrypoint for the `EventContract` dispatch.\n     */\n    dispatch(eventInfo) {\n        this.dispatcher.dispatch(eventInfo);\n    }\n    /** Internal method that does basic disaptching. */\n    dispatchToDelegate(eventInfoWrapper) {\n        if (eventInfoWrapper.getIsReplay()) {\n            prepareEventForReplay(eventInfoWrapper);\n        }\n        prepareEventForBubbling(eventInfoWrapper);\n        while (eventInfoWrapper.getAction()) {\n            prepareEventForDispatch(eventInfoWrapper);\n            // If this is a capture event, ONLY dispatch if the action element is the target.\n            if (isCaptureEventType(eventInfoWrapper.getEventType()) &&\n                eventInfoWrapper.getAction().element !== eventInfoWrapper.getTargetElement()) {\n                return;\n            }\n            this.dispatchDelegate(eventInfoWrapper.getEvent(), eventInfoWrapper.getAction().name);\n            if (propagationStopped(eventInfoWrapper)) {\n                return;\n            }\n            this.actionResolver.resolveParentAction(eventInfoWrapper.eventInfo);\n        }\n    }\n}\nfunction prepareEventForBubbling(eventInfoWrapper) {\n    const event = eventInfoWrapper.getEvent();\n    const originalStopPropagation = eventInfoWrapper.getEvent().stopPropagation.bind(event);\n    const stopPropagation = () => {\n        event[PROPAGATION_STOPPED_SYMBOL] = true;\n        originalStopPropagation();\n    };\n    patchEventInstance(event, 'stopPropagation', stopPropagation);\n    patchEventInstance(event, 'stopImmediatePropagation', stopPropagation);\n}\nfunction propagationStopped(eventInfoWrapper) {\n    const event = eventInfoWrapper.getEvent();\n    return !!event[PROPAGATION_STOPPED_SYMBOL];\n}\nfunction prepareEventForReplay(eventInfoWrapper) {\n    const event = eventInfoWrapper.getEvent();\n    const target = eventInfoWrapper.getTargetElement();\n    const originalPreventDefault = event.preventDefault.bind(event);\n    patchEventInstance(event, 'target', target);\n    patchEventInstance(event, 'eventPhase', EventPhase.REPLAY);\n    patchEventInstance(event, 'preventDefault', () => {\n        originalPreventDefault();\n        throw new Error(PREVENT_DEFAULT_ERROR_MESSAGE + (ngDevMode ? PREVENT_DEFAULT_ERROR_MESSAGE_DETAILS : ''));\n    });\n    patchEventInstance(event, 'composedPath', () => {\n        throw new Error(COMPOSED_PATH_ERROR_MESSAGE + (ngDevMode ? COMPOSED_PATH_ERROR_MESSAGE_DETAILS : ''));\n    });\n}\nfunction prepareEventForDispatch(eventInfoWrapper) {\n    const event = eventInfoWrapper.getEvent();\n    const currentTarget = eventInfoWrapper.getAction()?.element;\n    if (currentTarget) {\n        patchEventInstance(event, 'currentTarget', currentTarget, {\n            // `currentTarget` is going to get reassigned every dispatch.\n            configurable: true,\n        });\n    }\n}\n/**\n * Patch `Event` instance during non-standard `Event` dispatch. This patches just the `Event`\n * instance that the browser created, it does not patch global properties or methods.\n *\n * This is necessary because dispatching an `Event` outside of browser dispatch results in\n * incorrect properties and methods that need to be polyfilled or do not work.\n *\n * JSAction dispatch adds two extra \"phases\" to event dispatch:\n * 1. Event delegation - the event is being dispatched by a delegating event handler on a container\n *    (typically `window.document.documentElement`), to a delegated event handler on some child\n *    element. Certain `Event` properties will be unintuitive, such as `currentTarget`, which would\n *    be the container rather than the child element. Bubbling would also not work. In order to\n *    emulate the browser, these properties and methods on the `Event` are patched.\n * 2. Event replay - the event is being dispatched by the framework once the handlers have been\n *    loaded (during hydration, or late-loaded). Certain `Event` properties can be unset by the\n *    browser because the `Event` is no longer actively being dispatched, such as `target`. Other\n *    methods have no effect because the `Event` has already been dispatched, such as\n *    `preventDefault`. Bubbling would also not work. These properties and methods are patched,\n *    either to fill in information that the browser may have removed, or to throw errors in methods\n *    that no longer behave as expected.\n */\nfunction patchEventInstance(event, property, value, { configurable = false } = {}) {\n    Object.defineProperty(event, property, { value, configurable });\n}\n/**\n * Registers deferred functionality for an EventContract and a Jsaction\n * Dispatcher.\n */\nfunction registerDispatcher$1(eventContract, dispatcher) {\n    eventContract.ecrd((eventInfo) => {\n        dispatcher.dispatch(eventInfo);\n    }, Restriction.I_AM_THE_JSACTION_FRAMEWORK);\n}\n\n/** Creates an `EarlyJsactionData` object. */\nfunction createEarlyJsactionData(container) {\n    const q = [];\n    const d = (eventInfo) => {\n        q.push(eventInfo);\n    };\n    const h = (event) => {\n        d(createEventInfoFromParameters(event.type, event, event.target, container, Date.now()));\n    };\n    return {\n        c: container,\n        q,\n        et: [],\n        etc: [],\n        d,\n        h,\n    };\n}\n/** Add all the events to the container stored in the `EarlyJsactionData`. */\nfunction addEvents(earlyJsactionData, types, capture) {\n    for (let i = 0; i < types.length; i++) {\n        const eventType = types[i];\n        const eventTypes = capture ? earlyJsactionData.etc : earlyJsactionData.et;\n        eventTypes.push(eventType);\n        earlyJsactionData.c.addEventListener(eventType, earlyJsactionData.h, capture);\n    }\n}\n/** Get the queued `EventInfo` objects that were dispatched before a dispatcher was registered. */\nfunction getQueuedEventInfos(earlyJsactionData) {\n    return earlyJsactionData?.q ?? [];\n}\n/** Register a different dispatcher function on the `EarlyJsactionData`. */\nfunction registerDispatcher(earlyJsactionData, dispatcher) {\n    if (!earlyJsactionData) {\n        return;\n    }\n    earlyJsactionData.d = dispatcher;\n}\n/** Removes all event listener handlers. */\nfunction removeAllEventListeners(earlyJsactionData) {\n    if (!earlyJsactionData) {\n        return;\n    }\n    removeEventListeners(earlyJsactionData.c, earlyJsactionData.et, earlyJsactionData.h);\n    removeEventListeners(earlyJsactionData.c, earlyJsactionData.etc, earlyJsactionData.h, true);\n}\nfunction removeEventListeners(container, eventTypes, earlyEventHandler, capture) {\n    for (let i = 0; i < eventTypes.length; i++) {\n        container.removeEventListener(eventTypes[i], earlyEventHandler, /* useCapture */ capture);\n    }\n}\n\n/**\n * @define Support for the non-bubbling mouseenter and mouseleave events.  This\n * flag can be overridden in a build rule.\n */\nconst MOUSE_SPECIAL_SUPPORT = false;\n\n/**\n * @fileoverview Implements the local event handling contract. This\n * allows DOM objects in a container that enters into this contract to\n * define event handlers which are executed in a local context.\n *\n * One EventContract instance can manage the contract for multiple\n * containers, which are added using the addContainer() method.\n *\n * Events can be registered using the addEvent() method.\n *\n * A Dispatcher is added using the registerDispatcher() method. Until there is\n * a dispatcher, events are queued. The idea is that the EventContract\n * class is inlined in the HTML of the top level page and instantiated\n * right after the start of <body>. The Dispatcher class is contained\n * in the external deferred js, and instantiated and registered with\n * EventContract when the external javascript in the page loads. The\n * external javascript will also register the jsaction handlers, which\n * then pick up the queued events at the time of registration.\n *\n * Since this class is meant to be inlined in the main page HTML, the\n * size of the binary compiled from this file MUST be kept as small as\n * possible and thus its dependencies to a minimum.\n */\n/**\n * EventContract intercepts events in the bubbling phase at the\n * boundary of a container element, and maps them to generic actions\n * which are specified using the custom jsaction attribute in\n * HTML. Behavior of the application is then specified in terms of\n * handler for such actions, cf. jsaction.Dispatcher in dispatcher.js.\n *\n * This has several benefits: (1) No DOM event handlers need to be\n * registered on the specific elements in the UI. (2) The set of\n * events that the application has to handle can be specified in terms\n * of the semantics of the application, rather than in terms of DOM\n * events. (3) Invocation of handlers can be delayed and handlers can\n * be delay loaded in a generic way.\n */\nclass EventContract {\n    static MOUSE_SPECIAL_SUPPORT = MOUSE_SPECIAL_SUPPORT;\n    containerManager;\n    /**\n     * The DOM events which this contract covers. Used to prevent double\n     * registration of event types. The value of the map is the\n     * internally created DOM event handler function that handles the\n     * DOM events. See addEvent().\n     *\n     */\n    eventHandlers = {};\n    browserEventTypeToExtraEventTypes = {};\n    /**\n     * The dispatcher function. Events are passed to this function for\n     * handling once it was set using the registerDispatcher() method. This is\n     * done because the function is passed from another jsbinary, so passing the\n     * instance and invoking the method here would require to leave the method\n     * unobfuscated.\n     */\n    dispatcher = null;\n    /**\n     * The list of suspended `EventInfo` that will be dispatched\n     * as soon as the `Dispatcher` is registered.\n     */\n    queuedEventInfos = [];\n    constructor(containerManager) {\n        this.containerManager = containerManager;\n    }\n    handleEvent(eventType, event, container) {\n        const eventInfo = createEventInfoFromParameters(\n        /* eventType= */ eventType, \n        /* event= */ event, \n        /* targetElement= */ event.target, \n        /* container= */ container, \n        /* timestamp= */ Date.now());\n        this.handleEventInfo(eventInfo);\n    }\n    /**\n     * Handle an `EventInfo`.\n     */\n    handleEventInfo(eventInfo) {\n        if (!this.dispatcher) {\n            // All events are queued when the dispatcher isn't yet loaded.\n            setIsReplay(eventInfo, true);\n            this.queuedEventInfos?.push(eventInfo);\n            return;\n        }\n        this.dispatcher(eventInfo);\n    }\n    /**\n     * Enables jsaction handlers to be called for the event type given by\n     * name.\n     *\n     * If the event is already registered, this does nothing.\n     *\n     * @param prefixedEventType If supplied, this event is used in\n     *     the actual browser event registration instead of the name that is\n     *     exposed to jsaction. Use this if you e.g. want users to be able\n     *     to subscribe to jsaction=\"transitionEnd:foo\" while the underlying\n     *     event is webkitTransitionEnd in one browser and mozTransitionEnd\n     *     in another.\n     *\n     * @param passive A boolean value that, if `true`, indicates that the event\n     *     handler will never call `preventDefault()`.\n     */\n    addEvent(eventType, prefixedEventType, passive) {\n        if (eventType in this.eventHandlers || !this.containerManager) {\n            return;\n        }\n        if (!EventContract.MOUSE_SPECIAL_SUPPORT && MOUSE_SPECIAL_EVENT_TYPES.indexOf(eventType) >= 0) {\n            return;\n        }\n        const eventHandler = (eventType, event, container) => {\n            this.handleEvent(eventType, event, container);\n        };\n        // Store the callback to allow us to replay events.\n        this.eventHandlers[eventType] = eventHandler;\n        const browserEventType = getBrowserEventType(prefixedEventType || eventType);\n        if (browserEventType !== eventType) {\n            const eventTypes = this.browserEventTypeToExtraEventTypes[browserEventType] || [];\n            eventTypes.push(eventType);\n            this.browserEventTypeToExtraEventTypes[browserEventType] = eventTypes;\n        }\n        this.containerManager.addEventListener(browserEventType, (element) => {\n            return (event) => {\n                eventHandler(eventType, event, element);\n            };\n        }, passive);\n    }\n    /**\n     * Gets the queued early events and replay them using the appropriate handler\n     * in the provided event contract. Once all the events are replayed, it cleans\n     * up the early contract.\n     */\n    replayEarlyEvents(earlyJsactionData = window._ejsa) {\n        // Check if the early contract is present and prevent calling this function\n        // more than once.\n        if (!earlyJsactionData) {\n            return;\n        }\n        // Replay the early contract events.\n        this.replayEarlyEventInfos(earlyJsactionData.q);\n        // Clean up the early contract.\n        removeAllEventListeners(earlyJsactionData);\n        delete window._ejsa;\n    }\n    /**\n     * Replays all the early `EventInfo` objects, dispatching them through the normal\n     * `EventContract` flow.\n     */\n    replayEarlyEventInfos(earlyEventInfos) {\n        for (let i = 0; i < earlyEventInfos.length; i++) {\n            const earlyEventInfo = earlyEventInfos[i];\n            const eventTypes = this.getEventTypesForBrowserEventType(earlyEventInfo.eventType);\n            for (let j = 0; j < eventTypes.length; j++) {\n                const eventInfo = cloneEventInfo(earlyEventInfo);\n                // EventInfo eventType maps to JSAction's internal event type,\n                // rather than the browser event type.\n                setEventType(eventInfo, eventTypes[j]);\n                this.handleEventInfo(eventInfo);\n            }\n        }\n    }\n    /**\n     * Returns all JSAction event types that have been registered for a given\n     * browser event type.\n     */\n    getEventTypesForBrowserEventType(browserEventType) {\n        const eventTypes = [];\n        if (this.eventHandlers[browserEventType]) {\n            eventTypes.push(browserEventType);\n        }\n        if (this.browserEventTypeToExtraEventTypes[browserEventType]) {\n            eventTypes.push(...this.browserEventTypeToExtraEventTypes[browserEventType]);\n        }\n        return eventTypes;\n    }\n    /**\n     * Returns the event handler function for a given event type.\n     */\n    handler(eventType) {\n        return this.eventHandlers[eventType];\n    }\n    /**\n     * Cleans up the event contract. This resets all of the `EventContract`'s\n     * internal state. Users are responsible for not using this `EventContract`\n     * after it has been cleaned up.\n     */\n    cleanUp() {\n        this.containerManager?.cleanUp();\n        this.containerManager = null;\n        this.eventHandlers = {};\n        this.browserEventTypeToExtraEventTypes = {};\n        this.dispatcher = null;\n        this.queuedEventInfos = [];\n    }\n    /**\n     * Register a dispatcher function. Event info of each event mapped to\n     * a jsaction is passed for handling to this callback. The queued\n     * events are passed as well to the dispatcher for later replaying\n     * once the dispatcher is registered. Clears the event queue to null.\n     *\n     * @param dispatcher The dispatcher function.\n     * @param restriction\n     */\n    registerDispatcher(dispatcher, restriction) {\n        this.ecrd(dispatcher, restriction);\n    }\n    /**\n     * Unrenamed alias for registerDispatcher. Necessary for any codebases that\n     * split the `EventContract` and `Dispatcher` code into different compilation\n     * units.\n     */\n    ecrd(dispatcher, restriction) {\n        this.dispatcher = dispatcher;\n        if (this.queuedEventInfos?.length) {\n            for (let i = 0; i < this.queuedEventInfos.length; i++) {\n                this.handleEventInfo(this.queuedEventInfos[i]);\n            }\n            this.queuedEventInfos = null;\n        }\n    }\n}\n\n/**\n * Creates an `EarlyJsactionData`, adds events to it, and populates it on a nested object on\n * the window.\n */\nfunction bootstrapAppScopedEarlyEventContract(container, appId, bubbleEventTypes, captureEventTypes, dataContainer = window) {\n    const earlyJsactionData = createEarlyJsactionData(container);\n    if (!dataContainer._ejsas) {\n        dataContainer._ejsas = {};\n    }\n    dataContainer._ejsas[appId] = earlyJsactionData;\n    addEvents(earlyJsactionData, bubbleEventTypes);\n    addEvents(earlyJsactionData, captureEventTypes, /* capture= */ true);\n}\n/** Get the queued `EventInfo` objects that were dispatched before a dispatcher was registered. */\nfunction getAppScopedQueuedEventInfos(appId, dataContainer = window) {\n    return getQueuedEventInfos(dataContainer._ejsas?.[appId]);\n}\n/**\n * Registers a dispatcher function on the `EarlyJsactionData` present on the nested object on the\n * window.\n */\nfunction registerAppScopedDispatcher(restriction, appId, dispatcher, dataContainer = window) {\n    registerDispatcher(dataContainer._ejsas?.[appId], dispatcher);\n}\n/** Removes all event listener handlers. */\nfunction removeAllAppScopedEventListeners(appId, dataContainer = window) {\n    removeAllEventListeners(dataContainer._ejsas?.[appId]);\n}\n/** Clear the early event contract. */\nfunction clearAppScopedEarlyEventContract(appId, dataContainer = window) {\n    if (!dataContainer._ejsas) {\n        return;\n    }\n    dataContainer._ejsas[appId] = undefined;\n}\n\nexport { Attribute, EventContract, EventContractContainer, EventDispatcher, EventInfoWrapper, EventPhase, bootstrapAppScopedEarlyEventContract, clearAppScopedEarlyEventContract, getDefaulted as getActionCache, getAppScopedQueuedEventInfos, isCaptureEventType, isEarlyEventType, registerAppScopedDispatcher, registerDispatcher$1 as registerDispatcher, removeAllAppScopedEventListeners };\n","/**\n * @license Angular v20.3.6\n * (c) 2010-2025 Google LLC. https://angular.dev/\n * License: MIT\n */\n\nimport { RuntimeError, InjectionToken, getCurrentTNode, assertInInjectionContext, signalAsReadonlyFn, assertNgModuleType, Injector, inject, defineInjectable as __defineInjectable, formatRuntimeError, INTERNAL_APPLICATION_ERROR_HANDLER, PROVIDED_ZONELESS, PendingTasksInternal, stringify, ChangeDetectionScheduler, errorHandlerEnvironmentInitializer, inject as __inject, INJECTOR_SCOPE, makeEnvironmentProviders, runInInjectionContext, provideEnvironmentInitializer, ErrorHandler, _global, isComponentHost, getComponentLViewByIndex, getLView, DECLARATION_COMPONENT_VIEW, defineInjector as __defineInjector, ENVIRONMENT_INITIALIZER, unwrapRNode, CLEANUP, isLContainer, HOST, hasI18n, unwrapLView, RENDERER, assertTNode, isProjectionTNode, getComponentDef, PARENT, isRootView, HEADER_OFFSET, TVIEW, CONTEXT, CONTAINER_HEADER_OFFSET, isLView, getTNode, assertNotInReactiveContext, ViewContext, DestroyRef, setInjectorProfilerContext, emitEffectCreatedEvent, getNullInjector } from './root_effect_scheduler.mjs';\nexport { DOCUMENT, EnvironmentInjector, INJECTOR, PendingTasks, VERSION, Version, defineInjectable, forwardRef, importProvidersFrom, isSignal, isStandalone, provideBrowserGlobalErrorListeners, resolveForwardRef, signal, EffectScheduler as EffectScheduler, NG_COMP_DEF as NG_COMP_DEF, NG_DIR_DEF as NG_DIR_DEF, NG_ELEMENT_ID as NG_ELEMENT_ID, NG_INJ_DEF as NG_INJ_DEF, NG_MOD_DEF as NG_MOD_DEF, NG_PIPE_DEF as NG_PIPE_DEF, NG_PROV_DEF as NG_PROV_DEF, R3Injector as R3Injector, XSS_SECURITY_URL as XSS_SECURITY_URL, ZONELESS_ENABLED as ZONELESS_ENABLED, convertToBitFlags as convertToBitFlags, createInjector as createInjector, getInjectableDef as getInjectableDef, isEnvironmentProviders as isEnvironmentProviders, isInjectable as isInjectable, store as store, truncateMiddle as truncateMiddle, unwrapWritableSignal, disableBindings, enableBindings, invalidFactoryDep, namespaceHTML, namespaceMathML, namespaceSVG, resetView, restoreView } from './root_effect_scheduler.mjs';\nimport { SIGNAL_NODE, signalSetFn, SIGNAL, producerAccessed, consumerDestroy, consumerPollProducersForChange, consumerBeforeComputation, consumerAfterComputation } from './signal.mjs';\nimport { injectAttribute as __injectAttribute, createMultiResultQuerySignalFn, createSingleResultOptionalQuerySignalFn, createSingleResultRequiredQuerySignalFn, makePropDecorator, NgModuleFactory, COMPILER_OPTIONS, setJitOptions, isComponentResourceResolutionQueueEmpty, getCompilerFacade, resolveComponentResources, IMAGE_CONFIG, getDocument, setClassMetadata, Injectable, NgZone, PROVIDED_NG_ZONE, remove, isPromise, ApplicationInitStatus, LOCALE_ID, DEFAULT_LOCALE_ID, setLocaleId, ApplicationRef, internalProvideZoneChangeDetection, ChangeDetectionSchedulerImpl, createNgModuleRefWithProviders, optionsReducer, getNgZone, getNgZoneOptions, publishDefaultGlobalUtils, PLATFORM_INITIALIZER, publishSignalConfiguration, checkNoChangesInternal, UseExhaustiveCheckNoChanges, getRegisteredNgModuleType, ViewRef as ViewRef$1, isListLikeIterable, iterateListLike, isJsObject, defineNgModule as __defineNgModule, NgModule, profiler, assertStandaloneComponentType, EnvironmentNgModuleRefAdapter, JSACTION_BLOCK_ELEMENT_MAP, APP_ID, setStashFn, APP_BOOTSTRAP_LISTENER, JSACTION_EVENT_CONTRACT, removeListeners, isIncrementalHydrationEnabled, DEFER_BLOCK_SSR_ID_ATTRIBUTE, invokeListeners, triggerHydrationFromBlockName, IS_EVENT_REPLAY_ENABLED, EVENT_REPLAY_ENABLED_DEFAULT, performanceMarkFeature, sharedStashFunction, sharedMapFunction, enableStashEventListenerImpl, isI18nHydrationEnabled, TransferState, NGH_DATA_KEY, NGH_DEFER_BLOCKS_KEY, SKIP_HYDRATION_ATTR_NAME, NGH_ATTR_NAME, getLNodeForHydration, isI18nHydrationSupportEnabled, getOrComputeI18nChildren, trySerializeI18nBlock, I18N_DATA, isTNodeShape, isDetachedByI18n, TEMPLATES, isDisconnectedNode, isInSkipHydrationBlock, unsupportedProjectionOfDomNodes, CONTAINERS, isLetDeclaration, ELEMENT_CONTAINERS, processTextNodeBeforeSerialization, setJSActionAttributes, ViewEncapsulation as ViewEncapsulation$1, collectNativeNodes, TEMPLATE_ID, NUM_ROOT_NODES, isDeferBlock, getLDeferBlockDetails, getTDeferBlockDetails, collectNativeNodesInLContainer, validateNodeExists, validateMatchingNode, DEFER_BLOCK_ID, DEFER_BLOCK_STATE, DEFER_BLOCK_STATE$1, MULTIPLIER, NODES, calcPathForNode, DISCONNECTED_NODES, convertHydrateTriggersToJsAction, DEFER_HYDRATE_TRIGGERS, DEFER_PARENT_BLOCK_ID, IS_I18N_HYDRATION_ENABLED, IS_HYDRATION_DOM_REUSE_ENABLED, IS_INCREMENTAL_HYDRATION_ENABLED, DEHYDRATED_BLOCK_REGISTRY, DehydratedBlockRegistry, processBlockData, gatherDeferBlocksCommentNodes, processAndInitTriggers, appendDeferBlocksToJSActionMap, verifySsrContentsIntegrity, Console, PRESERVE_HOST_CONTENT, cleanupDehydratedViews, countBlocksSkippedByHydration, enableRetrieveHydrationInfoImpl, enableLocateOrCreateElementNodeImpl, enableLocateOrCreateTextNodeImpl, enableLocateOrCreateElementContainerNodeImpl, enableLocateOrCreateContainerAnchorImpl, enableLocateOrCreateContainerRefImpl, enableFindMatchingDehydratedViewImpl, enableApplyRootElementTransformImpl, enableLocateOrCreateI18nNodeImpl, enablePrepareI18nBlockForHydrationImpl, setIsI18nHydrationSupportEnabled, enableClaimDehydratedIcuCaseImpl, enableRetrieveDeferBlockDataImpl, readPatchedLView, angularCoreEnv, setClassMetadataAsync, NOOP_AFTER_RENDER_REF, AfterRenderManager, TracingService, AfterRenderImpl, AfterRenderSequence, AFTER_RENDER_PHASES, assertComponentDef, ComponentFactory } from './debug_node.mjs';\nexport { ANIMATION_MODULE_TYPE, APP_INITIALIZER, Attribute, CSP_NONCE, CUSTOM_ELEMENTS_SCHEMA, ChangeDetectionStrategy, Compiler, CompilerFactory, Component, ComponentFactory$1 as ComponentFactory, ComponentFactoryResolver, ComponentRef, DEFAULT_CURRENCY_CODE, DebugElement, DebugEventListener, DebugNode, Directive, ElementRef, EventEmitter, Host, HostBinding, HostListener, Inject, Input, MAX_ANIMATION_TIMEOUT, MissingTranslationStrategy, ModuleWithComponentFactories, NO_ERRORS_SCHEMA, NgModuleFactory$1 as NgModuleFactory, NgModuleRef$1 as NgModuleRef, NgProbeToken, Optional, Output, PACKAGE_ROOT_URL, PLATFORM_ID, Pipe, QueryList, Renderer2, RendererFactory2, RendererStyleFlags2, Sanitizer, SecurityContext, Self, SimpleChange, SkipSelf, TRANSLATIONS, TRANSLATIONS_FORMAT, TemplateRef, Testability, TestabilityRegistry, Type, ViewContainerRef, afterEveryRender, afterNextRender, asNativeElements, createEnvironmentInjector, createNgModule, createNgModuleRef, enableProfiling, getDebugNode, inputBinding, makeStateKey, outputBinding, provideAppInitializer, provideNgReflectAttributes, provideZoneChangeDetection, provideZonelessChangeDetection, setTestabilityGetter, twoWayBinding, ANIMATIONS_DISABLED as ANIMATIONS_DISABLED, AcxChangeDetectionStrategy as AcxChangeDetectionStrategy, AcxViewEncapsulation as AcxViewEncapsulation, ComponentFactory$1 as ComponentFactory, DEFER_BLOCK_CONFIG as DEFER_BLOCK_CONFIG, DEFER_BLOCK_DEPENDENCY_INTERCEPTOR as DEFER_BLOCK_DEPENDENCY_INTERCEPTOR, DeferBlockBehavior as DeferBlockBehavior, DeferBlockState as DeferBlockState, Framework as Framework, HydrationStatus as HydrationStatus, IMAGE_CONFIG_DEFAULTS as IMAGE_CONFIG_DEFAULTS, IS_ENABLED_BLOCKING_INITIAL_NAVIGATION as IS_ENABLED_BLOCKING_INITIAL_NAVIGATION, LContext as LContext, LocaleDataIndex as LocaleDataIndex, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR as NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR, NO_CHANGE as NO_CHANGE, NoopNgZone as NoopNgZone, ReflectionCapabilities as ReflectionCapabilities, ComponentRef$1 as Render3ComponentRef, NgModuleRef as Render3NgModuleRef, SSR_CONTENT_INTEGRITY_MARKER as SSR_CONTENT_INTEGRITY_MARKER, TESTABILITY as TESTABILITY, TESTABILITY_GETTER as TESTABILITY_GETTER, TimerScheduler as TimerScheduler, TracingAction as TracingAction, _sanitizeHtml as _sanitizeHtml, _sanitizeUrl as _sanitizeUrl, allLeavingAnimations as allLeavingAnimations, allowSanitizationBypassAndThrow as allowSanitizationBypassAndThrow, bypassSanitizationTrustHtml as bypassSanitizationTrustHtml, bypassSanitizationTrustResourceUrl as bypassSanitizationTrustResourceUrl, bypassSanitizationTrustScript as bypassSanitizationTrustScript, bypassSanitizationTrustStyle as bypassSanitizationTrustStyle, bypassSanitizationTrustUrl as bypassSanitizationTrustUrl, clearResolutionOfComponentResourcesQueue as clearResolutionOfComponentResourcesQueue, compileComponent as compileComponent, compileDirective as compileDirective, compileNgModule as compileNgModule, compileNgModuleDefs as compileNgModuleDefs, compilePipe as compilePipe, depsTracker as depsTracker, devModeEqual as devModeEqual, findLocaleData as findLocaleData, flushModuleScopingQueueAsMuchAsPossible as flushModuleScopingQueueAsMuchAsPossible, generateStandaloneInDeclarationsError as generateStandaloneInDeclarationsError, getAsyncClassMetadataFn as getAsyncClassMetadataFn, getDebugNode as getDebugNode, getDeferBlocks as getDeferBlocks, getDirectives as getDirectives, getHostElement as getHostElement, getLContext as getLContext, getLocaleCurrencyCode as getLocaleCurrencyCode, getLocalePluralCase as getLocalePluralCase, getSanitizationBypassType as getSanitizationBypassType, getTransferState as getTransferState, getUnknownElementStrictMode, getUnknownPropertyStrictMode, inferTagNameFromDefinition as inferTagNameFromDefinition, isBoundToModule as isBoundToModule, isComponentDefPendingResolution as isComponentDefPendingResolution, isNgModule as isNgModule, isSubscribable as isSubscribable, isViewDirty as isViewDirty, markForRefresh as markForRefresh, noSideEffects as noSideEffects, patchComponentDefWithScope as patchComponentDefWithScope, publishExternalGlobalUtil as publishExternalGlobalUtil, readHydrationInfo as readHydrationInfo, registerLocaleData as registerLocaleData, renderDeferBlockState as renderDeferBlockState, resetCompiledComponents as resetCompiledComponents, resetIncrementalHydrationEnabledWarnedForTests as resetIncrementalHydrationEnabledWarnedForTests, resetJitOptions as resetJitOptions, restoreComponentResolutionQueue as restoreComponentResolutionQueue, setAllowDuplicateNgModuleIdsForTest as setAllowDuplicateNgModuleIdsForTest, setClassDebugInfo, setDocument as setDocument, setUnknownElementStrictMode, setUnknownPropertyStrictMode, transitiveScopesFor as transitiveScopesFor, triggerResourceLoading as triggerResourceLoading, unregisterAllLocaleData as unregisterLocaleData, unwrapSafeValue as unwrapSafeValue, CopyDefinitionFeature, ExternalStylesFeature, HostDirectivesFeature, InheritDefinitionFeature, NgOnChangesFeature, ProvidersFeature, advance, animateEnter, animateEnterListener, animateLeave, animateLeaveListener, ariaProperty, attachSourceLocations, attribute, classMap, classProp, componentInstance, conditional, conditionalBranchCreate, conditionalCreate, contentQuery, contentQuerySignal, declareLet, defer, deferEnableTimerScheduling, deferHydrateNever, deferHydrateOnHover, deferHydrateOnIdle, deferHydrateOnImmediate, deferHydrateOnInteraction, deferHydrateOnTimer, deferHydrateOnViewport, deferHydrateWhen, deferOnHover, deferOnIdle, deferOnImmediate, deferOnInteraction, deferOnTimer, deferOnViewport, deferPrefetchOnHover, deferPrefetchOnIdle, deferPrefetchOnImmediate, deferPrefetchOnInteraction, deferPrefetchOnTimer, deferPrefetchOnViewport, deferPrefetchWhen, deferWhen, defineComponent, defineDirective, definePipe, directiveInject, domElement, domElementContainer, domElementContainerEnd, domElementContainerStart, domElementEnd, domElementStart, domListener, domProperty, domTemplate, element, elementContainer, elementContainerEnd, elementContainerStart, elementEnd, elementStart, getComponentDepsFactory, getCurrentView, getInheritedFactory, getReplaceMetadataURL, i18n, i18nApply, i18nAttributes, i18nEnd, i18nExp, i18nPostprocess, i18nStart, interpolate, interpolate1, interpolate2, interpolate3, interpolate4, interpolate5, interpolate6, interpolate7, interpolate8, interpolateV, invalidFactory, listener, loadQuery, nextContext, pipe, pipeBind1, pipeBind2, pipeBind3, pipeBind4, pipeBindV, projection, projectionDef, property, pureFunction0, pureFunction1, pureFunction2, pureFunction3, pureFunction4, pureFunction5, pureFunction6, pureFunction7, pureFunction8, pureFunctionV, queryAdvance, queryRefresh, readContextLet, reference, registerNgModuleType as registerNgModuleType, repeater, repeaterCreate, repeaterTrackByIdentity, repeaterTrackByIndex, replaceMetadata, resolveBody, resolveDocument, resolveWindow, sanitizeHtml, sanitizeResourceUrl, sanitizeScript, sanitizeStyle, sanitizeUrl, sanitizeUrlOrResourceUrl, setComponentScope, setNgModuleScope, storeLet, styleMap, styleProp, syntheticHostListener, syntheticHostProperty, template, templateRefExtractor, text, textInterpolate, textInterpolate1, textInterpolate2, textInterpolate3, textInterpolate4, textInterpolate5, textInterpolate6, textInterpolate7, textInterpolate8, textInterpolateV, trustConstantHtml, trustConstantResourceUrl, twoWayBindingSet, twoWayListener, twoWayProperty, validateIframeAttribute, viewQuery, viewQuerySignal } from './debug_node.mjs';\nimport { OutputEmitterRef } from './resource.mjs';\nexport { computed, effect, linkedSignal, resource, untracked, ResourceImpl as ResourceImpl, encapsulateResourceError as encapsulateResourceError, getOutputDestroyRef as getOutputDestroyRef } from './resource.mjs';\nexport { setAlternateWeakRefImpl as setAlternateWeakRefImpl } from './weak_ref.mjs';\nexport { setCurrentInjector as setCurrentInjector } from './not_found.mjs';\nimport { clearAppScopedEarlyEventContract, EventContract, EventContractContainer, EventDispatcher, registerDispatcher, EventPhase, getAppScopedQueuedEventInfos, isEarlyEventType, isCaptureEventType } from './primitives/event-dispatch.mjs';\nimport 'rxjs';\nimport '@angular/core/primitives/signals';\nimport '@angular/core/primitives/di';\nimport 'rxjs/operators';\nimport './attribute.mjs';\nimport './effect.mjs';\n\nconst REQUIRED_UNSET_VALUE = /* @__PURE__ */ Symbol('InputSignalNode#UNSET');\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nconst INPUT_SIGNAL_NODE = /* @__PURE__ */ (() => {\n    return {\n        ...SIGNAL_NODE,\n        transformFn: undefined,\n        applyValueToInputSignal(node, value) {\n            signalSetFn(node, value);\n        },\n    };\n})();\n\nconst INPUT_SIGNAL_BRAND_WRITE_TYPE = /* @__PURE__ */ Symbol();\n/**\n * Creates an input signal.\n *\n * @param initialValue The initial value.\n *   Can be set to {@link REQUIRED_UNSET_VALUE} for required inputs.\n * @param options Additional options for the input. e.g. a transform, or an alias.\n */\nfunction createInputSignal(initialValue, options) {\n    const node = Object.create(INPUT_SIGNAL_NODE);\n    node.value = initialValue;\n    // Perf note: Always set `transformFn` here to ensure that `node` always\n    // has the same v8 class shape, allowing monomorphic reads on input signals.\n    node.transformFn = options?.transform;\n    function inputValueFn() {\n        // Record that someone looked at this signal.\n        producerAccessed(node);\n        if (node.value === REQUIRED_UNSET_VALUE) {\n            let message = null;\n            if (ngDevMode) {\n                const name = options?.debugName ?? options?.alias;\n                message = `Input${name ? ` \"${name}\"` : ''} is required but no value is available yet.`;\n            }\n            throw new RuntimeError(-950 /* RuntimeErrorCode.REQUIRED_INPUT_NO_VALUE */, message);\n        }\n        return node.value;\n    }\n    inputValueFn[SIGNAL] = node;\n    if (ngDevMode) {\n        inputValueFn.toString = () => `[Input Signal: ${inputValueFn()}]`;\n        node.debugName = options?.debugName;\n    }\n    return inputValueFn;\n}\n\nvar FactoryTarget;\n(function (FactoryTarget) {\n    FactoryTarget[FactoryTarget[\"Directive\"] = 0] = \"Directive\";\n    FactoryTarget[FactoryTarget[\"Component\"] = 1] = \"Component\";\n    FactoryTarget[FactoryTarget[\"Injectable\"] = 2] = \"Injectable\";\n    FactoryTarget[FactoryTarget[\"Pipe\"] = 3] = \"Pipe\";\n    FactoryTarget[FactoryTarget[\"NgModule\"] = 4] = \"NgModule\";\n})(FactoryTarget || (FactoryTarget = {}));\nvar R3TemplateDependencyKind;\n(function (R3TemplateDependencyKind) {\n    R3TemplateDependencyKind[R3TemplateDependencyKind[\"Directive\"] = 0] = \"Directive\";\n    R3TemplateDependencyKind[R3TemplateDependencyKind[\"Pipe\"] = 1] = \"Pipe\";\n    R3TemplateDependencyKind[R3TemplateDependencyKind[\"NgModule\"] = 2] = \"NgModule\";\n})(R3TemplateDependencyKind || (R3TemplateDependencyKind = {}));\nvar ViewEncapsulation;\n(function (ViewEncapsulation) {\n    ViewEncapsulation[ViewEncapsulation[\"Emulated\"] = 0] = \"Emulated\";\n    // Historically the 1 value was for `Native` encapsulation which has been removed as of v11.\n    ViewEncapsulation[ViewEncapsulation[\"None\"] = 2] = \"None\";\n    ViewEncapsulation[ViewEncapsulation[\"ShadowDom\"] = 3] = \"ShadowDom\";\n})(ViewEncapsulation || (ViewEncapsulation = {}));\n\n/*!\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n/**\n * Creates a token that can be used to inject static attributes of the host node.\n *\n * @usageNotes\n * ### Injecting an attribute that is known to exist\n * ```ts\n * @Directive()\n * class MyDir {\n *   attr: string = inject(new HostAttributeToken('some-attr'));\n * }\n * ```\n *\n * ### Optionally injecting an attribute\n * ```ts\n * @Directive()\n * class MyDir {\n *   attr: string | null = inject(new HostAttributeToken('some-attr'), {optional: true});\n * }\n * ```\n * @publicApi\n */\nclass HostAttributeToken {\n    attributeName;\n    constructor(attributeName) {\n        this.attributeName = attributeName;\n    }\n    /** @internal */\n    __NG_ELEMENT_ID__ = () => __injectAttribute(this.attributeName);\n    toString() {\n        return `HostAttributeToken ${this.attributeName}`;\n    }\n}\n\n/**\n * A token that can be used to inject the tag name of the host node.\n *\n * @usageNotes\n * ### Injecting a tag name that is known to exist\n * ```ts\n * @Directive()\n * class MyDir {\n *   tagName: string = inject(HOST_TAG_NAME);\n * }\n * ```\n *\n * ### Optionally injecting a tag name\n * ```ts\n * @Directive()\n * class MyDir {\n *   tagName: string | null = inject(HOST_TAG_NAME, {optional: true});\n * }\n * ```\n * @publicApi\n */\nconst HOST_TAG_NAME = new InjectionToken(ngDevMode ? 'HOST_TAG_NAME' : '');\n// HOST_TAG_NAME should be resolved at the current node, similar to e.g. ElementRef,\n// so we manually specify __NG_ELEMENT_ID__ here, instead of using a factory.\n// tslint:disable-next-line:no-toplevel-property-access\nHOST_TAG_NAME.__NG_ELEMENT_ID__ = (flags) => {\n    const tNode = getCurrentTNode();\n    if (tNode === null) {\n        throw new RuntimeError(204 /* RuntimeErrorCode.INVALID_INJECTION_TOKEN */, ngDevMode &&\n            'HOST_TAG_NAME can only be injected in directives and components ' +\n                'during construction time (in a class constructor or as a class field initializer)');\n    }\n    if (tNode.type & 2 /* TNodeType.Element */) {\n        return tNode.value;\n    }\n    if (flags & 8 /* InternalInjectFlags.Optional */) {\n        return null;\n    }\n    throw new RuntimeError(204 /* RuntimeErrorCode.INVALID_INJECTION_TOKEN */, ngDevMode &&\n        `HOST_TAG_NAME was used on ${getDevModeNodeName(tNode)} which doesn't have an underlying element in the DOM. ` +\n            `This is invalid, and so the dependency should be marked as optional.`);\n};\nfunction getDevModeNodeName(tNode) {\n    if (tNode.type & 8 /* TNodeType.ElementContainer */) {\n        return 'an <ng-container>';\n    }\n    else if (tNode.type & 4 /* TNodeType.Container */) {\n        return 'an <ng-template>';\n    }\n    else if (tNode.type & 128 /* TNodeType.LetDeclaration */) {\n        return 'an @let declaration';\n    }\n    else {\n        return 'a node';\n    }\n}\n\n/**\n * The `output` function allows declaration of Angular outputs in\n * directives and components.\n *\n * You can use outputs to emit values to parent directives and component.\n * Parents can subscribe to changes via:\n *\n * - template event bindings. For example, `(myOutput)=\"doSomething($event)\"`\n * - programmatic subscription by using `OutputRef#subscribe`.\n *\n * @usageNotes\n *\n * To use `output()`, import the function from `@angular/core`.\n *\n * ```ts\n * import {output} from '@angular/core';\n * ```\n *\n * Inside your component, introduce a new class member and initialize\n * it with a call to `output`.\n *\n * ```ts\n * @Directive({\n *   ...\n * })\n * export class MyDir {\n *   nameChange = output<string>();    // OutputEmitterRef<string>\n *   onClick    = output();            // OutputEmitterRef<void>\n * }\n * ```\n *\n * You can emit values to consumers of your directive, by using\n * the `emit` method from `OutputEmitterRef`.\n *\n * ```ts\n * updateName(newName: string): void {\n *   this.nameChange.emit(newName);\n * }\n * ```\n * @initializerApiFunction {\"showTypesInSignaturePreview\": true}\n * @publicApi 19.0\n */\nfunction output(opts) {\n    ngDevMode && assertInInjectionContext(output);\n    return new OutputEmitterRef();\n}\n\nfunction inputFunction(initialValue, opts) {\n    ngDevMode && assertInInjectionContext(input);\n    return createInputSignal(initialValue, opts);\n}\nfunction inputRequiredFunction(opts) {\n    ngDevMode && assertInInjectionContext(input);\n    return createInputSignal(REQUIRED_UNSET_VALUE, opts);\n}\n/**\n * The `input` function allows declaration of Angular inputs in directives\n * and components.\n *\n * There are two variants of inputs that can be declared:\n *\n *   1. **Optional inputs** with an initial value.\n *   2. **Required inputs** that consumers need to set.\n *\n * By default, the `input` function will declare optional inputs that\n * always have an initial value. Required inputs can be declared\n * using the `input.required()` function.\n *\n * Inputs are signals. The values of an input are exposed as a `Signal`.\n * The signal always holds the latest value of the input that is bound\n * from the parent.\n *\n * @usageNotes\n * To use signal-based inputs, import `input` from `@angular/core`.\n *\n * ```ts\n * import {input} from '@angular/core';\n * ```\n *\n * Inside your component, introduce a new class member and initialize\n * it with a call to `input` or `input.required`.\n *\n * ```ts\n * @Component({\n *   ...\n * })\n * export class UserProfileComponent {\n *   firstName = input<string>();             // Signal<string|undefined>\n *   lastName  = input.required<string>();    // Signal<string>\n *   age       = input(0)                     // Signal<number>\n * }\n * ```\n *\n * Inside your component template, you can display values of the inputs\n * by calling the signal.\n *\n * ```html\n * <span>{{firstName()}}</span>\n * ```\n *\n * @publicAPI\n * @initializerApiFunction\n */\nconst input = (() => {\n    // Note: This may be considered a side-effect, but nothing will depend on\n    // this assignment, unless this `input` constant export is accessed. It's a\n    // self-contained side effect that is local to the user facing`input` export.\n    inputFunction.required = inputRequiredFunction;\n    return inputFunction;\n})();\n\nfunction viewChildFn(locator, opts) {\n    ngDevMode && assertInInjectionContext(viewChild);\n    return createSingleResultOptionalQuerySignalFn(opts);\n}\nfunction viewChildRequiredFn(locator, opts) {\n    ngDevMode && assertInInjectionContext(viewChild);\n    return createSingleResultRequiredQuerySignalFn(opts);\n}\n/**\n * Initializes a view child query.\n *\n * Consider using `viewChild.required` for queries that should always match.\n *\n * @usageNotes\n * Create a child query in your component by declaring a\n * class field and initializing it with the `viewChild()` function.\n *\n * ```angular-ts\n * @Component({template: '<div #el></div><my-component #cmp />'})\n * export class TestComponent {\n *   divEl = viewChild<ElementRef>('el');                   // Signal<ElementRef|undefined>\n *   divElRequired = viewChild.required<ElementRef>('el');  // Signal<ElementRef>\n *   cmp = viewChild(MyComponent);                          // Signal<MyComponent|undefined>\n *   cmpRequired = viewChild.required(MyComponent);         // Signal<MyComponent>\n * }\n * ```\n *\n * @publicApi 19.0\n * @initializerApiFunction\n */\nconst viewChild = (() => {\n    // Note: This may be considered a side-effect, but nothing will depend on\n    // this assignment, unless this `viewChild` constant export is accessed. It's a\n    // self-contained side effect that is local to the user facing `viewChild` export.\n    viewChildFn.required = viewChildRequiredFn;\n    return viewChildFn;\n})();\n/**\n * Initializes a view children query.\n *\n * Query results are represented as a signal of a read-only collection containing all matched\n * elements.\n *\n * @usageNotes\n * Create a children query in your component by declaring a\n * class field and initializing it with the `viewChildren()` function.\n *\n * ```ts\n * @Component({...})\n * export class TestComponent {\n *   divEls = viewChildren<ElementRef>('el');   // Signal<ReadonlyArray<ElementRef>>\n * }\n * ```\n *\n * @initializerApiFunction\n * @publicApi 19.0\n */\nfunction viewChildren(locator, opts) {\n    ngDevMode && assertInInjectionContext(viewChildren);\n    return createMultiResultQuerySignalFn(opts);\n}\nfunction contentChildFn(locator, opts) {\n    ngDevMode && assertInInjectionContext(contentChild);\n    return createSingleResultOptionalQuerySignalFn(opts);\n}\nfunction contentChildRequiredFn(locator, opts) {\n    ngDevMode && assertInInjectionContext(contentChildren);\n    return createSingleResultRequiredQuerySignalFn(opts);\n}\n/**\n * Initializes a content child query. Consider using `contentChild.required` for queries that should\n * always match.\n *\n * @usageNotes\n * Create a child query in your component by declaring a\n * class field and initializing it with the `contentChild()` function.\n *\n * ```ts\n * @Component({...})\n * export class TestComponent {\n *   headerEl = contentChild<ElementRef>('h');                    // Signal<ElementRef|undefined>\n *   headerElElRequired = contentChild.required<ElementRef>('h'); // Signal<ElementRef>\n *   header = contentChild(MyHeader);                             // Signal<MyHeader|undefined>\n *   headerRequired = contentChild.required(MyHeader);            // Signal<MyHeader>\n * }\n * ```\n *\n * Note: By default `descendants` is `true` which means the query will traverse all descendants in the same template.\n *\n * @initializerApiFunction\n * @publicApi 19.0\n */\nconst contentChild = (() => {\n    // Note: This may be considered a side-effect, but nothing will depend on\n    // this assignment, unless this `viewChild` constant export is accessed. It's a\n    // self-contained side effect that is local to the user facing `viewChild` export.\n    contentChildFn.required = contentChildRequiredFn;\n    return contentChildFn;\n})();\n/**\n * Initializes a content children query.\n *\n * Query results are represented as a signal of a read-only collection containing all matched\n * elements.\n *\n * @usageNotes\n * Create a children query in your component by declaring a\n * class field and initializing it with the `contentChildren()` function.\n *\n * ```ts\n * @Component({...})\n * export class TestComponent {\n *   headerEl = contentChildren<ElementRef>('h');   // Signal<ReadonlyArray<ElementRef>>\n * }\n * ```\n *\n * Note: By default `descendants` is `false` which means the query will not traverse all descendants in the same template.\n *\n * @initializerApiFunction\n * @publicApi 19.0\n */\nfunction contentChildren(locator, opts) {\n    return createMultiResultQuerySignalFn(opts);\n}\n\n/**\n * Creates a model signal.\n *\n * @param initialValue The initial value.\n *   Can be set to {@link REQUIRED_UNSET_VALUE} for required model signals.\n * @param options Additional options for the model.\n */\nfunction createModelSignal(initialValue, opts) {\n    const node = Object.create(INPUT_SIGNAL_NODE);\n    const emitterRef = new OutputEmitterRef();\n    node.value = initialValue;\n    function getter() {\n        producerAccessed(node);\n        assertModelSet(node.value);\n        return node.value;\n    }\n    getter[SIGNAL] = node;\n    getter.asReadonly = signalAsReadonlyFn.bind(getter);\n    // TODO: Should we throw an error when updating a destroyed model?\n    getter.set = (newValue) => {\n        if (!node.equal(node.value, newValue)) {\n            signalSetFn(node, newValue);\n            emitterRef.emit(newValue);\n        }\n    };\n    getter.update = (updateFn) => {\n        assertModelSet(node.value);\n        getter.set(updateFn(node.value));\n    };\n    getter.subscribe = emitterRef.subscribe.bind(emitterRef);\n    getter.destroyRef = emitterRef.destroyRef;\n    if (ngDevMode) {\n        getter.toString = () => `[Model Signal: ${getter()}]`;\n        node.debugName = opts?.debugName;\n    }\n    return getter;\n}\n/** Asserts that a model's value is set. */\nfunction assertModelSet(value) {\n    if (value === REQUIRED_UNSET_VALUE) {\n        throw new RuntimeError(952 /* RuntimeErrorCode.REQUIRED_MODEL_NO_VALUE */, ngDevMode && 'Model is required but no value is available yet.');\n    }\n}\n\nfunction modelFunction(initialValue, opts) {\n    ngDevMode && assertInInjectionContext(model);\n    return createModelSignal(initialValue, opts);\n}\nfunction modelRequiredFunction(opts) {\n    ngDevMode && assertInInjectionContext(model);\n    return createModelSignal(REQUIRED_UNSET_VALUE, opts);\n}\n/**\n * `model` declares a writeable signal that is exposed as an input/output\n * pair on the containing directive.\n *\n * The input name is taken either from the class member or from the `alias` option.\n * The output name is generated by taking the input name and appending `Change`.\n *\n * @usageNotes\n *\n * To use `model()`, import the function from `@angular/core`.\n *\n * ```ts\n * import {model} from '@angular/core';\n * ```\n *\n * Inside your component, introduce a new class member and initialize\n * it with a call to `model` or `model.required`.\n *\n * ```ts\n * @Directive({\n *   ...\n * })\n * export class MyDir {\n *   firstName = model<string>();            // ModelSignal<string|undefined>\n *   lastName  = model.required<string>();   // ModelSignal<string>\n *   age       = model(0);                   // ModelSignal<number>\n * }\n * ```\n *\n * Inside your component template, you can display the value of a `model`\n * by calling the signal.\n *\n * ```html\n * <span>{{firstName()}}</span>\n * ```\n *\n * Updating the `model` is equivalent to updating a writable signal.\n *\n * ```ts\n * updateName(newFirstName: string): void {\n *   this.firstName.set(newFirstName);\n * }\n * ```\n *\n * @publicApi 19.0\n * @initializerApiFunction\n */\nconst model = (() => {\n    // Note: This may be considered a side-effect, but nothing will depend on\n    // this assignment, unless this `model` constant export is accessed. It's a\n    // self-contained side effect that is local to the user facing `model` export.\n    modelFunction.required = modelRequiredFunction;\n    return modelFunction;\n})();\n\n// Stores the default value of `emitDistinctChangesOnly` when the `emitDistinctChangesOnly` is not\n// explicitly set.\nconst emitDistinctChangesOnlyDefaultValue = true;\n/**\n * Base class for query metadata.\n *\n * @see {@link ContentChildren}\n * @see {@link ContentChild}\n * @see {@link ViewChildren}\n * @see {@link ViewChild}\n *\n * @publicApi\n */\nclass Query {\n}\n/**\n * ContentChildren decorator and metadata.\n *\n *\n * @Annotation\n * @publicApi\n */\nconst ContentChildren = makePropDecorator('ContentChildren', (selector, opts = {}) => ({\n    selector,\n    first: false,\n    isViewQuery: false,\n    descendants: false,\n    emitDistinctChangesOnly: emitDistinctChangesOnlyDefaultValue,\n    ...opts,\n}), Query);\n/**\n * ContentChild decorator and metadata.\n *\n *\n * @Annotation\n *\n * @publicApi\n */\nconst ContentChild = makePropDecorator('ContentChild', (selector, opts = {}) => ({\n    selector,\n    first: true,\n    isViewQuery: false,\n    descendants: true,\n    ...opts,\n}), Query);\n/**\n * ViewChildren decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nconst ViewChildren = makePropDecorator('ViewChildren', (selector, opts = {}) => ({\n    selector,\n    first: false,\n    isViewQuery: true,\n    descendants: true,\n    emitDistinctChangesOnly: emitDistinctChangesOnlyDefaultValue,\n    ...opts,\n}), Query);\n/**\n * ViewChild decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nconst ViewChild = makePropDecorator('ViewChild', (selector, opts) => ({\n    selector,\n    first: true,\n    isViewQuery: true,\n    descendants: true,\n    ...opts,\n}), Query);\n\nfunction compileNgModuleFactory(injector, options, moduleType) {\n    ngDevMode && assertNgModuleType(moduleType);\n    const moduleFactory = new NgModuleFactory(moduleType);\n    // All of the logic below is irrelevant for AOT-compiled code.\n    if (typeof ngJitMode !== 'undefined' && !ngJitMode) {\n        return Promise.resolve(moduleFactory);\n    }\n    const compilerOptions = injector.get(COMPILER_OPTIONS, []).concat(options);\n    // Configure the compiler to use the provided options. This call may fail when multiple modules\n    // are bootstrapped with incompatible options, as a component can only be compiled according to\n    // a single set of options.\n    setJitOptions({\n        defaultEncapsulation: _lastDefined(compilerOptions.map((opts) => opts.defaultEncapsulation)),\n        preserveWhitespaces: _lastDefined(compilerOptions.map((opts) => opts.preserveWhitespaces)),\n    });\n    if (isComponentResourceResolutionQueueEmpty()) {\n        return Promise.resolve(moduleFactory);\n    }\n    const compilerProviders = compilerOptions.flatMap((option) => option.providers ?? []);\n    // In case there are no compiler providers, we just return the module factory as\n    // there won't be any resource loader. This can happen with Ivy, because AOT compiled\n    // modules can be still passed through \"bootstrapModule\". In that case we shouldn't\n    // unnecessarily require the JIT compiler.\n    if (compilerProviders.length === 0) {\n        return Promise.resolve(moduleFactory);\n    }\n    const compiler = getCompilerFacade({\n        usage: 0 /* JitCompilerUsage.Decorator */,\n        kind: 'NgModule',\n        type: moduleType,\n    });\n    const compilerInjector = Injector.create({ providers: compilerProviders });\n    const resourceLoader = compilerInjector.get(compiler.ResourceLoader);\n    // The resource loader can also return a string while the \"resolveComponentResources\"\n    // always expects a promise. Therefore we need to wrap the returned value in a promise.\n    return resolveComponentResources((url) => Promise.resolve(resourceLoader.get(url))).then(() => moduleFactory);\n}\nfunction _lastDefined(args) {\n    for (let i = args.length - 1; i >= 0; i--) {\n        if (args[i] !== undefined) {\n            return args[i];\n        }\n    }\n    return undefined;\n}\n\n// A delay in milliseconds before the scan is run after onLoad, to avoid any\n// potential race conditions with other LCP-related functions. This delay\n// happens outside of the main JavaScript execution and will only effect the timing\n// on when the warning becomes visible in the console.\nconst SCAN_DELAY = 200;\nconst OVERSIZED_IMAGE_TOLERANCE = 1200;\nclass ImagePerformanceWarning {\n    // Map of full image URLs -> original `ngSrc` values.\n    window = null;\n    observer = null;\n    options = inject(IMAGE_CONFIG);\n    lcpImageUrl;\n    start() {\n        if ((typeof ngServerMode !== 'undefined' && ngServerMode) ||\n            typeof PerformanceObserver === 'undefined' ||\n            (this.options?.disableImageSizeWarning && this.options?.disableImageLazyLoadWarning)) {\n            return;\n        }\n        this.observer = this.initPerformanceObserver();\n        const doc = getDocument();\n        const win = doc.defaultView;\n        if (win) {\n            this.window = win;\n            // Wait to avoid race conditions where LCP image triggers\n            // load event before it's recorded by the performance observer\n            const waitToScan = () => {\n                setTimeout(this.scanImages.bind(this), SCAN_DELAY);\n            };\n            const setup = () => {\n                // Consider the case when the application is created and destroyed multiple times.\n                // Typically, applications are created instantly once the page is loaded, and the\n                // `window.load` listener is always triggered. However, the `window.load` event will never\n                // be fired if the page is loaded, and the application is created later. Checking for\n                // `readyState` is the easiest way to determine whether the page has been loaded or not.\n                if (doc.readyState === 'complete') {\n                    waitToScan();\n                }\n                else {\n                    this.window?.addEventListener('load', waitToScan, { once: true });\n                }\n            };\n            // Angular doesn't have to run change detection whenever any asynchronous tasks are invoked in\n            // the scope of this functionality.\n            if (typeof Zone !== 'undefined') {\n                Zone.root.run(() => setup());\n            }\n            else {\n                setup();\n            }\n        }\n    }\n    ngOnDestroy() {\n        this.observer?.disconnect();\n    }\n    initPerformanceObserver() {\n        if (typeof PerformanceObserver === 'undefined') {\n            return null;\n        }\n        const observer = new PerformanceObserver((entryList) => {\n            const entries = entryList.getEntries();\n            if (entries.length === 0)\n                return;\n            // We use the latest entry produced by the `PerformanceObserver` as the best\n            // signal on which element is actually an LCP one. As an example, the first image to load on\n            // a page, by virtue of being the only thing on the page so far, is often a LCP candidate\n            // and gets reported by PerformanceObserver, but isn't necessarily the LCP element.\n            const lcpElement = entries[entries.length - 1];\n            // Cast to `any` due to missing `element` on the `LargestContentfulPaint` type of entry.\n            // See https://developer.mozilla.org/en-US/docs/Web/API/LargestContentfulPaint\n            const imgSrc = lcpElement.element?.src ?? '';\n            // Exclude `data:` and `blob:` URLs, since they are fetched resources.\n            if (imgSrc.startsWith('data:') || imgSrc.startsWith('blob:'))\n                return;\n            this.lcpImageUrl = imgSrc;\n        });\n        observer.observe({ type: 'largest-contentful-paint', buffered: true });\n        return observer;\n    }\n    scanImages() {\n        const images = getDocument().querySelectorAll('img');\n        let lcpElementFound, lcpElementLoadedCorrectly = false;\n        // Important: do not refactor this to use `images.forEach` or\n        // `for (const ... of ...)`, because images might be a custom internal\n        // data structure  such as a lazily evaluated query result in Domino.\n        // (This naturally would never be a case in any browser).\n        for (let index = 0; index < images.length; index++) {\n            const image = images[index];\n            if (!image) {\n                continue;\n            }\n            if (!this.options?.disableImageSizeWarning) {\n                // Image elements using the NgOptimizedImage directive are excluded,\n                // as that directive has its own version of this check.\n                if (!image.getAttribute('ng-img') && this.isOversized(image)) {\n                    logOversizedImageWarning(image.src);\n                }\n            }\n            if (!this.options?.disableImageLazyLoadWarning && this.lcpImageUrl) {\n                if (image.src === this.lcpImageUrl) {\n                    lcpElementFound = true;\n                    if (image.loading !== 'lazy' || image.getAttribute('ng-img')) {\n                        // This variable is set to true and never goes back to false to account\n                        // for the case where multiple images have the same src url, and some\n                        // have lazy loading while others don't.\n                        // Also ignore NgOptimizedImage because there's a different warning for that.\n                        lcpElementLoadedCorrectly = true;\n                    }\n                }\n            }\n        }\n        if (lcpElementFound &&\n            !lcpElementLoadedCorrectly &&\n            this.lcpImageUrl &&\n            !this.options?.disableImageLazyLoadWarning) {\n            logLazyLCPWarning(this.lcpImageUrl);\n        }\n    }\n    isOversized(image) {\n        if (!this.window) {\n            return false;\n        }\n        // The `isOversized` check may not be applicable or may require adjustments\n        // for several types of image formats or scenarios. Currently, we specify only\n        // `svg`, but this may also include `gif` since their quality isnt tied to\n        // dimensions in the same way as raster images.\n        const nonOversizedImageExtentions = [\n            // SVG images are vector-based, which means they can scale\n            // to any size without losing quality.\n            '.svg',\n        ];\n        // Convert it to lowercase because this may have uppercase\n        // extensions, such as `IMAGE.SVG`.\n        // We fallback to an empty string because `src` may be `undefined`\n        // if it is explicitly set to `null` by some third-party code\n        // (e.g., `image.src = null`).\n        const imageSource = (image.src || '').toLowerCase();\n        if (nonOversizedImageExtentions.some((extension) => imageSource.endsWith(extension))) {\n            return false;\n        }\n        const computedStyle = this.window.getComputedStyle(image);\n        let renderedWidth = parseFloat(computedStyle.getPropertyValue('width'));\n        let renderedHeight = parseFloat(computedStyle.getPropertyValue('height'));\n        const boxSizing = computedStyle.getPropertyValue('box-sizing');\n        const objectFit = computedStyle.getPropertyValue('object-fit');\n        if (objectFit === `cover`) {\n            // Object fit cover may indicate a use case such as a sprite sheet where\n            // this warning does not apply.\n            return false;\n        }\n        if (boxSizing === 'border-box') {\n            // If the image `box-sizing` is set to `border-box`, we adjust the rendered\n            // dimensions by subtracting padding values.\n            const paddingTop = computedStyle.getPropertyValue('padding-top');\n            const paddingRight = computedStyle.getPropertyValue('padding-right');\n            const paddingBottom = computedStyle.getPropertyValue('padding-bottom');\n            const paddingLeft = computedStyle.getPropertyValue('padding-left');\n            renderedWidth -= parseFloat(paddingRight) + parseFloat(paddingLeft);\n            renderedHeight -= parseFloat(paddingTop) + parseFloat(paddingBottom);\n        }\n        const intrinsicWidth = image.naturalWidth;\n        const intrinsicHeight = image.naturalHeight;\n        const recommendedWidth = this.window.devicePixelRatio * renderedWidth;\n        const recommendedHeight = this.window.devicePixelRatio * renderedHeight;\n        const oversizedWidth = intrinsicWidth - recommendedWidth >= OVERSIZED_IMAGE_TOLERANCE;\n        const oversizedHeight = intrinsicHeight - recommendedHeight >= OVERSIZED_IMAGE_TOLERANCE;\n        return oversizedWidth || oversizedHeight;\n    }\n    static fac = function ImagePerformanceWarning_Factory(__ngFactoryType__) { return new (__ngFactoryType__ || ImagePerformanceWarning)(); };\n    static prov = /*@__PURE__*/ __defineInjectable({ token: ImagePerformanceWarning, factory: ImagePerformanceWarning.fac, providedIn: 'root' });\n}\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(ImagePerformanceWarning, [{\n        type: Injectable,\n        args: [{ providedIn: 'root' }]\n    }], null, null); })();\nfunction logLazyLCPWarning(src) {\n    console.warn(formatRuntimeError(-913 /* RuntimeErrorCode.IMAGE_PERFORMANCE_WARNING */, `An image with src ${src} is the Largest Contentful Paint (LCP) element ` +\n        `but was given a \"loading\" value of \"lazy\", which can negatively impact ` +\n        `application loading performance. This warning can be addressed by ` +\n        `changing the loading value of the LCP image to \"eager\", or by using the ` +\n        `NgOptimizedImage directive's prioritization utilities. For more ` +\n        `information about addressing or disabling this warning, see ` +\n        `https://angular.dev/errors/NG0913`));\n}\nfunction logOversizedImageWarning(src) {\n    console.warn(formatRuntimeError(-913 /* RuntimeErrorCode.IMAGE_PERFORMANCE_WARNING */, `An image with src ${src} has intrinsic file dimensions much larger than its ` +\n        `rendered size. This can negatively impact application loading performance. ` +\n        `For more information about addressing or disabling this warning, see ` +\n        `https://angular.dev/errors/NG0913`));\n}\n\n/**\n * Internal token that allows to register extra callbacks that should be invoked during the\n * `PlatformRef.destroy` operation. This token is needed to avoid a direct reference to the\n * `PlatformRef` class (i.e. register the callback via `PlatformRef.onDestroy`), thus making the\n * entire class tree-shakeable.\n */\nconst PLATFORM_DESTROY_LISTENERS = new InjectionToken(ngDevMode ? 'PlatformDestroyListeners' : '');\n\n/**\n * InjectionToken to control root component bootstrap behavior.\n *\n * This token is primarily used in Angular's server-side rendering (SSR) scenarios,\n * particularly by the `@angular/ssr` package, to manage whether the root component\n * should be bootstrapped during the application initialization process.\n *\n * ## Purpose:\n * During SSR route extraction, setting this token to `false` prevents Angular from\n * bootstrapping the root component. This avoids unnecessary component rendering,\n * enabling route extraction without requiring additional APIs or triggering\n * component logic.\n *\n * ## Behavior:\n * - **`false`**: Prevents the root component from being bootstrapped.\n * - **`true`** (default): Proceeds with the normal root component bootstrap process.\n *\n * This mechanism ensures SSR can efficiently separate route extraction logic\n * from component rendering.\n */\nconst ENABLE_ROOT_COMPONENT_BOOTSTRAP = new InjectionToken(ngDevMode ? 'ENABLE_ROOT_COMPONENT_BOOTSTRAP' : '');\nfunction isApplicationBootstrapConfig(config) {\n    return !config.moduleRef;\n}\nfunction bootstrap(config) {\n    const envInjector = isApplicationBootstrapConfig(config)\n        ? config.r3Injector\n        : config.moduleRef.injector;\n    const ngZone = envInjector.get(NgZone);\n    return ngZone.run(() => {\n        if (isApplicationBootstrapConfig(config)) {\n            config.r3Injector.resolveInjectorInitializers();\n        }\n        else {\n            config.moduleRef.resolveInjectorInitializers();\n        }\n        const exceptionHandler = envInjector.get(INTERNAL_APPLICATION_ERROR_HANDLER);\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            if (envInjector.get(PROVIDED_ZONELESS) && envInjector.get(PROVIDED_NG_ZONE)) {\n                throw new RuntimeError(408 /* RuntimeErrorCode.PROVIDED_BOTH_ZONE_AND_ZONELESS */, 'Invalid change detection configuration: ' +\n                    'provideZoneChangeDetection and provideZonelessChangeDetection cannot be used together.');\n            }\n        }\n        let onErrorSubscription;\n        ngZone.runOutsideAngular(() => {\n            onErrorSubscription = ngZone.onError.subscribe({\n                next: exceptionHandler,\n            });\n        });\n        // If the whole platform is destroyed, invoke the `destroy` method\n        // for all bootstrapped applications as well.\n        if (isApplicationBootstrapConfig(config)) {\n            const destroyListener = () => envInjector.destroy();\n            const onPlatformDestroyListeners = config.platformInjector.get(PLATFORM_DESTROY_LISTENERS);\n            onPlatformDestroyListeners.add(destroyListener);\n            envInjector.onDestroy(() => {\n                onErrorSubscription.unsubscribe();\n                onPlatformDestroyListeners.delete(destroyListener);\n            });\n        }\n        else {\n            const destroyListener = () => config.moduleRef.destroy();\n            const onPlatformDestroyListeners = config.platformInjector.get(PLATFORM_DESTROY_LISTENERS);\n            onPlatformDestroyListeners.add(destroyListener);\n            config.moduleRef.onDestroy(() => {\n                remove(config.allPlatformModules, config.moduleRef);\n                onErrorSubscription.unsubscribe();\n                onPlatformDestroyListeners.delete(destroyListener);\n            });\n        }\n        return _callAndReportToErrorHandler(exceptionHandler, ngZone, () => {\n            const pendingTasks = envInjector.get(PendingTasksInternal);\n            const taskId = pendingTasks.add();\n            const initStatus = envInjector.get(ApplicationInitStatus);\n            initStatus.runInitializers();\n            return initStatus.donePromise\n                .then(() => {\n                // If the `LOCALE_ID` provider is defined at bootstrap then we set the value for ivy\n                const localeId = envInjector.get(LOCALE_ID, DEFAULT_LOCALE_ID);\n                setLocaleId(localeId || DEFAULT_LOCALE_ID);\n                const enableRootComponentbootstrap = envInjector.get(ENABLE_ROOT_COMPONENT_BOOTSTRAP, true);\n                if (!enableRootComponentbootstrap) {\n                    if (isApplicationBootstrapConfig(config)) {\n                        return envInjector.get(ApplicationRef);\n                    }\n                    config.allPlatformModules.push(config.moduleRef);\n                    return config.moduleRef;\n                }\n                if (typeof ngDevMode === 'undefined' || ngDevMode) {\n                    const imagePerformanceService = envInjector.get(ImagePerformanceWarning);\n                    imagePerformanceService.start();\n                }\n                if (isApplicationBootstrapConfig(config)) {\n                    const appRef = envInjector.get(ApplicationRef);\n                    if (config.rootComponent !== undefined) {\n                        appRef.bootstrap(config.rootComponent);\n                    }\n                    return appRef;\n                }\n                else {\n                    moduleBootstrapImpl?.(config.moduleRef, config.allPlatformModules);\n                    return config.moduleRef;\n                }\n            })\n                .finally(() => void pendingTasks.remove(taskId));\n        });\n    });\n}\n/**\n * Having a separate symbol for the module bootstrap implementation allows us to\n * tree shake the module based bootstrap implementation in standalone apps.\n */\nlet moduleBootstrapImpl;\n/**\n * Set the implementation of the module based bootstrap.\n */\nfunction setModuleBootstrapImpl() {\n    moduleBootstrapImpl = _moduleDoBootstrap;\n}\nfunction _moduleDoBootstrap(moduleRef, allPlatformModules) {\n    const appRef = moduleRef.injector.get(ApplicationRef);\n    if (moduleRef._bootstrapComponents.length > 0) {\n        moduleRef._bootstrapComponents.forEach((f) => appRef.bootstrap(f));\n    }\n    else if (moduleRef.instance.ngDoBootstrap) {\n        moduleRef.instance.ngDoBootstrap(appRef);\n    }\n    else {\n        throw new RuntimeError(-403 /* RuntimeErrorCode.BOOTSTRAP_COMPONENTS_NOT_FOUND */, ngDevMode &&\n            `The module ${stringify(moduleRef.instance.constructor)} was bootstrapped, ` +\n                `but it does not declare \"@NgModule.bootstrap\" components nor a \"ngDoBootstrap\" method. ` +\n                `Please define one of these.`);\n    }\n    allPlatformModules.push(moduleRef);\n}\nfunction _callAndReportToErrorHandler(errorHandler, ngZone, callback) {\n    try {\n        const result = callback();\n        if (isPromise(result)) {\n            return result.catch((e) => {\n                ngZone.runOutsideAngular(() => errorHandler(e));\n                // rethrow as the exception handler might not do it\n                throw e;\n            });\n        }\n        return result;\n    }\n    catch (e) {\n        ngZone.runOutsideAngular(() => errorHandler(e));\n        // rethrow as the exception handler might not do it\n        throw e;\n    }\n}\n\n/**\n * The Angular platform is the entry point for Angular on a web page.\n * Each page has exactly one platform. Services (such as reflection) which are common\n * to every Angular application running on the page are bound in its scope.\n * A page's platform is initialized implicitly when a platform is created using a platform\n * factory such as `PlatformBrowser`, or explicitly by calling the `createPlatform()` function.\n *\n * @publicApi\n */\nclass PlatformRef {\n    _injector;\n    _modules = [];\n    _destroyListeners = [];\n    _destroyed = false;\n    /** @internal */\n    constructor(_injector) {\n        this._injector = _injector;\n    }\n    /**\n     * Creates an instance of an `@NgModule` for the given platform.\n     *\n     * @deprecated Passing NgModule factories as the `PlatformRef.bootstrapModuleFactory` function\n     *     argument is deprecated. Use the `PlatformRef.bootstrapModule` API instead.\n     */\n    bootstrapModuleFactory(moduleFactory, options) {\n        const scheduleInRootZone = options?.scheduleInRootZone;\n        const ngZoneFactory = () => getNgZone(options?.ngZone, {\n            ...getNgZoneOptions({\n                eventCoalescing: options?.ngZoneEventCoalescing,\n                runCoalescing: options?.ngZoneRunCoalescing,\n            }),\n            scheduleInRootZone,\n        });\n        const ignoreChangesOutsideZone = options?.ignoreChangesOutsideZone;\n        const allAppProviders = [\n            internalProvideZoneChangeDetection({\n                ngZoneFactory,\n                ignoreChangesOutsideZone,\n            }),\n            { provide: ChangeDetectionScheduler, useExisting: ChangeDetectionSchedulerImpl },\n            errorHandlerEnvironmentInitializer,\n        ];\n        const moduleRef = createNgModuleRefWithProviders(moduleFactory.moduleType, this.injector, allAppProviders);\n        setModuleBootstrapImpl();\n        return bootstrap({\n            moduleRef,\n            allPlatformModules: this._modules,\n            platformInjector: this.injector,\n        });\n    }\n    /**\n     * Creates an instance of an `@NgModule` for a given platform.\n     *\n     * @usageNotes\n     * ### Simple Example\n     *\n     * ```ts\n     * @NgModule({\n     *   imports: [BrowserModule]\n     * })\n     * class MyModule {}\n     *\n     * let moduleRef = platformBrowser().bootstrapModule(MyModule);\n     * ```\n     *\n     */\n    bootstrapModule(moduleType, compilerOptions = []) {\n        const options = optionsReducer({}, compilerOptions);\n        setModuleBootstrapImpl();\n        return compileNgModuleFactory(this.injector, options, moduleType).then((moduleFactory) => this.bootstrapModuleFactory(moduleFactory, options));\n    }\n    /**\n     * Registers a listener to be called when the platform is destroyed.\n     */\n    onDestroy(callback) {\n        this._destroyListeners.push(callback);\n    }\n    /**\n     * Retrieves the platform {@link Injector}, which is the parent injector for\n     * every Angular application on the page and provides singleton providers.\n     */\n    get injector() {\n        return this._injector;\n    }\n    /**\n     * Destroys the current Angular platform and all Angular applications on the page.\n     * Destroys all modules and listeners registered with the platform.\n     */\n    destroy() {\n        if (this._destroyed) {\n            throw new RuntimeError(404 /* RuntimeErrorCode.PLATFORM_ALREADY_DESTROYED */, ngDevMode && 'The platform has already been destroyed!');\n        }\n        this._modules.slice().forEach((module) => module.destroy());\n        this._destroyListeners.forEach((listener) => listener());\n        const destroyListeners = this._injector.get(PLATFORM_DESTROY_LISTENERS, null);\n        if (destroyListeners) {\n            destroyListeners.forEach((listener) => listener());\n            destroyListeners.clear();\n        }\n        this._destroyed = true;\n    }\n    /**\n     * Indicates whether this instance was destroyed.\n     */\n    get destroyed() {\n        return this._destroyed;\n    }\n    static fac = function PlatformRef_Factory(__ngFactoryType__) { return new (__ngFactoryType__ || PlatformRef)(__inject(Injector)); };\n    static prov = /*@__PURE__*/ __defineInjectable({ token: PlatformRef, factory: PlatformRef.fac, providedIn: 'platform' });\n}\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(PlatformRef, [{\n        type: Injectable,\n        args: [{ providedIn: 'platform' }]\n    }], () => [{ type: Injector }], null); })();\n\nlet _platformInjector = null;\n/**\n * Creates a platform.\n * Platforms must be created on launch using this function.\n *\n * @publicApi\n */\nfunction createPlatform(injector) {\n    if (getPlatform()) {\n        throw new RuntimeError(400 /* RuntimeErrorCode.MULTIPLE_PLATFORMS */, ngDevMode && 'There can be only one platform. Destroy the previous one to create a new one.');\n    }\n    publishDefaultGlobalUtils();\n    publishSignalConfiguration();\n    // During SSR, using this setting and using an injector from the global can cause the\n    // injector to be used for a different requjest due to concurrency.\n    _platformInjector = typeof ngServerMode === 'undefined' || !ngServerMode ? injector : null;\n    const platform = injector.get(PlatformRef);\n    runPlatformInitializers(injector);\n    return platform;\n}\n/**\n * Creates a factory for a platform. Can be used to provide or override `Providers` specific to\n * your application's runtime needs, such as `PLATFORM_INITIALIZER` and `PLATFORM_ID`.\n * @param parentPlatformFactory Another platform factory to modify. Allows you to compose factories\n * to build up configurations that might be required by different libraries or parts of the\n * application.\n * @param name Identifies the new platform factory.\n * @param providers A set of dependency providers for platforms created with the new factory.\n *\n * @publicApi\n */\nfunction createPlatformFactory(parentPlatformFactory, name, providers = []) {\n    const desc = `Platform: ${name}`;\n    const marker = new InjectionToken(desc);\n    return (extraProviders = []) => {\n        let platform = getPlatform();\n        if (!platform) {\n            const platformProviders = [\n                ...providers,\n                ...extraProviders,\n                { provide: marker, useValue: true },\n            ];\n            platform =\n                parentPlatformFactory?.(platformProviders) ??\n                    createPlatform(createPlatformInjector(platformProviders, desc));\n        }\n        return typeof ngServerMode !== 'undefined' && ngServerMode ? platform : assertPlatform(marker);\n    };\n}\n/**\n * Helper function to create an instance of a platform injector (that maintains the 'platform'\n * scope).\n */\nfunction createPlatformInjector(providers = [], name) {\n    return Injector.create({\n        name,\n        providers: [\n            { provide: INJECTOR_SCOPE, useValue: 'platform' },\n            { provide: PLATFORM_DESTROY_LISTENERS, useValue: new Set([() => (_platformInjector = null)]) },\n            ...providers,\n        ],\n    });\n}\n/**\n * Checks that there is currently a platform that contains the given token as a provider.\n *\n * @publicApi\n */\nfunction assertPlatform(requiredToken) {\n    const platform = getPlatform();\n    if (!platform) {\n        throw new RuntimeError(-401 /* RuntimeErrorCode.PLATFORM_NOT_FOUND */, ngDevMode && 'No platform exists!');\n    }\n    if ((typeof ngDevMode === 'undefined' || ngDevMode) &&\n        !platform.injector.get(requiredToken, null)) {\n        throw new RuntimeError(400 /* RuntimeErrorCode.MULTIPLE_PLATFORMS */, 'A platform with a different configuration has been created. Please destroy it first.');\n    }\n    return platform;\n}\n/**\n * Returns the current platform in the browser environment. In the server environment,\n * returns `null`. If you need access to the platform information, inject `PlatformRef` in your application.\n *\n * @publicApi\n */\nfunction getPlatform() {\n    if (typeof ngServerMode !== 'undefined' && ngServerMode) {\n        return null;\n    }\n    return _platformInjector?.get(PlatformRef) ?? null;\n}\n/**\n * Destroys the current Angular platform and all Angular applications on the page.\n * Destroys all modules and listeners registered with the platform.\n *\n * This function should not be used in a server environment, as it will be a no-op.\n *\n * @publicApi\n */\nfunction destroyPlatform() {\n    getPlatform()?.destroy();\n}\n/**\n * The goal of this function is to bootstrap a platform injector,\n * but avoid referencing `PlatformRef` class.\n * This function is needed for bootstrapping a Standalone Component.\n */\nfunction createOrReusePlatformInjector(providers = []) {\n    // If a platform injector already exists, it means that the platform\n    // is already bootstrapped and no additional actions are required.\n    if (_platformInjector)\n        return _platformInjector;\n    publishDefaultGlobalUtils();\n    // Otherwise, setup a new platform injector and run platform initializers.\n    const injector = createPlatformInjector(providers);\n    // During SSR, using this setting and using an injector from the global can cause the\n    // injector to be used for a different request due to concurrency.\n    if (typeof ngServerMode === 'undefined' || !ngServerMode) {\n        _platformInjector = injector;\n    }\n    publishSignalConfiguration();\n    runPlatformInitializers(injector);\n    return injector;\n}\n/**\n * @description\n * This function is used to provide initialization functions that will be executed upon\n * initialization of the platform injector.\n *\n * Note that the provided initializer is run in the injection context.\n *\n * Previously, this was achieved using the `PLATFORM_INITIALIZER` token which is now deprecated.\n *\n * @see {@link PLATFORM_INITIALIZER}\n *\n * @publicApi\n */\nfunction providePlatformInitializer(initializerFn) {\n    return makeEnvironmentProviders([\n        {\n            provide: PLATFORM_INITIALIZER,\n            useValue: initializerFn,\n            multi: true,\n        },\n    ]);\n}\nfunction runPlatformInitializers(injector) {\n    const inits = injector.get(PLATFORM_INITIALIZER, null);\n    runInInjectionContext(injector, () => {\n        inits?.forEach((init) => init());\n    });\n}\n\nfunction exhaustiveCheckNoChangesInterval(interval) {\n    return provideEnvironmentInitializer(() => {\n        const applicationRef = inject(ApplicationRef);\n        const errorHandler = inject(ErrorHandler);\n        const scheduler = inject(ChangeDetectionSchedulerImpl);\n        const ngZone = inject(NgZone);\n        function scheduleCheckNoChanges() {\n            ngZone.runOutsideAngular(() => {\n                setTimeout(() => {\n                    if (applicationRef.destroyed) {\n                        return;\n                    }\n                    if (scheduler.pendingRenderTaskId || scheduler.runningTick) {\n                        scheduleCheckNoChanges();\n                        return;\n                    }\n                    for (const view of applicationRef.allViews) {\n                        try {\n                            checkNoChangesInternal(view._lView, true /** exhaustive */);\n                        }\n                        catch (e) {\n                            errorHandler.handleError(e);\n                        }\n                    }\n                    scheduleCheckNoChanges();\n                }, interval);\n            });\n        }\n        scheduleCheckNoChanges();\n    });\n}\n\nfunction provideCheckNoChangesConfig(options) {\n    return makeEnvironmentProviders(typeof ngDevMode === 'undefined' || ngDevMode\n        ? [\n            {\n                provide: UseExhaustiveCheckNoChanges,\n                useValue: options.exhaustive,\n            },\n            options?.interval !== undefined ? exhaustiveCheckNoChangesInterval(options.interval) : [],\n        ]\n        : []);\n}\n\n/**\n * Returns whether Angular is in development mode.\n *\n * By default, this is true, unless `enableProdMode` is invoked prior to calling this method or the\n * application is built using the Angular CLI with the `optimization` option.\n * @see {@link /cli/build ng build}\n *\n * @publicApi\n */\nfunction isDevMode() {\n    return typeof ngDevMode === 'undefined' || !!ngDevMode;\n}\n/**\n * Disable Angular's development mode, which turns off assertions and other\n * checks within the framework.\n *\n * One important assertion this disables verifies that a change detection pass\n * does not result in additional changes to any bindings (also known as\n * unidirectional data flow).\n *\n * Using this method is discouraged as the Angular CLI will set production mode when using the\n * `optimization` option.\n * @see {@link /cli/build ng build}\n *\n * @publicApi\n */\nfunction enableProdMode() {\n    // The below check is there so when ngDevMode is set via terser\n    // `global['ngDevMode'] = false;` is also dropped.\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        _global['ngDevMode'] = false;\n    }\n}\n\n/**\n * Returns the NgModuleFactory with the given id (specified using [@NgModule.id\n * field](api/core/NgModule#id)), if it exists and has been loaded. Factories for NgModules that do\n * not specify an `id` cannot be retrieved. Throws if an NgModule cannot be found.\n * @publicApi\n * @deprecated Use `getNgModuleById` instead.\n */\nfunction getModuleFactory(id) {\n    const type = getRegisteredNgModuleType(id);\n    if (!type)\n        throw noModuleError(id);\n    return new NgModuleFactory(type);\n}\n/**\n * Returns the NgModule class with the given id (specified using [@NgModule.id\n * field](api/core/NgModule#id)), if it exists and has been loaded. Classes for NgModules that do\n * not specify an `id` cannot be retrieved. Throws if an NgModule cannot be found.\n * @publicApi\n */\nfunction getNgModuleById(id) {\n    const type = getRegisteredNgModuleType(id);\n    if (!type)\n        throw noModuleError(id);\n    return type;\n}\nfunction noModuleError(id) {\n    return new Error(`No module with ID ${id} loaded`);\n}\n\n/**\n * Base class that provides change detection functionality.\n * A change-detection tree collects all views that are to be checked for changes.\n * Use the methods to add and remove views from the tree, initiate change-detection,\n * and explicitly mark views as _dirty_, meaning that they have changed and need to be re-rendered.\n *\n * @see [Using change detection hooks](guide/components/lifecycle#using-change-detection-hooks)\n * @see [Defining custom change detection](guide/components/lifecycle#defining-custom-change-detection)\n *\n * @usageNotes\n *\n * The following examples demonstrate how to modify default change-detection behavior\n * to perform explicit detection when needed.\n *\n * ### Use `markForCheck()` with `CheckOnce` strategy\n *\n * The following example sets the `OnPush` change-detection strategy for a component\n * (`CheckOnce`, rather than the default `CheckAlways`), then forces a second check\n * after an interval.\n *\n * {@example core/ts/change_detect/change-detection.ts region='mark-for-check'}\n *\n * ### Detach change detector to limit how often check occurs\n *\n * The following example defines a component with a large list of read-only data\n * that is expected to change constantly, many times per second.\n * To improve performance, we want to check and update the list\n * less often than the changes actually occur. To do that, we detach\n * the component's change detector and perform an explicit local check every five seconds.\n *\n * {@example core/ts/change_detect/change-detection.ts region='detach'}\n *\n *\n * ### Reattaching a detached component\n *\n * The following example creates a component displaying live data.\n * The component detaches its change detector from the main change detector tree\n * when the `live` property is set to false, and reattaches it when the property\n * becomes true.\n *\n * {@example core/ts/change_detect/change-detection.ts region='reattach'}\n *\n * @publicApi\n */\nclass ChangeDetectorRef {\n    /**\n     * @internal\n     * @nocollapse\n     */\n    static __NG_ELEMENT_ID__ = injectChangeDetectorRef;\n}\n/** Returns a ChangeDetectorRef (a.k.a. a ViewRef) */\nfunction injectChangeDetectorRef(flags) {\n    return createViewRef(getCurrentTNode(), getLView(), (flags & 16 /* InternalInjectFlags.ForPipe */) === 16 /* InternalInjectFlags.ForPipe */);\n}\n/**\n * Creates a ViewRef and stores it on the injector as ChangeDetectorRef (public alias).\n *\n * @param tNode The node that is requesting a ChangeDetectorRef\n * @param lView The view to which the node belongs\n * @param isPipe Whether the view is being injected into a pipe.\n * @returns The ChangeDetectorRef to use\n */\nfunction createViewRef(tNode, lView, isPipe) {\n    if (isComponentHost(tNode) && !isPipe) {\n        // The LView represents the location where the component is declared.\n        // Instead we want the LView for the component View and so we need to look it up.\n        const componentView = getComponentLViewByIndex(tNode.index, lView); // look down\n        return new ViewRef$1(componentView, componentView);\n    }\n    else if (tNode.type &\n        (3 /* TNodeType.AnyRNode */ | 12 /* TNodeType.AnyContainer */ | 32 /* TNodeType.Icu */ | 128 /* TNodeType.LetDeclaration */)) {\n        // The LView represents the location where the injection is requested from.\n        // We need to locate the containing LView (in case where the `lView` is an embedded view)\n        const hostComponentView = lView[DECLARATION_COMPONENT_VIEW]; // look up\n        return new ViewRef$1(hostComponentView, lView);\n    }\n    return null;\n}\n\n/**\n * Represents an Angular view.\n *\n * @see {@link /api/core/ChangeDetectorRef?tab=usage-notes Change detection usage}\n *\n * @publicApi\n */\nclass ViewRef extends ChangeDetectorRef {\n}\n/**\n * Represents an Angular view in a view container.\n * An embedded view can be referenced from a component\n * other than the hosting component whose template defines it, or it can be defined\n * independently by a `TemplateRef`.\n *\n * Properties of elements in a view can change, but the structure (number and order) of elements in\n * a view cannot. Change the structure of elements by inserting, moving, or\n * removing nested views in a view container.\n *\n * @see {@link ViewContainerRef}\n *\n * @usageNotes\n *\n * The following template breaks down into two separate `TemplateRef` instances,\n * an outer one and an inner one.\n *\n * ```html\n * Count: {{items.length}}\n * <ul>\n *   <li *ngFor=\"let  item of items\">{{item}}</li>\n * </ul>\n * ```\n *\n * This is the outer `TemplateRef`:\n *\n * ```html\n * Count: {{items.length}}\n * <ul>\n *   <ng-template ngFor let-item [ngForOf]=\"items\"></ng-template>\n * </ul>\n * ```\n *\n * This is the inner `TemplateRef`:\n *\n * ```html\n *   <li>{{item}}</li>\n * ```\n *\n * The outer and inner `TemplateRef` instances are assembled into views as follows:\n *\n * ```html\n * <!-- ViewRef: outer-0 -->\n * Count: 2\n * <ul>\n *   <ng-template view-container-ref></ng-template>\n *   <!-- ViewRef: inner-1 --><li>first</li><!-- /ViewRef: inner-1 -->\n *   <!-- ViewRef: inner-2 --><li>second</li><!-- /ViewRef: inner-2 -->\n * </ul>\n * <!-- /ViewRef: outer-0 -->\n * ```\n * @publicApi\n */\nclass EmbeddedViewRef extends ViewRef {\n}\n\nclass DefaultIterableDifferFactory {\n    constructor() { }\n    supports(obj) {\n        return isListLikeIterable(obj);\n    }\n    create(trackByFn) {\n        return new DefaultIterableDiffer(trackByFn);\n    }\n}\nconst trackByIdentity = (index, item) => item;\n/**\n * @deprecated v4.0.0 - Should not be part of public API.\n * @publicApi\n */\nclass DefaultIterableDiffer {\n    length = 0;\n    // TODO: confirm the usage of `collection` as it's unused, readonly and on a non public API.\n    collection;\n    // Keeps track of the used records at any point in time (during & across `_check()` calls)\n    _linkedRecords = null;\n    // Keeps track of the removed records at any point in time during `_check()` calls.\n    _unlinkedRecords = null;\n    _previousItHead = null;\n    _itHead = null;\n    _itTail = null;\n    _additionsHead = null;\n    _additionsTail = null;\n    _movesHead = null;\n    _movesTail = null;\n    _removalsHead = null;\n    _removalsTail = null;\n    // Keeps track of records where custom track by is the same, but item identity has changed\n    _identityChangesHead = null;\n    _identityChangesTail = null;\n    _trackByFn;\n    constructor(trackByFn) {\n        this._trackByFn = trackByFn || trackByIdentity;\n    }\n    forEachItem(fn) {\n        let record;\n        for (record = this._itHead; record !== null; record = record._next) {\n            fn(record);\n        }\n    }\n    forEachOperation(fn) {\n        let nextIt = this._itHead;\n        let nextRemove = this._removalsHead;\n        let addRemoveOffset = 0;\n        let moveOffsets = null;\n        while (nextIt || nextRemove) {\n            // Figure out which is the next record to process\n            // Order: remove, add, move\n            const record = !nextRemove ||\n                (nextIt &&\n                    nextIt.currentIndex < getPreviousIndex(nextRemove, addRemoveOffset, moveOffsets))\n                ? nextIt\n                : nextRemove;\n            const adjPreviousIndex = getPreviousIndex(record, addRemoveOffset, moveOffsets);\n            const currentIndex = record.currentIndex;\n            // consume the item, and adjust the addRemoveOffset and update moveDistance if necessary\n            if (record === nextRemove) {\n                addRemoveOffset--;\n                nextRemove = nextRemove._nextRemoved;\n            }\n            else {\n                nextIt = nextIt._next;\n                if (record.previousIndex == null) {\n                    addRemoveOffset++;\n                }\n                else {\n                    // INVARIANT:  currentIndex < previousIndex\n                    if (!moveOffsets)\n                        moveOffsets = [];\n                    const localMovePreviousIndex = adjPreviousIndex - addRemoveOffset;\n                    const localCurrentIndex = currentIndex - addRemoveOffset;\n                    if (localMovePreviousIndex != localCurrentIndex) {\n                        for (let i = 0; i < localMovePreviousIndex; i++) {\n                            const offset = i < moveOffsets.length ? moveOffsets[i] : (moveOffsets[i] = 0);\n                            const index = offset + i;\n                            if (localCurrentIndex <= index && index < localMovePreviousIndex) {\n                                moveOffsets[i] = offset + 1;\n                            }\n                        }\n                        const previousIndex = record.previousIndex;\n                        moveOffsets[previousIndex] = localCurrentIndex - localMovePreviousIndex;\n                    }\n                }\n            }\n            if (adjPreviousIndex !== currentIndex) {\n                fn(record, adjPreviousIndex, currentIndex);\n            }\n        }\n    }\n    forEachPreviousItem(fn) {\n        let record;\n        for (record = this._previousItHead; record !== null; record = record._nextPrevious) {\n            fn(record);\n        }\n    }\n    forEachAddedItem(fn) {\n        let record;\n        for (record = this._additionsHead; record !== null; record = record._nextAdded) {\n            fn(record);\n        }\n    }\n    forEachMovedItem(fn) {\n        let record;\n        for (record = this._movesHead; record !== null; record = record._nextMoved) {\n            fn(record);\n        }\n    }\n    forEachRemovedItem(fn) {\n        let record;\n        for (record = this._removalsHead; record !== null; record = record._nextRemoved) {\n            fn(record);\n        }\n    }\n    forEachIdentityChange(fn) {\n        let record;\n        for (record = this._identityChangesHead; record !== null; record = record._nextIdentityChange) {\n            fn(record);\n        }\n    }\n    diff(collection) {\n        if (collection == null)\n            collection = [];\n        if (!isListLikeIterable(collection)) {\n            throw new RuntimeError(900 /* RuntimeErrorCode.INVALID_DIFFER_INPUT */, ngDevMode &&\n                `Error trying to diff '${stringify(collection)}'. Only arrays and iterables are allowed`);\n        }\n        if (this.check(collection)) {\n            return this;\n        }\n        else {\n            return null;\n        }\n    }\n    onDestroy() { }\n    check(collection) {\n        this._reset();\n        let record = this._itHead;\n        let mayBeDirty = false;\n        let index;\n        let item;\n        let itemTrackBy;\n        if (Array.isArray(collection)) {\n            this.length = collection.length;\n            for (let index = 0; index < this.length; index++) {\n                item = collection[index];\n                itemTrackBy = this._trackByFn(index, item);\n                if (record === null || !Object.is(record.trackById, itemTrackBy)) {\n                    record = this._mismatch(record, item, itemTrackBy, index);\n                    mayBeDirty = true;\n                }\n                else {\n                    if (mayBeDirty) {\n                        // TODO(misko): can we limit this to duplicates only?\n                        record = this._verifyReinsertion(record, item, itemTrackBy, index);\n                    }\n                    if (!Object.is(record.item, item))\n                        this._addIdentityChange(record, item);\n                }\n                record = record._next;\n            }\n        }\n        else {\n            index = 0;\n            iterateListLike(collection, (item) => {\n                itemTrackBy = this._trackByFn(index, item);\n                if (record === null || !Object.is(record.trackById, itemTrackBy)) {\n                    record = this._mismatch(record, item, itemTrackBy, index);\n                    mayBeDirty = true;\n                }\n                else {\n                    if (mayBeDirty) {\n                        // TODO(misko): can we limit this to duplicates only?\n                        record = this._verifyReinsertion(record, item, itemTrackBy, index);\n                    }\n                    if (!Object.is(record.item, item))\n                        this._addIdentityChange(record, item);\n                }\n                record = record._next;\n                index++;\n            });\n            this.length = index;\n        }\n        this._truncate(record);\n        this.collection = collection;\n        return this.isDirty;\n    }\n    /* CollectionChanges is considered dirty if it has any additions, moves, removals, or identity\n     * changes.\n     */\n    get isDirty() {\n        return (this._additionsHead !== null ||\n            this._movesHead !== null ||\n            this._removalsHead !== null ||\n            this._identityChangesHead !== null);\n    }\n    /**\n     * Reset the state of the change objects to show no changes. This means set previousKey to\n     * currentKey, and clear all of the queues (additions, moves, removals).\n     * Set the previousIndexes of moved and added items to their currentIndexes\n     * Reset the list of additions, moves and removals\n     *\n     * @internal\n     */\n    _reset() {\n        if (this.isDirty) {\n            let record;\n            for (record = this._previousItHead = this._itHead; record !== null; record = record._next) {\n                record._nextPrevious = record._next;\n            }\n            for (record = this._additionsHead; record !== null; record = record._nextAdded) {\n                record.previousIndex = record.currentIndex;\n            }\n            this._additionsHead = this._additionsTail = null;\n            for (record = this._movesHead; record !== null; record = record._nextMoved) {\n                record.previousIndex = record.currentIndex;\n            }\n            this._movesHead = this._movesTail = null;\n            this._removalsHead = this._removalsTail = null;\n            this._identityChangesHead = this._identityChangesTail = null;\n            // TODO(vicb): when assert gets supported\n            // assert(!this.isDirty);\n        }\n    }\n    /**\n     * This is the core function which handles differences between collections.\n     *\n     * - `record` is the record which we saw at this position last time. If null then it is a new\n     *   item.\n     * - `item` is the current item in the collection\n     * - `index` is the position of the item in the collection\n     *\n     * @internal\n     */\n    _mismatch(record, item, itemTrackBy, index) {\n        // The previous record after which we will append the current one.\n        let previousRecord;\n        if (record === null) {\n            previousRecord = this._itTail;\n        }\n        else {\n            previousRecord = record._prev;\n            // Remove the record from the collection since we know it does not match the item.\n            this._remove(record);\n        }\n        // See if we have evicted the item, which used to be at some anterior position of _itHead list.\n        record = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy, null);\n        if (record !== null) {\n            // It is an item which we have evicted earlier: reinsert it back into the list.\n            // But first we need to check if identity changed, so we can update in view if necessary.\n            if (!Object.is(record.item, item))\n                this._addIdentityChange(record, item);\n            this._reinsertAfter(record, previousRecord, index);\n        }\n        else {\n            // Attempt to see if the item is at some posterior position of _itHead list.\n            record = this._linkedRecords === null ? null : this._linkedRecords.get(itemTrackBy, index);\n            if (record !== null) {\n                // We have the item in _itHead at/after `index` position. We need to move it forward in the\n                // collection.\n                // But first we need to check if identity changed, so we can update in view if necessary.\n                if (!Object.is(record.item, item))\n                    this._addIdentityChange(record, item);\n                this._moveAfter(record, previousRecord, index);\n            }\n            else {\n                // It is a new item: add it.\n                record = this._addAfter(new IterableChangeRecord_(item, itemTrackBy), previousRecord, index);\n            }\n        }\n        return record;\n    }\n    /**\n     * This check is only needed if an array contains duplicates. (Short circuit of nothing dirty)\n     *\n     * Use case: `[a, a]` => `[b, a, a]`\n     *\n     * If we did not have this check then the insertion of `b` would:\n     *   1) evict first `a`\n     *   2) insert `b` at `0` index.\n     *   3) leave `a` at index `1` as is. <-- this is wrong!\n     *   3) reinsert `a` at index 2. <-- this is wrong!\n     *\n     * The correct behavior is:\n     *   1) evict first `a`\n     *   2) insert `b` at `0` index.\n     *   3) reinsert `a` at index 1.\n     *   3) move `a` at from `1` to `2`.\n     *\n     *\n     * Double check that we have not evicted a duplicate item. We need to check if the item type may\n     * have already been removed:\n     * The insertion of b will evict the first 'a'. If we don't reinsert it now it will be reinserted\n     * at the end. Which will show up as the two 'a's switching position. This is incorrect, since a\n     * better way to think of it is as insert of 'b' rather then switch 'a' with 'b' and then add 'a'\n     * at the end.\n     *\n     * @internal\n     */\n    _verifyReinsertion(record, item, itemTrackBy, index) {\n        let reinsertRecord = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy, null);\n        if (reinsertRecord !== null) {\n            record = this._reinsertAfter(reinsertRecord, record._prev, index);\n        }\n        else if (record.currentIndex != index) {\n            record.currentIndex = index;\n            this._addToMoves(record, index);\n        }\n        return record;\n    }\n    /**\n     * Get rid of any excess {@link IterableChangeRecord_}s from the previous collection\n     *\n     * - `record` The first excess {@link IterableChangeRecord_}.\n     *\n     * @internal\n     */\n    _truncate(record) {\n        // Anything after that needs to be removed;\n        while (record !== null) {\n            const nextRecord = record._next;\n            this._addToRemovals(this._unlink(record));\n            record = nextRecord;\n        }\n        if (this._unlinkedRecords !== null) {\n            this._unlinkedRecords.clear();\n        }\n        if (this._additionsTail !== null) {\n            this._additionsTail._nextAdded = null;\n        }\n        if (this._movesTail !== null) {\n            this._movesTail._nextMoved = null;\n        }\n        if (this._itTail !== null) {\n            this._itTail._next = null;\n        }\n        if (this._removalsTail !== null) {\n            this._removalsTail._nextRemoved = null;\n        }\n        if (this._identityChangesTail !== null) {\n            this._identityChangesTail._nextIdentityChange = null;\n        }\n    }\n    /** @internal */\n    _reinsertAfter(record, prevRecord, index) {\n        if (this._unlinkedRecords !== null) {\n            this._unlinkedRecords.remove(record);\n        }\n        const prev = record._prevRemoved;\n        const next = record._nextRemoved;\n        if (prev === null) {\n            this._removalsHead = next;\n        }\n        else {\n            prev._nextRemoved = next;\n        }\n        if (next === null) {\n            this._removalsTail = prev;\n        }\n        else {\n            next._prevRemoved = prev;\n        }\n        this._insertAfter(record, prevRecord, index);\n        this._addToMoves(record, index);\n        return record;\n    }\n    /** @internal */\n    _moveAfter(record, prevRecord, index) {\n        this._unlink(record);\n        this._insertAfter(record, prevRecord, index);\n        this._addToMoves(record, index);\n        return record;\n    }\n    /** @internal */\n    _addAfter(record, prevRecord, index) {\n        this._insertAfter(record, prevRecord, index);\n        if (this._additionsTail === null) {\n            // TODO(vicb):\n            // assert(this._additionsHead === null);\n            this._additionsTail = this._additionsHead = record;\n        }\n        else {\n            // TODO(vicb):\n            // assert(_additionsTail._nextAdded === null);\n            // assert(record._nextAdded === null);\n            this._additionsTail = this._additionsTail._nextAdded = record;\n        }\n        return record;\n    }\n    /** @internal */\n    _insertAfter(record, prevRecord, index) {\n        // TODO(vicb):\n        // assert(record != prevRecord);\n        // assert(record._next === null);\n        // assert(record._prev === null);\n        const next = prevRecord === null ? this._itHead : prevRecord._next;\n        // TODO(vicb):\n        // assert(next != record);\n        // assert(prevRecord != record);\n        record._next = next;\n        record._prev = prevRecord;\n        if (next === null) {\n            this._itTail = record;\n        }\n        else {\n            next._prev = record;\n        }\n        if (prevRecord === null) {\n            this._itHead = record;\n        }\n        else {\n            prevRecord._next = record;\n        }\n        if (this._linkedRecords === null) {\n            this._linkedRecords = new _DuplicateMap();\n        }\n        this._linkedRecords.put(record);\n        record.currentIndex = index;\n        return record;\n    }\n    /** @internal */\n    _remove(record) {\n        return this._addToRemovals(this._unlink(record));\n    }\n    /** @internal */\n    _unlink(record) {\n        if (this._linkedRecords !== null) {\n            this._linkedRecords.remove(record);\n        }\n        const prev = record._prev;\n        const next = record._next;\n        // TODO(vicb):\n        // assert((record._prev = null) === null);\n        // assert((record._next = null) === null);\n        if (prev === null) {\n            this._itHead = next;\n        }\n        else {\n            prev._next = next;\n        }\n        if (next === null) {\n            this._itTail = prev;\n        }\n        else {\n            next._prev = prev;\n        }\n        return record;\n    }\n    /** @internal */\n    _addToMoves(record, toIndex) {\n        // TODO(vicb):\n        // assert(record._nextMoved === null);\n        if (record.previousIndex === toIndex) {\n            return record;\n        }\n        if (this._movesTail === null) {\n            // TODO(vicb):\n            // assert(_movesHead === null);\n            this._movesTail = this._movesHead = record;\n        }\n        else {\n            // TODO(vicb):\n            // assert(_movesTail._nextMoved === null);\n            this._movesTail = this._movesTail._nextMoved = record;\n        }\n        return record;\n    }\n    _addToRemovals(record) {\n        if (this._unlinkedRecords === null) {\n            this._unlinkedRecords = new _DuplicateMap();\n        }\n        this._unlinkedRecords.put(record);\n        record.currentIndex = null;\n        record._nextRemoved = null;\n        if (this._removalsTail === null) {\n            // TODO(vicb):\n            // assert(_removalsHead === null);\n            this._removalsTail = this._removalsHead = record;\n            record._prevRemoved = null;\n        }\n        else {\n            // TODO(vicb):\n            // assert(_removalsTail._nextRemoved === null);\n            // assert(record._nextRemoved === null);\n            record._prevRemoved = this._removalsTail;\n            this._removalsTail = this._removalsTail._nextRemoved = record;\n        }\n        return record;\n    }\n    /** @internal */\n    _addIdentityChange(record, item) {\n        record.item = item;\n        if (this._identityChangesTail === null) {\n            this._identityChangesTail = this._identityChangesHead = record;\n        }\n        else {\n            this._identityChangesTail = this._identityChangesTail._nextIdentityChange = record;\n        }\n        return record;\n    }\n}\nclass IterableChangeRecord_ {\n    item;\n    trackById;\n    currentIndex = null;\n    previousIndex = null;\n    /** @internal */\n    _nextPrevious = null;\n    /** @internal */\n    _prev = null;\n    /** @internal */\n    _next = null;\n    /** @internal */\n    _prevDup = null;\n    /** @internal */\n    _nextDup = null;\n    /** @internal */\n    _prevRemoved = null;\n    /** @internal */\n    _nextRemoved = null;\n    /** @internal */\n    _nextAdded = null;\n    /** @internal */\n    _nextMoved = null;\n    /** @internal */\n    _nextIdentityChange = null;\n    constructor(item, trackById) {\n        this.item = item;\n        this.trackById = trackById;\n    }\n}\n// A linked list of IterableChangeRecords with the same IterableChangeRecord_.item\nclass _DuplicateItemRecordList {\n    /** @internal */\n    _head = null;\n    /** @internal */\n    _tail = null;\n    /**\n     * Append the record to the list of duplicates.\n     *\n     * Note: by design all records in the list of duplicates hold the same value in record.item.\n     */\n    add(record) {\n        if (this._head === null) {\n            this._head = this._tail = record;\n            record._nextDup = null;\n            record._prevDup = null;\n        }\n        else {\n            // TODO(vicb):\n            // assert(record.item ==  _head.item ||\n            //       record.item is num && record.item.isNaN && _head.item is num && _head.item.isNaN);\n            this._tail._nextDup = record;\n            record._prevDup = this._tail;\n            record._nextDup = null;\n            this._tail = record;\n        }\n    }\n    // Returns a IterableChangeRecord_ having IterableChangeRecord_.trackById == trackById and\n    // IterableChangeRecord_.currentIndex >= atOrAfterIndex\n    get(trackById, atOrAfterIndex) {\n        let record;\n        for (record = this._head; record !== null; record = record._nextDup) {\n            if ((atOrAfterIndex === null || atOrAfterIndex <= record.currentIndex) &&\n                Object.is(record.trackById, trackById)) {\n                return record;\n            }\n        }\n        return null;\n    }\n    /**\n     * Remove one {@link IterableChangeRecord_} from the list of duplicates.\n     *\n     * Returns whether the list of duplicates is empty.\n     */\n    remove(record) {\n        // TODO(vicb):\n        // assert(() {\n        //  // verify that the record being removed is in the list.\n        //  for (IterableChangeRecord_ cursor = _head; cursor != null; cursor = cursor._nextDup) {\n        //    if (identical(cursor, record)) return true;\n        //  }\n        //  return false;\n        //});\n        const prev = record._prevDup;\n        const next = record._nextDup;\n        if (prev === null) {\n            this._head = next;\n        }\n        else {\n            prev._nextDup = next;\n        }\n        if (next === null) {\n            this._tail = prev;\n        }\n        else {\n            next._prevDup = prev;\n        }\n        return this._head === null;\n    }\n}\nclass _DuplicateMap {\n    map = new Map();\n    put(record) {\n        const key = record.trackById;\n        let duplicates = this.map.get(key);\n        if (!duplicates) {\n            duplicates = new _DuplicateItemRecordList();\n            this.map.set(key, duplicates);\n        }\n        duplicates.add(record);\n    }\n    /**\n     * Retrieve the `value` using key. Because the IterableChangeRecord_ value may be one which we\n     * have already iterated over, we use the `atOrAfterIndex` to pretend it is not there.\n     *\n     * Use case: `[a, b, c, a, a]` if we are at index `3` which is the second `a` then asking if we\n     * have any more `a`s needs to return the second `a`.\n     */\n    get(trackById, atOrAfterIndex) {\n        const key = trackById;\n        const recordList = this.map.get(key);\n        return recordList ? recordList.get(trackById, atOrAfterIndex) : null;\n    }\n    /**\n     * Removes a {@link IterableChangeRecord_} from the list of duplicates.\n     *\n     * The list of duplicates also is removed from the map if it gets empty.\n     */\n    remove(record) {\n        const key = record.trackById;\n        const recordList = this.map.get(key);\n        // Remove the list of duplicates when it gets empty\n        if (recordList.remove(record)) {\n            this.map.delete(key);\n        }\n        return record;\n    }\n    get isEmpty() {\n        return this.map.size === 0;\n    }\n    clear() {\n        this.map.clear();\n    }\n}\nfunction getPreviousIndex(item, addRemoveOffset, moveOffsets) {\n    const previousIndex = item.previousIndex;\n    if (previousIndex === null)\n        return previousIndex;\n    let moveOffset = 0;\n    if (moveOffsets && previousIndex < moveOffsets.length) {\n        moveOffset = moveOffsets[previousIndex];\n    }\n    return previousIndex + addRemoveOffset + moveOffset;\n}\n\nclass DefaultKeyValueDifferFactory {\n    constructor() { }\n    supports(obj) {\n        return obj instanceof Map || isJsObject(obj);\n    }\n    create() {\n        return new DefaultKeyValueDiffer();\n    }\n}\nclass DefaultKeyValueDiffer {\n    _records = new Map();\n    _mapHead = null;\n    // _appendAfter is used in the check loop\n    _appendAfter = null;\n    _previousMapHead = null;\n    _changesHead = null;\n    _changesTail = null;\n    _additionsHead = null;\n    _additionsTail = null;\n    _removalsHead = null;\n    _removalsTail = null;\n    get isDirty() {\n        return (this._additionsHead !== null || this._changesHead !== null || this._removalsHead !== null);\n    }\n    forEachItem(fn) {\n        let record;\n        for (record = this._mapHead; record !== null; record = record._next) {\n            fn(record);\n        }\n    }\n    forEachPreviousItem(fn) {\n        let record;\n        for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {\n            fn(record);\n        }\n    }\n    forEachChangedItem(fn) {\n        let record;\n        for (record = this._changesHead; record !== null; record = record._nextChanged) {\n            fn(record);\n        }\n    }\n    forEachAddedItem(fn) {\n        let record;\n        for (record = this._additionsHead; record !== null; record = record._nextAdded) {\n            fn(record);\n        }\n    }\n    forEachRemovedItem(fn) {\n        let record;\n        for (record = this._removalsHead; record !== null; record = record._nextRemoved) {\n            fn(record);\n        }\n    }\n    diff(map) {\n        if (!map) {\n            map = new Map();\n        }\n        else if (!(map instanceof Map || isJsObject(map))) {\n            throw new RuntimeError(900 /* RuntimeErrorCode.INVALID_DIFFER_INPUT */, ngDevMode && `Error trying to diff '${stringify(map)}'. Only maps and objects are allowed`);\n        }\n        return this.check(map) ? this : null;\n    }\n    onDestroy() { }\n    /**\n     * Check the current state of the map vs the previous.\n     * The algorithm is optimised for when the keys do no change.\n     */\n    check(map) {\n        this._reset();\n        let insertBefore = this._mapHead;\n        this._appendAfter = null;\n        this._forEach(map, (value, key) => {\n            if (insertBefore && insertBefore.key === key) {\n                this._maybeAddToChanges(insertBefore, value);\n                this._appendAfter = insertBefore;\n                insertBefore = insertBefore._next;\n            }\n            else {\n                const record = this._getOrCreateRecordForKey(key, value);\n                insertBefore = this._insertBeforeOrAppend(insertBefore, record);\n            }\n        });\n        // Items remaining at the end of the list have been deleted\n        if (insertBefore) {\n            if (insertBefore._prev) {\n                insertBefore._prev._next = null;\n            }\n            this._removalsHead = insertBefore;\n            for (let record = insertBefore; record !== null; record = record._nextRemoved) {\n                if (record === this._mapHead) {\n                    this._mapHead = null;\n                }\n                this._records.delete(record.key);\n                record._nextRemoved = record._next;\n                record.previousValue = record.currentValue;\n                record.currentValue = null;\n                record._prev = null;\n                record._next = null;\n            }\n        }\n        // Make sure tails have no next records from previous runs\n        if (this._changesTail)\n            this._changesTail._nextChanged = null;\n        if (this._additionsTail)\n            this._additionsTail._nextAdded = null;\n        return this.isDirty;\n    }\n    /**\n     * Inserts a record before `before` or append at the end of the list when `before` is null.\n     *\n     * Notes:\n     * - This method appends at `this._appendAfter`,\n     * - This method updates `this._appendAfter`,\n     * - The return value is the new value for the insertion pointer.\n     */\n    _insertBeforeOrAppend(before, record) {\n        if (before) {\n            const prev = before._prev;\n            record._next = before;\n            record._prev = prev;\n            before._prev = record;\n            if (prev) {\n                prev._next = record;\n            }\n            if (before === this._mapHead) {\n                this._mapHead = record;\n            }\n            this._appendAfter = before;\n            return before;\n        }\n        if (this._appendAfter) {\n            this._appendAfter._next = record;\n            record._prev = this._appendAfter;\n        }\n        else {\n            this._mapHead = record;\n        }\n        this._appendAfter = record;\n        return null;\n    }\n    _getOrCreateRecordForKey(key, value) {\n        if (this._records.has(key)) {\n            const record = this._records.get(key);\n            this._maybeAddToChanges(record, value);\n            const prev = record._prev;\n            const next = record._next;\n            if (prev) {\n                prev._next = next;\n            }\n            if (next) {\n                next._prev = prev;\n            }\n            record._next = null;\n            record._prev = null;\n            return record;\n        }\n        const record = new KeyValueChangeRecord_(key);\n        this._records.set(key, record);\n        record.currentValue = value;\n        this._addToAdditions(record);\n        return record;\n    }\n    /** @internal */\n    _reset() {\n        if (this.isDirty) {\n            let record;\n            // let `_previousMapHead` contain the state of the map before the changes\n            this._previousMapHead = this._mapHead;\n            for (record = this._previousMapHead; record !== null; record = record._next) {\n                record._nextPrevious = record._next;\n            }\n            // Update `record.previousValue` with the value of the item before the changes\n            // We need to update all changed items (that's those which have been added and changed)\n            for (record = this._changesHead; record !== null; record = record._nextChanged) {\n                record.previousValue = record.currentValue;\n            }\n            for (record = this._additionsHead; record != null; record = record._nextAdded) {\n                record.previousValue = record.currentValue;\n            }\n            this._changesHead = this._changesTail = null;\n            this._additionsHead = this._additionsTail = null;\n            this._removalsHead = null;\n        }\n    }\n    // Add the record or a given key to the list of changes only when the value has actually changed\n    _maybeAddToChanges(record, newValue) {\n        if (!Object.is(newValue, record.currentValue)) {\n            record.previousValue = record.currentValue;\n            record.currentValue = newValue;\n            this._addToChanges(record);\n        }\n    }\n    _addToAdditions(record) {\n        if (this._additionsHead === null) {\n            this._additionsHead = this._additionsTail = record;\n        }\n        else {\n            this._additionsTail._nextAdded = record;\n            this._additionsTail = record;\n        }\n    }\n    _addToChanges(record) {\n        if (this._changesHead === null) {\n            this._changesHead = this._changesTail = record;\n        }\n        else {\n            this._changesTail._nextChanged = record;\n            this._changesTail = record;\n        }\n    }\n    /** @internal */\n    _forEach(obj, fn) {\n        if (obj instanceof Map) {\n            obj.forEach(fn);\n        }\n        else {\n            Object.keys(obj).forEach((k) => fn(obj[k], k));\n        }\n    }\n}\nclass KeyValueChangeRecord_ {\n    key;\n    previousValue = null;\n    currentValue = null;\n    /** @internal */\n    _nextPrevious = null;\n    /** @internal */\n    _next = null;\n    /** @internal */\n    _prev = null;\n    /** @internal */\n    _nextAdded = null;\n    /** @internal */\n    _nextRemoved = null;\n    /** @internal */\n    _nextChanged = null;\n    constructor(key) {\n        this.key = key;\n    }\n}\n\nfunction defaultIterableDiffersFactory() {\n    return new IterableDiffers([new DefaultIterableDifferFactory()]);\n}\n/**\n * A repository of different iterable diffing strategies used by NgFor, NgClass, and others.\n *\n * @publicApi\n */\nclass IterableDiffers {\n    factories;\n    /** @nocollapse */\n    static prov = /** @pureOrBreakMyCode */ /* @__PURE__ */ __defineInjectable({\n        token: IterableDiffers,\n        providedIn: 'root',\n        factory: defaultIterableDiffersFactory,\n    });\n    constructor(factories) {\n        this.factories = factories;\n    }\n    static create(factories, parent) {\n        if (parent != null) {\n            const copied = parent.factories.slice();\n            factories = factories.concat(copied);\n        }\n        return new IterableDiffers(factories);\n    }\n    /**\n     * Takes an array of {@link IterableDifferFactory} and returns a provider used to extend the\n     * inherited {@link IterableDiffers} instance with the provided factories and return a new\n     * {@link IterableDiffers} instance.\n     *\n     * @usageNotes\n     * ### Example\n     *\n     * The following example shows how to extend an existing list of factories,\n     * which will only be applied to the injector for this component and its children.\n     * This step is all that's required to make a new {@link IterableDiffer} available.\n     *\n     * ```ts\n     * @Component({\n     *   viewProviders: [\n     *     IterableDiffers.extend([new ImmutableListDiffer()])\n     *   ]\n     * })\n     * ```\n     */\n    static extend(factories) {\n        return {\n            provide: IterableDiffers,\n            useFactory: () => {\n                const parent = inject(IterableDiffers, { optional: true, skipSelf: true });\n                // if parent is null, it means that we are in the root injector and we have just overridden\n                // the default injection mechanism for IterableDiffers, in such a case just assume\n                // `defaultIterableDiffersFactory`.\n                return IterableDiffers.create(factories, parent || defaultIterableDiffersFactory());\n            },\n        };\n    }\n    find(iterable) {\n        const factory = this.factories.find((f) => f.supports(iterable));\n        if (factory != null) {\n            return factory;\n        }\n        else {\n            throw new RuntimeError(901 /* RuntimeErrorCode.NO_SUPPORTING_DIFFER_FACTORY */, ngDevMode &&\n                `Cannot find a differ supporting object '${iterable}' of type '${getTypeNameForDebugging(iterable)}'`);\n        }\n    }\n}\nfunction getTypeNameForDebugging(type) {\n    return type['name'] || typeof type;\n}\n\nfunction defaultKeyValueDiffersFactory() {\n    return new KeyValueDiffers([new DefaultKeyValueDifferFactory()]);\n}\n/**\n * A repository of different Map diffing strategies used by NgClass, NgStyle, and others.\n *\n * @publicApi\n */\nclass KeyValueDiffers {\n    /** @nocollapse */\n    static prov = /** @pureOrBreakMyCode */ /* @__PURE__ */ __defineInjectable({\n        token: KeyValueDiffers,\n        providedIn: 'root',\n        factory: defaultKeyValueDiffersFactory,\n    });\n    factories;\n    constructor(factories) {\n        this.factories = factories;\n    }\n    static create(factories, parent) {\n        if (parent) {\n            const copied = parent.factories.slice();\n            factories = factories.concat(copied);\n        }\n        return new KeyValueDiffers(factories);\n    }\n    /**\n     * Takes an array of {@link KeyValueDifferFactory} and returns a provider used to extend the\n     * inherited {@link KeyValueDiffers} instance with the provided factories and return a new\n     * {@link KeyValueDiffers} instance.\n     *\n     * @usageNotes\n     * ### Example\n     *\n     * The following example shows how to extend an existing list of factories,\n     * which will only be applied to the injector for this component and its children.\n     * This step is all that's required to make a new {@link KeyValueDiffer} available.\n     *\n     * ```ts\n     * @Component({\n     *   viewProviders: [\n     *     KeyValueDiffers.extend([new ImmutableMapDiffer()])\n     *   ]\n     * })\n     * ```\n     */\n    static extend(factories) {\n        return {\n            provide: KeyValueDiffers,\n            useFactory: () => {\n                const parent = inject(KeyValueDiffers, { optional: true, skipSelf: true });\n                // if parent is null, it means that we are in the root injector and we have just overridden\n                // the default injection mechanism for KeyValueDiffers, in such a case just assume\n                // `defaultKeyValueDiffersFactory`.\n                return KeyValueDiffers.create(factories, parent || defaultKeyValueDiffersFactory());\n            },\n        };\n    }\n    find(kv) {\n        const factory = this.factories.find((f) => f.supports(kv));\n        if (factory) {\n            return factory;\n        }\n        throw new RuntimeError(901 /* RuntimeErrorCode.NO_SUPPORTING_DIFFER_FACTORY */, ngDevMode && `Cannot find a differ supporting object '${kv}'`);\n    }\n}\n\n/**\n * Structural diffing for `Object`s and `Map`s.\n */\nconst keyValDiff = [new DefaultKeyValueDifferFactory()];\n/**\n * Structural diffing for `Iterable` types such as `Array`s.\n */\nconst iterableDiff = [new DefaultIterableDifferFactory()];\nconst defaultIterableDiffers = new IterableDiffers(iterableDiff);\nconst defaultKeyValueDiffers = new KeyValueDiffers(keyValDiff);\n\n/**\n * This platform has to be included in any other platform\n *\n * @publicApi\n */\nconst platformCore = createPlatformFactory(null, 'core', []);\n\n/**\n * Re-exported by `BrowserModule`, which is included automatically in the root\n * `AppModule` when you create a new app with the CLI `new` command. Eagerly injects\n * `ApplicationRef` to instantiate it.\n *\n * @publicApi\n */\nclass ApplicationModule {\n    // Inject ApplicationRef to make it eager...\n    constructor(appRef) { }\n    static fac = function ApplicationModule_Factory(__ngFactoryType__) { return new (__ngFactoryType__ || ApplicationModule)(__inject(ApplicationRef)); };\n    static mod = /*@__PURE__*/ __defineNgModule({ type: ApplicationModule });\n    static inj = /*@__PURE__*/ __defineInjector({});\n}\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(ApplicationModule, [{\n        type: NgModule\n    }], () => [{ type: ApplicationRef }], null); })();\n\n/**\n * Internal create application API that implements the core application creation logic and optional\n * bootstrap logic.\n *\n * Platforms (such as `platform-browser`) may require different set of application and platform\n * providers for an application to function correctly. As a result, platforms may use this function\n * internally and supply the necessary providers during the bootstrap, while exposing\n * platform-specific APIs as a part of their public API.\n *\n * @returns A promise that returns an `ApplicationRef` instance once resolved.\n */\nfunction internalCreateApplication(config) {\n    const { rootComponent, appProviders, platformProviders, platformRef } = config;\n    profiler(8 /* ProfilerEvent.BootstrapApplicationStart */);\n    if (typeof ngServerMode !== 'undefined' && ngServerMode && !platformRef) {\n        throw new RuntimeError(-401 /* RuntimeErrorCode.PLATFORM_NOT_FOUND */, ngDevMode &&\n            'Missing Platform: This may be due to using `bootstrapApplication` on the server without passing a `BootstrapContext`. ' +\n                'Please make sure that `bootstrapApplication` is called with a `context` argument.');\n    }\n    try {\n        const platformInjector = platformRef?.injector ?? createOrReusePlatformInjector(platformProviders);\n        if ((typeof ngDevMode === 'undefined' || ngDevMode) && rootComponent !== undefined) {\n            assertStandaloneComponentType(rootComponent);\n        }\n        // Create root application injector based on a set of providers configured at the platform\n        // bootstrap level as well as providers passed to the bootstrap call by a user.\n        const allAppProviders = [\n            internalProvideZoneChangeDetection({}),\n            { provide: ChangeDetectionScheduler, useExisting: ChangeDetectionSchedulerImpl },\n            errorHandlerEnvironmentInitializer,\n            ...(appProviders || []),\n        ];\n        const adapter = new EnvironmentNgModuleRefAdapter({\n            providers: allAppProviders,\n            parent: platformInjector,\n            debugName: typeof ngDevMode === 'undefined' || ngDevMode ? 'Environment Injector' : '',\n            // We skip environment initializers because we need to run them inside the NgZone, which\n            // happens after we get the NgZone instance from the Injector.\n            runEnvironmentInitializers: false,\n        });\n        return bootstrap({\n            r3Injector: adapter.injector,\n            platformInjector,\n            rootComponent,\n        });\n    }\n    catch (e) {\n        return Promise.reject(e);\n    }\n    finally {\n        profiler(9 /* ProfilerEvent.BootstrapApplicationEnd */);\n    }\n}\n\n/** Apps in which we've enabled event replay.\n *  This is to prevent initializing event replay more than once per app.\n */\nconst appsWithEventReplay = new WeakSet();\n/**\n * The key that represents all replayable elements that are not in defer blocks.\n */\nconst EAGER_CONTENT_LISTENERS_KEY = '';\n/**\n * A list of block events that need to be replayed\n */\nlet blockEventQueue = [];\n/**\n * Determines whether Event Replay feature should be activated on the client.\n */\nfunction shouldEnableEventReplay(injector) {\n    return injector.get(IS_EVENT_REPLAY_ENABLED, EVENT_REPLAY_ENABLED_DEFAULT);\n}\n/**\n * Returns a set of providers required to setup support for event replay.\n * Requires hydration to be enabled separately.\n */\nfunction withEventReplay() {\n    const providers = [\n        {\n            provide: IS_EVENT_REPLAY_ENABLED,\n            useFactory: () => {\n                let isEnabled = true;\n                if (typeof ngServerMode === 'undefined' || !ngServerMode) {\n                    // Note: globalThis[CONTRACT_PROPERTY] may be undefined in case Event Replay feature\n                    // is enabled, but there are no events configured in this application, in which case\n                    // we don't activate this feature, since there are no events to replay.\n                    const appId = inject(APP_ID);\n                    isEnabled = !!window._ejsas?.[appId];\n                }\n                if (isEnabled) {\n                    performanceMarkFeature('NgEventReplay');\n                }\n                return isEnabled;\n            },\n        },\n    ];\n    if (typeof ngServerMode === 'undefined' || !ngServerMode) {\n        providers.push({\n            provide: ENVIRONMENT_INITIALIZER,\n            useValue: () => {\n                const appRef = inject(ApplicationRef);\n                const { injector } = appRef;\n                // We have to check for the appRef here due to the possibility of multiple apps\n                // being present on the same page. We only want to enable event replay for the\n                // apps that actually want it.\n                if (!appsWithEventReplay.has(appRef)) {\n                    const jsActionMap = inject(JSACTION_BLOCK_ELEMENT_MAP);\n                    if (shouldEnableEventReplay(injector)) {\n                        enableStashEventListenerImpl();\n                        const appId = injector.get(APP_ID);\n                        const clearStashFn = setStashFn(appId, (rEl, eventName, listenerFn) => {\n                            // If a user binds to a ng-container and uses a directive that binds using a host listener,\n                            // this element could be a comment node. So we need to ensure we have an actual element\n                            // node before stashing anything.\n                            if (rEl.nodeType !== Node.ELEMENT_NODE)\n                                return;\n                            sharedStashFunction(rEl, eventName, listenerFn);\n                            sharedMapFunction(rEl, jsActionMap);\n                        });\n                        // Clean up the reference to the function set by the environment initializer,\n                        // as the function closure may capture injected elements and prevent them\n                        // from being properly garbage collected.\n                        appRef.onDestroy(clearStashFn);\n                    }\n                }\n            },\n            multi: true,\n        }, {\n            provide: APP_BOOTSTRAP_LISTENER,\n            useFactory: () => {\n                const appRef = inject(ApplicationRef);\n                const { injector } = appRef;\n                return () => {\n                    // We have to check for the appRef here due to the possibility of multiple apps\n                    // being present on the same page. We only want to enable event replay for the\n                    // apps that actually want it.\n                    if (!shouldEnableEventReplay(injector) || appsWithEventReplay.has(appRef)) {\n                        return;\n                    }\n                    appsWithEventReplay.add(appRef);\n                    const appId = injector.get(APP_ID);\n                    appRef.onDestroy(() => {\n                        appsWithEventReplay.delete(appRef);\n                        // Ensure that we're always safe calling this in the browser.\n                        if (typeof ngServerMode !== 'undefined' && !ngServerMode) {\n                            // `_ejsa` should be deleted when the app is destroyed, ensuring that\n                            // no elements are still captured in the global list and are not prevented\n                            // from being garbage collected.\n                            clearAppScopedEarlyEventContract(appId);\n                        }\n                    });\n                    // Kick off event replay logic once hydration for the initial part\n                    // of the application is completed. This timing is similar to the unclaimed\n                    // dehydrated views cleanup timing.\n                    appRef.whenStable().then(() => {\n                        // Note: we have to check whether the application is destroyed before\n                        // performing other operations with the `injector`.\n                        // The application may be destroyed **before** it becomes stable, so when\n                        // the `whenStable` resolves, the injector might already be in\n                        // a destroyed state. Thus, calling `injector.get` would throw an error\n                        // indicating that the injector has already been destroyed.\n                        if (appRef.destroyed) {\n                            return;\n                        }\n                        const eventContractDetails = injector.get(JSACTION_EVENT_CONTRACT);\n                        initEventReplay(eventContractDetails, injector);\n                        const jsActionMap = injector.get(JSACTION_BLOCK_ELEMENT_MAP);\n                        jsActionMap.get(EAGER_CONTENT_LISTENERS_KEY)?.forEach(removeListeners);\n                        jsActionMap.delete(EAGER_CONTENT_LISTENERS_KEY);\n                        const eventContract = eventContractDetails.instance;\n                        // This removes event listeners registered through the container manager,\n                        // as listeners registered on `document.body` might never be removed if we\n                        // don't clean up the contract.\n                        if (isIncrementalHydrationEnabled(injector)) {\n                            // When incremental hydration is enabled, we cannot clean up the event\n                            // contract immediately because we're unaware if there are any deferred\n                            // blocks to hydrate. We can only schedule a contract cleanup when the\n                            // app is destroyed.\n                            appRef.onDestroy(() => eventContract.cleanUp());\n                        }\n                        else {\n                            eventContract.cleanUp();\n                        }\n                    });\n                };\n            },\n            multi: true,\n        });\n    }\n    return providers;\n}\nconst initEventReplay = (eventDelegation, injector) => {\n    const appId = injector.get(APP_ID);\n    // This is set in packages/platform-server/src/utils.ts\n    const earlyJsactionData = window._ejsas[appId];\n    const eventContract = (eventDelegation.instance = new EventContract(new EventContractContainer(earlyJsactionData.c)));\n    for (const et of earlyJsactionData.et) {\n        eventContract.addEvent(et);\n    }\n    for (const et of earlyJsactionData.etc) {\n        eventContract.addEvent(et);\n    }\n    const eventInfos = getAppScopedQueuedEventInfos(appId);\n    eventContract.replayEarlyEventInfos(eventInfos);\n    clearAppScopedEarlyEventContract(appId);\n    const dispatcher = new EventDispatcher((event) => {\n        invokeRegisteredReplayListeners(injector, event, event.currentTarget);\n    });\n    registerDispatcher(eventContract, dispatcher);\n};\n/**\n * Extracts information about all DOM events (added in a template) registered on elements in a give\n * LView. Maps collected events to a corresponding DOM element (an element is used as a key).\n */\nfunction collectDomEventsInfo(tView, lView, eventTypesToReplay) {\n    const domEventsInfo = new Map();\n    const lCleanup = lView[CLEANUP];\n    const tCleanup = tView.cleanup;\n    if (!tCleanup || !lCleanup) {\n        return domEventsInfo;\n    }\n    for (let i = 0; i < tCleanup.length;) {\n        const firstParam = tCleanup[i++];\n        const secondParam = tCleanup[i++];\n        if (typeof firstParam !== 'string') {\n            continue;\n        }\n        const eventType = firstParam;\n        if (!isEarlyEventType(eventType)) {\n            continue;\n        }\n        if (isCaptureEventType(eventType)) {\n            eventTypesToReplay.capture.add(eventType);\n        }\n        else {\n            eventTypesToReplay.regular.add(eventType);\n        }\n        const listenerElement = unwrapRNode(lView[secondParam]);\n        i++; // move the cursor to the next position (location of the listener idx)\n        const useCaptureOrIndx = tCleanup[i++];\n        // if useCaptureOrIndx is boolean then report it as is.\n        // if useCaptureOrIndx is positive number then it in unsubscribe method\n        // if useCaptureOrIndx is negative number then it is a Subscription\n        const isDomEvent = typeof useCaptureOrIndx === 'boolean' || useCaptureOrIndx >= 0;\n        if (!isDomEvent) {\n            continue;\n        }\n        if (!domEventsInfo.has(listenerElement)) {\n            domEventsInfo.set(listenerElement, [eventType]);\n        }\n        else {\n            domEventsInfo.get(listenerElement).push(eventType);\n        }\n    }\n    return domEventsInfo;\n}\nfunction invokeRegisteredReplayListeners(injector, event, currentTarget) {\n    const blockName = (currentTarget && currentTarget.getAttribute(DEFER_BLOCK_SSR_ID_ATTRIBUTE)) ?? '';\n    if (/d\\d+/.test(blockName)) {\n        hydrateAndInvokeBlockListeners(blockName, injector, event, currentTarget);\n    }\n    else if (event.eventPhase === EventPhase.REPLAY) {\n        invokeListeners(event, currentTarget);\n    }\n}\nfunction hydrateAndInvokeBlockListeners(blockName, injector, event, currentTarget) {\n    blockEventQueue.push({ event, currentTarget });\n    triggerHydrationFromBlockName(injector, blockName, replayQueuedBlockEvents);\n}\nfunction replayQueuedBlockEvents(hydratedBlocks) {\n    // clone the queue\n    const queue = [...blockEventQueue];\n    const hydrated = new Set(hydratedBlocks);\n    // empty it\n    blockEventQueue = [];\n    for (let { event, currentTarget } of queue) {\n        const blockName = currentTarget.getAttribute(DEFER_BLOCK_SSR_ID_ATTRIBUTE);\n        if (hydrated.has(blockName)) {\n            invokeListeners(event, currentTarget);\n        }\n        else {\n            // requeue events that weren't yet hydrated\n            blockEventQueue.push({ event, currentTarget });\n        }\n    }\n}\n\n/**\n * A collection that tracks all serialized views (`ngh` DOM annotations)\n * to avoid duplication. An attempt to add a duplicate view results in the\n * collection returning the index of the previously collected serialized view.\n * This reduces the number of annotations needed for a given page.\n */\nclass SerializedViewCollection {\n    views = [];\n    indexByContent = new Map();\n    add(serializedView) {\n        const viewAsString = JSON.stringify(serializedView);\n        if (!this.indexByContent.has(viewAsString)) {\n            const index = this.views.length;\n            this.views.push(serializedView);\n            this.indexByContent.set(viewAsString, index);\n            return index;\n        }\n        return this.indexByContent.get(viewAsString);\n    }\n    getAll() {\n        return this.views;\n    }\n}\n/**\n * Global counter that is used to generate a unique id for TViews\n * during the serialization process.\n */\nlet tViewSsrId = 0;\n/**\n * Generates a unique id for a given TView and returns this id.\n * The id is also stored on this instance of a TView and reused in\n * subsequent calls.\n *\n * This id is needed to uniquely identify and pick up dehydrated views\n * at runtime.\n */\nfunction getSsrId(tView) {\n    if (!tView.ssrId) {\n        tView.ssrId = `t${tViewSsrId++}`;\n    }\n    return tView.ssrId;\n}\n/**\n * Computes the number of root nodes in a given view\n * (or child nodes in a given container if a tNode is provided).\n */\nfunction calcNumRootNodes(tView, lView, tNode) {\n    const rootNodes = [];\n    collectNativeNodes(tView, lView, tNode, rootNodes);\n    return rootNodes.length;\n}\n/**\n * Computes the number of root nodes in all views in a given LContainer.\n */\nfunction calcNumRootNodesInLContainer(lContainer) {\n    const rootNodes = [];\n    collectNativeNodesInLContainer(lContainer, rootNodes);\n    return rootNodes.length;\n}\n/**\n * Annotates root level component's LView for hydration,\n * see `annotateHostElementForHydration` for additional information.\n */\nfunction annotateComponentLViewForHydration(lView, context, injector) {\n    const hostElement = lView[HOST];\n    // Root elements might also be annotated with the `ngSkipHydration` attribute,\n    // check if it's present before starting the serialization process.\n    if (hostElement && !hostElement.hasAttribute(SKIP_HYDRATION_ATTR_NAME)) {\n        return annotateHostElementForHydration(hostElement, lView, null, context);\n    }\n    return null;\n}\n/**\n * Annotates root level LContainer for hydration. This happens when a root component\n * injects ViewContainerRef, thus making the component an anchor for a view container.\n * This function serializes the component itself as well as all views from the view\n * container.\n */\nfunction annotateLContainerForHydration(lContainer, context, injector) {\n    const componentLView = unwrapLView(lContainer[HOST]);\n    // Serialize the root component itself.\n    const componentLViewNghIndex = annotateComponentLViewForHydration(componentLView, context);\n    if (componentLViewNghIndex === null) {\n        // Component was not serialized (for example, if hydration was skipped by adding\n        // the `ngSkipHydration` attribute or this component uses i18n blocks in the template,\n        // but `withI18nSupport()` was not added), avoid annotating host element with the `ngh`\n        // attribute.\n        return;\n    }\n    const hostElement = unwrapRNode(componentLView[HOST]);\n    // Serialize all views within this view container.\n    const rootLView = lContainer[PARENT];\n    const rootLViewNghIndex = annotateHostElementForHydration(hostElement, rootLView, null, context);\n    const renderer = componentLView[RENDERER];\n    // For cases when a root component also acts as an anchor node for a ViewContainerRef\n    // (for example, when ViewContainerRef is injected in a root component), there is a need\n    // to serialize information about the component itself, as well as an LContainer that\n    // represents this ViewContainerRef. Effectively, we need to serialize 2 pieces of info:\n    // (1) hydration info for the root component itself and (2) hydration info for the\n    // ViewContainerRef instance (an LContainer). Each piece of information is included into\n    // the hydration data (in the TransferState object) separately, thus we end up with 2 ids.\n    // Since we only have 1 root element, we encode both bits of info into a single string:\n    // ids are separated by the `|` char (e.g. `10|25`, where `10` is the ngh for a component view\n    // and 25 is the `ngh` for a root view which holds LContainer).\n    const finalIndex = `${componentLViewNghIndex}|${rootLViewNghIndex}`;\n    renderer.setAttribute(hostElement, NGH_ATTR_NAME, finalIndex);\n}\n/**\n * Annotates all components bootstrapped in a given ApplicationRef\n * with info needed for hydration.\n *\n * @param appRef An instance of an ApplicationRef.\n * @param doc A reference to the current Document instance.\n * @return event types that need to be replayed\n */\nfunction annotateForHydration(appRef, doc) {\n    const injector = appRef.injector;\n    const isI18nHydrationEnabledVal = isI18nHydrationEnabled(injector);\n    const isIncrementalHydrationEnabledVal = isIncrementalHydrationEnabled(injector);\n    const serializedViewCollection = new SerializedViewCollection();\n    const corruptedTextNodes = new Map();\n    const viewRefs = appRef._views;\n    const shouldReplayEvents = injector.get(IS_EVENT_REPLAY_ENABLED, EVENT_REPLAY_ENABLED_DEFAULT);\n    const eventTypesToReplay = {\n        regular: new Set(),\n        capture: new Set(),\n    };\n    const deferBlocks = new Map();\n    const appId = appRef.injector.get(APP_ID);\n    for (const viewRef of viewRefs) {\n        const lNode = getLNodeForHydration(viewRef);\n        // An `lView` might be `null` if a `ViewRef` represents\n        // an embedded view (not a component view).\n        if (lNode !== null) {\n            const context = {\n                serializedViewCollection,\n                corruptedTextNodes,\n                isI18nHydrationEnabled: isI18nHydrationEnabledVal,\n                isIncrementalHydrationEnabled: isIncrementalHydrationEnabledVal,\n                i18nChildren: new Map(),\n                eventTypesToReplay,\n                shouldReplayEvents,\n                appId,\n                deferBlocks,\n            };\n            if (isLContainer(lNode)) {\n                annotateLContainerForHydration(lNode, context);\n            }\n            else {\n                annotateComponentLViewForHydration(lNode, context);\n            }\n            insertCorruptedTextNodeMarkers(corruptedTextNodes, doc);\n        }\n    }\n    // Note: we *always* include hydration info key and a corresponding value\n    // into the TransferState, even if the list of serialized views is empty.\n    // This is needed as a signal to the client that the server part of the\n    // hydration logic was setup and enabled correctly. Otherwise, if a client\n    // hydration doesn't find a key in the transfer state - an error is produced.\n    const serializedViews = serializedViewCollection.getAll();\n    const transferState = injector.get(TransferState);\n    transferState.set(NGH_DATA_KEY, serializedViews);\n    if (deferBlocks.size > 0) {\n        const blocks = {};\n        for (const [id, info] of deferBlocks.entries()) {\n            blocks[id] = info;\n        }\n        transferState.set(NGH_DEFER_BLOCKS_KEY, blocks);\n    }\n    return eventTypesToReplay;\n}\n/**\n * Serializes the lContainer data into a list of SerializedView objects,\n * that represent views within this lContainer.\n *\n * @param lContainer the lContainer we are serializing\n * @param tNode the TNode that contains info about this LContainer\n * @param lView that hosts this LContainer\n * @param parentDeferBlockId the defer block id of the parent if it exists\n * @param context the hydration context\n * @returns an array of the `SerializedView` objects\n */\nfunction serializeLContainer(lContainer, tNode, lView, parentDeferBlockId, context) {\n    const views = [];\n    let lastViewAsString = '';\n    for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {\n        let childLView = lContainer[i];\n        let template;\n        let numRootNodes;\n        let serializedView;\n        if (isRootView(childLView)) {\n            // If this is a root view, get an LView for the underlying component,\n            // because it contains information about the view to serialize.\n            childLView = childLView[HEADER_OFFSET];\n            // If we have an LContainer at this position, this indicates that the\n            // host element was used as a ViewContainerRef anchor (e.g. a `ViewContainerRef`\n            // was injected within the component class). This case requires special handling.\n            if (isLContainer(childLView)) {\n                // Calculate the number of root nodes in all views in a given container\n                // and increment by one to account for an anchor node itself, i.e. in this\n                // scenario we'll have a layout that would look like this:\n                // `<app-root /><#VIEW1><#VIEW2>...<!--container-->`\n                // The `+1` is to capture the `<app-root />` element.\n                numRootNodes = calcNumRootNodesInLContainer(childLView) + 1;\n                annotateLContainerForHydration(childLView, context);\n                const componentLView = unwrapLView(childLView[HOST]);\n                serializedView = {\n                    [TEMPLATE_ID]: componentLView[TVIEW].ssrId,\n                    [NUM_ROOT_NODES]: numRootNodes,\n                };\n            }\n        }\n        if (!serializedView) {\n            const childTView = childLView[TVIEW];\n            if (childTView.type === 1 /* TViewType.Component */) {\n                template = childTView.ssrId;\n                // This is a component view, thus it has only 1 root node: the component\n                // host node itself (other nodes would be inside that host node).\n                numRootNodes = 1;\n            }\n            else {\n                template = getSsrId(childTView);\n                numRootNodes = calcNumRootNodes(childTView, childLView, childTView.firstChild);\n            }\n            serializedView = {\n                [TEMPLATE_ID]: template,\n                [NUM_ROOT_NODES]: numRootNodes,\n            };\n            let isHydrateNeverBlock = false;\n            // If this is a defer block, serialize extra info.\n            if (isDeferBlock(lView[TVIEW], tNode)) {\n                const lDetails = getLDeferBlockDetails(lView, tNode);\n                const tDetails = getTDeferBlockDetails(lView[TVIEW], tNode);\n                if (context.isIncrementalHydrationEnabled && tDetails.hydrateTriggers !== null) {\n                    const deferBlockId = `d${context.deferBlocks.size}`;\n                    if (tDetails.hydrateTriggers.has(7 /* DeferBlockTrigger.Never */)) {\n                        isHydrateNeverBlock = true;\n                    }\n                    let rootNodes = [];\n                    collectNativeNodesInLContainer(lContainer, rootNodes);\n                    // Add defer block into info context.deferBlocks\n                    const deferBlockInfo = {\n                        [NUM_ROOT_NODES]: rootNodes.length,\n                        [DEFER_BLOCK_STATE]: lDetails[DEFER_BLOCK_STATE$1],\n                    };\n                    const serializedTriggers = serializeHydrateTriggers(tDetails.hydrateTriggers);\n                    if (serializedTriggers.length > 0) {\n                        deferBlockInfo[DEFER_HYDRATE_TRIGGERS] = serializedTriggers;\n                    }\n                    if (parentDeferBlockId !== null) {\n                        // Serialize parent id only when it's present.\n                        deferBlockInfo[DEFER_PARENT_BLOCK_ID] = parentDeferBlockId;\n                    }\n                    context.deferBlocks.set(deferBlockId, deferBlockInfo);\n                    const node = unwrapRNode(lContainer);\n                    if (node !== undefined) {\n                        if (node.nodeType === Node.COMMENT_NODE) {\n                            annotateDeferBlockAnchorForHydration(node, deferBlockId);\n                        }\n                    }\n                    else {\n                        ngDevMode && validateNodeExists(node, childLView, tNode);\n                        ngDevMode &&\n                            validateMatchingNode(node, Node.COMMENT_NODE, null, childLView, tNode, true);\n                        annotateDeferBlockAnchorForHydration(node, deferBlockId);\n                    }\n                    if (!isHydrateNeverBlock) {\n                        // Add JSAction attributes for root nodes that use some hydration triggers\n                        annotateDeferBlockRootNodesWithJsAction(tDetails, rootNodes, deferBlockId, context);\n                    }\n                    // Use current block id as parent for nested routes.\n                    parentDeferBlockId = deferBlockId;\n                    // Serialize extra info into the view object.\n                    // TODO(incremental-hydration): this should be serialized and included at a different level\n                    // (not at the view level).\n                    serializedView[DEFER_BLOCK_ID] = deferBlockId;\n                }\n                // DEFER_BLOCK_STATE is used for reconciliation in hydration, both regular and incremental.\n                // We need to know which template is rendered when hydrating. So we serialize this state\n                // regardless of hydration type.\n                serializedView[DEFER_BLOCK_STATE] = lDetails[DEFER_BLOCK_STATE$1];\n            }\n            if (!isHydrateNeverBlock) {\n                Object.assign(serializedView, serializeLView(lContainer[i], parentDeferBlockId, context));\n            }\n        }\n        // Check if the previous view has the same shape (for example, it was\n        // produced by the *ngFor), in which case bump the counter on the previous\n        // view instead of including the same information again.\n        const currentViewAsString = JSON.stringify(serializedView);\n        if (views.length > 0 && currentViewAsString === lastViewAsString) {\n            const previousView = views[views.length - 1];\n            previousView[MULTIPLIER] ??= 1;\n            previousView[MULTIPLIER]++;\n        }\n        else {\n            // Record this view as most recently added.\n            lastViewAsString = currentViewAsString;\n            views.push(serializedView);\n        }\n    }\n    return views;\n}\nfunction serializeHydrateTriggers(triggerMap) {\n    const serializableDeferBlockTrigger = new Set([\n        0 /* DeferBlockTrigger.Idle */,\n        1 /* DeferBlockTrigger.Immediate */,\n        2 /* DeferBlockTrigger.Viewport */,\n        5 /* DeferBlockTrigger.Timer */,\n    ]);\n    let triggers = [];\n    for (let [trigger, details] of triggerMap) {\n        if (serializableDeferBlockTrigger.has(trigger)) {\n            if (details === null) {\n                triggers.push(trigger);\n            }\n            else {\n                triggers.push({ trigger, delay: details.delay });\n            }\n        }\n    }\n    return triggers;\n}\n/**\n * Helper function to produce a node path (which navigation steps runtime logic\n * needs to take to locate a node) and stores it in the `NODES` section of the\n * current serialized view.\n */\nfunction appendSerializedNodePath(ngh, tNode, lView, excludedParentNodes) {\n    const noOffsetIndex = tNode.index - HEADER_OFFSET;\n    ngh[NODES] ??= {};\n    // Ensure we don't calculate the path multiple times.\n    ngh[NODES][noOffsetIndex] ??= calcPathForNode(tNode, lView, excludedParentNodes);\n}\n/**\n * Helper function to append information about a disconnected node.\n * This info is needed at runtime to avoid DOM lookups for this element\n * and instead, the element would be created from scratch.\n */\nfunction appendDisconnectedNodeIndex(ngh, tNodeOrNoOffsetIndex) {\n    const noOffsetIndex = typeof tNodeOrNoOffsetIndex === 'number'\n        ? tNodeOrNoOffsetIndex\n        : tNodeOrNoOffsetIndex.index - HEADER_OFFSET;\n    ngh[DISCONNECTED_NODES] ??= [];\n    if (!ngh[DISCONNECTED_NODES].includes(noOffsetIndex)) {\n        ngh[DISCONNECTED_NODES].push(noOffsetIndex);\n    }\n}\n/**\n * Serializes the lView data into a SerializedView object that will later be added\n * to the TransferState storage and referenced using the `ngh` attribute on a host\n * element.\n *\n * @param lView the lView we are serializing\n * @param context the hydration context\n * @returns the `SerializedView` object containing the data to be added to the host node\n */\nfunction serializeLView(lView, parentDeferBlockId = null, context) {\n    const ngh = {};\n    const tView = lView[TVIEW];\n    const i18nChildren = getOrComputeI18nChildren(tView, context);\n    const nativeElementsToEventTypes = context.shouldReplayEvents\n        ? collectDomEventsInfo(tView, lView, context.eventTypesToReplay)\n        : null;\n    // Iterate over DOM element references in an LView.\n    for (let i = HEADER_OFFSET; i < tView.bindingStartIndex; i++) {\n        const tNode = tView.data[i];\n        const noOffsetIndex = i - HEADER_OFFSET;\n        // Attempt to serialize any i18n data for the given slot. We do this first, as i18n\n        // has its own process for serialization.\n        const i18nData = trySerializeI18nBlock(lView, i, context);\n        if (i18nData) {\n            ngh[I18N_DATA] ??= {};\n            ngh[I18N_DATA][noOffsetIndex] = i18nData.caseQueue;\n            for (const nodeNoOffsetIndex of i18nData.disconnectedNodes) {\n                appendDisconnectedNodeIndex(ngh, nodeNoOffsetIndex);\n            }\n            for (const nodeNoOffsetIndex of i18nData.disjointNodes) {\n                const tNode = tView.data[nodeNoOffsetIndex + HEADER_OFFSET];\n                ngDevMode && assertTNode(tNode);\n                appendSerializedNodePath(ngh, tNode, lView, i18nChildren);\n            }\n            continue;\n        }\n        // Skip processing of a given slot in the following cases:\n        // - Local refs (e.g. <div #localRef>) take up an extra slot in LViews\n        //   to store the same element. In this case, there is no information in\n        //   a corresponding slot in TNode data structure.\n        // - When a slot contains something other than a TNode. For example, there\n        //   might be some metadata information about a defer block or a control flow block.\n        if (!isTNodeShape(tNode)) {\n            continue;\n        }\n        // Skip any nodes that are in an i18n block but are considered detached (i.e. not\n        // present in the template). These nodes are disconnected from the DOM tree, and\n        // so we don't want to serialize any information about them.\n        if (isDetachedByI18n(tNode)) {\n            continue;\n        }\n        // Serialize information about template.\n        if (isLContainer(lView[i]) && tNode.tView) {\n            ngh[TEMPLATES] ??= {};\n            ngh[TEMPLATES][noOffsetIndex] = getSsrId(tNode.tView);\n        }\n        // Check if a native node that represents a given TNode is disconnected from the DOM tree.\n        // Such nodes must be excluded from the hydration (since the hydration won't be able to\n        // find them), so the TNode ids are collected and used at runtime to skip the hydration.\n        // This situation may happen during the content projection, when some nodes don't make it\n        // into one of the content projection slots (for example, when there is no default\n        // <ng-content /> slot in projector component's template).\n        if (isDisconnectedNode(tNode, lView) && isContentProjectedNode(tNode)) {\n            appendDisconnectedNodeIndex(ngh, tNode);\n            continue;\n        }\n        if (Array.isArray(tNode.projection)) {\n            for (const projectionHeadTNode of tNode.projection) {\n                // We may have `null`s in slots with no projected content.\n                if (!projectionHeadTNode)\n                    continue;\n                if (!Array.isArray(projectionHeadTNode)) {\n                    // If we process re-projected content (i.e. `<ng-content>`\n                    // appears at projection location), skip annotations for this content\n                    // since all DOM nodes in this projection were handled while processing\n                    // a parent lView, which contains those nodes.\n                    if (!isProjectionTNode(projectionHeadTNode) &&\n                        !isInSkipHydrationBlock(projectionHeadTNode)) {\n                        if (isDisconnectedNode(projectionHeadTNode, lView)) {\n                            // Check whether this node is connected, since we may have a TNode\n                            // in the data structure as a projection segment head, but the\n                            // content projection slot might be disabled (e.g.\n                            // <ng-content *ngIf=\"false\" />).\n                            appendDisconnectedNodeIndex(ngh, projectionHeadTNode);\n                        }\n                        else {\n                            appendSerializedNodePath(ngh, projectionHeadTNode, lView, i18nChildren);\n                        }\n                    }\n                }\n                else {\n                    // If a value is an array, it means that we are processing a projection\n                    // where projectable nodes were passed in as DOM nodes (for example, when\n                    // calling `ViewContainerRef.createComponent(CmpA, {projectableNodes: [...]})`).\n                    //\n                    // In this scenario, nodes can come from anywhere (either created manually,\n                    // accessed via `document.querySelector`, etc) and may be in any state\n                    // (attached or detached from the DOM tree). As a result, we can not reliably\n                    // restore the state for such cases during hydration.\n                    throw unsupportedProjectionOfDomNodes(unwrapRNode(lView[i]));\n                }\n            }\n        }\n        conditionallyAnnotateNodePath(ngh, tNode, lView, i18nChildren);\n        if (isLContainer(lView[i])) {\n            // Serialize views within this LContainer.\n            const hostNode = lView[i][HOST]; // host node of this container\n            // LView[i][HOST] can be of 2 different types:\n            // - either a DOM node\n            // - or an array that represents an LView of a component\n            if (Array.isArray(hostNode)) {\n                // This is a component, serialize info about it.\n                const targetNode = unwrapRNode(hostNode);\n                if (!targetNode.hasAttribute(SKIP_HYDRATION_ATTR_NAME)) {\n                    annotateHostElementForHydration(targetNode, hostNode, parentDeferBlockId, context);\n                }\n            }\n            ngh[CONTAINERS] ??= {};\n            ngh[CONTAINERS][noOffsetIndex] = serializeLContainer(lView[i], tNode, lView, parentDeferBlockId, context);\n        }\n        else if (Array.isArray(lView[i]) && !isLetDeclaration(tNode)) {\n            // This is a component, annotate the host node with an `ngh` attribute.\n            // Note: Let declarations that return an array are also storing an array in the LView,\n            // we need to exclude them.\n            const targetNode = unwrapRNode(lView[i][HOST]);\n            if (!targetNode.hasAttribute(SKIP_HYDRATION_ATTR_NAME)) {\n                annotateHostElementForHydration(targetNode, lView[i], parentDeferBlockId, context);\n            }\n        }\n        else {\n            // <ng-container> case\n            if (tNode.type & 8 /* TNodeType.ElementContainer */) {\n                // An <ng-container> is represented by the number of\n                // top-level nodes. This information is needed to skip over\n                // those nodes to reach a corresponding anchor node (comment node).\n                ngh[ELEMENT_CONTAINERS] ??= {};\n                ngh[ELEMENT_CONTAINERS][noOffsetIndex] = calcNumRootNodes(tView, lView, tNode.child);\n            }\n            else if (tNode.type & (16 /* TNodeType.Projection */ | 128 /* TNodeType.LetDeclaration */)) {\n                // Current TNode represents an `<ng-content>` slot or `@let` declaration,\n                // thus it has no DOM elements associated with it, so the **next sibling**\n                // node would not be able to find an anchor. In this case, use full path instead.\n                let nextTNode = tNode.next;\n                // Skip over all `<ng-content>` slots and `@let` declarations in a row.\n                while (nextTNode !== null &&\n                    nextTNode.type & (16 /* TNodeType.Projection */ | 128 /* TNodeType.LetDeclaration */)) {\n                    nextTNode = nextTNode.next;\n                }\n                if (nextTNode && !isInSkipHydrationBlock(nextTNode)) {\n                    // Handle a tNode after the `<ng-content>` slot.\n                    appendSerializedNodePath(ngh, nextTNode, lView, i18nChildren);\n                }\n            }\n            else if (tNode.type & 1 /* TNodeType.Text */) {\n                const rNode = unwrapRNode(lView[i]);\n                processTextNodeBeforeSerialization(context, rNode);\n            }\n        }\n        // Attach `jsaction` attribute to elements that have registered listeners,\n        // thus potentially having a need to do an event replay.\n        if (nativeElementsToEventTypes && tNode.type & 2 /* TNodeType.Element */) {\n            const nativeElement = unwrapRNode(lView[i]);\n            if (nativeElementsToEventTypes.has(nativeElement)) {\n                setJSActionAttributes(nativeElement, nativeElementsToEventTypes.get(nativeElement), parentDeferBlockId);\n            }\n        }\n    }\n    return ngh;\n}\n/**\n * Serializes node location in cases when it's needed, specifically:\n *\n *  1. If `tNode.projectionNext` is different from `tNode.next` - it means that\n *     the next `tNode` after projection is different from the one in the original\n *     template. Since hydration relies on `tNode.next`, this serialized info\n *     is required to help runtime code find the node at the correct location.\n *  2. In certain content projection-based use-cases, it's possible that only\n *     a content of a projected element is rendered. In this case, content nodes\n *     require an extra annotation, since runtime logic can't rely on parent-child\n *     connection to identify the location of a node.\n */\nfunction conditionallyAnnotateNodePath(ngh, tNode, lView, excludedParentNodes) {\n    if (isProjectionTNode(tNode)) {\n        // Do not annotate projection nodes (<ng-content />), since\n        // they don't have a corresponding DOM node representing them.\n        return;\n    }\n    // Handle case #1 described above.\n    if (tNode.projectionNext &&\n        tNode.projectionNext !== tNode.next &&\n        !isInSkipHydrationBlock(tNode.projectionNext)) {\n        appendSerializedNodePath(ngh, tNode.projectionNext, lView, excludedParentNodes);\n    }\n    // Handle case #2 described above.\n    // Note: we only do that for the first node (i.e. when `tNode.prev === null`),\n    // the rest of the nodes would rely on the current node location, so no extra\n    // annotation is needed.\n    if (tNode.prev === null &&\n        tNode.parent !== null &&\n        isDisconnectedNode(tNode.parent, lView) &&\n        !isDisconnectedNode(tNode, lView)) {\n        appendSerializedNodePath(ngh, tNode, lView, excludedParentNodes);\n    }\n}\n/**\n * Determines whether a component instance that is represented\n * by a given LView uses `ViewEncapsulation.ShadowDom`.\n */\nfunction componentUsesShadowDomEncapsulation(lView) {\n    const instance = lView[CONTEXT];\n    return instance?.constructor\n        ? getComponentDef(instance.constructor)?.encapsulation === ViewEncapsulation$1.ShadowDom\n        : false;\n}\n/**\n * Annotates component host element for hydration:\n * - by either adding the `ngh` attribute and collecting hydration-related info\n *   for the serialization and transferring to the client\n * - or by adding the `ngSkipHydration` attribute in case Angular detects that\n *   component contents is not compatible with hydration.\n *\n * @param element The Host element to be annotated\n * @param lView The associated LView\n * @param context The hydration context\n * @returns An index of serialized view from the transfer state object\n *          or `null` when a given component can not be serialized.\n */\nfunction annotateHostElementForHydration(element, lView, parentDeferBlockId, context) {\n    const renderer = lView[RENDERER];\n    if ((hasI18n(lView) && !isI18nHydrationSupportEnabled()) ||\n        componentUsesShadowDomEncapsulation(lView)) {\n        // Attach the skip hydration attribute if this component:\n        // - either has i18n blocks, since hydrating such blocks is not yet supported\n        // - or uses ShadowDom view encapsulation, since Domino doesn't support\n        //   shadow DOM, so we can not guarantee that client and server representations\n        //   would exactly match\n        renderer.setAttribute(element, SKIP_HYDRATION_ATTR_NAME, '');\n        return null;\n    }\n    else {\n        const ngh = serializeLView(lView, parentDeferBlockId, context);\n        const index = context.serializedViewCollection.add(ngh);\n        renderer.setAttribute(element, NGH_ATTR_NAME, index.toString());\n        return index;\n    }\n}\n/**\n * Annotates defer block comment node for hydration:\n *\n * @param comment The Host element to be annotated\n * @param deferBlockId the id of the target defer block\n */\nfunction annotateDeferBlockAnchorForHydration(comment, deferBlockId) {\n    comment.textContent = `ngh=${deferBlockId}`;\n}\n/**\n * Physically inserts the comment nodes to ensure empty text nodes and adjacent\n * text node separators are preserved after server serialization of the DOM.\n * These get swapped back for empty text nodes or separators once hydration happens\n * on the client.\n *\n * @param corruptedTextNodes The Map of text nodes to be replaced with comments\n * @param doc The document\n */\nfunction insertCorruptedTextNodeMarkers(corruptedTextNodes, doc) {\n    for (const [textNode, marker] of corruptedTextNodes) {\n        textNode.after(doc.createComment(marker));\n    }\n}\n/**\n * Detects whether a given TNode represents a node that\n * is being content projected.\n */\nfunction isContentProjectedNode(tNode) {\n    let currentTNode = tNode;\n    while (currentTNode != null) {\n        // If we come across a component host node in parent nodes -\n        // this TNode is in the content projection section.\n        if (isComponentHost(currentTNode)) {\n            return true;\n        }\n        currentTNode = currentTNode.parent;\n    }\n    return false;\n}\n/**\n * Incremental hydration requires that any defer block root node\n * with interaction or hover triggers have all of their root nodes\n * trigger hydration with those events. So we need to make sure all\n * the root nodes of that block have the proper jsaction attribute\n * to ensure hydration is triggered, since the content is dehydrated\n */\nfunction annotateDeferBlockRootNodesWithJsAction(tDetails, rootNodes, parentDeferBlockId, context) {\n    const actionList = convertHydrateTriggersToJsAction(tDetails.hydrateTriggers);\n    for (let et of actionList) {\n        context.eventTypesToReplay.regular.add(et);\n    }\n    if (actionList.length > 0) {\n        const elementNodes = rootNodes.filter((rn) => rn.nodeType === Node.ELEMENT_NODE);\n        for (let rNode of elementNodes) {\n            setJSActionAttributes(rNode, actionList, parentDeferBlockId);\n        }\n    }\n}\n\n/**\n * Indicates whether the hydration-related code was added,\n * prevents adding it multiple times.\n */\nlet isHydrationSupportEnabled = false;\n/**\n * Indicates whether the i18n-related code was added,\n * prevents adding it multiple times.\n *\n * Note: This merely controls whether the code is loaded,\n * while `setIsI18nHydrationSupportEnabled` determines\n * whether i18n blocks are serialized or hydrated.\n */\nlet isI18nHydrationRuntimeSupportEnabled = false;\n/**\n * Indicates whether the incremental hydration code was added,\n * prevents adding it multiple times.\n */\nlet isIncrementalHydrationRuntimeSupportEnabled = false;\n/**\n * Defines a period of time that Angular waits for the `ApplicationRef.isStable` to emit `true`.\n * If there was no event with the `true` value during this time, Angular reports a warning.\n */\nconst APPLICATION_IS_STABLE_TIMEOUT = 10_000;\n/**\n * Brings the necessary hydration code in tree-shakable manner.\n * The code is only present when the `provideClientHydration` is\n * invoked. Otherwise, this code is tree-shaken away during the\n * build optimization step.\n *\n * This technique allows us to swap implementations of methods so\n * tree shaking works appropriately when hydration is disabled or\n * enabled. It brings in the appropriate version of the method that\n * supports hydration only when enabled.\n */\nfunction enableHydrationRuntimeSupport() {\n    if (!isHydrationSupportEnabled) {\n        isHydrationSupportEnabled = true;\n        enableRetrieveHydrationInfoImpl();\n        enableLocateOrCreateElementNodeImpl();\n        enableLocateOrCreateTextNodeImpl();\n        enableLocateOrCreateElementContainerNodeImpl();\n        enableLocateOrCreateContainerAnchorImpl();\n        enableLocateOrCreateContainerRefImpl();\n        enableFindMatchingDehydratedViewImpl();\n        enableApplyRootElementTransformImpl();\n    }\n}\n/**\n * Brings the necessary i18n hydration code in tree-shakable manner.\n * Similar to `enableHydrationRuntimeSupport`, the code is only\n * present when `withI18nSupport` is invoked.\n */\nfunction enableI18nHydrationRuntimeSupport() {\n    if (!isI18nHydrationRuntimeSupportEnabled) {\n        isI18nHydrationRuntimeSupportEnabled = true;\n        enableLocateOrCreateI18nNodeImpl();\n        enablePrepareI18nBlockForHydrationImpl();\n        enableClaimDehydratedIcuCaseImpl();\n    }\n}\n/**\n * Brings the necessary incremental hydration code in tree-shakable manner.\n * Similar to `enableHydrationRuntimeSupport`, the code is only\n * present when `enableIncrementalHydrationRuntimeSupport` is invoked.\n */\nfunction enableIncrementalHydrationRuntimeSupport() {\n    if (!isIncrementalHydrationRuntimeSupportEnabled) {\n        isIncrementalHydrationRuntimeSupportEnabled = true;\n        enableRetrieveDeferBlockDataImpl();\n    }\n}\n/**\n * Outputs a message with hydration stats into a console.\n */\nfunction printHydrationStats(injector) {\n    const console = injector.get(Console);\n    const message = `Angular hydrated ${ngDevMode.hydratedComponents} component(s) ` +\n        `and ${ngDevMode.hydratedNodes} node(s), ` +\n        `${ngDevMode.componentsSkippedHydration} component(s) were skipped. ` +\n        (isIncrementalHydrationEnabled(injector)\n            ? `${ngDevMode.deferBlocksWithIncrementalHydration} defer block(s) were configured to use incremental hydration. `\n            : '') +\n        `Learn more at https://angular.dev/guide/hydration.`;\n    // tslint:disable-next-line:no-console\n    console.log(message);\n}\n/**\n * Returns a Promise that is resolved when an application becomes stable.\n */\nfunction whenStableWithTimeout(appRef) {\n    const whenStablePromise = appRef.whenStable();\n    if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n        const timeoutTime = APPLICATION_IS_STABLE_TIMEOUT;\n        const console = appRef.injector.get(Console);\n        const ngZone = appRef.injector.get(NgZone);\n        // The following call should not and does not prevent the app to become stable\n        // We cannot use RxJS timer here because the app would remain unstable.\n        // This also avoids an extra change detection cycle.\n        const timeoutId = ngZone.runOutsideAngular(() => {\n            return setTimeout(() => logWarningOnStableTimedout(timeoutTime, console), timeoutTime);\n        });\n        whenStablePromise.finally(() => clearTimeout(timeoutId));\n    }\n    return whenStablePromise;\n}\n/**\n * Defines a name of an attribute that is added to the <body> tag\n * in the `index.html` file in case a given route was configured\n * with `RenderMode.Client`. 'cm' is an abbreviation for \"Client Mode\".\n */\nconst CLIENT_RENDER_MODE_FLAG = 'ngcm';\n/**\n * Checks whether the `RenderMode.Client` was defined for the current route.\n */\nfunction isClientRenderModeEnabled() {\n    const doc = getDocument();\n    return ((typeof ngServerMode === 'undefined' || !ngServerMode) &&\n        doc.body.hasAttribute(CLIENT_RENDER_MODE_FLAG));\n}\n/**\n * Returns a set of providers required to setup hydration support\n * for an application that is server side rendered. This function is\n * included into the `provideClientHydration` public API function from\n * the `platform-browser` package.\n *\n * The function sets up an internal flag that would be recognized during\n * the server side rendering time as well, so there is no need to\n * configure or change anything in NgUniversal to enable the feature.\n */\nfunction withDomHydration() {\n    const providers = [\n        {\n            provide: IS_HYDRATION_DOM_REUSE_ENABLED,\n            useFactory: () => {\n                let isEnabled = true;\n                if (typeof ngServerMode === 'undefined' || !ngServerMode) {\n                    // On the client, verify that the server response contains\n                    // hydration annotations. Otherwise, keep hydration disabled.\n                    const transferState = inject(TransferState, { optional: true });\n                    isEnabled = !!transferState?.get(NGH_DATA_KEY, null);\n                }\n                if (isEnabled) {\n                    performanceMarkFeature('NgHydration');\n                }\n                return isEnabled;\n            },\n        },\n        {\n            provide: ENVIRONMENT_INITIALIZER,\n            useValue: () => {\n                // i18n support is enabled by calling withI18nSupport(), but there's\n                // no way to turn it off (e.g. for tests), so we turn it off by default.\n                setIsI18nHydrationSupportEnabled(false);\n                if (typeof ngServerMode !== 'undefined' && ngServerMode) {\n                    // Since this function is used across both server and client,\n                    // make sure that the runtime code is only added when invoked\n                    // on the client (see the `enableHydrationRuntimeSupport` function\n                    // call below).\n                    return;\n                }\n                if (inject(IS_HYDRATION_DOM_REUSE_ENABLED)) {\n                    verifySsrContentsIntegrity(getDocument());\n                    enableHydrationRuntimeSupport();\n                }\n                else if (typeof ngDevMode !== 'undefined' && ngDevMode && !isClientRenderModeEnabled()) {\n                    const console = inject(Console);\n                    const message = formatRuntimeError(-505 /* RuntimeErrorCode.MISSING_HYDRATION_ANNOTATIONS */, 'Angular hydration was requested on the client, but there was no ' +\n                        'serialized information present in the server response, ' +\n                        'thus hydration was not enabled. ' +\n                        'Make sure the `provideClientHydration()` is included into the list ' +\n                        'of providers in the server part of the application configuration.');\n                    console.warn(message);\n                }\n            },\n            multi: true,\n        },\n    ];\n    if (typeof ngServerMode === 'undefined' || !ngServerMode) {\n        providers.push({\n            provide: PRESERVE_HOST_CONTENT,\n            useFactory: () => {\n                // Preserve host element content only in a browser\n                // environment and when hydration is configured properly.\n                // On a server, an application is rendered from scratch,\n                // so the host content needs to be empty.\n                return inject(IS_HYDRATION_DOM_REUSE_ENABLED);\n            },\n        }, {\n            provide: APP_BOOTSTRAP_LISTENER,\n            useFactory: () => {\n                if (inject(IS_HYDRATION_DOM_REUSE_ENABLED)) {\n                    const appRef = inject(ApplicationRef);\n                    return () => {\n                        // Wait until an app becomes stable and cleanup all views that\n                        // were not claimed during the application bootstrap process.\n                        // The timing is similar to when we start the serialization process\n                        // on the server.\n                        //\n                        // Note: the cleanup task *MUST* be scheduled within the Angular zone in Zone apps\n                        // to ensure that change detection is properly run afterward.\n                        whenStableWithTimeout(appRef).then(() => {\n                            // Note: we have to check whether the application is destroyed before\n                            // performing other operations with the `injector`.\n                            // The application may be destroyed **before** it becomes stable, so when\n                            // the `whenStableWithTimeout` resolves, the injector might already be in\n                            // a destroyed state. Thus, calling `injector.get` would throw an error\n                            // indicating that the injector has already been destroyed.\n                            if (appRef.destroyed) {\n                                return;\n                            }\n                            cleanupDehydratedViews(appRef);\n                            if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n                                countBlocksSkippedByHydration(appRef.injector);\n                                printHydrationStats(appRef.injector);\n                            }\n                        });\n                    };\n                }\n                return () => { }; // noop\n            },\n            multi: true,\n        });\n    }\n    return makeEnvironmentProviders(providers);\n}\n/**\n * Returns a set of providers required to setup support for i18n hydration.\n * Requires hydration to be enabled separately.\n */\nfunction withI18nSupport() {\n    return [\n        {\n            provide: IS_I18N_HYDRATION_ENABLED,\n            useFactory: () => inject(IS_HYDRATION_DOM_REUSE_ENABLED),\n        },\n        {\n            provide: ENVIRONMENT_INITIALIZER,\n            useValue: () => {\n                if (inject(IS_HYDRATION_DOM_REUSE_ENABLED)) {\n                    enableI18nHydrationRuntimeSupport();\n                    setIsI18nHydrationSupportEnabled(true);\n                    performanceMarkFeature('NgI18nHydration');\n                }\n            },\n            multi: true,\n        },\n    ];\n}\n/**\n * Returns a set of providers required to setup support for incremental hydration.\n * Requires hydration to be enabled separately.\n * Enabling incremental hydration also enables event replay for the entire app.\n */\nfunction withIncrementalHydration() {\n    const providers = [\n        withEventReplay(),\n        {\n            provide: IS_INCREMENTAL_HYDRATION_ENABLED,\n            useValue: true,\n        },\n        {\n            provide: DEHYDRATED_BLOCK_REGISTRY,\n            useClass: DehydratedBlockRegistry,\n        },\n        {\n            provide: ENVIRONMENT_INITIALIZER,\n            useValue: () => {\n                enableIncrementalHydrationRuntimeSupport();\n                performanceMarkFeature('NgIncrementalHydration');\n            },\n            multi: true,\n        },\n    ];\n    if (typeof ngServerMode === 'undefined' || !ngServerMode) {\n        providers.push({\n            provide: APP_BOOTSTRAP_LISTENER,\n            useFactory: () => {\n                const injector = inject(Injector);\n                const doc = getDocument();\n                return () => {\n                    const deferBlockData = processBlockData(injector);\n                    const commentsByBlockId = gatherDeferBlocksCommentNodes(doc, doc.body);\n                    processAndInitTriggers(injector, deferBlockData, commentsByBlockId);\n                    appendDeferBlocksToJSActionMap(doc, injector);\n                };\n            },\n            multi: true,\n        });\n    }\n    return providers;\n}\n/**\n *\n * @param time The time in ms until the stable timedout warning message is logged\n */\nfunction logWarningOnStableTimedout(time, console) {\n    const message = `Angular hydration expected the ApplicationRef.isStable() to emit \\`true\\`, but it ` +\n        `didn't happen within ${time}ms. Angular hydration logic depends on the application becoming stable ` +\n        `as a signal to complete hydration process.`;\n    console.warn(formatRuntimeError(-506 /* RuntimeErrorCode.HYDRATION_STABLE_TIMEDOUT */, message));\n}\n\n/**\n * Transforms a value (typically a string) to a boolean.\n * Intended to be used as a transform function of an input.\n *\n *  @usageNotes\n *  ```ts\n *  status = input({ transform: booleanAttribute });\n *  ```\n * @param value Value to be transformed.\n *\n * @publicApi\n */\nfunction booleanAttribute(value) {\n    return typeof value === 'boolean' ? value : value != null && value !== 'false';\n}\n/**\n * Transforms a value (typically a string) to a number.\n * Intended to be used as a transform function of an input.\n * @param value Value to be transformed.\n * @param fallbackValue Value to use if the provided value can't be parsed as a number.\n *\n *  @usageNotes\n *  ```ts\n *  status = input({ transform: numberAttribute });\n *  ```\n *\n * @publicApi\n */\nfunction numberAttribute(value, fallbackValue = NaN) {\n    // parseFloat(value) handles most of the cases we're interested in (it treats null, empty string,\n    // and other non-number values as NaN, where Number just uses 0) but it considers the string\n    // '123hello' to be a valid number. Therefore we also check if Number(value) is NaN.\n    const isNumberValue = !isNaN(parseFloat(value)) && !isNaN(Number(value));\n    return isNumberValue ? Number(value) : fallbackValue;\n}\n\nconst PERFORMANCE_MARK_PREFIX = '';\nlet enablePerfLogging = false;\n/**\n * Function that will start measuring against the performance API\n * Should be used in pair with stopMeasuring\n */\nfunction startMeasuring(label) {\n    if (!enablePerfLogging) {\n        return;\n    }\n    const { startLabel } = labels(label);\n    /* tslint:disable:ban */\n    performance.mark(startLabel);\n    /* tslint:enable:ban */\n}\n/**\n * Function that will stop measuring against the performance API\n * Should be used in pair with startMeasuring\n */\nfunction stopMeasuring(label) {\n    if (!enablePerfLogging) {\n        return;\n    }\n    const { startLabel, labelName, endLabel } = labels(label);\n    /* tslint:disable:ban */\n    performance.mark(endLabel);\n    performance.measure(labelName, startLabel, endLabel);\n    performance.clearMarks(startLabel);\n    performance.clearMarks(endLabel);\n    /* tslint:enable:ban */\n}\nfunction labels(label) {\n    const labelName = `${PERFORMANCE_MARK_PREFIX}:${label}`;\n    return {\n        labelName,\n        startLabel: `start:${labelName}`,\n        endLabel: `end:${labelName}`,\n    };\n}\nlet warningLogged = false;\n/**\n * This enables an internal performance profiler\n *\n * It should not be imported in application code\n */\nfunction enableProfiling() {\n    if (!warningLogged &&\n        (typeof performance === 'undefined' || !performance.mark || !performance.measure)) {\n        warningLogged = true;\n        console.warn('Performance API is not supported on this platform');\n        return;\n    }\n    enablePerfLogging = true;\n}\nfunction disableProfiling() {\n    enablePerfLogging = false;\n}\n\n/*!\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n/**\n * Gets the class name of the closest component to a node.\n * Warning! this function will return minified names if the name of the component is minified. The\n * consumer of the function is responsible for resolving the minified name to its original name.\n * @param node Node from which to start the search.\n */\nfunction getClosestComponentName(node) {\n    let currentNode = node;\n    while (currentNode) {\n        const lView = readPatchedLView(currentNode);\n        if (lView !== null) {\n            for (let i = HEADER_OFFSET; i < lView.length; i++) {\n                const current = lView[i];\n                if ((!isLView(current) && !isLContainer(current)) || current[HOST] !== currentNode) {\n                    continue;\n                }\n                const tView = lView[TVIEW];\n                const tNode = getTNode(tView, i);\n                if (isComponentHost(tNode)) {\n                    const def = tView.data[tNode.directiveStart + tNode.componentOffset];\n                    const name = def.debugInfo?.className || def.type.name;\n                    // Note: the name may be an empty string if the class name is\n                    // dropped due to minification. In such cases keep going up the tree.\n                    if (name) {\n                        return name;\n                    }\n                    else {\n                        break;\n                    }\n                }\n            }\n        }\n        currentNode = currentNode.parentNode;\n    }\n    return null;\n}\n\n/*!\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n/**\n * Utility function used during template type checking to assert that a value is of a certain type.\n * @codeGenApi\n */\nfunction assertType(value) { }\n\n/**\n * Compiles a partial directive declaration object into a full directive definition object.\n *\n * @codeGenApi\n */\nfunction ngDeclareDirective(decl) {\n    const compiler = getCompilerFacade({\n        usage: 1 /* JitCompilerUsage.PartialDeclaration */,\n        kind: 'directive',\n        type: decl.type,\n    });\n    return compiler.compileDirectiveDeclaration(angularCoreEnv, `ng:///${decl.type.name}/fac.js`, decl);\n}\n/**\n * Evaluates the class metadata declaration.\n *\n * @codeGenApi\n */\nfunction ngDeclareClassMetadata(decl) {\n    setClassMetadata(decl.type, decl.decorators, decl.ctorParameters ?? null, decl.propDecorators ?? null);\n}\n/**\n * Evaluates the class metadata of a component that contains deferred blocks.\n *\n * @codeGenApi\n */\nfunction ngDeclareClassMetadataAsync(decl) {\n    setClassMetadataAsync(decl.type, decl.resolveDeferredDeps, (...types) => {\n        const meta = decl.resolveMetadata(...types);\n        setClassMetadata(decl.type, meta.decorators, meta.ctorParameters, meta.propDecorators);\n    });\n}\n/**\n * Compiles a partial component declaration object into a full component definition object.\n *\n * @codeGenApi\n */\nfunction ngDeclareComponent(decl) {\n    const compiler = getCompilerFacade({\n        usage: 1 /* JitCompilerUsage.PartialDeclaration */,\n        kind: 'component',\n        type: decl.type,\n    });\n    return compiler.compileComponentDeclaration(angularCoreEnv, `ng:///${decl.type.name}/cmp.js`, decl);\n}\n/**\n * Compiles a partial pipe declaration object into a full pipe definition object.\n *\n * @codeGenApi\n */\nfunction ngDeclareFactory(decl) {\n    const compiler = getCompilerFacade({\n        usage: 1 /* JitCompilerUsage.PartialDeclaration */,\n        kind: getFactoryKind(decl.target),\n        type: decl.type,\n    });\n    return compiler.compileFactoryDeclaration(angularCoreEnv, `ng:///${decl.type.name}/fac.js`, decl);\n}\nfunction getFactoryKind(target) {\n    switch (target) {\n        case FactoryTarget.Directive:\n            return 'directive';\n        case FactoryTarget.Component:\n            return 'component';\n        case FactoryTarget.Injectable:\n            return 'injectable';\n        case FactoryTarget.Pipe:\n            return 'pipe';\n        case FactoryTarget.NgModule:\n            return 'NgModule';\n    }\n}\n/**\n * Compiles a partial injectable declaration object into a full injectable definition object.\n *\n * @codeGenApi\n */\nfunction ngDeclareInjectable(decl) {\n    const compiler = getCompilerFacade({\n        usage: 1 /* JitCompilerUsage.PartialDeclaration */,\n        kind: 'injectable',\n        type: decl.type,\n    });\n    return compiler.compileInjectableDeclaration(angularCoreEnv, `ng:///${decl.type.name}/prov.js`, decl);\n}\n/**\n * Compiles a partial injector declaration object into a full injector definition object.\n *\n * @codeGenApi\n */\nfunction ngDeclareInjector(decl) {\n    const compiler = getCompilerFacade({\n        usage: 1 /* JitCompilerUsage.PartialDeclaration */,\n        kind: 'NgModule',\n        type: decl.type,\n    });\n    return compiler.compileInjectorDeclaration(angularCoreEnv, `ng:///${decl.type.name}/inj.js`, decl);\n}\n/**\n * Compiles a partial NgModule declaration object into a full NgModule definition object.\n *\n * @codeGenApi\n */\nfunction ngDeclareNgModule(decl) {\n    const compiler = getCompilerFacade({\n        usage: 1 /* JitCompilerUsage.PartialDeclaration */,\n        kind: 'NgModule',\n        type: decl.type,\n    });\n    return compiler.compileNgModuleDeclaration(angularCoreEnv, `ng:///${decl.type.name}/mod.js`, decl);\n}\n/**\n * Compiles a partial pipe declaration object into a full pipe definition object.\n *\n * @codeGenApi\n */\nfunction ngDeclarePipe(decl) {\n    const compiler = getCompilerFacade({\n        usage: 1 /* JitCompilerUsage.PartialDeclaration */,\n        kind: 'pipe',\n        type: decl.type,\n    });\n    return compiler.compilePipeDeclaration(angularCoreEnv, `ng:///${decl.type.name}/pipe.js`, decl);\n}\n\nconst NOT_SET = /* @__PURE__ */ Symbol('NOT_SET');\nconst EMPTY_CLEANUP_SET = /* @__PURE__ */ new Set();\nconst AFTER_RENDER_PHASE_EFFECT_NODE = /* @__PURE__ */ (() => ({\n    ...SIGNAL_NODE,\n    consumerIsAlwaysLive: true,\n    consumerAllowSignalWrites: true,\n    value: NOT_SET,\n    cleanup: null,\n    /** Called when the effect becomes dirty */\n    consumerMarkedDirty() {\n        if (this.sequence.impl.executing) {\n            // If hooks are in the middle of executing, then it matters whether this node has yet been\n            // executed within its sequence. If not, then we don't want to notify the scheduler since\n            // this node will be reached naturally.\n            if (this.sequence.lastPhase === null || this.sequence.lastPhase < this.phase) {\n                return;\n            }\n            // If during the execution of a later phase an earlier phase became dirty, then we should not\n            // run any further phases until the earlier one reruns.\n            this.sequence.erroredOrDestroyed = true;\n        }\n        // Either hooks are not running, or we're marking a node dirty that has already run within its\n        // sequence.\n        this.sequence.scheduler.notify(7 /* NotificationSource.RenderHook */);\n    },\n    phaseFn(previousValue) {\n        this.sequence.lastPhase = this.phase;\n        if (!this.dirty) {\n            return this.signal;\n        }\n        this.dirty = false;\n        if (this.value !== NOT_SET && !consumerPollProducersForChange(this)) {\n            // None of our producers report a change since the last time they were read, so no\n            // recomputation of our value is necessary.\n            return this.signal;\n        }\n        // Run any needed cleanup functions.\n        try {\n            for (const cleanupFn of this.cleanup ?? EMPTY_CLEANUP_SET) {\n                cleanupFn();\n            }\n        }\n        finally {\n            // Even if a cleanup function errors, ensure it's cleared.\n            this.cleanup?.clear();\n        }\n        // Prepare to call the user's effect callback. If there was a previous phase, then it gave us\n        // its value as a `Signal`, otherwise `previousValue` will be `undefined`.\n        const args = [];\n        if (previousValue !== undefined) {\n            args.push(previousValue);\n        }\n        args.push(this.registerCleanupFn);\n        // Call the user's callback in our reactive context.\n        const prevConsumer = consumerBeforeComputation(this);\n        let newValue;\n        try {\n            newValue = this.userFn.apply(null, args);\n        }\n        finally {\n            consumerAfterComputation(this, prevConsumer);\n        }\n        if (this.value === NOT_SET || !this.equal(this.value, newValue)) {\n            this.value = newValue;\n            this.version++;\n        }\n        return this.signal;\n    },\n}))();\n/**\n * An `AfterRenderSequence` that manages an `afterRenderEffect`'s phase effects.\n */\nclass AfterRenderEffectSequence extends AfterRenderSequence {\n    scheduler;\n    /**\n     * While this sequence is executing, this tracks the last phase which was called by the\n     * `afterRender` machinery.\n     *\n     * When a phase effect is marked dirty, this is used to determine whether it's already run or not.\n     */\n    lastPhase = null;\n    /**\n     * The reactive nodes for each phase, if a phase effect is defined for that phase.\n     *\n     * These are initialized to `undefined` but set in the constructor.\n     */\n    nodes = [undefined, undefined, undefined, undefined];\n    constructor(impl, effectHooks, view, scheduler, injector, snapshot = null) {\n        // Note that we also initialize the underlying `AfterRenderSequence` hooks to `undefined` and\n        // populate them as we create reactive nodes below.\n        super(impl, [undefined, undefined, undefined, undefined], view, false, injector.get(DestroyRef), snapshot);\n        this.scheduler = scheduler;\n        // Setup a reactive node for each phase.\n        for (const phase of AFTER_RENDER_PHASES) {\n            const effectHook = effectHooks[phase];\n            if (effectHook === undefined) {\n                continue;\n            }\n            const node = Object.create(AFTER_RENDER_PHASE_EFFECT_NODE);\n            node.sequence = this;\n            node.phase = phase;\n            node.userFn = effectHook;\n            node.dirty = true;\n            node.signal = (() => {\n                producerAccessed(node);\n                return node.value;\n            });\n            node.signal[SIGNAL] = node;\n            node.registerCleanupFn = (fn) => (node.cleanup ??= new Set()).add(fn);\n            this.nodes[phase] = node;\n            // Install the upstream hook which runs the `phaseFn` for this phase.\n            this.hooks[phase] = (value) => node.phaseFn(value);\n            if (ngDevMode) {\n                setupDebugInfo(node, injector);\n            }\n        }\n    }\n    afterRun() {\n        super.afterRun();\n        // We're done running this sequence, so reset `lastPhase`.\n        this.lastPhase = null;\n    }\n    destroy() {\n        super.destroy();\n        // Run the cleanup functions for each node.\n        for (const node of this.nodes) {\n            if (node) {\n                try {\n                    for (const fn of node.cleanup ?? EMPTY_CLEANUP_SET) {\n                        fn();\n                    }\n                }\n                finally {\n                    consumerDestroy(node);\n                }\n            }\n        }\n    }\n}\n/**\n * @publicApi\n */\nfunction afterRenderEffect(callbackOrSpec, options) {\n    ngDevMode &&\n        assertNotInReactiveContext(afterRenderEffect, 'Call `afterRenderEffect` outside of a reactive context. For example, create the render ' +\n            'effect inside the component constructor`.');\n    if (ngDevMode && !options?.injector) {\n        assertInInjectionContext(afterRenderEffect);\n    }\n    if (typeof ngServerMode !== 'undefined' && ngServerMode) {\n        return NOOP_AFTER_RENDER_REF;\n    }\n    const injector = options?.injector ?? inject(Injector);\n    const scheduler = injector.get(ChangeDetectionScheduler);\n    const manager = injector.get(AfterRenderManager);\n    const tracing = injector.get(TracingService, null, { optional: true });\n    manager.impl ??= injector.get(AfterRenderImpl);\n    let spec = callbackOrSpec;\n    if (typeof spec === 'function') {\n        spec = { mixedReadWrite: callbackOrSpec };\n    }\n    const viewContext = injector.get(ViewContext, null, { optional: true });\n    const sequence = new AfterRenderEffectSequence(manager.impl, [spec.earlyRead, spec.write, spec.mixedReadWrite, spec.read], viewContext?.view, scheduler, injector, tracing?.snapshot(null));\n    manager.impl.register(sequence);\n    return sequence;\n}\nfunction setupDebugInfo(node, injector) {\n    node.debugName = `afterRenderEffect - ${phaseDebugName(node.phase)} phase`;\n    const prevInjectorProfilerContext = setInjectorProfilerContext({ injector, token: null });\n    try {\n        emitEffectCreatedEvent({ [SIGNAL]: node, destroy() { } });\n    }\n    finally {\n        setInjectorProfilerContext(prevInjectorProfilerContext);\n    }\n}\nfunction phaseDebugName(phase) {\n    switch (phase) {\n        case 0 /* AfterRenderPhase.EarlyRead */:\n            return 'EarlyRead';\n        case 1 /* AfterRenderPhase.Write */:\n            return 'Write';\n        case 2 /* AfterRenderPhase.MixedReadWrite */:\n            return 'MixedReadWrite';\n        case 3 /* AfterRenderPhase.Read */:\n            return 'Read';\n    }\n}\n\n/**\n * Creates a `ComponentRef` instance based on provided component type and a set of options.\n *\n * @usageNotes\n *\n * The example below demonstrates how the `createComponent` function can be used\n * to create an instance of a ComponentRef dynamically and attach it to an ApplicationRef,\n * so that it gets included into change detection cycles.\n *\n * Note: the example uses standalone components, but the function can also be used for\n * non-standalone components (declared in an NgModule) as well.\n *\n * ```angular-ts\n * @Component({\n *   standalone: true,\n *   template: `Hello {{ name }}!`\n * })\n * class HelloComponent {\n *   name = 'Angular';\n * }\n *\n * @Component({\n *   standalone: true,\n *   template: `<div id=\"hello-component-host\"></div>`\n * })\n * class RootComponent {}\n *\n * // Bootstrap an application.\n * const applicationRef = await bootstrapApplication(RootComponent);\n *\n * // Locate a DOM node that would be used as a host.\n * const hostElement = document.getElementById('hello-component-host');\n *\n * // Get an `EnvironmentInjector` instance from the `ApplicationRef`.\n * const environmentInjector = applicationRef.injector;\n *\n * // We can now create a `ComponentRef` instance.\n * const componentRef = createComponent(HelloComponent, {hostElement, environmentInjector});\n *\n * // Last step is to register the newly created ref using the `ApplicationRef` instance\n * // to include the component view into change detection cycles.\n * applicationRef.attachView(componentRef.hostView);\n * componentRef.changeDetectorRef.detectChanges();\n * ```\n *\n * @param component Component class reference.\n * @param options Set of options to use:\n *  * `environmentInjector`: An `EnvironmentInjector` instance to be used for the component.\n *  * `hostElement` (optional): A DOM node that should act as a host node for the component. If not\n * provided, Angular creates one based on the tag name used in the component selector (and falls\n * back to using `div` if selector doesn't have tag name info).\n *  * `elementInjector` (optional): An `ElementInjector` instance, see additional info about it\n * [here](guide/di/hierarchical-dependency-injection#elementinjector).\n *  * `projectableNodes` (optional): A list of DOM nodes that should be projected through\n * [`<ng-content>`](api/core/ng-content) of the new component instance, e.g.,\n * `[[element1, element2]]`: projects `element1` and `element2` into the same `<ng-content>`.\n * `[[element1, element2], [element3]]`: projects `element1` and `element2` into one `<ng-content>`,\n * and `element3` into a separate `<ng-content>`.\n *  * `directives` (optional): Directives that should be applied to the component.\n *  * `bindings` (optional): Bindings to apply to the root component.\n * @returns ComponentRef instance that represents a given Component.\n *\n * @publicApi\n */\nfunction createComponent(component, options) {\n    ngDevMode && assertComponentDef(component);\n    const componentDef = getComponentDef(component);\n    const elementInjector = options.elementInjector || getNullInjector();\n    const factory = new ComponentFactory(componentDef);\n    return factory.create(elementInjector, options.projectableNodes, options.hostElement, options.environmentInjector, options.directives, options.bindings);\n}\n/**\n * Creates an object that allows to retrieve component metadata.\n *\n * @usageNotes\n *\n * The example below demonstrates how to use the function and how the fields\n * of the returned object map to the component metadata.\n *\n * ```angular-ts\n * @Component({\n *   standalone: true,\n *   selector: 'foo-component',\n *   template: `\n *     <ng-content></ng-content>\n *     <ng-content select=\"content-selector-a\"></ng-content>\n *   `,\n * })\n * class FooComponent {\n *   @Input('inputName') inputPropName: string;\n *   @Output('outputName') outputPropName = new EventEmitter<void>();\n * }\n *\n * const mirror = reflectComponentType(FooComponent);\n * expect(mirror.type).toBe(FooComponent);\n * expect(mirror.selector).toBe('foo-component');\n * expect(mirror.isStandalone).toBe(true);\n * expect(mirror.inputs).toEqual([{propName: 'inputName', templateName: 'inputPropName'}]);\n * expect(mirror.outputs).toEqual([{propName: 'outputName', templateName: 'outputPropName'}]);\n * expect(mirror.ngContentSelectors).toEqual([\n *   '*',                 // first `<ng-content>` in a template, the selector defaults to `*`\n *   'content-selector-a' // second `<ng-content>` in a template\n * ]);\n * ```\n *\n * @param component Component class reference.\n * @returns An object that allows to retrieve component metadata.\n *\n * @publicApi\n */\nfunction reflectComponentType(component) {\n    const componentDef = getComponentDef(component);\n    if (!componentDef)\n        return null;\n    const factory = new ComponentFactory(componentDef);\n    return {\n        get selector() {\n            return factory.selector;\n        },\n        get type() {\n            return factory.componentType;\n        },\n        get inputs() {\n            return factory.inputs;\n        },\n        get outputs() {\n            return factory.outputs;\n        },\n        get ngContentSelectors() {\n            return factory.ngContentSelectors;\n        },\n        get isStandalone() {\n            return componentDef.standalone;\n        },\n        get isSignal() {\n            return componentDef.signals;\n        },\n    };\n}\n\n/**\n * Merge multiple application configurations from left to right.\n *\n * @param configs Two or more configurations to be merged.\n * @returns A merged [ApplicationConfig](api/core/ApplicationConfig).\n *\n * @publicApi\n */\nfunction mergeApplicationConfig(...configs) {\n    return configs.reduce((prev, curr) => {\n        return Object.assign(prev, curr, { providers: [...prev.providers, ...curr.providers] });\n    }, { providers: [] });\n}\n\n/**\n * Injection token representing the current HTTP request object.\n *\n * Use this token to access the current request when handling server-side\n * rendering (SSR).\n *\n * @remarks\n * This token may be `null` in the following scenarios:\n *\n * * During the build processes.\n * * When the application is rendered in the browser (client-side rendering).\n * * When performing static site generation (SSG).\n * * During route extraction in development (at the time of the request).\n *\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Request `Request` on MDN}\n *\n * @publicApi\n */\nconst REQUEST = new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'REQUEST' : '', {\n    providedIn: 'platform',\n    factory: () => null,\n});\n/**\n * Injection token for response initialization options.\n *\n * Use this token to provide response options for configuring or initializing\n * HTTP responses in server-side rendering or API endpoints.\n *\n * @remarks\n * This token may be `null` in the following scenarios:\n *\n * * During the build processes.\n * * When the application is rendered in the browser (client-side rendering).\n * * When performing static site generation (SSG).\n * * During route extraction in development (at the time of the request).\n *\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Response/Response `ResponseInit` on MDN}\n *\n * @publicApi\n */\nconst RESPONSE_INIT = new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'RESPONSE_INIT' : '', {\n    providedIn: 'platform',\n    factory: () => null,\n});\n/**\n * Injection token for additional request context.\n *\n * Use this token to pass custom metadata or context related to the current request in server-side rendering.\n *\n * @remarks\n * This token is only available during server-side rendering and will be `null` in other contexts.\n *\n * @publicApi\n */\nconst REQUEST_CONTEXT = new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'REQUEST_CONTEXT' : '', {\n    providedIn: 'platform',\n    factory: () => null,\n});\n\nexport { APP_BOOTSTRAP_LISTENER, APP_ID, ApplicationInitStatus, ApplicationModule, ApplicationRef, COMPILER_OPTIONS, ChangeDetectorRef, ContentChild, ContentChildren, DefaultIterableDiffer, DestroyRef, ENVIRONMENT_INITIALIZER, EmbeddedViewRef, ErrorHandler, HOST_TAG_NAME, HostAttributeToken, Injectable, InjectionToken, Injector, IterableDiffers, KeyValueDiffers, LOCALE_ID, NgModule, NgZone, OutputEmitterRef, PLATFORM_INITIALIZER, PlatformRef, Query, REQUEST, REQUEST_CONTEXT, RESPONSE_INIT, TransferState, ViewChild, ViewChildren, ViewEncapsulation$1 as ViewEncapsulation, ViewRef, afterRenderEffect, assertInInjectionContext, assertNotInReactiveContext, assertPlatform, booleanAttribute, contentChild, contentChildren, createComponent, createPlatform, createPlatformFactory, destroyPlatform, enableProdMode, getModuleFactory, getNgModuleById, getPlatform, inject, input, isDevMode, makeEnvironmentProviders, mergeApplicationConfig, model, numberAttribute, output, platformCore, provideCheckNoChangesConfig, provideEnvironmentInitializer, providePlatformInitializer, reflectComponentType, runInInjectionContext, viewChild, viewChildren, AfterRenderManager as AfterRenderManager, CLIENT_RENDER_MODE_FLAG as CLIENT_RENDER_MODE_FLAG, CONTAINER_HEADER_OFFSET as CONTAINER_HEADER_OFFSET, ChangeDetectionScheduler as ChangeDetectionScheduler, ChangeDetectionSchedulerImpl as ChangeDetectionSchedulerImpl, Console as Console, DEFAULT_LOCALE_ID as DEFAULT_LOCALE_ID, DEHYDRATED_BLOCK_REGISTRY as DEHYDRATED_BLOCK_REGISTRY, ENABLE_ROOT_COMPONENT_BOOTSTRAP as ENABLE_ROOT_COMPONENT_BOOTSTRAP, IMAGE_CONFIG as IMAGE_CONFIG, INJECTOR_SCOPE as INJECTOR_SCOPE, INPUT_SIGNAL_BRAND_WRITE_TYPE, INTERNAL_APPLICATION_ERROR_HANDLER as INTERNAL_APPLICATION_ERROR_HANDLER, IS_HYDRATION_DOM_REUSE_ENABLED as IS_HYDRATION_DOM_REUSE_ENABLED, IS_INCREMENTAL_HYDRATION_ENABLED as IS_INCREMENTAL_HYDRATION_ENABLED, JSACTION_BLOCK_ELEMENT_MAP as JSACTION_BLOCK_ELEMENT_MAP, JSACTION_EVENT_CONTRACT as JSACTION_EVENT_CONTRACT, NgModuleFactory as NgModuleFactory, PERFORMANCE_MARK_PREFIX as PERFORMANCE_MARK_PREFIX, PROVIDED_NG_ZONE as PROVIDED_NG_ZONE, PendingTasksInternal as PendingTasksInternal, ComponentFactory as Render3ComponentFactory, RuntimeError as RuntimeError, SIGNAL as SIGNAL, TracingService as TracingService, ViewRef$1 as ViewRef, annotateForHydration as annotateForHydration, assertType, compileNgModuleFactory as compileNgModuleFactory, createOrReusePlatformInjector as createOrReusePlatformInjector, defaultIterableDiffers as defaultIterableDiffers, defaultKeyValueDiffers as defaultKeyValueDiffers, disableProfiling as disableProfiling, enableProfiling as enableProfiling, formatRuntimeError as formatRuntimeError, getClosestComponentName as getClosestComponentName, getComponentDef as getComponentDef, getDocument as getDocument, _global as global, injectChangeDetectorRef as injectChangeDetectorRef, internalCreateApplication as internalCreateApplication, internalProvideZoneChangeDetection as internalProvideZoneChangeDetection, isPromise as isPromise, performanceMarkFeature as performanceMarkFeature, resolveComponentResources as resolveComponentResources, setClassMetadata as setClassMetadata, setClassMetadataAsync as setClassMetadataAsync, setInjectorProfilerContext as setInjectorProfilerContext, setLocaleId as setLocaleId, startMeasuring as startMeasuring, stopMeasuring as stopMeasuring, stringify as stringify, withDomHydration as withDomHydration, withEventReplay as withEventReplay, withI18nSupport as withI18nSupport, withIncrementalHydration as withIncrementalHydration, FactoryTarget as FactoryTarget, __defineInjectable as defineInjectable, __defineInjector as defineInjector, __defineNgModule as defineNgModule, __inject as inject, __injectAttribute as injectAttribute, ngDeclareClassMetadata, ngDeclareClassMetadataAsync, ngDeclareComponent, ngDeclareDirective, ngDeclareFactory, ngDeclareInjectable, ngDeclareInjector, ngDeclareNgModule, ngDeclarePipe };\n"],"x_google_ignoreList":[0,1]}