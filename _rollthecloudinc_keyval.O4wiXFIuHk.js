import { a as E } from "@nf-internal/chunk-SAS4U2ED";
import { a as D } from "@nf-internal/chunk-CAFTJBEE";
import "@nf-internal/chunk-LVWEWWR5";
import { a as w, b as x, h as M, k as O } from "@nf-internal/chunk-GL2BOVXA";
var F = M(E(), 1), I = M(D(), 1);
import * as f from "@angular/core";
import { PLATFORM_ID as V } from "@angular/core";
import * as v from "@rollthecloudinc/crud";
import { CrudAdaptorPlugin as b, CrudModule as N } from "@rollthecloudinc/crud";
import { from as y, Observable as g, of as u } from "rxjs";
import { switchMap as a, map as d, filter as R, reduce as S, defaultIfEmpty as K, catchError as P } from "rxjs/operators";
import { isPlatformBrowser as k } from "@angular/common";
import * as A from "@rollthecloudinc/dparam";
var j = l => O(null, null, function* () { return k(l) ? yield import("@nf-internal/dist-FPZVN5BX") : { set: () => Promise.resolve(void 0), keys: () => Promise.resolve([]), getMany: () => Promise.resolve([]), setMany: () => Promise.resolve(void 0) }; }), _ = (l, h) => new b({ id: "idb_keyval", title: "Idb Keyval", create: ({ object: s, identity: p, params: o, parentObject: c }) => u({ success: !1 }).pipe(a(() => p({ object: s, parentObject: c }).pipe(d(({ identity: t }) => ({ identity: t })))), a(({ identity: t }) => o && Object.keys(o).length !== 0 ? l.paramValues(new Map(Object.entries(o))).pipe(d(n => Array.from(n.entries()).reduce((r, [e, i]) => x(w({}, r), { [e]: i }), {})), d(n => ({ identity: t, options: n }))) : u({ identity: t, options: {} })), d(({ identity: t, options: n }) => ({ name: n.prefix + t, object: s })), a(({ name: t, object: n }) => y(j(h)).pipe(a(({ set: r }) => new g(e => { r(t, n).then(i => { console.log("idb write succeeded"), console.log(i), e.next({ success: !0 }), e.complete(); }).catch(i => { console.log("idb write failed"), console.log(i), e.next({ success: !1 }), e.complete(); }); })))), P(t => (console.error("Error in create stream:", t), u({ success: !1, error: t.message })))), read: ({}) => u({ success: !1 }), update: ({ object: s, identity: p, params: o, parentObject: c }) => u({ success: !1 }).pipe(a(() => p({ object: s, parentObject: c }).pipe(d(({ identity: t }) => ({ identity: t })))), a(({ identity: t }) => o && Object.keys(o).length !== 0 ? l.paramValues(new Map(Object.entries(o))).pipe(d(n => Array.from(n.entries()).reduce((r, [e, i]) => x(w({}, r), { [e]: i }), {})), d(n => ({ identity: t, options: n }))) : u({ identity: t, options: {} })), d(({ identity: t, options: n }) => ({ name: n.prefix + t, object: s })), a(({ name: t, object: n }) => y(j(h)).pipe(a(({ set: r }) => new g(e => { r(t, n).then(i => { console.log("idb write succeeded"), console.log(i), e.next({ success: !0 }), e.complete(); }).catch(i => { console.log("idb write failed"), console.log(i), e.next({ success: !1 }), e.complete(); }); })))), P(t => (console.error("Error in update stream:", t), u({ success: !1, error: t.message })))), delete: ({}) => u({ success: !1 }), query: ({ params: s, rule: p, identity: o }) => l.paramValues(new Map(Object.keys(s).map(c => [c, s[c]]))).pipe(a(c => y(j(h)).pipe(a(({ keys: t, getMany: n }) => new g(r => { t().then(e => e.filter(i => `${i}`.indexOf(c.get("prefix")) === 0)).then(e => n(e)).then(e => { r.next({ entities: e, success: !0 }), r.complete(); }).catch(e => { console.error("idb query failed:", e), r.next({ entities: [], success: !1 }), r.complete(); }); })))), a(c => p ? new g(t => { let n = new F.Engine; n.addOperator("startsWith", (r, e) => typeof e == "string" && typeof r == "string" && e.indexOf(r) === 0), n.addOperator("term||wildcard", (r, e) => { let i = JSON.parse(decodeURIComponent(e)), m = I.JSONPath({ path: "$.term.*.value.@string()", json: i, flatten: !0 }); return i.wildcard !== void 0 || i.term && m.length !== 0 && m[0] === r; }), n.addRule(p), n.addFact("identity", (r, e) => new g(i => { e.factValue("entity").then(m => o({ object: m }).pipe(d(({ identity: C }) => C)).toPromise()).then(m => { i.next(m), i.complete(); }); }).toPromise(), { cache: !1 }), y(c.entities).pipe(a(r => new g(e => { n.removeFact("entity"), n.addFact("entity", r, { cache: !1 }), n.run().then(i => { e.next([r, i.events.findIndex(m => m.type === "visible") > -1]), e.complete(); }); })), R(([r, e]) => e), d(([r]) => r), S((r, e) => [...r, e], []), K([])).subscribe(r => { t.next(x(w({}, c), { entities: r })), t.complete(); }); }) : u(c))) }), U = ({ data: l, key: h }) => s => () => k(s) ? y(import("@nf-internal/dist-FPZVN5BX")).pipe(a(({ setMany: p }) => new g(o => { let c = l.map(t => [h({ data: t }), t]); p(c).then(() => { console.log("data loaded into idb"), o.next(null), o.complete(); }).catch(t => { console.log("data load into idb failure:", t), o.next(null), o.complete(); }); }))) : u(null).pipe(d(() => (console.log("Skipping IDB data initialization during SSR."), null))), W = (() => { class l {
    constructor(s, p, o) { this.platformId = s, p.register(_(o, s)); }
    static { this.\u0275fac = function (p) { return new (p || l)(f.\u0275\u0275inject(V), f.\u0275\u0275inject(v.CrudAdaptorPluginManager), f.\u0275\u0275inject(A.ParamEvaluatorService)); }; }
    static { this.\u0275mod = f.\u0275\u0275defineNgModule({ type: l }); }
    static { this.\u0275inj = f.\u0275\u0275defineInjector({ imports: [N] }); }
} return l; })();
export { W as KeyvalModule, _ as idbEntityCrudAdaptorPluginFactory, U as initializeIdbDataFactory };
//# sourceMappingURL=_rollthecloudinc_keyval.O4wiXFIuHk.js.map
