{"version":3,"file":"8699.cc76b46df352dc43.js","mappings":"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","names":["concat","_len","arguments","length","args","Array","_key","concatAll","mergeAll","from","popScheduler","of","scheduler","filter","predicate","thisArg","operate","source","subscriber","index","subscribe","createOperatorSubscriber","value","call","next","startWith","values","switchMap","project","resultSelector","innerSubscriber","isComplete","checkComplete","complete","unsubscribe","innerIndex","outerIndex","innerFrom","innerValue","take","count","EMPTY","seen","takeUntil","notifier","noop","closed","_c0","_c1","_c2","_MatMenuItem_Conditional_4_Template","rf","ctx","i0","_c3","_MatMenu_ng_template_0_Template","_r1","ctx_r1","emit","$event","_onAnimationStart","animationName","_onAnimationDone","_classList","_animationsDisabled","_panelAnimationState","_isAnimating","panelId","ariaLabel","ariaLabelledby","ariaDescribedby","MAT_MENU_PANEL","InjectionToken","MatMenuItem","_MatMenuItem","_createClass","_this$_parentMenu","_this$_parentMenu$add","_classCallCheck","this","_defineProperty","inject","ElementRef","DOCUMENT","FocusMonitor","optional","ChangeDetectorRef","Subject","_CdkPrivateStyleLoader","load","_StructuralStylesLoader","_parentMenu","addItem","key","origin","options","_focusMonitor","focusVia","_getHostElement","focus","_focused","monitor","_elementRef","stopMonitoring","removeItem","_hovered","disabled","nativeElement","event","preventDefault","stopPropagation","_clone$textContent","clone","cloneNode","icons","querySelectorAll","i","remove","textContent","trim","isHighlighted","_highlighted","_changeDetectorRef","markForCheck","triggersSubmenu","_triggersSubmenu","_document","activeElement","__ngFactoryType__","type","selectors","hostAttrs","hostVars","hostBindings","_checkDisabled","_handleMouseEnter","role","_getTabIndex","inputs","booleanAttribute","disableRipple","exportAs","attrs","ngContentSelectors","decls","vars","consts","template","dependencies","MatRipple","encapsulation","changeDetection","MAT_MENU_CONTENT","MatMenuContent","_MatMenuContent","TemplateRef","ApplicationRef","Injector","ViewContainerRef","context","undefined","_portal","TemplatePortal","_template","_viewContainerRef","detach","_outlet","DomPortalOutlet","createElement","_appRef","_injector","element","elementRef","parentNode","insertBefore","outletElement","attach","_attached","_this$_portal","isAttached","_this$_outlet","dispose","features","provide","useExisting","MAT_MENU_DEFAULT_OPTIONS","providedIn","factory","MAT_MENU_DEFAULT_OPTIONS_FACTORY","overlapTrigger","xPosition","yPosition","backdropClass","ENTER_ANIMATION","EXIT_ANIMATION","MatMenu","_MatMenu","QueryList","signal","apply","_toConsumableArray","EventEmitter","_IdGenerator","getId","defaultOptions","overlayPanelClass","_xPosition","_yPosition","hasBackdrop","get","set","setPositionClasses","classes","previousPanelClass","_previousPanelClass","newClassList","_objectSpread","split","forEach","className","panelClass","_this","_updateDirectDescendants","_keyManager","FocusKeyManager","_directDescendantItems","withWrap","withTypeAhead","withHomeAndEnd","tabOut","changes","pipe","items","merge","map","item","focusedItem","updateActiveItem","itemsList","_manager$activeItem","manager","activeItem","_hasFocus","toArray","Math","max","min","activeItemIndex","setActiveItem","setNextItemActive","_this$_keyManager","_this$_firstItemFocus","destroy","_firstItemFocusRef","clearTimeout","_exitFallbackTimeout","_item","keyCode","ESCAPE","hasModifierKey","LEFT_ARROW","parentMenu","direction","RIGHT_ARROW","UP_ARROW","DOWN_ARROW","setFocusOrigin","onKeydown","_this$_firstItemFocus2","_this2","afterNextRender","menuPanel","_resolvePanel","contains","document","setFirstItemActive","injector","_depth","posX","posY","state","isExit","_animationDone","isOpen","_this3","scrollTop","setTimeout","_this4","_allItems","reset","notifyOnChanges","first","closest","contentQueries","dirIndex","_t","lazyContent","viewQuery","templateRef","classList","outputs","close","styles","MAT_MENU_SCROLL_STRATEGY","createRepositionScrollStrategy","MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER","deps","useFactory","MAT_MENU_SCROLL_STRATEGY_FACTORY","_overlay","MENU_PANEL_TOP_PADDING","PANELS_TO_TRIGGERS","WeakMap","MatMenuTriggerBase","_MatMenuTriggerBase","_canHaveBackdrop","self","Directionality","NgZone","Subscription","_parentMaterialMenu","_menuInternal","menu","_this$_menuItemInstan","_this5","_menuCloseSubscription","reason","_destroyMenu","_menuItemInstance","_setTriggersSubmenu","_this$_pendingRemoval","_menu","_ownsMenu","delete","_pendingRemoval","_closingActionsSubscription","_overlayRef","_menuOpen","_dir","_this$_menu","autoFocus","_this$_pendingRemoval2","_this6","previousTrigger","_closeMenu","_menu$lazyContent","overlayRef","_createOverlay","overlayConfig","getConfig","positionStrategy","_setPosition","hasAttached","_getPortal","menuData","_menuClosingActions","dir","focusFirstItem","_openedBy","_setIsMenuOpen","_setIsOpen","withLockedPosition","reapplyLastPosition","_element","_this$_pendingRemoval3","_menu$lazyContent3","menuOpen","_menu$lazyContent2","has","restoreFocus","menuOpened","menuClosed","_setHighlighted","_this7","config","_getOverlayConfig","_subscribeToPositions","createOverlayRef","keydownEvents","_handleKeydown","OverlayConfig","createFlexibleConnectedPositionStrategy","_getOverlayOrigin","withGrowAfterOpen","withTransformOriginOn","scrollStrategy","_scrollStrategy","disableAnimations","position","_this8","positionChanges","change","_ngZone","run","connectionPair","overlayX","overlayY","_ref2","_slicedToArray","originX","originFallbackX","_ref4","overlayFallbackY","originY","originFallbackY","overlayFallbackX","offsetY","_parentInnerPadding","firstItem","offsetTop","withPositions","_this9","outsideClicks","_getOutsideClickStream","detachments","parentClose","hover","active","MatMenuTrigger","_MatMenuTrigger","_MatMenuTriggerBase2","_this0","_callSuper","renderer","Renderer2","_cleanupTouchstart","listen","isFakeTouchstartFromScreenReader","passive","_inherits","v","_superPropGet","closeMenu","openMenu","_openMenu","_this$_overlayRef","updatePosition","_handleHover","_hoverSubscription","backdropClick","isFakeMousedownFromScreenReader","button","ENTER","SPACE","toggleMenu","_this1","_this1$_parentMateria","_handleClick","_handleMousedown","_deprecatedMatMenuTriggerFor","onMenuOpen","onMenuClose","MatContextMenuTrigger","_MatContextMenuTrigger","_MatMenuTriggerBase3","_this10","x","y","initialX","initialY","initialScrollX","initialScrollY","ViewportRuler","ScrollDispatcher","_this$_scrollSubscrip","_scrollSubscription","_initializePoint","clientX","clientY","_updatePosition","_openContextMenu","_this$_scrollSubscrip2","_point","_this11","outsidePointerEvents","skipWhile","taking","_isWithinMenuOrTrigger","_getEventTarget","_this11$_rootNode","_rootNode","_getShadowRoot","elementFromPoint","_triggerPressedControl","ctrlKey","target","_this$_overlayRef2","overlay","hostElement","_this$_scrollSubscrip3","_this12","_scrollDispatcher","scrolled","_viewportRuler","getViewportScrollPosition","point","top","left","scrollPosition","setOrigin","_handleContextMenuEvent","MatMenuModule","_MatMenuModule","providers","imports","MatRippleModule","MatCommonModule","OverlayModule","CdkScrollableModule","matMenuAnimations","transformMenu","name","definitions","opacity","transform","offset","expr","animation","timings","fadeInItems","_MatRippleModule","_arrayWithHoles","r","isArray","_nonIterableRest","TypeError","e","arrayWithHoles","A","_iterableToArrayLimit","l","t","Symbol","iterator","n","u","a","f","o","Object","done","push","return","unsupportedIterableToArray","nonIterableRest"],"ignoreList":[],"sourceRoot":"webpack:///","sources":["./node_modules/rxjs/dist/esm/internal/observable/concat.js","./node_modules/rxjs/dist/esm/internal/operators/concatAll.js","./node_modules/rxjs/dist/esm/internal/observable/of.js","./node_modules/rxjs/dist/esm/internal/operators/filter.js","./node_modules/rxjs/dist/esm/internal/operators/startWith.js","./node_modules/rxjs/dist/esm/internal/operators/switchMap.js","./node_modules/rxjs/dist/esm/internal/operators/take.js","./node_modules/rxjs/dist/esm/internal/operators/takeUntil.js","./node_modules/@angular/material/fesm2022/menu.mjs","./node_modules/rxjs/dist/esm/internal/operators/skipWhile.js","./node_modules/@angular/material/fesm2022/ripple-module.mjs","./node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","./node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","./node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/slicedToArray.js","./node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js"],"sourcesContent":["import { concatAll } from '../operators/concatAll';\nimport { popScheduler } from '../util/args';\nimport { from } from './from';\nexport function concat(...args) {\n    return concatAll()(from(args, popScheduler(args)));\n}\n","import { mergeAll } from './mergeAll';\nexport function concatAll() {\n    return mergeAll(1);\n}\n","import { popScheduler } from '../util/args';\nimport { from } from './from';\nexport function of(...args) {\n    const scheduler = popScheduler(args);\n    return from(args, scheduler);\n}\n","import { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function filter(predicate, thisArg) {\n    return operate((source, subscriber) => {\n        let index = 0;\n        source.subscribe(createOperatorSubscriber(subscriber, (value) => predicate.call(thisArg, value, index++) && subscriber.next(value)));\n    });\n}\n","import { concat } from '../observable/concat';\nimport { popScheduler } from '../util/args';\nimport { operate } from '../util/lift';\nexport function startWith(...values) {\n    const scheduler = popScheduler(values);\n    return operate((source, subscriber) => {\n        (scheduler ? concat(values, source, scheduler) : concat(values, source)).subscribe(subscriber);\n    });\n}\n","import { innerFrom } from '../observable/innerFrom';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function switchMap(project, resultSelector) {\n    return operate((source, subscriber) => {\n        let innerSubscriber = null;\n        let index = 0;\n        let isComplete = false;\n        const checkComplete = () => isComplete && !innerSubscriber && subscriber.complete();\n        source.subscribe(createOperatorSubscriber(subscriber, (value) => {\n            innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();\n            let innerIndex = 0;\n            const outerIndex = index++;\n            innerFrom(project(value, outerIndex)).subscribe((innerSubscriber = createOperatorSubscriber(subscriber, (innerValue) => subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue), () => {\n                innerSubscriber = null;\n                checkComplete();\n            })));\n        }, () => {\n            isComplete = true;\n            checkComplete();\n        }));\n    });\n}\n","import { EMPTY } from '../observable/empty';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function take(count) {\n    return count <= 0\n        ?\n            () => EMPTY\n        : operate((source, subscriber) => {\n            let seen = 0;\n            source.subscribe(createOperatorSubscriber(subscriber, (value) => {\n                if (++seen <= count) {\n                    subscriber.next(value);\n                    if (count <= seen) {\n                        subscriber.complete();\n                    }\n                }\n            }));\n        });\n}\n","import { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { innerFrom } from '../observable/innerFrom';\nimport { noop } from '../util/noop';\nexport function takeUntil(notifier) {\n    return operate((source, subscriber) => {\n        innerFrom(notifier).subscribe(createOperatorSubscriber(subscriber, () => subscriber.complete(), noop));\n        !subscriber.closed && source.subscribe(subscriber);\n    });\n}\n","import * as i0 from '@angular/core';\nimport { InjectionToken, inject, ElementRef, DOCUMENT, ChangeDetectorRef, booleanAttribute, Component, ChangeDetectionStrategy, ViewEncapsulation, Input, TemplateRef, ApplicationRef, Injector, ViewContainerRef, Directive, QueryList, signal, EventEmitter, afterNextRender, ContentChildren, ViewChild, ContentChild, Output, NgZone, Renderer2, NgModule } from '@angular/core';\nimport { FocusMonitor, _IdGenerator, FocusKeyManager, isFakeTouchstartFromScreenReader, isFakeMousedownFromScreenReader } from '@angular/cdk/a11y';\nimport { UP_ARROW, DOWN_ARROW, RIGHT_ARROW, LEFT_ARROW, ESCAPE, hasModifierKey, ENTER, SPACE } from '@angular/cdk/keycodes';\nimport { Subject, merge, Subscription, of } from 'rxjs';\nimport { startWith, switchMap, takeUntil, take, filter, skipWhile } from 'rxjs/operators';\nimport { _CdkPrivateStyleLoader } from '@angular/cdk/private';\nimport { _StructuralStylesLoader } from './structural-styles.mjs';\nimport { MatRipple } from './ripple.mjs';\nimport { TemplatePortal, DomPortalOutlet } from '@angular/cdk/portal';\nimport { _animationsDisabled } from './animation.mjs';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { createRepositionScrollStrategy, createOverlayRef, OverlayConfig, createFlexibleConnectedPositionStrategy, ViewportRuler, ScrollDispatcher, OverlayModule } from '@angular/cdk/overlay';\nimport { _getEventTarget, _getShadowRoot } from '@angular/cdk/platform';\nimport { CdkScrollableModule } from '@angular/cdk/scrolling';\nimport { MatRippleModule } from './ripple-module.mjs';\nimport { MatCommonModule } from './common-module.mjs';\nimport '@angular/cdk/coercion';\nimport '@angular/cdk/layout';\n\n/**\n * Injection token used to provide the parent menu to menu-specific components.\n * @docs-private\n */\nconst MAT_MENU_PANEL = new InjectionToken('MAT_MENU_PANEL');\n\n/**\n * Single item inside a `mat-menu`. Provides the menu item styling and accessibility treatment.\n */\nclass MatMenuItem {\n    _elementRef = inject(ElementRef);\n    _document = inject(DOCUMENT);\n    _focusMonitor = inject(FocusMonitor);\n    _parentMenu = inject(MAT_MENU_PANEL, { optional: true });\n    _changeDetectorRef = inject(ChangeDetectorRef);\n    /** ARIA role for the menu item. */\n    role = 'menuitem';\n    /** Whether the menu item is disabled. */\n    disabled = false;\n    /** Whether ripples are disabled on the menu item. */\n    disableRipple = false;\n    /** Stream that emits when the menu item is hovered. */\n    _hovered = new Subject();\n    /** Stream that emits when the menu item is focused. */\n    _focused = new Subject();\n    /** Whether the menu item is highlighted. */\n    _highlighted = false;\n    /** Whether the menu item acts as a trigger for a sub-menu. */\n    _triggersSubmenu = false;\n    constructor() {\n        inject(_CdkPrivateStyleLoader).load(_StructuralStylesLoader);\n        this._parentMenu?.addItem?.(this);\n    }\n    /** Focuses the menu item. */\n    focus(origin, options) {\n        if (this._focusMonitor && origin) {\n            this._focusMonitor.focusVia(this._getHostElement(), origin, options);\n        }\n        else {\n            this._getHostElement().focus(options);\n        }\n        this._focused.next(this);\n    }\n    ngAfterViewInit() {\n        if (this._focusMonitor) {\n            // Start monitoring the element, so it gets the appropriate focused classes. We want\n            // to show the focus style for menu items only when the focus was not caused by a\n            // mouse or touch interaction.\n            this._focusMonitor.monitor(this._elementRef, false);\n        }\n    }\n    ngOnDestroy() {\n        if (this._focusMonitor) {\n            this._focusMonitor.stopMonitoring(this._elementRef);\n        }\n        if (this._parentMenu && this._parentMenu.removeItem) {\n            this._parentMenu.removeItem(this);\n        }\n        this._hovered.complete();\n        this._focused.complete();\n    }\n    /** Used to set the `tabindex`. */\n    _getTabIndex() {\n        return this.disabled ? '-1' : '0';\n    }\n    /** Returns the host DOM element. */\n    _getHostElement() {\n        return this._elementRef.nativeElement;\n    }\n    /** Prevents the default element actions if it is disabled. */\n    _checkDisabled(event) {\n        if (this.disabled) {\n            event.preventDefault();\n            event.stopPropagation();\n        }\n    }\n    /** Emits to the hover stream. */\n    _handleMouseEnter() {\n        this._hovered.next(this);\n    }\n    /** Gets the label to be used when determining whether the option should be focused. */\n    getLabel() {\n        const clone = this._elementRef.nativeElement.cloneNode(true);\n        const icons = clone.querySelectorAll('mat-icon, .material-icons');\n        // Strip away icons, so they don't show up in the text.\n        for (let i = 0; i < icons.length; i++) {\n            icons[i].remove();\n        }\n        return clone.textContent?.trim() || '';\n    }\n    _setHighlighted(isHighlighted) {\n        // We need to mark this for check for the case where the content is coming from a\n        // `matMenuContent` whose change detection tree is at the declaration position,\n        // not the insertion position. See #23175.\n        this._highlighted = isHighlighted;\n        this._changeDetectorRef.markForCheck();\n    }\n    _setTriggersSubmenu(triggersSubmenu) {\n        this._triggersSubmenu = triggersSubmenu;\n        this._changeDetectorRef.markForCheck();\n    }\n    _hasFocus() {\n        return this._document && this._document.activeElement === this._getHostElement();\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: MatMenuItem, deps: [], target: i0.ɵɵFactoryTarget.Component });\n    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"17.0.0\", version: \"20.2.0-next.2\", type: MatMenuItem, isStandalone: true, selector: \"[mat-menu-item]\", inputs: { role: \"role\", disabled: [\"disabled\", \"disabled\", booleanAttribute], disableRipple: [\"disableRipple\", \"disableRipple\", booleanAttribute] }, host: { listeners: { \"click\": \"_checkDisabled($event)\", \"mouseenter\": \"_handleMouseEnter()\" }, properties: { \"attr.role\": \"role\", \"class.mat-mdc-menu-item-highlighted\": \"_highlighted\", \"class.mat-mdc-menu-item-submenu-trigger\": \"_triggersSubmenu\", \"attr.tabindex\": \"_getTabIndex()\", \"attr.aria-disabled\": \"disabled\", \"attr.disabled\": \"disabled || null\" }, classAttribute: \"mat-mdc-menu-item mat-focus-indicator\" }, exportAs: [\"matMenuItem\"], ngImport: i0, template: \"<ng-content select=\\\"mat-icon, [matMenuItemIcon]\\\"></ng-content>\\n<span class=\\\"mat-mdc-menu-item-text\\\"><ng-content></ng-content></span>\\n<div class=\\\"mat-mdc-menu-ripple\\\" matRipple\\n     [matRippleDisabled]=\\\"disableRipple || disabled\\\"\\n     [matRippleTrigger]=\\\"_getHostElement()\\\">\\n</div>\\n\\n@if (_triggersSubmenu) {\\n     <svg\\n       class=\\\"mat-mdc-menu-submenu-icon\\\"\\n       viewBox=\\\"0 0 5 10\\\"\\n       focusable=\\\"false\\\"\\n       aria-hidden=\\\"true\\\"><polygon points=\\\"0,0 5,5 0,10\\\"/></svg>\\n}\\n\", dependencies: [{ kind: \"directive\", type: MatRipple, selector: \"[mat-ripple], [matRipple]\", inputs: [\"matRippleColor\", \"matRippleUnbounded\", \"matRippleCentered\", \"matRippleRadius\", \"matRippleAnimation\", \"matRippleDisabled\", \"matRippleTrigger\"], exportAs: [\"matRipple\"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: MatMenuItem, decorators: [{\n            type: Component,\n            args: [{ selector: '[mat-menu-item]', exportAs: 'matMenuItem', host: {\n                        '[attr.role]': 'role',\n                        'class': 'mat-mdc-menu-item mat-focus-indicator',\n                        '[class.mat-mdc-menu-item-highlighted]': '_highlighted',\n                        '[class.mat-mdc-menu-item-submenu-trigger]': '_triggersSubmenu',\n                        '[attr.tabindex]': '_getTabIndex()',\n                        '[attr.aria-disabled]': 'disabled',\n                        '[attr.disabled]': 'disabled || null',\n                        '(click)': '_checkDisabled($event)',\n                        '(mouseenter)': '_handleMouseEnter()',\n                    }, changeDetection: ChangeDetectionStrategy.OnPush, encapsulation: ViewEncapsulation.None, imports: [MatRipple], template: \"<ng-content select=\\\"mat-icon, [matMenuItemIcon]\\\"></ng-content>\\n<span class=\\\"mat-mdc-menu-item-text\\\"><ng-content></ng-content></span>\\n<div class=\\\"mat-mdc-menu-ripple\\\" matRipple\\n     [matRippleDisabled]=\\\"disableRipple || disabled\\\"\\n     [matRippleTrigger]=\\\"_getHostElement()\\\">\\n</div>\\n\\n@if (_triggersSubmenu) {\\n     <svg\\n       class=\\\"mat-mdc-menu-submenu-icon\\\"\\n       viewBox=\\\"0 0 5 10\\\"\\n       focusable=\\\"false\\\"\\n       aria-hidden=\\\"true\\\"><polygon points=\\\"0,0 5,5 0,10\\\"/></svg>\\n}\\n\" }]\n        }], ctorParameters: () => [], propDecorators: { role: [{\n                type: Input\n            }], disabled: [{\n                type: Input,\n                args: [{ transform: booleanAttribute }]\n            }], disableRipple: [{\n                type: Input,\n                args: [{ transform: booleanAttribute }]\n            }] } });\n\n/**\n * Throws an exception for the case when menu's x-position value isn't valid.\n * In other words, it doesn't match 'before' or 'after'.\n * @docs-private\n */\nfunction throwMatMenuInvalidPositionX() {\n    throw Error(`xPosition value must be either 'before' or after'.\n      Example: <mat-menu xPosition=\"before\" #menu=\"matMenu\"></mat-menu>`);\n}\n/**\n * Throws an exception for the case when menu's y-position value isn't valid.\n * In other words, it doesn't match 'above' or 'below'.\n * @docs-private\n */\nfunction throwMatMenuInvalidPositionY() {\n    throw Error(`yPosition value must be either 'above' or below'.\n      Example: <mat-menu yPosition=\"above\" #menu=\"matMenu\"></mat-menu>`);\n}\n/**\n * Throws an exception for the case when a menu is assigned\n * to a trigger that is placed inside the same menu.\n * @docs-private\n */\nfunction throwMatMenuRecursiveError() {\n    throw Error(`matMenuTriggerFor: menu cannot contain its own trigger. Assign a menu that is ` +\n        `not a parent of the trigger or move the trigger outside of the menu.`);\n}\n\n/**\n * Injection token that can be used to reference instances of `MatMenuContent`. It serves\n * as alternative token to the actual `MatMenuContent` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nconst MAT_MENU_CONTENT = new InjectionToken('MatMenuContent');\n/** Menu content that will be rendered lazily once the menu is opened. */\nclass MatMenuContent {\n    _template = inject(TemplateRef);\n    _appRef = inject(ApplicationRef);\n    _injector = inject(Injector);\n    _viewContainerRef = inject(ViewContainerRef);\n    _document = inject(DOCUMENT);\n    _changeDetectorRef = inject(ChangeDetectorRef);\n    _portal;\n    _outlet;\n    /** Emits when the menu content has been attached. */\n    _attached = new Subject();\n    constructor() { }\n    /**\n     * Attaches the content with a particular context.\n     * @docs-private\n     */\n    attach(context = {}) {\n        if (!this._portal) {\n            this._portal = new TemplatePortal(this._template, this._viewContainerRef);\n        }\n        this.detach();\n        if (!this._outlet) {\n            this._outlet = new DomPortalOutlet(this._document.createElement('div'), this._appRef, this._injector);\n        }\n        const element = this._template.elementRef.nativeElement;\n        // Because we support opening the same menu from different triggers (which in turn have their\n        // own `OverlayRef` panel), we have to re-insert the host element every time, otherwise we\n        // risk it staying attached to a pane that's no longer in the DOM.\n        element.parentNode.insertBefore(this._outlet.outletElement, element);\n        // When `MatMenuContent` is used in an `OnPush` component, the insertion of the menu\n        // content via `createEmbeddedView` does not cause the content to be seen as \"dirty\"\n        // by Angular. This causes the `@ContentChildren` for menu items within the menu to\n        // not be updated by Angular. By explicitly marking for check here, we tell Angular that\n        // it needs to check for new menu items and update the `@ContentChild` in `MatMenu`.\n        this._changeDetectorRef.markForCheck();\n        this._portal.attach(this._outlet, context);\n        this._attached.next();\n    }\n    /**\n     * Detaches the content.\n     * @docs-private\n     */\n    detach() {\n        if (this._portal?.isAttached) {\n            this._portal.detach();\n        }\n    }\n    ngOnDestroy() {\n        this.detach();\n        this._outlet?.dispose();\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: MatMenuContent, deps: [], target: i0.ɵɵFactoryTarget.Directive });\n    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"20.2.0-next.2\", type: MatMenuContent, isStandalone: true, selector: \"ng-template[matMenuContent]\", providers: [{ provide: MAT_MENU_CONTENT, useExisting: MatMenuContent }], ngImport: i0 });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: MatMenuContent, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: 'ng-template[matMenuContent]',\n                    providers: [{ provide: MAT_MENU_CONTENT, useExisting: MatMenuContent }],\n                }]\n        }], ctorParameters: () => [] });\n\n/** Injection token to be used to override the default options for `mat-menu`. */\nconst MAT_MENU_DEFAULT_OPTIONS = new InjectionToken('mat-menu-default-options', {\n    providedIn: 'root',\n    factory: MAT_MENU_DEFAULT_OPTIONS_FACTORY,\n});\n/**\n * @docs-private\n * @deprecated No longer used, will be removed.\n * @breaking-change 21.0.0\n */\nfunction MAT_MENU_DEFAULT_OPTIONS_FACTORY() {\n    return {\n        overlapTrigger: false,\n        xPosition: 'after',\n        yPosition: 'below',\n        backdropClass: 'cdk-overlay-transparent-backdrop',\n    };\n}\n/** Name of the enter animation `@keyframes`. */\nconst ENTER_ANIMATION = '_mat-menu-enter';\n/** Name of the exit animation `@keyframes`. */\nconst EXIT_ANIMATION = '_mat-menu-exit';\nclass MatMenu {\n    _elementRef = inject(ElementRef);\n    _changeDetectorRef = inject(ChangeDetectorRef);\n    _injector = inject(Injector);\n    _keyManager;\n    _xPosition;\n    _yPosition;\n    _firstItemFocusRef;\n    _exitFallbackTimeout;\n    /** Whether animations are currently disabled. */\n    _animationsDisabled = _animationsDisabled();\n    /** All items inside the menu. Includes items nested inside another menu. */\n    _allItems;\n    /** Only the direct descendant menu items. */\n    _directDescendantItems = new QueryList();\n    /** Classes to be applied to the menu panel. */\n    _classList = {};\n    /** Current state of the panel animation. */\n    _panelAnimationState = 'void';\n    /** Emits whenever an animation on the menu completes. */\n    _animationDone = new Subject();\n    /** Whether the menu is animating. */\n    _isAnimating = signal(false, ...(ngDevMode ? [{ debugName: \"_isAnimating\" }] : []));\n    /** Parent menu of the current menu panel. */\n    parentMenu;\n    /** Layout direction of the menu. */\n    direction;\n    /** Class or list of classes to be added to the overlay panel. */\n    overlayPanelClass;\n    /** Class to be added to the backdrop element. */\n    backdropClass;\n    /** aria-label for the menu panel. */\n    ariaLabel;\n    /** aria-labelledby for the menu panel. */\n    ariaLabelledby;\n    /** aria-describedby for the menu panel. */\n    ariaDescribedby;\n    /** Position of the menu in the X axis. */\n    get xPosition() {\n        return this._xPosition;\n    }\n    set xPosition(value) {\n        if (value !== 'before' &&\n            value !== 'after' &&\n            (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            throwMatMenuInvalidPositionX();\n        }\n        this._xPosition = value;\n        this.setPositionClasses();\n    }\n    /** Position of the menu in the Y axis. */\n    get yPosition() {\n        return this._yPosition;\n    }\n    set yPosition(value) {\n        if (value !== 'above' && value !== 'below' && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            throwMatMenuInvalidPositionY();\n        }\n        this._yPosition = value;\n        this.setPositionClasses();\n    }\n    /** @docs-private */\n    templateRef;\n    /**\n     * List of the items inside of a menu.\n     * @deprecated\n     * @breaking-change 8.0.0\n     */\n    items;\n    /**\n     * Menu content that will be rendered lazily.\n     * @docs-private\n     */\n    lazyContent;\n    /** Whether the menu should overlap its trigger. */\n    overlapTrigger;\n    /** Whether the menu has a backdrop. */\n    hasBackdrop;\n    /**\n     * This method takes classes set on the host mat-menu element and applies them on the\n     * menu template that displays in the overlay container.  Otherwise, it's difficult\n     * to style the containing menu from outside the component.\n     * @param classes list of class names\n     */\n    set panelClass(classes) {\n        const previousPanelClass = this._previousPanelClass;\n        const newClassList = { ...this._classList };\n        if (previousPanelClass && previousPanelClass.length) {\n            previousPanelClass.split(' ').forEach((className) => {\n                newClassList[className] = false;\n            });\n        }\n        this._previousPanelClass = classes;\n        if (classes && classes.length) {\n            classes.split(' ').forEach((className) => {\n                newClassList[className] = true;\n            });\n            this._elementRef.nativeElement.className = '';\n        }\n        this._classList = newClassList;\n    }\n    _previousPanelClass;\n    /**\n     * This method takes classes set on the host mat-menu element and applies them on the\n     * menu template that displays in the overlay container.  Otherwise, it's difficult\n     * to style the containing menu from outside the component.\n     * @deprecated Use `panelClass` instead.\n     * @breaking-change 8.0.0\n     */\n    get classList() {\n        return this.panelClass;\n    }\n    set classList(classes) {\n        this.panelClass = classes;\n    }\n    /** Event emitted when the menu is closed. */\n    closed = new EventEmitter();\n    /**\n     * Event emitted when the menu is closed.\n     * @deprecated Switch to `closed` instead\n     * @breaking-change 8.0.0\n     */\n    close = this.closed;\n    panelId = inject(_IdGenerator).getId('mat-menu-panel-');\n    constructor() {\n        const defaultOptions = inject(MAT_MENU_DEFAULT_OPTIONS);\n        this.overlayPanelClass = defaultOptions.overlayPanelClass || '';\n        this._xPosition = defaultOptions.xPosition;\n        this._yPosition = defaultOptions.yPosition;\n        this.backdropClass = defaultOptions.backdropClass;\n        this.overlapTrigger = defaultOptions.overlapTrigger;\n        this.hasBackdrop = defaultOptions.hasBackdrop;\n    }\n    ngOnInit() {\n        this.setPositionClasses();\n    }\n    ngAfterContentInit() {\n        this._updateDirectDescendants();\n        this._keyManager = new FocusKeyManager(this._directDescendantItems)\n            .withWrap()\n            .withTypeAhead()\n            .withHomeAndEnd();\n        this._keyManager.tabOut.subscribe(() => this.closed.emit('tab'));\n        // If a user manually (programmatically) focuses a menu item, we need to reflect that focus\n        // change back to the key manager. Note that we don't need to unsubscribe here because _focused\n        // is internal and we know that it gets completed on destroy.\n        this._directDescendantItems.changes\n            .pipe(startWith(this._directDescendantItems), switchMap(items => merge(...items.map((item) => item._focused))))\n            .subscribe(focusedItem => this._keyManager.updateActiveItem(focusedItem));\n        this._directDescendantItems.changes.subscribe((itemsList) => {\n            // Move focus to another item, if the active item is removed from the list.\n            // We need to debounce the callback, because multiple items might be removed\n            // in quick succession.\n            const manager = this._keyManager;\n            if (this._panelAnimationState === 'enter' && manager.activeItem?._hasFocus()) {\n                const items = itemsList.toArray();\n                const index = Math.max(0, Math.min(items.length - 1, manager.activeItemIndex || 0));\n                if (items[index] && !items[index].disabled) {\n                    manager.setActiveItem(index);\n                }\n                else {\n                    manager.setNextItemActive();\n                }\n            }\n        });\n    }\n    ngOnDestroy() {\n        this._keyManager?.destroy();\n        this._directDescendantItems.destroy();\n        this.closed.complete();\n        this._firstItemFocusRef?.destroy();\n        clearTimeout(this._exitFallbackTimeout);\n    }\n    /** Stream that emits whenever the hovered menu item changes. */\n    _hovered() {\n        // Coerce the `changes` property because Angular types it as `Observable<any>`\n        const itemChanges = this._directDescendantItems.changes;\n        return itemChanges.pipe(startWith(this._directDescendantItems), switchMap(items => merge(...items.map((item) => item._hovered))));\n    }\n    /*\n     * Registers a menu item with the menu.\n     * @docs-private\n     * @deprecated No longer being used. To be removed.\n     * @breaking-change 9.0.0\n     */\n    addItem(_item) { }\n    /**\n     * Removes an item from the menu.\n     * @docs-private\n     * @deprecated No longer being used. To be removed.\n     * @breaking-change 9.0.0\n     */\n    removeItem(_item) { }\n    /** Handle a keyboard event from the menu, delegating to the appropriate action. */\n    _handleKeydown(event) {\n        const keyCode = event.keyCode;\n        const manager = this._keyManager;\n        switch (keyCode) {\n            case ESCAPE:\n                if (!hasModifierKey(event)) {\n                    event.preventDefault();\n                    this.closed.emit('keydown');\n                }\n                break;\n            case LEFT_ARROW:\n                if (this.parentMenu && this.direction === 'ltr') {\n                    this.closed.emit('keydown');\n                }\n                break;\n            case RIGHT_ARROW:\n                if (this.parentMenu && this.direction === 'rtl') {\n                    this.closed.emit('keydown');\n                }\n                break;\n            default:\n                if (keyCode === UP_ARROW || keyCode === DOWN_ARROW) {\n                    manager.setFocusOrigin('keyboard');\n                }\n                manager.onKeydown(event);\n                return;\n        }\n    }\n    /**\n     * Focus the first item in the menu.\n     * @param origin Action from which the focus originated. Used to set the correct styling.\n     */\n    focusFirstItem(origin = 'program') {\n        // Wait for `afterNextRender` to ensure iOS VoiceOver screen reader focuses the first item (#24735).\n        this._firstItemFocusRef?.destroy();\n        this._firstItemFocusRef = afterNextRender(() => {\n            const menuPanel = this._resolvePanel();\n            // If an item in the menuPanel is already focused, avoid overriding the focus.\n            if (!menuPanel || !menuPanel.contains(document.activeElement)) {\n                const manager = this._keyManager;\n                manager.setFocusOrigin(origin).setFirstItemActive();\n                // If there's no active item at this point, it means that all the items are disabled.\n                // Move focus to the menuPanel panel so keyboard events like Escape still work. Also this will\n                // give _some_ feedback to screen readers.\n                if (!manager.activeItem && menuPanel) {\n                    menuPanel.focus();\n                }\n            }\n        }, { injector: this._injector });\n    }\n    /**\n     * Resets the active item in the menu. This is used when the menu is opened, allowing\n     * the user to start from the first option when pressing the down arrow.\n     */\n    resetActiveItem() {\n        this._keyManager.setActiveItem(-1);\n    }\n    /**\n     * @deprecated No longer used and will be removed.\n     * @breaking-change 21.0.0\n     */\n    setElevation(_depth) { }\n    /**\n     * Adds classes to the menu panel based on its position. Can be used by\n     * consumers to add specific styling based on the position.\n     * @param posX Position of the menu along the x axis.\n     * @param posY Position of the menu along the y axis.\n     * @docs-private\n     */\n    setPositionClasses(posX = this.xPosition, posY = this.yPosition) {\n        this._classList = {\n            ...this._classList,\n            ['mat-menu-before']: posX === 'before',\n            ['mat-menu-after']: posX === 'after',\n            ['mat-menu-above']: posY === 'above',\n            ['mat-menu-below']: posY === 'below',\n        };\n        this._changeDetectorRef.markForCheck();\n    }\n    /** Callback that is invoked when the panel animation completes. */\n    _onAnimationDone(state) {\n        const isExit = state === EXIT_ANIMATION;\n        if (isExit || state === ENTER_ANIMATION) {\n            if (isExit) {\n                clearTimeout(this._exitFallbackTimeout);\n                this._exitFallbackTimeout = undefined;\n            }\n            this._animationDone.next(isExit ? 'void' : 'enter');\n            this._isAnimating.set(false);\n        }\n    }\n    _onAnimationStart(state) {\n        if (state === ENTER_ANIMATION || state === EXIT_ANIMATION) {\n            this._isAnimating.set(true);\n        }\n    }\n    _setIsOpen(isOpen) {\n        this._panelAnimationState = isOpen ? 'enter' : 'void';\n        if (isOpen) {\n            if (this._keyManager.activeItemIndex === 0) {\n                // Scroll the content element to the top as soon as the animation starts. This is necessary,\n                // because we move focus to the first item while it's still being animated, which can throw\n                // the browser off when it determines the scroll position. Alternatively we can move focus\n                // when the animation is done, however moving focus asynchronously will interrupt screen\n                // readers which are in the process of reading out the menu already. We take the `element`\n                // from the `event` since we can't use a `ViewChild` to access the pane.\n                const menuPanel = this._resolvePanel();\n                if (menuPanel) {\n                    menuPanel.scrollTop = 0;\n                }\n            }\n        }\n        else if (!this._animationsDisabled) {\n            // Some apps do `* { animation: none !important; }` in tests which will prevent the\n            // `animationend` event from firing. Since the exit animation is loading-bearing for\n            // removing the content from the DOM, add a fallback timer.\n            this._exitFallbackTimeout = setTimeout(() => this._onAnimationDone(EXIT_ANIMATION), 200);\n        }\n        // Animation events won't fire when animations are disabled so we simulate them.\n        if (this._animationsDisabled) {\n            setTimeout(() => {\n                this._onAnimationDone(isOpen ? ENTER_ANIMATION : EXIT_ANIMATION);\n            });\n        }\n        this._changeDetectorRef.markForCheck();\n    }\n    /**\n     * Sets up a stream that will keep track of any newly-added menu items and will update the list\n     * of direct descendants. We collect the descendants this way, because `_allItems` can include\n     * items that are part of child menus, and using a custom way of registering items is unreliable\n     * when it comes to maintaining the item order.\n     */\n    _updateDirectDescendants() {\n        this._allItems.changes\n            .pipe(startWith(this._allItems))\n            .subscribe((items) => {\n            this._directDescendantItems.reset(items.filter(item => item._parentMenu === this));\n            this._directDescendantItems.notifyOnChanges();\n        });\n    }\n    /** Gets the menu panel DOM node. */\n    _resolvePanel() {\n        let menuPanel = null;\n        if (this._directDescendantItems.length) {\n            // Because the `mat-menuPanel` is at the DOM insertion point, not inside the overlay, we don't\n            // have a nice way of getting a hold of the menuPanel panel. We can't use a `ViewChild` either\n            // because the panel is inside an `ng-template`. We work around it by starting from one of\n            // the items and walking up the DOM.\n            menuPanel = this._directDescendantItems.first._getHostElement().closest('[role=\"menu\"]');\n        }\n        return menuPanel;\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: MatMenu, deps: [], target: i0.ɵɵFactoryTarget.Component });\n    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"16.1.0\", version: \"20.2.0-next.2\", type: MatMenu, isStandalone: true, selector: \"mat-menu\", inputs: { backdropClass: \"backdropClass\", ariaLabel: [\"aria-label\", \"ariaLabel\"], ariaLabelledby: [\"aria-labelledby\", \"ariaLabelledby\"], ariaDescribedby: [\"aria-describedby\", \"ariaDescribedby\"], xPosition: \"xPosition\", yPosition: \"yPosition\", overlapTrigger: [\"overlapTrigger\", \"overlapTrigger\", booleanAttribute], hasBackdrop: [\"hasBackdrop\", \"hasBackdrop\", (value) => (value == null ? null : booleanAttribute(value))], panelClass: [\"class\", \"panelClass\"], classList: \"classList\" }, outputs: { closed: \"closed\", close: \"close\" }, host: { properties: { \"attr.aria-label\": \"null\", \"attr.aria-labelledby\": \"null\", \"attr.aria-describedby\": \"null\" } }, providers: [{ provide: MAT_MENU_PANEL, useExisting: MatMenu }], queries: [{ propertyName: \"lazyContent\", first: true, predicate: MAT_MENU_CONTENT, descendants: true }, { propertyName: \"_allItems\", predicate: MatMenuItem, descendants: true }, { propertyName: \"items\", predicate: MatMenuItem }], viewQueries: [{ propertyName: \"templateRef\", first: true, predicate: TemplateRef, descendants: true }], exportAs: [\"matMenu\"], ngImport: i0, template: \"<ng-template>\\n  <div\\n    class=\\\"mat-mdc-menu-panel\\\"\\n    [id]=\\\"panelId\\\"\\n    [class]=\\\"_classList\\\"\\n    [class.mat-menu-panel-animations-disabled]=\\\"_animationsDisabled\\\"\\n    [class.mat-menu-panel-exit-animation]=\\\"_panelAnimationState === 'void'\\\"\\n    [class.mat-menu-panel-animating]=\\\"_isAnimating()\\\"\\n    (click)=\\\"closed.emit('click')\\\"\\n    tabindex=\\\"-1\\\"\\n    role=\\\"menu\\\"\\n    (animationstart)=\\\"_onAnimationStart($event.animationName)\\\"\\n    (animationend)=\\\"_onAnimationDone($event.animationName)\\\"\\n    (animationcancel)=\\\"_onAnimationDone($event.animationName)\\\"\\n    [attr.aria-label]=\\\"ariaLabel || null\\\"\\n    [attr.aria-labelledby]=\\\"ariaLabelledby || null\\\"\\n    [attr.aria-describedby]=\\\"ariaDescribedby || null\\\">\\n    <div class=\\\"mat-mdc-menu-content\\\">\\n      <ng-content></ng-content>\\n    </div>\\n  </div>\\n</ng-template>\\n\", styles: [\"mat-menu{display:none}.mat-mdc-menu-content{margin:0;padding:8px 0;outline:0}.mat-mdc-menu-content,.mat-mdc-menu-content .mat-mdc-menu-item .mat-mdc-menu-item-text{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;flex:1;white-space:normal;font-family:var(--mat-menu-item-label-text-font, var(--mat-sys-label-large-font));line-height:var(--mat-menu-item-label-text-line-height, var(--mat-sys-label-large-line-height));font-size:var(--mat-menu-item-label-text-size, var(--mat-sys-label-large-size));letter-spacing:var(--mat-menu-item-label-text-tracking, var(--mat-sys-label-large-tracking));font-weight:var(--mat-menu-item-label-text-weight, var(--mat-sys-label-large-weight))}@keyframes _mat-menu-enter{from{opacity:0;transform:scale(0.8)}to{opacity:1;transform:none}}@keyframes _mat-menu-exit{from{opacity:1}to{opacity:0}}.mat-mdc-menu-panel{min-width:112px;max-width:280px;overflow:auto;box-sizing:border-box;outline:0;animation:_mat-menu-enter 120ms cubic-bezier(0, 0, 0.2, 1);border-radius:var(--mat-menu-container-shape, var(--mat-sys-corner-extra-small));background-color:var(--mat-menu-container-color, var(--mat-sys-surface-container));box-shadow:var(--mat-menu-container-elevation-shadow, 0px 3px 1px -2px rgba(0, 0, 0, 0.2), 0px 2px 2px 0px rgba(0, 0, 0, 0.14), 0px 1px 5px 0px rgba(0, 0, 0, 0.12));will-change:transform,opacity}.mat-mdc-menu-panel.mat-menu-panel-exit-animation{animation:_mat-menu-exit 100ms 25ms linear forwards}.mat-mdc-menu-panel.mat-menu-panel-animations-disabled{animation:none}.mat-mdc-menu-panel.mat-menu-panel-animating{pointer-events:none}.mat-mdc-menu-panel.mat-menu-panel-animating:has(.mat-mdc-menu-content:empty){display:none}@media(forced-colors: active){.mat-mdc-menu-panel{outline:solid 1px}}.mat-mdc-menu-panel .mat-divider{color:var(--mat-menu-divider-color, var(--mat-sys-surface-variant));margin-bottom:var(--mat-menu-divider-bottom-spacing, 8px);margin-top:var(--mat-menu-divider-top-spacing, 8px)}.mat-mdc-menu-item{display:flex;position:relative;align-items:center;justify-content:flex-start;overflow:hidden;padding:0;cursor:pointer;width:100%;text-align:left;box-sizing:border-box;color:inherit;font-size:inherit;background:none;text-decoration:none;margin:0;min-height:48px;padding-left:var(--mat-menu-item-leading-spacing, 12px);padding-right:var(--mat-menu-item-trailing-spacing, 12px);-webkit-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:rgba(0,0,0,0)}.mat-mdc-menu-item::-moz-focus-inner{border:0}[dir=rtl] .mat-mdc-menu-item{padding-left:var(--mat-menu-item-trailing-spacing, 12px);padding-right:var(--mat-menu-item-leading-spacing, 12px)}.mat-mdc-menu-item:has(.material-icons,mat-icon,[matButtonIcon]){padding-left:var(--mat-menu-item-with-icon-leading-spacing, 12px);padding-right:var(--mat-menu-item-with-icon-trailing-spacing, 12px)}[dir=rtl] .mat-mdc-menu-item:has(.material-icons,mat-icon,[matButtonIcon]){padding-left:var(--mat-menu-item-with-icon-trailing-spacing, 12px);padding-right:var(--mat-menu-item-with-icon-leading-spacing, 12px)}.mat-mdc-menu-item,.mat-mdc-menu-item:visited,.mat-mdc-menu-item:link{color:var(--mat-menu-item-label-text-color, var(--mat-sys-on-surface))}.mat-mdc-menu-item .mat-icon-no-color,.mat-mdc-menu-item .mat-mdc-menu-submenu-icon{color:var(--mat-menu-item-icon-color, var(--mat-sys-on-surface-variant))}.mat-mdc-menu-item[disabled]{cursor:default;opacity:.38}.mat-mdc-menu-item[disabled]::after{display:block;position:absolute;content:\\\"\\\";top:0;left:0;bottom:0;right:0}.mat-mdc-menu-item:focus{outline:0}.mat-mdc-menu-item .mat-icon{flex-shrink:0;margin-right:var(--mat-menu-item-spacing, 12px);height:var(--mat-menu-item-icon-size, 24px);width:var(--mat-menu-item-icon-size, 24px)}[dir=rtl] .mat-mdc-menu-item{text-align:right}[dir=rtl] .mat-mdc-menu-item .mat-icon{margin-right:0;margin-left:var(--mat-menu-item-spacing, 12px)}.mat-mdc-menu-item:not([disabled]):hover{background-color:var(--mat-menu-item-hover-state-layer-color, color-mix(in srgb, var(--mat-sys-on-surface) calc(var(--mat-sys-hover-state-layer-opacity) * 100%), transparent))}.mat-mdc-menu-item:not([disabled]).cdk-program-focused,.mat-mdc-menu-item:not([disabled]).cdk-keyboard-focused,.mat-mdc-menu-item:not([disabled]).mat-mdc-menu-item-highlighted{background-color:var(--mat-menu-item-focus-state-layer-color, color-mix(in srgb, var(--mat-sys-on-surface) calc(var(--mat-sys-focus-state-layer-opacity) * 100%), transparent))}@media(forced-colors: active){.mat-mdc-menu-item{margin-top:1px}}.mat-mdc-menu-submenu-icon{width:var(--mat-menu-item-icon-size, 24px);height:10px;fill:currentColor;padding-left:var(--mat-menu-item-spacing, 12px)}[dir=rtl] .mat-mdc-menu-submenu-icon{padding-right:var(--mat-menu-item-spacing, 12px);padding-left:0}[dir=rtl] .mat-mdc-menu-submenu-icon polygon{transform:scaleX(-1);transform-origin:center}@media(forced-colors: active){.mat-mdc-menu-submenu-icon{fill:CanvasText}}.mat-mdc-menu-item .mat-mdc-menu-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}\\n\"], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: MatMenu, decorators: [{\n            type: Component,\n            args: [{ selector: 'mat-menu', changeDetection: ChangeDetectionStrategy.OnPush, encapsulation: ViewEncapsulation.None, exportAs: 'matMenu', host: {\n                        '[attr.aria-label]': 'null',\n                        '[attr.aria-labelledby]': 'null',\n                        '[attr.aria-describedby]': 'null',\n                    }, providers: [{ provide: MAT_MENU_PANEL, useExisting: MatMenu }], template: \"<ng-template>\\n  <div\\n    class=\\\"mat-mdc-menu-panel\\\"\\n    [id]=\\\"panelId\\\"\\n    [class]=\\\"_classList\\\"\\n    [class.mat-menu-panel-animations-disabled]=\\\"_animationsDisabled\\\"\\n    [class.mat-menu-panel-exit-animation]=\\\"_panelAnimationState === 'void'\\\"\\n    [class.mat-menu-panel-animating]=\\\"_isAnimating()\\\"\\n    (click)=\\\"closed.emit('click')\\\"\\n    tabindex=\\\"-1\\\"\\n    role=\\\"menu\\\"\\n    (animationstart)=\\\"_onAnimationStart($event.animationName)\\\"\\n    (animationend)=\\\"_onAnimationDone($event.animationName)\\\"\\n    (animationcancel)=\\\"_onAnimationDone($event.animationName)\\\"\\n    [attr.aria-label]=\\\"ariaLabel || null\\\"\\n    [attr.aria-labelledby]=\\\"ariaLabelledby || null\\\"\\n    [attr.aria-describedby]=\\\"ariaDescribedby || null\\\">\\n    <div class=\\\"mat-mdc-menu-content\\\">\\n      <ng-content></ng-content>\\n    </div>\\n  </div>\\n</ng-template>\\n\", styles: [\"mat-menu{display:none}.mat-mdc-menu-content{margin:0;padding:8px 0;outline:0}.mat-mdc-menu-content,.mat-mdc-menu-content .mat-mdc-menu-item .mat-mdc-menu-item-text{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;flex:1;white-space:normal;font-family:var(--mat-menu-item-label-text-font, var(--mat-sys-label-large-font));line-height:var(--mat-menu-item-label-text-line-height, var(--mat-sys-label-large-line-height));font-size:var(--mat-menu-item-label-text-size, var(--mat-sys-label-large-size));letter-spacing:var(--mat-menu-item-label-text-tracking, var(--mat-sys-label-large-tracking));font-weight:var(--mat-menu-item-label-text-weight, var(--mat-sys-label-large-weight))}@keyframes _mat-menu-enter{from{opacity:0;transform:scale(0.8)}to{opacity:1;transform:none}}@keyframes _mat-menu-exit{from{opacity:1}to{opacity:0}}.mat-mdc-menu-panel{min-width:112px;max-width:280px;overflow:auto;box-sizing:border-box;outline:0;animation:_mat-menu-enter 120ms cubic-bezier(0, 0, 0.2, 1);border-radius:var(--mat-menu-container-shape, var(--mat-sys-corner-extra-small));background-color:var(--mat-menu-container-color, var(--mat-sys-surface-container));box-shadow:var(--mat-menu-container-elevation-shadow, 0px 3px 1px -2px rgba(0, 0, 0, 0.2), 0px 2px 2px 0px rgba(0, 0, 0, 0.14), 0px 1px 5px 0px rgba(0, 0, 0, 0.12));will-change:transform,opacity}.mat-mdc-menu-panel.mat-menu-panel-exit-animation{animation:_mat-menu-exit 100ms 25ms linear forwards}.mat-mdc-menu-panel.mat-menu-panel-animations-disabled{animation:none}.mat-mdc-menu-panel.mat-menu-panel-animating{pointer-events:none}.mat-mdc-menu-panel.mat-menu-panel-animating:has(.mat-mdc-menu-content:empty){display:none}@media(forced-colors: active){.mat-mdc-menu-panel{outline:solid 1px}}.mat-mdc-menu-panel .mat-divider{color:var(--mat-menu-divider-color, var(--mat-sys-surface-variant));margin-bottom:var(--mat-menu-divider-bottom-spacing, 8px);margin-top:var(--mat-menu-divider-top-spacing, 8px)}.mat-mdc-menu-item{display:flex;position:relative;align-items:center;justify-content:flex-start;overflow:hidden;padding:0;cursor:pointer;width:100%;text-align:left;box-sizing:border-box;color:inherit;font-size:inherit;background:none;text-decoration:none;margin:0;min-height:48px;padding-left:var(--mat-menu-item-leading-spacing, 12px);padding-right:var(--mat-menu-item-trailing-spacing, 12px);-webkit-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:rgba(0,0,0,0)}.mat-mdc-menu-item::-moz-focus-inner{border:0}[dir=rtl] .mat-mdc-menu-item{padding-left:var(--mat-menu-item-trailing-spacing, 12px);padding-right:var(--mat-menu-item-leading-spacing, 12px)}.mat-mdc-menu-item:has(.material-icons,mat-icon,[matButtonIcon]){padding-left:var(--mat-menu-item-with-icon-leading-spacing, 12px);padding-right:var(--mat-menu-item-with-icon-trailing-spacing, 12px)}[dir=rtl] .mat-mdc-menu-item:has(.material-icons,mat-icon,[matButtonIcon]){padding-left:var(--mat-menu-item-with-icon-trailing-spacing, 12px);padding-right:var(--mat-menu-item-with-icon-leading-spacing, 12px)}.mat-mdc-menu-item,.mat-mdc-menu-item:visited,.mat-mdc-menu-item:link{color:var(--mat-menu-item-label-text-color, var(--mat-sys-on-surface))}.mat-mdc-menu-item .mat-icon-no-color,.mat-mdc-menu-item .mat-mdc-menu-submenu-icon{color:var(--mat-menu-item-icon-color, var(--mat-sys-on-surface-variant))}.mat-mdc-menu-item[disabled]{cursor:default;opacity:.38}.mat-mdc-menu-item[disabled]::after{display:block;position:absolute;content:\\\"\\\";top:0;left:0;bottom:0;right:0}.mat-mdc-menu-item:focus{outline:0}.mat-mdc-menu-item .mat-icon{flex-shrink:0;margin-right:var(--mat-menu-item-spacing, 12px);height:var(--mat-menu-item-icon-size, 24px);width:var(--mat-menu-item-icon-size, 24px)}[dir=rtl] .mat-mdc-menu-item{text-align:right}[dir=rtl] .mat-mdc-menu-item .mat-icon{margin-right:0;margin-left:var(--mat-menu-item-spacing, 12px)}.mat-mdc-menu-item:not([disabled]):hover{background-color:var(--mat-menu-item-hover-state-layer-color, color-mix(in srgb, var(--mat-sys-on-surface) calc(var(--mat-sys-hover-state-layer-opacity) * 100%), transparent))}.mat-mdc-menu-item:not([disabled]).cdk-program-focused,.mat-mdc-menu-item:not([disabled]).cdk-keyboard-focused,.mat-mdc-menu-item:not([disabled]).mat-mdc-menu-item-highlighted{background-color:var(--mat-menu-item-focus-state-layer-color, color-mix(in srgb, var(--mat-sys-on-surface) calc(var(--mat-sys-focus-state-layer-opacity) * 100%), transparent))}@media(forced-colors: active){.mat-mdc-menu-item{margin-top:1px}}.mat-mdc-menu-submenu-icon{width:var(--mat-menu-item-icon-size, 24px);height:10px;fill:currentColor;padding-left:var(--mat-menu-item-spacing, 12px)}[dir=rtl] .mat-mdc-menu-submenu-icon{padding-right:var(--mat-menu-item-spacing, 12px);padding-left:0}[dir=rtl] .mat-mdc-menu-submenu-icon polygon{transform:scaleX(-1);transform-origin:center}@media(forced-colors: active){.mat-mdc-menu-submenu-icon{fill:CanvasText}}.mat-mdc-menu-item .mat-mdc-menu-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}\\n\"] }]\n        }], ctorParameters: () => [], propDecorators: { _allItems: [{\n                type: ContentChildren,\n                args: [MatMenuItem, { descendants: true }]\n            }], backdropClass: [{\n                type: Input\n            }], ariaLabel: [{\n                type: Input,\n                args: ['aria-label']\n            }], ariaLabelledby: [{\n                type: Input,\n                args: ['aria-labelledby']\n            }], ariaDescribedby: [{\n                type: Input,\n                args: ['aria-describedby']\n            }], xPosition: [{\n                type: Input\n            }], yPosition: [{\n                type: Input\n            }], templateRef: [{\n                type: ViewChild,\n                args: [TemplateRef]\n            }], items: [{\n                type: ContentChildren,\n                args: [MatMenuItem, { descendants: false }]\n            }], lazyContent: [{\n                type: ContentChild,\n                args: [MAT_MENU_CONTENT]\n            }], overlapTrigger: [{\n                type: Input,\n                args: [{ transform: booleanAttribute }]\n            }], hasBackdrop: [{\n                type: Input,\n                args: [{ transform: (value) => (value == null ? null : booleanAttribute(value)) }]\n            }], panelClass: [{\n                type: Input,\n                args: ['class']\n            }], classList: [{\n                type: Input\n            }], closed: [{\n                type: Output\n            }], close: [{\n                type: Output\n            }] } });\n\n/** Injection token that determines the scroll handling while the menu is open. */\nconst MAT_MENU_SCROLL_STRATEGY = new InjectionToken('mat-menu-scroll-strategy', {\n    providedIn: 'root',\n    factory: () => {\n        const injector = inject(Injector);\n        return () => createRepositionScrollStrategy(injector);\n    },\n});\n/**\n * @docs-private\n * @deprecated No longer used, will be removed.\n * @breaking-change 21.0.0\n */\nfunction MAT_MENU_SCROLL_STRATEGY_FACTORY(_overlay) {\n    const injector = inject(Injector);\n    return () => createRepositionScrollStrategy(injector);\n}\n/**\n * @docs-private\n * @deprecated No longer used, will be removed.\n * @breaking-change 21.0.0\n */\nconst MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER = {\n    provide: MAT_MENU_SCROLL_STRATEGY,\n    deps: [],\n    useFactory: MAT_MENU_SCROLL_STRATEGY_FACTORY,\n};\n/**\n * Default top padding of the menu panel.\n * @deprecated No longer being used. Will be removed.\n * @breaking-change 15.0.0\n */\nconst MENU_PANEL_TOP_PADDING = 8;\n/** Mapping between menu panels and the last trigger that opened them. */\nconst PANELS_TO_TRIGGERS = new WeakMap();\n/** Directive applied to an element that should trigger a `mat-menu`. */\nclass MatMenuTriggerBase {\n    _canHaveBackdrop;\n    _element = inject(ElementRef);\n    _viewContainerRef = inject(ViewContainerRef);\n    _menuItemInstance = inject(MatMenuItem, { optional: true, self: true });\n    _dir = inject(Directionality, { optional: true });\n    _focusMonitor = inject(FocusMonitor);\n    _ngZone = inject(NgZone);\n    _injector = inject(Injector);\n    _scrollStrategy = inject(MAT_MENU_SCROLL_STRATEGY);\n    _changeDetectorRef = inject(ChangeDetectorRef);\n    _animationsDisabled = _animationsDisabled();\n    _portal;\n    _overlayRef = null;\n    _menuOpen = false;\n    _closingActionsSubscription = Subscription.EMPTY;\n    _menuCloseSubscription = Subscription.EMPTY;\n    _pendingRemoval;\n    /**\n     * We're specifically looking for a `MatMenu` here since the generic `MatMenuPanel`\n     * interface lacks some functionality around nested menus and animations.\n     */\n    _parentMaterialMenu;\n    /**\n     * Cached value of the padding of the parent menu panel.\n     * Used to offset sub-menus to compensate for the padding.\n     */\n    _parentInnerPadding;\n    // Tracking input type is necessary so it's possible to only auto-focus\n    // the first item of the list when the menu is opened via the keyboard\n    _openedBy = undefined;\n    /** Menu currently assigned to the trigger. */\n    get _menu() {\n        return this._menuInternal;\n    }\n    set _menu(menu) {\n        if (menu === this._menuInternal) {\n            return;\n        }\n        this._menuInternal = menu;\n        this._menuCloseSubscription.unsubscribe();\n        if (menu) {\n            if (menu === this._parentMaterialMenu && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                throwMatMenuRecursiveError();\n            }\n            this._menuCloseSubscription = menu.close.subscribe((reason) => {\n                this._destroyMenu(reason);\n                // If a click closed the menu, we should close the entire chain of nested menus.\n                if ((reason === 'click' || reason === 'tab') && this._parentMaterialMenu) {\n                    this._parentMaterialMenu.closed.emit(reason);\n                }\n            });\n        }\n        this._menuItemInstance?._setTriggersSubmenu(this._triggersSubmenu());\n    }\n    _menuInternal;\n    constructor(_canHaveBackdrop) {\n        this._canHaveBackdrop = _canHaveBackdrop;\n        const parentMenu = inject(MAT_MENU_PANEL, { optional: true });\n        this._parentMaterialMenu = parentMenu instanceof MatMenu ? parentMenu : undefined;\n    }\n    ngOnDestroy() {\n        if (this._menu && this._ownsMenu(this._menu)) {\n            PANELS_TO_TRIGGERS.delete(this._menu);\n        }\n        this._pendingRemoval?.unsubscribe();\n        this._menuCloseSubscription.unsubscribe();\n        this._closingActionsSubscription.unsubscribe();\n        if (this._overlayRef) {\n            this._overlayRef.dispose();\n            this._overlayRef = null;\n        }\n    }\n    /** Whether the menu is open. */\n    get menuOpen() {\n        return this._menuOpen;\n    }\n    /** The text direction of the containing app. */\n    get dir() {\n        return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';\n    }\n    /** Whether the menu triggers a sub-menu or a top-level one. */\n    _triggersSubmenu() {\n        return !!(this._menuItemInstance && this._parentMaterialMenu && this._menu);\n    }\n    _closeMenu() {\n        this._menu?.close.emit();\n    }\n    /** Internal method to open menu providing option to auto focus on first item. */\n    _openMenu(autoFocus) {\n        const menu = this._menu;\n        if (this._menuOpen || !menu) {\n            return;\n        }\n        this._pendingRemoval?.unsubscribe();\n        const previousTrigger = PANELS_TO_TRIGGERS.get(menu);\n        PANELS_TO_TRIGGERS.set(menu, this);\n        // If the same menu is currently attached to another trigger,\n        // we need to close it so it doesn't end up in a broken state.\n        if (previousTrigger && previousTrigger !== this) {\n            previousTrigger._closeMenu();\n        }\n        const overlayRef = this._createOverlay(menu);\n        const overlayConfig = overlayRef.getConfig();\n        const positionStrategy = overlayConfig.positionStrategy;\n        this._setPosition(menu, positionStrategy);\n        if (this._canHaveBackdrop) {\n            overlayConfig.hasBackdrop =\n                menu.hasBackdrop == null ? !this._triggersSubmenu() : menu.hasBackdrop;\n        }\n        else {\n            overlayConfig.hasBackdrop = false;\n        }\n        // We need the `hasAttached` check for the case where the user kicked off a removal animation,\n        // but re-entered the menu. Re-attaching the same portal will trigger an error otherwise.\n        if (!overlayRef.hasAttached()) {\n            overlayRef.attach(this._getPortal(menu));\n            menu.lazyContent?.attach(this.menuData);\n        }\n        this._closingActionsSubscription = this._menuClosingActions().subscribe(() => this._closeMenu());\n        menu.parentMenu = this._triggersSubmenu() ? this._parentMaterialMenu : undefined;\n        menu.direction = this.dir;\n        if (autoFocus) {\n            menu.focusFirstItem(this._openedBy || 'program');\n        }\n        this._setIsMenuOpen(true);\n        if (menu instanceof MatMenu) {\n            menu._setIsOpen(true);\n            menu._directDescendantItems.changes.pipe(takeUntil(menu.close)).subscribe(() => {\n                // Re-adjust the position without locking when the amount of items\n                // changes so that the overlay is allowed to pick a new optimal position.\n                positionStrategy.withLockedPosition(false).reapplyLastPosition();\n                positionStrategy.withLockedPosition(true);\n            });\n        }\n    }\n    /**\n     * Focuses the menu trigger.\n     * @param origin Source of the menu trigger's focus.\n     */\n    focus(origin, options) {\n        if (this._focusMonitor && origin) {\n            this._focusMonitor.focusVia(this._element, origin, options);\n        }\n        else {\n            this._element.nativeElement.focus(options);\n        }\n    }\n    /** Closes the menu and does the necessary cleanup. */\n    _destroyMenu(reason) {\n        const overlayRef = this._overlayRef;\n        const menu = this._menu;\n        if (!overlayRef || !this.menuOpen) {\n            return;\n        }\n        this._closingActionsSubscription.unsubscribe();\n        this._pendingRemoval?.unsubscribe();\n        // Note that we don't wait for the animation to finish if another trigger took\n        // over the menu, because the panel will end up empty which looks glitchy.\n        if (menu instanceof MatMenu && this._ownsMenu(menu)) {\n            this._pendingRemoval = menu._animationDone.pipe(take(1)).subscribe(() => {\n                overlayRef.detach();\n                // Only detach the lazy content if no other trigger took over the menu, otherwise we may\n                // detach something we no longer own. Note that we don't use `this._ownsMenu` here,\n                // because the current trigger relinquishes ownership as soon as the closing sequence\n                // is kicked off whereas the animation takes some time to play out.\n                if (!PANELS_TO_TRIGGERS.has(menu)) {\n                    menu.lazyContent?.detach();\n                }\n            });\n            menu._setIsOpen(false);\n        }\n        else {\n            overlayRef.detach();\n            menu?.lazyContent?.detach();\n        }\n        if (menu && this._ownsMenu(menu)) {\n            PANELS_TO_TRIGGERS.delete(menu);\n        }\n        // Always restore focus if the user is navigating using the keyboard or the menu was opened\n        // programmatically. We don't restore for non-root triggers, because it can prevent focus\n        // from making it back to the root trigger when closing a long chain of menus by clicking\n        // on the backdrop.\n        if (this.restoreFocus &&\n            (reason === 'keydown' || !this._openedBy || !this._triggersSubmenu())) {\n            this.focus(this._openedBy);\n        }\n        this._openedBy = undefined;\n        this._setIsMenuOpen(false);\n    }\n    // set state rather than toggle to support triggers sharing a menu\n    _setIsMenuOpen(isOpen) {\n        if (isOpen !== this._menuOpen) {\n            this._menuOpen = isOpen;\n            this._menuOpen ? this.menuOpened.emit() : this.menuClosed.emit();\n            if (this._triggersSubmenu()) {\n                this._menuItemInstance._setHighlighted(isOpen);\n            }\n            this._changeDetectorRef.markForCheck();\n        }\n    }\n    /**\n     * This method creates the overlay from the provided menu's template and saves its\n     * OverlayRef so that it can be attached to the DOM when openMenu is called.\n     */\n    _createOverlay(menu) {\n        if (!this._overlayRef) {\n            const config = this._getOverlayConfig(menu);\n            this._subscribeToPositions(menu, config.positionStrategy);\n            this._overlayRef = createOverlayRef(this._injector, config);\n            this._overlayRef.keydownEvents().subscribe(event => {\n                if (this._menu instanceof MatMenu) {\n                    this._menu._handleKeydown(event);\n                }\n            });\n        }\n        return this._overlayRef;\n    }\n    /**\n     * This method builds the configuration object needed to create the overlay, the OverlayState.\n     * @returns OverlayConfig\n     */\n    _getOverlayConfig(menu) {\n        return new OverlayConfig({\n            positionStrategy: createFlexibleConnectedPositionStrategy(this._injector, this._getOverlayOrigin())\n                .withLockedPosition()\n                .withGrowAfterOpen()\n                .withTransformOriginOn('.mat-menu-panel, .mat-mdc-menu-panel'),\n            backdropClass: menu.backdropClass || 'cdk-overlay-transparent-backdrop',\n            panelClass: menu.overlayPanelClass,\n            scrollStrategy: this._scrollStrategy(),\n            direction: this._dir || 'ltr',\n            disableAnimations: this._animationsDisabled,\n        });\n    }\n    /**\n     * Listens to changes in the position of the overlay and sets the correct classes\n     * on the menu based on the new position. This ensures the animation origin is always\n     * correct, even if a fallback position is used for the overlay.\n     */\n    _subscribeToPositions(menu, position) {\n        if (menu.setPositionClasses) {\n            position.positionChanges.subscribe(change => {\n                this._ngZone.run(() => {\n                    const posX = change.connectionPair.overlayX === 'start' ? 'after' : 'before';\n                    const posY = change.connectionPair.overlayY === 'top' ? 'below' : 'above';\n                    menu.setPositionClasses(posX, posY);\n                });\n            });\n        }\n    }\n    /**\n     * Sets the appropriate positions on a position strategy\n     * so the overlay connects with the trigger correctly.\n     * @param positionStrategy Strategy whose position to update.\n     */\n    _setPosition(menu, positionStrategy) {\n        let [originX, originFallbackX] = menu.xPosition === 'before' ? ['end', 'start'] : ['start', 'end'];\n        let [overlayY, overlayFallbackY] = menu.yPosition === 'above' ? ['bottom', 'top'] : ['top', 'bottom'];\n        let [originY, originFallbackY] = [overlayY, overlayFallbackY];\n        let [overlayX, overlayFallbackX] = [originX, originFallbackX];\n        let offsetY = 0;\n        if (this._triggersSubmenu()) {\n            // When the menu is a sub-menu, it should always align itself\n            // to the edges of the trigger, instead of overlapping it.\n            overlayFallbackX = originX = menu.xPosition === 'before' ? 'start' : 'end';\n            originFallbackX = overlayX = originX === 'end' ? 'start' : 'end';\n            if (this._parentMaterialMenu) {\n                if (this._parentInnerPadding == null) {\n                    const firstItem = this._parentMaterialMenu.items.first;\n                    this._parentInnerPadding = firstItem ? firstItem._getHostElement().offsetTop : 0;\n                }\n                offsetY = overlayY === 'bottom' ? this._parentInnerPadding : -this._parentInnerPadding;\n            }\n        }\n        else if (!menu.overlapTrigger) {\n            originY = overlayY === 'top' ? 'bottom' : 'top';\n            originFallbackY = overlayFallbackY === 'top' ? 'bottom' : 'top';\n        }\n        positionStrategy.withPositions([\n            { originX, originY, overlayX, overlayY, offsetY },\n            { originX: originFallbackX, originY, overlayX: overlayFallbackX, overlayY, offsetY },\n            {\n                originX,\n                originY: originFallbackY,\n                overlayX,\n                overlayY: overlayFallbackY,\n                offsetY: -offsetY,\n            },\n            {\n                originX: originFallbackX,\n                originY: originFallbackY,\n                overlayX: overlayFallbackX,\n                overlayY: overlayFallbackY,\n                offsetY: -offsetY,\n            },\n        ]);\n    }\n    /** Returns a stream that emits whenever an action that should close the menu occurs. */\n    _menuClosingActions() {\n        const outsideClicks = this._getOutsideClickStream(this._overlayRef);\n        const detachments = this._overlayRef.detachments();\n        const parentClose = this._parentMaterialMenu ? this._parentMaterialMenu.closed : of();\n        const hover = this._parentMaterialMenu\n            ? this._parentMaterialMenu\n                ._hovered()\n                .pipe(filter(active => this._menuOpen && active !== this._menuItemInstance))\n            : of();\n        return merge(outsideClicks, parentClose, hover, detachments);\n    }\n    /** Gets the portal that should be attached to the overlay. */\n    _getPortal(menu) {\n        // Note that we can avoid this check by keeping the portal on the menu panel.\n        // While it would be cleaner, we'd have to introduce another required method on\n        // `MatMenuPanel`, making it harder to consume.\n        if (!this._portal || this._portal.templateRef !== menu.templateRef) {\n            this._portal = new TemplatePortal(menu.templateRef, this._viewContainerRef);\n        }\n        return this._portal;\n    }\n    /**\n     * Determines whether the trigger owns a specific menu panel, at the current point in time.\n     * This allows us to distinguish the case where the same panel is passed into multiple triggers\n     * and multiple are open at a time.\n     */\n    _ownsMenu(menu) {\n        return PANELS_TO_TRIGGERS.get(menu) === this;\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: MatMenuTriggerBase, deps: \"invalid\", target: i0.ɵɵFactoryTarget.Directive });\n    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"20.2.0-next.2\", type: MatMenuTriggerBase, isStandalone: true, ngImport: i0 });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: MatMenuTriggerBase, decorators: [{\n            type: Directive\n        }], ctorParameters: () => [{ type: undefined }] });\n\n/** Directive applied to an element that should trigger a `mat-menu`. */\nclass MatMenuTrigger extends MatMenuTriggerBase {\n    _cleanupTouchstart;\n    _hoverSubscription = Subscription.EMPTY;\n    /**\n     * @deprecated\n     * @breaking-change 8.0.0\n     */\n    get _deprecatedMatMenuTriggerFor() {\n        return this.menu;\n    }\n    set _deprecatedMatMenuTriggerFor(v) {\n        this.menu = v;\n    }\n    /** References the menu instance that the trigger is associated with. */\n    get menu() {\n        return this._menu;\n    }\n    set menu(menu) {\n        this._menu = menu;\n    }\n    /** Data to be passed along to any lazily-rendered content. */\n    menuData;\n    /**\n     * Whether focus should be restored when the menu is closed.\n     * Note that disabling this option can have accessibility implications\n     * and it's up to you to manage focus, if you decide to turn it off.\n     */\n    restoreFocus = true;\n    /** Event emitted when the associated menu is opened. */\n    menuOpened = new EventEmitter();\n    /**\n     * Event emitted when the associated menu is opened.\n     * @deprecated Switch to `menuOpened` instead\n     * @breaking-change 8.0.0\n     */\n    // tslint:disable-next-line:no-output-on-prefix\n    onMenuOpen = this.menuOpened;\n    /** Event emitted when the associated menu is closed. */\n    menuClosed = new EventEmitter();\n    /**\n     * Event emitted when the associated menu is closed.\n     * @deprecated Switch to `menuClosed` instead\n     * @breaking-change 8.0.0\n     */\n    // tslint:disable-next-line:no-output-on-prefix\n    onMenuClose = this.menuClosed;\n    constructor() {\n        super(true);\n        const renderer = inject(Renderer2);\n        this._cleanupTouchstart = renderer.listen(this._element.nativeElement, 'touchstart', (event) => {\n            if (!isFakeTouchstartFromScreenReader(event)) {\n                this._openedBy = 'touch';\n            }\n        }, { passive: true });\n    }\n    /** Whether the menu triggers a sub-menu or a top-level one. */\n    triggersSubmenu() {\n        return super._triggersSubmenu();\n    }\n    /** Toggles the menu between the open and closed states. */\n    toggleMenu() {\n        return this.menuOpen ? this.closeMenu() : this.openMenu();\n    }\n    /** Opens the menu. */\n    openMenu() {\n        this._openMenu(true);\n    }\n    /** Closes the menu. */\n    closeMenu() {\n        this._closeMenu();\n    }\n    /**\n     * Updates the position of the menu to ensure that it fits all options within the viewport.\n     */\n    updatePosition() {\n        this._overlayRef?.updatePosition();\n    }\n    ngAfterContentInit() {\n        this._handleHover();\n    }\n    ngOnDestroy() {\n        super.ngOnDestroy();\n        this._cleanupTouchstart();\n        this._hoverSubscription.unsubscribe();\n    }\n    _getOverlayOrigin() {\n        return this._element;\n    }\n    _getOutsideClickStream(overlayRef) {\n        return overlayRef.backdropClick();\n    }\n    /** Handles mouse presses on the trigger. */\n    _handleMousedown(event) {\n        if (!isFakeMousedownFromScreenReader(event)) {\n            // Since right or middle button clicks won't trigger the `click` event,\n            // we shouldn't consider the menu as opened by mouse in those cases.\n            this._openedBy = event.button === 0 ? 'mouse' : undefined;\n            // Since clicking on the trigger won't close the menu if it opens a sub-menu,\n            // we should prevent focus from moving onto it via click to avoid the\n            // highlight from lingering on the menu item.\n            if (this.triggersSubmenu()) {\n                event.preventDefault();\n            }\n        }\n    }\n    /** Handles key presses on the trigger. */\n    _handleKeydown(event) {\n        const keyCode = event.keyCode;\n        // Pressing enter on the trigger will trigger the click handler later.\n        if (keyCode === ENTER || keyCode === SPACE) {\n            this._openedBy = 'keyboard';\n        }\n        if (this.triggersSubmenu() &&\n            ((keyCode === RIGHT_ARROW && this.dir === 'ltr') ||\n                (keyCode === LEFT_ARROW && this.dir === 'rtl'))) {\n            this._openedBy = 'keyboard';\n            this.openMenu();\n        }\n    }\n    /** Handles click events on the trigger. */\n    _handleClick(event) {\n        if (this.triggersSubmenu()) {\n            // Stop event propagation to avoid closing the parent menu.\n            event.stopPropagation();\n            this.openMenu();\n        }\n        else {\n            this.toggleMenu();\n        }\n    }\n    /** Handles the cases where the user hovers over the trigger. */\n    _handleHover() {\n        // Subscribe to changes in the hovered item in order to toggle the panel.\n        if (this.triggersSubmenu() && this._parentMaterialMenu) {\n            this._hoverSubscription = this._parentMaterialMenu._hovered().subscribe(active => {\n                if (active === this._menuItemInstance &&\n                    !active.disabled &&\n                    // Ignore hover events if the parent menu is in the process of being closed (see #31956).\n                    this._parentMaterialMenu?._panelAnimationState !== 'void') {\n                    this._openedBy = 'mouse';\n                    // Open the menu, but do NOT auto-focus on first item when just hovering.\n                    // When VoiceOver is enabled, this is particularly confusing as the focus will\n                    // cause another hover event, and continue opening sub-menus without interaction.\n                    this._openMenu(false);\n                }\n            });\n        }\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: MatMenuTrigger, deps: [], target: i0.ɵɵFactoryTarget.Directive });\n    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"20.2.0-next.2\", type: MatMenuTrigger, isStandalone: true, selector: \"[mat-menu-trigger-for], [matMenuTriggerFor]\", inputs: { _deprecatedMatMenuTriggerFor: [\"mat-menu-trigger-for\", \"_deprecatedMatMenuTriggerFor\"], menu: [\"matMenuTriggerFor\", \"menu\"], menuData: [\"matMenuTriggerData\", \"menuData\"], restoreFocus: [\"matMenuTriggerRestoreFocus\", \"restoreFocus\"] }, outputs: { menuOpened: \"menuOpened\", onMenuOpen: \"onMenuOpen\", menuClosed: \"menuClosed\", onMenuClose: \"onMenuClose\" }, host: { listeners: { \"click\": \"_handleClick($event)\", \"mousedown\": \"_handleMousedown($event)\", \"keydown\": \"_handleKeydown($event)\" }, properties: { \"attr.aria-haspopup\": \"menu ? \\\"menu\\\" : null\", \"attr.aria-expanded\": \"menuOpen\", \"attr.aria-controls\": \"menuOpen ? menu?.panelId : null\" }, classAttribute: \"mat-mdc-menu-trigger\" }, exportAs: [\"matMenuTrigger\"], usesInheritance: true, ngImport: i0 });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: MatMenuTrigger, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[mat-menu-trigger-for], [matMenuTriggerFor]',\n                    host: {\n                        'class': 'mat-mdc-menu-trigger',\n                        '[attr.aria-haspopup]': 'menu ? \"menu\" : null',\n                        '[attr.aria-expanded]': 'menuOpen',\n                        '[attr.aria-controls]': 'menuOpen ? menu?.panelId : null',\n                        '(click)': '_handleClick($event)',\n                        '(mousedown)': '_handleMousedown($event)',\n                        '(keydown)': '_handleKeydown($event)',\n                    },\n                    exportAs: 'matMenuTrigger',\n                }]\n        }], ctorParameters: () => [], propDecorators: { _deprecatedMatMenuTriggerFor: [{\n                type: Input,\n                args: ['mat-menu-trigger-for']\n            }], menu: [{\n                type: Input,\n                args: ['matMenuTriggerFor']\n            }], menuData: [{\n                type: Input,\n                args: ['matMenuTriggerData']\n            }], restoreFocus: [{\n                type: Input,\n                args: ['matMenuTriggerRestoreFocus']\n            }], menuOpened: [{\n                type: Output\n            }], onMenuOpen: [{\n                type: Output\n            }], menuClosed: [{\n                type: Output\n            }], onMenuClose: [{\n                type: Output\n            }] } });\n\n/**\n * Trigger that opens a menu whenever the user right-clicks within its host element.\n */\nclass MatContextMenuTrigger extends MatMenuTriggerBase {\n    _point = { x: 0, y: 0, initialX: 0, initialY: 0, initialScrollX: 0, initialScrollY: 0 };\n    _triggerPressedControl = false;\n    _rootNode;\n    _document = inject(DOCUMENT);\n    _viewportRuler = inject(ViewportRuler);\n    _scrollDispatcher = inject(ScrollDispatcher);\n    _scrollSubscription;\n    /** References the menu instance that the trigger is associated with. */\n    get menu() {\n        return this._menu;\n    }\n    set menu(menu) {\n        this._menu = menu;\n    }\n    /** Data to be passed along to any lazily-rendered content. */\n    menuData;\n    /**\n     * Whether focus should be restored when the menu is closed.\n     * Note that disabling this option can have accessibility implications\n     * and it's up to you to manage focus, if you decide to turn it off.\n     */\n    restoreFocus = true;\n    /** Whether the context menu is disabled. */\n    disabled = false;\n    /** Event emitted when the associated menu is opened. */\n    menuOpened = new EventEmitter();\n    /** Event emitted when the associated menu is closed. */\n    menuClosed = new EventEmitter();\n    constructor() {\n        super(false);\n    }\n    ngOnDestroy() {\n        super.ngOnDestroy();\n        this._scrollSubscription?.unsubscribe();\n    }\n    /** Handler for `contextmenu` events. */\n    _handleContextMenuEvent(event) {\n        if (!this.disabled) {\n            event.preventDefault();\n            // If the menu is already open, only update its position.\n            if (this.menuOpen) {\n                this._initializePoint(event.clientX, event.clientY);\n                this._updatePosition();\n            }\n            else {\n                this._openContextMenu(event);\n            }\n        }\n    }\n    _destroyMenu(reason) {\n        super._destroyMenu(reason);\n        this._scrollSubscription?.unsubscribe();\n    }\n    _getOverlayOrigin() {\n        return this._point;\n    }\n    _getOutsideClickStream(overlayRef) {\n        return overlayRef.outsidePointerEvents().pipe(skipWhile((event, index) => {\n            if (event.type === 'contextmenu') {\n                // Do not close when attempting to open a context menu within the trigger.\n                return this._isWithinMenuOrTrigger(_getEventTarget(event));\n            }\n            else if (event.type === 'auxclick') {\n                // Skip the first `auxclick` since it happens at\n                // the same time as the event that opens the menu.\n                if (index === 0) {\n                    return true;\n                }\n                // Do not close on `auxclick` within the menu since we want to reposition the menu\n                // instead. Note that we have to resolve the clicked element using its position,\n                // rather than `event.target`, because the `target` is set to the `body`.\n                this._rootNode ??= _getShadowRoot(this._element.nativeElement) || this._document;\n                return this._isWithinMenuOrTrigger(this._rootNode.elementFromPoint(event.clientX, event.clientY));\n            }\n            // Using a mouse, the `contextmenu` event can fire either when pressing the right button\n            // or left button + control. Most browsers won't dispatch a `click` event right after\n            // a `contextmenu` event triggered by left button + control, but Safari will (see #27832).\n            // This closes the menu immediately. To work around it, we check that both the triggering\n            // event and the current outside click event both had the control key pressed, and that\n            // that this is the first outside click event.\n            return this._triggerPressedControl && index === 0 && event.ctrlKey;\n        }));\n    }\n    /** Checks whether an element is within the trigger or the opened overlay. */\n    _isWithinMenuOrTrigger(target) {\n        if (!target) {\n            return false;\n        }\n        const element = this._element.nativeElement;\n        if (target === element || element.contains(target)) {\n            return true;\n        }\n        const overlay = this._overlayRef?.hostElement;\n        return overlay === target || !!overlay?.contains(target);\n    }\n    /** Opens the context menu. */\n    _openContextMenu(event) {\n        // A context menu can be triggered via a mouse right click or a keyboard shortcut.\n        if (event.button === 2) {\n            this._openedBy = 'mouse';\n        }\n        else {\n            this._openedBy = event.button === 0 ? 'keyboard' : undefined;\n        }\n        this._initializePoint(event.clientX, event.clientY);\n        this._triggerPressedControl = event.ctrlKey;\n        super._openMenu(true);\n        this._scrollSubscription?.unsubscribe();\n        this._scrollSubscription = this._scrollDispatcher.scrolled(0).subscribe(() => {\n            // When passing a point to the connected position strategy, the position\n            // won't update as the user is scrolling so we have to do it manually.\n            const position = this._viewportRuler.getViewportScrollPosition();\n            const point = this._point;\n            point.y = point.initialY + (point.initialScrollY - position.top);\n            point.x = point.initialX + (point.initialScrollX - position.left);\n            this._updatePosition();\n        });\n    }\n    /** Initializes the point representing the origin relative to which the menu will be rendered. */\n    _initializePoint(x, y) {\n        const scrollPosition = this._viewportRuler.getViewportScrollPosition();\n        const point = this._point;\n        point.x = point.initialX = x;\n        point.y = point.initialY = y;\n        point.initialScrollX = scrollPosition.left;\n        point.initialScrollY = scrollPosition.top;\n    }\n    /** Refreshes the position of the overlay. */\n    _updatePosition() {\n        const overlayRef = this._overlayRef;\n        if (overlayRef) {\n            const positionStrategy = overlayRef.getConfig()\n                .positionStrategy;\n            positionStrategy.setOrigin(this._point);\n            overlayRef.updatePosition();\n        }\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: MatContextMenuTrigger, deps: [], target: i0.ɵɵFactoryTarget.Directive });\n    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"16.1.0\", version: \"20.2.0-next.2\", type: MatContextMenuTrigger, isStandalone: true, selector: \"[matContextMenuTriggerFor]\", inputs: { menu: [\"matContextMenuTriggerFor\", \"menu\"], menuData: [\"matContextMenuTriggerData\", \"menuData\"], restoreFocus: [\"matContextMenuTriggerRestoreFocus\", \"restoreFocus\"], disabled: [\"matContextMenuTriggerDisabled\", \"disabled\", booleanAttribute] }, outputs: { menuOpened: \"menuOpened\", menuClosed: \"menuClosed\" }, host: { listeners: { \"contextmenu\": \"_handleContextMenuEvent($event)\" }, properties: { \"class.mat-context-menu-trigger-disabled\": \"disabled\", \"attr.aria-controls\": \"menuOpen ? menu?.panelId : null\" }, classAttribute: \"mat-context-menu-trigger\" }, exportAs: [\"matContextMenuTrigger\"], usesInheritance: true, ngImport: i0 });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: MatContextMenuTrigger, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[matContextMenuTriggerFor]',\n                    host: {\n                        'class': 'mat-context-menu-trigger',\n                        '[class.mat-context-menu-trigger-disabled]': 'disabled',\n                        '[attr.aria-controls]': 'menuOpen ? menu?.panelId : null',\n                        '(contextmenu)': '_handleContextMenuEvent($event)',\n                    },\n                    exportAs: 'matContextMenuTrigger',\n                }]\n        }], ctorParameters: () => [], propDecorators: { menu: [{\n                type: Input,\n                args: [{ alias: 'matContextMenuTriggerFor', required: true }]\n            }], menuData: [{\n                type: Input,\n                args: ['matContextMenuTriggerData']\n            }], restoreFocus: [{\n                type: Input,\n                args: ['matContextMenuTriggerRestoreFocus']\n            }], disabled: [{\n                type: Input,\n                args: [{ alias: 'matContextMenuTriggerDisabled', transform: booleanAttribute }]\n            }], menuOpened: [{\n                type: Output\n            }], menuClosed: [{\n                type: Output\n            }] } });\n\nclass MatMenuModule {\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: MatMenuModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\n    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: MatMenuModule, imports: [MatRippleModule,\n            MatCommonModule,\n            OverlayModule,\n            MatMenu,\n            MatMenuItem,\n            MatMenuContent,\n            MatMenuTrigger,\n            MatContextMenuTrigger], exports: [CdkScrollableModule,\n            MatMenu,\n            MatCommonModule,\n            MatMenuItem,\n            MatMenuContent,\n            MatMenuTrigger,\n            MatContextMenuTrigger] });\n    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: MatMenuModule, providers: [MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER], imports: [MatRippleModule,\n            MatCommonModule,\n            OverlayModule, CdkScrollableModule,\n            MatCommonModule] });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: MatMenuModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [\n                        MatRippleModule,\n                        MatCommonModule,\n                        OverlayModule,\n                        MatMenu,\n                        MatMenuItem,\n                        MatMenuContent,\n                        MatMenuTrigger,\n                        MatContextMenuTrigger,\n                    ],\n                    exports: [\n                        CdkScrollableModule,\n                        MatMenu,\n                        MatCommonModule,\n                        MatMenuItem,\n                        MatMenuContent,\n                        MatMenuTrigger,\n                        MatContextMenuTrigger,\n                    ],\n                    providers: [MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER],\n                }]\n        }] });\n\n/**\n * Animations used by the mat-menu component.\n * Animation duration and timing values are based on:\n * https://material.io/guidelines/components/menus.html#menus-usage\n * @docs-private\n * @deprecated No longer used, will be removed.\n * @breaking-change 21.0.0\n */\nconst matMenuAnimations = {\n    // Represents:\n    // trigger('transformMenu', [\n    //   state(\n    //     'void',\n    //     style({\n    //       opacity: 0,\n    //       transform: 'scale(0.8)',\n    //     }),\n    //   ),\n    //   transition(\n    //     'void => enter',\n    //     animate(\n    //       '120ms cubic-bezier(0, 0, 0.2, 1)',\n    //       style({\n    //         opacity: 1,\n    //         transform: 'scale(1)',\n    //       }),\n    //     ),\n    //   ),\n    //   transition('* => void', animate('100ms 25ms linear', style({opacity: 0}))),\n    // ])\n    /**\n     * This animation controls the menu panel's entry and exit from the page.\n     *\n     * When the menu panel is added to the DOM, it scales in and fades in its border.\n     *\n     * When the menu panel is removed from the DOM, it simply fades out after a brief\n     * delay to display the ripple.\n     */\n    transformMenu: {\n        type: 7,\n        name: 'transformMenu',\n        definitions: [\n            {\n                type: 0,\n                name: 'void',\n                styles: { type: 6, styles: { opacity: 0, transform: 'scale(0.8)' }, offset: null },\n            },\n            {\n                type: 1,\n                expr: 'void => enter',\n                animation: {\n                    type: 4,\n                    styles: { type: 6, styles: { opacity: 1, transform: 'scale(1)' }, offset: null },\n                    timings: '120ms cubic-bezier(0, 0, 0.2, 1)',\n                },\n                options: null,\n            },\n            {\n                type: 1,\n                expr: '* => void',\n                animation: {\n                    type: 4,\n                    styles: { type: 6, styles: { opacity: 0 }, offset: null },\n                    timings: '100ms 25ms linear',\n                },\n                options: null,\n            },\n        ],\n        options: {},\n    },\n    // Represents:\n    // trigger('fadeInItems', [\n    //   // TODO(crisbeto): this is inside the `transformMenu`\n    //   // now. Remove next time we do breaking changes.\n    //   state('showing', style({opacity: 1})),\n    //   transition('void => *', [\n    //     style({opacity: 0}),\n    //     animate('400ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)'),\n    //   ]),\n    // ])\n    /**\n     * This animation fades in the background color and content of the menu panel\n     * after its containing element is scaled in.\n     */\n    fadeInItems: {\n        type: 7,\n        name: 'fadeInItems',\n        definitions: [\n            {\n                type: 0,\n                name: 'showing',\n                styles: { type: 6, styles: { opacity: 1 }, offset: null },\n            },\n            {\n                type: 1,\n                expr: 'void => *',\n                animation: [\n                    { type: 6, styles: { opacity: 0 }, offset: null },\n                    { type: 4, styles: null, timings: '400ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)' },\n                ],\n                options: null,\n            },\n        ],\n        options: {},\n    },\n};\n/**\n * @deprecated\n * @breaking-change 8.0.0\n * @docs-private\n */\nconst fadeInItems = matMenuAnimations.fadeInItems;\n/**\n * @deprecated\n * @breaking-change 8.0.0\n * @docs-private\n */\nconst transformMenu = matMenuAnimations.transformMenu;\n\nexport { MAT_MENU_CONTENT, MAT_MENU_DEFAULT_OPTIONS, MAT_MENU_PANEL, MAT_MENU_SCROLL_STRATEGY, MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER, MENU_PANEL_TOP_PADDING, MatContextMenuTrigger, MatMenu, MatMenuContent, MatMenuItem, MatMenuModule, MatMenuTrigger, fadeInItems, matMenuAnimations, transformMenu };\n","import { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function skipWhile(predicate) {\n    return operate((source, subscriber) => {\n        let taking = false;\n        let index = 0;\n        source.subscribe(createOperatorSubscriber(subscriber, (value) => (taking || (taking = !predicate(value, index++))) && subscriber.next(value)));\n    });\n}\n","import * as i0 from '@angular/core';\nimport { NgModule } from '@angular/core';\nimport { MatCommonModule } from './common-module.mjs';\nimport { MatRipple } from './ripple.mjs';\n\nclass MatRippleModule {\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: MatRippleModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\n    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: MatRippleModule, imports: [MatCommonModule, MatRipple], exports: [MatRipple, MatCommonModule] });\n    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: MatRippleModule, imports: [MatCommonModule, MatCommonModule] });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"20.2.0-next.2\", ngImport: i0, type: MatRippleModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [MatCommonModule, MatRipple],\n                    exports: [MatRipple, MatCommonModule],\n                }]\n        }] });\n\nexport { MatRippleModule };\n","function _arrayWithHoles(r) {\n  if (Array.isArray(r)) return r;\n}\nexport { _arrayWithHoles as default };","function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nexport { _nonIterableRest as default };","import arrayWithHoles from \"./arrayWithHoles.js\";\nimport iterableToArrayLimit from \"./iterableToArrayLimit.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableRest from \"./nonIterableRest.js\";\nfunction _slicedToArray(r, e) {\n  return arrayWithHoles(r) || iterableToArrayLimit(r, e) || unsupportedIterableToArray(r, e) || nonIterableRest();\n}\nexport { _slicedToArray as default };","function _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = !0,\n      o = !1;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) {\n        if (Object(t) !== t) return;\n        f = !1;\n      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = !0, n = r;\n    } finally {\n      try {\n        if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}\nexport { _iterableToArrayLimit as default };"],"x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14]}