{"version":3,"file":"8146.b7f0b121b257d6a2.js","mappings":"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","names":["createLinkedSignal","sourceFn","computationFn","equalityFn","node","Object","create","LINKED_SIGNAL_NODE","source","computation","undefined","equal","getter","producerUpdateValueVersion","producerAccessed","value","ERRORED","error","runPostProducerCreatedFn","SIGNAL","linkedSignalSetFn","newValue","signalSetFn","producerMarkClean","linkedSignalUpdateFn","updater","signalUpdateFn","_objectSpread","REACTIVE_NODE","UNSET","dirty","defaultEquals","kind","producerMustRecompute","COMPUTING","producerRecomputeValue","Error","oldValue","prevConsumer","consumerBeforeComputation","newSourceValue","sourceValue","err","consumerAfterComputation","version","untracked","nonReactiveReadsFn","setActiveConsumer","BASE_EFFECT_NODE","consumerIsAlwaysLive","consumerAllowSignalWrites","runEffect","consumerPollProducersForChange","prevNode","cleanup","fn","activeConsumer","inNotificationPhase","epoch","postProducerCreatedFn","Symbol","consumer","prev","getActiveConsumer","isInNotificationPhase","isReactive","lastCleanEpoch","producers","producersTail","consumers","consumersTail","recomputing","consumerMarkedDirty","consumerOnSignalRead","prevProducerLink","producer","nextProducerLink","isRecomputing","nextProducer","lastReadVersion","prevConsumerLink","isValidLink","checkLink","link","isLive","consumerIsLive","newLink","nextConsumer","producerAddLiveConsumer","producerIncrementEpoch","producerNotifyConsumers","consumerMarkDirty","producerUpdatesAllowed","_activeConsumer","_node$consumerMarkedD","call","resetConsumerBeforeComputation","finalizeConsumerAfterComputation","toRemove","producerRemoveLiveConsumerLink","seenVersion","consumerDestroy","wasLive","producerLink","_postProducerCreatedF","setPostProducerCreatedFn","a","b","is","createComputed","COMPUTED_NODE","computed","wasEqual","throwInvalidWriteToSignalErrorFn","defaultThrowError","throwInvalidWriteToSignalError","setThrowInvalidWriteToSignalError","postSignalSetFn","createSignal","initialValue","SIGNAL_NODE","signalGetFn","updateFn","setPostSignalSetFn","signalValueChanged","_postSignalSetFn2","runPostSignalSetFn","_postSignalSetFn"],"ignoreList":[],"sourceRoot":"webpack:///","sources":["./node_modules/@angular/core/fesm2022/effect.mjs","./node_modules/@angular/core/fesm2022/signal.mjs"],"sourcesContent":["/**\n * @license Angular v20.3.6\n * (c) 2010-2025 Google LLC. https://angular.dev/\n * License: MIT\n */\n\nimport { SIGNAL, runPostProducerCreatedFn, producerUpdateValueVersion, signalSetFn, producerMarkClean, signalUpdateFn, REACTIVE_NODE, UNSET, defaultEquals, COMPUTING, consumerBeforeComputation, ERRORED, consumerAfterComputation, producerAccessed, setActiveConsumer, consumerPollProducersForChange } from './signal.mjs';\n\nfunction createLinkedSignal(sourceFn, computationFn, equalityFn) {\n    const node = Object.create(LINKED_SIGNAL_NODE);\n    node.source = sourceFn;\n    node.computation = computationFn;\n    if (equalityFn != undefined) {\n        node.equal = equalityFn;\n    }\n    const linkedSignalGetter = () => {\n        // Check if the value needs updating before returning it.\n        producerUpdateValueVersion(node);\n        // Record that someone looked at this signal.\n        producerAccessed(node);\n        if (node.value === ERRORED) {\n            throw node.error;\n        }\n        return node.value;\n    };\n    const getter = linkedSignalGetter;\n    getter[SIGNAL] = node;\n    if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n        const debugName = node.debugName ? ' (' + node.debugName + ')' : '';\n        getter.toString = () => `[LinkedSignal${debugName}: ${node.value}]`;\n    }\n    runPostProducerCreatedFn(node);\n    return getter;\n}\nfunction linkedSignalSetFn(node, newValue) {\n    producerUpdateValueVersion(node);\n    signalSetFn(node, newValue);\n    producerMarkClean(node);\n}\nfunction linkedSignalUpdateFn(node, updater) {\n    producerUpdateValueVersion(node);\n    signalUpdateFn(node, updater);\n    producerMarkClean(node);\n}\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `LINKED_SIGNAL_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nconst LINKED_SIGNAL_NODE = /* @__PURE__ */ (() => {\n    return {\n        ...REACTIVE_NODE,\n        value: UNSET,\n        dirty: true,\n        error: null,\n        equal: defaultEquals,\n        kind: 'linkedSignal',\n        producerMustRecompute(node) {\n            // Force a recomputation if there's no current value, or if the current value is in the\n            // process of being calculated (which should throw an error).\n            return node.value === UNSET || node.value === COMPUTING;\n        },\n        producerRecomputeValue(node) {\n            if (node.value === COMPUTING) {\n                // Our computation somehow led to a cyclic read of itself.\n                throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode ? 'Detected cycle in computations.' : '');\n            }\n            const oldValue = node.value;\n            node.value = COMPUTING;\n            const prevConsumer = consumerBeforeComputation(node);\n            let newValue;\n            try {\n                const newSourceValue = node.source();\n                const prev = oldValue === UNSET || oldValue === ERRORED\n                    ? undefined\n                    : {\n                        source: node.sourceValue,\n                        value: oldValue,\n                    };\n                newValue = node.computation(newSourceValue, prev);\n                node.sourceValue = newSourceValue;\n            }\n            catch (err) {\n                newValue = ERRORED;\n                node.error = err;\n            }\n            finally {\n                consumerAfterComputation(node, prevConsumer);\n            }\n            if (oldValue !== UNSET && newValue !== ERRORED && node.equal(oldValue, newValue)) {\n                // No change to `valueVersion` - old and new values are\n                // semantically equivalent.\n                node.value = oldValue;\n                return;\n            }\n            node.value = newValue;\n            node.version++;\n        },\n    };\n})();\n\n/**\n * Execute an arbitrary function in a non-reactive (non-tracking) context. The executed function\n * can, optionally, return a value.\n */\nfunction untracked(nonReactiveReadsFn) {\n    const prevConsumer = setActiveConsumer(null);\n    // We are not trying to catch any particular errors here, just making sure that the consumers\n    // stack is restored in case of errors.\n    try {\n        return nonReactiveReadsFn();\n    }\n    finally {\n        setActiveConsumer(prevConsumer);\n    }\n}\n\nconst BASE_EFFECT_NODE = \n/* @__PURE__ */ (() => ({\n    ...REACTIVE_NODE,\n    consumerIsAlwaysLive: true,\n    consumerAllowSignalWrites: true,\n    dirty: true,\n    kind: 'effect',\n}))();\nfunction runEffect(node) {\n    node.dirty = false;\n    if (node.version > 0 && !consumerPollProducersForChange(node)) {\n        return;\n    }\n    node.version++;\n    const prevNode = consumerBeforeComputation(node);\n    try {\n        node.cleanup();\n        node.fn();\n    }\n    finally {\n        consumerAfterComputation(node, prevNode);\n    }\n}\n\nexport { BASE_EFFECT_NODE, createLinkedSignal, linkedSignalSetFn, linkedSignalUpdateFn, runEffect, untracked };\n","/**\n * @license Angular v20.3.6\n * (c) 2010-2025 Google LLC. https://angular.dev/\n * License: MIT\n */\n\n/**\n * The currently active consumer `ReactiveNode`, if running code in a reactive context.\n *\n * Change this via `setActiveConsumer`.\n */\nlet activeConsumer = null;\nlet inNotificationPhase = false;\n/**\n * Global epoch counter. Incremented whenever a source signal is set.\n */\nlet epoch = 1;\n/**\n * If set, called after a producer `ReactiveNode` is created.\n */\nlet postProducerCreatedFn = null;\n/**\n * Symbol used to tell `Signal`s apart from other functions.\n *\n * This can be used to auto-unwrap signals in various cases, or to auto-wrap non-signal values.\n */\nconst SIGNAL = /* @__PURE__ */ Symbol('SIGNAL');\nfunction setActiveConsumer(consumer) {\n    const prev = activeConsumer;\n    activeConsumer = consumer;\n    return prev;\n}\nfunction getActiveConsumer() {\n    return activeConsumer;\n}\nfunction isInNotificationPhase() {\n    return inNotificationPhase;\n}\nfunction isReactive(value) {\n    return value[SIGNAL] !== undefined;\n}\nconst REACTIVE_NODE = {\n    version: 0,\n    lastCleanEpoch: 0,\n    dirty: false,\n    producers: undefined,\n    producersTail: undefined,\n    consumers: undefined,\n    consumersTail: undefined,\n    recomputing: false,\n    consumerAllowSignalWrites: false,\n    consumerIsAlwaysLive: false,\n    kind: 'unknown',\n    producerMustRecompute: () => false,\n    producerRecomputeValue: () => { },\n    consumerMarkedDirty: () => { },\n    consumerOnSignalRead: () => { },\n};\n/**\n * Called by implementations when a producer's signal is read.\n */\nfunction producerAccessed(node) {\n    if (inNotificationPhase) {\n        throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode\n            ? `Assertion error: signal read during notification phase`\n            : '');\n    }\n    if (activeConsumer === null) {\n        // Accessed outside of a reactive context, so nothing to record.\n        return;\n    }\n    activeConsumer.consumerOnSignalRead(node);\n    const prevProducerLink = activeConsumer.producersTail;\n    // If the last producer we accessed is the same as the current one, we can skip adding a new\n    // link\n    if (prevProducerLink !== undefined && prevProducerLink.producer === node) {\n        return;\n    }\n    let nextProducerLink = undefined;\n    const isRecomputing = activeConsumer.recomputing;\n    if (isRecomputing) {\n        // If we're incrementally rebuilding the producers list, we want to check if the next producer\n        // in the list is the same as the one we're trying to add.\n        // If the previous producer is defined, then the next producer is just the one that follows it.\n        // Otherwise, we should check the head of the producers list (the first node that we accessed the last time this consumer was run).\n        nextProducerLink =\n            prevProducerLink !== undefined ? prevProducerLink.nextProducer : activeConsumer.producers;\n        if (nextProducerLink !== undefined && nextProducerLink.producer === node) {\n            // If the next producer is the same as the one we're trying to add, we can just update the\n            // last read version, update the tail of the producers list of this rerun, and return.\n            activeConsumer.producersTail = nextProducerLink;\n            nextProducerLink.lastReadVersion = node.version;\n            return;\n        }\n    }\n    const prevConsumerLink = node.consumersTail;\n    // If the producer we're accessing already has a link to this consumer, we can skip adding a new\n    // link. This can short circuit the creation of a new link in the case where the consumer reads alternating ReeactiveNodes\n    if (prevConsumerLink !== undefined &&\n        prevConsumerLink.consumer === activeConsumer &&\n        // However, we have to make sure that the link we've discovered isn't from a node that is incrementally rebuilding its producer list\n        (!isRecomputing || isValidLink(prevConsumerLink, activeConsumer))) {\n        // If we found an existing link to the consumer we can just return.\n        return;\n    }\n    // If we got here, it means that we need to create a new link between the producer and the consumer.\n    const isLive = consumerIsLive(activeConsumer);\n    const newLink = {\n        producer: node,\n        consumer: activeConsumer,\n        // instead of eagerly destroying the previous link, we delay until we've finished recomputing\n        // the producers list, so that we can destroy all of the old links at once.\n        nextProducer: nextProducerLink,\n        prevConsumer: prevConsumerLink,\n        lastReadVersion: node.version,\n        nextConsumer: undefined,\n    };\n    activeConsumer.producersTail = newLink;\n    if (prevProducerLink !== undefined) {\n        prevProducerLink.nextProducer = newLink;\n    }\n    else {\n        activeConsumer.producers = newLink;\n    }\n    if (isLive) {\n        producerAddLiveConsumer(node, newLink);\n    }\n}\n/**\n * Increment the global epoch counter.\n *\n * Called by source producers (that is, not computeds) whenever their values change.\n */\nfunction producerIncrementEpoch() {\n    epoch++;\n}\n/**\n * Ensure this producer's `version` is up-to-date.\n */\nfunction producerUpdateValueVersion(node) {\n    if (consumerIsLive(node) && !node.dirty) {\n        // A live consumer will be marked dirty by producers, so a clean state means that its version\n        // is guaranteed to be up-to-date.\n        return;\n    }\n    if (!node.dirty && node.lastCleanEpoch === epoch) {\n        // Even non-live consumers can skip polling if they previously found themselves to be clean at\n        // the current epoch, since their dependencies could not possibly have changed (such a change\n        // would've increased the epoch).\n        return;\n    }\n    if (!node.producerMustRecompute(node) && !consumerPollProducersForChange(node)) {\n        // None of our producers report a change since the last time they were read, so no\n        // recomputation of our value is necessary, and we can consider ourselves clean.\n        producerMarkClean(node);\n        return;\n    }\n    node.producerRecomputeValue(node);\n    // After recomputing the value, we're no longer dirty.\n    producerMarkClean(node);\n}\n/**\n * Propagate a dirty notification to live consumers of this producer.\n */\nfunction producerNotifyConsumers(node) {\n    if (node.consumers === undefined) {\n        return;\n    }\n    // Prevent signal reads when we're updating the graph\n    const prev = inNotificationPhase;\n    inNotificationPhase = true;\n    try {\n        for (let link = node.consumers; link !== undefined; link = link.nextConsumer) {\n            const consumer = link.consumer;\n            if (!consumer.dirty) {\n                consumerMarkDirty(consumer);\n            }\n        }\n    }\n    finally {\n        inNotificationPhase = prev;\n    }\n}\n/**\n * Whether this `ReactiveNode` in its producer capacity is currently allowed to initiate updates,\n * based on the current consumer context.\n */\nfunction producerUpdatesAllowed() {\n    return activeConsumer?.consumerAllowSignalWrites !== false;\n}\nfunction consumerMarkDirty(node) {\n    node.dirty = true;\n    producerNotifyConsumers(node);\n    node.consumerMarkedDirty?.(node);\n}\nfunction producerMarkClean(node) {\n    node.dirty = false;\n    node.lastCleanEpoch = epoch;\n}\n/**\n * Prepare this consumer to run a computation in its reactive context and set\n * it as the active consumer.\n *\n * Must be called by subclasses which represent reactive computations, before those computations\n * begin.\n */\nfunction consumerBeforeComputation(node) {\n    if (node)\n        resetConsumerBeforeComputation(node);\n    return setActiveConsumer(node);\n}\n/**\n * Prepare this consumer to run a computation in its reactive context.\n *\n * We expose this mainly for code where we manually batch effects into a single\n * consumer. In those cases we may wish to \"reopen\" a consumer multiple times\n * in initial render before finalizing it. Most code should just call\n * `consumerBeforeComputation` instead of calling this directly.\n */\nfunction resetConsumerBeforeComputation(node) {\n    node.producersTail = undefined;\n    node.recomputing = true;\n}\n/**\n * Finalize this consumer's state and set previous consumer as the active consumer after a\n * reactive computation has run.\n *\n * Must be called by subclasses which represent reactive computations, after those computations\n * have finished.\n */\nfunction consumerAfterComputation(node, prevConsumer) {\n    setActiveConsumer(prevConsumer);\n    if (node)\n        finalizeConsumerAfterComputation(node);\n}\n/**\n * Finalize this consumer's state after a reactive computation has run.\n *\n * We expose this mainly for code where we manually batch effects into a single\n * consumer. In those cases we may wish to \"reopen\" a consumer multiple times\n * in initial render before finalizing it. Most code should just call\n * `consumerAfterComputation` instead of calling this directly.\n */\nfunction finalizeConsumerAfterComputation(node) {\n    node.recomputing = false;\n    // We've finished incrementally rebuilding the producers list, now if there are any producers\n    // that are after producersTail, they are stale and should be removed.\n    const producersTail = node.producersTail;\n    let toRemove = producersTail !== undefined ? producersTail.nextProducer : node.producers;\n    if (toRemove !== undefined) {\n        if (consumerIsLive(node)) {\n            // For each stale link, we first unlink it from the producers list of consumers\n            do {\n                toRemove = producerRemoveLiveConsumerLink(toRemove);\n            } while (toRemove !== undefined);\n        }\n        // Now, we can truncate the producers list to remove all stale links.\n        if (producersTail !== undefined) {\n            producersTail.nextProducer = undefined;\n        }\n        else {\n            node.producers = undefined;\n        }\n    }\n}\n/**\n * Determine whether this consumer has any dependencies which have changed since the last time\n * they were read.\n */\nfunction consumerPollProducersForChange(node) {\n    // Poll producers for change.\n    for (let link = node.producers; link !== undefined; link = link.nextProducer) {\n        const producer = link.producer;\n        const seenVersion = link.lastReadVersion;\n        // First check the versions. A mismatch means that the producer's value is known to have\n        // changed since the last time we read it.\n        if (seenVersion !== producer.version) {\n            return true;\n        }\n        // The producer's version is the same as the last time we read it, but it might itself be\n        // stale. Force the producer to recompute its version (calculating a new value if necessary).\n        producerUpdateValueVersion(producer);\n        // Now when we do this check, `producer.version` is guaranteed to be up to date, so if the\n        // versions still match then it has not changed since the last time we read it.\n        if (seenVersion !== producer.version) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Disconnect this consumer from the graph.\n */\nfunction consumerDestroy(node) {\n    if (consumerIsLive(node)) {\n        // Drop all connections from the graph to this node.\n        let link = node.producers;\n        while (link !== undefined) {\n            link = producerRemoveLiveConsumerLink(link);\n        }\n    }\n    // Truncate all the linked lists to drop all connection from this node to the graph.\n    node.producers = undefined;\n    node.producersTail = undefined;\n    node.consumers = undefined;\n    node.consumersTail = undefined;\n}\n/**\n * Add `consumer` as a live consumer of this node.\n *\n * Note that this operation is potentially transitive. If this node becomes live, then it becomes\n * a live consumer of all of its current producers.\n */\nfunction producerAddLiveConsumer(node, link) {\n    const consumersTail = node.consumersTail;\n    const wasLive = consumerIsLive(node);\n    if (consumersTail !== undefined) {\n        link.nextConsumer = consumersTail.nextConsumer;\n        consumersTail.nextConsumer = link;\n    }\n    else {\n        link.nextConsumer = undefined;\n        node.consumers = link;\n    }\n    link.prevConsumer = consumersTail;\n    node.consumersTail = link;\n    if (!wasLive) {\n        for (let link = node.producers; link !== undefined; link = link.nextProducer) {\n            producerAddLiveConsumer(link.producer, link);\n        }\n    }\n}\nfunction producerRemoveLiveConsumerLink(link) {\n    const producer = link.producer;\n    const nextProducer = link.nextProducer;\n    const nextConsumer = link.nextConsumer;\n    const prevConsumer = link.prevConsumer;\n    link.nextConsumer = undefined;\n    link.prevConsumer = undefined;\n    if (nextConsumer !== undefined) {\n        nextConsumer.prevConsumer = prevConsumer;\n    }\n    else {\n        producer.consumersTail = prevConsumer;\n    }\n    if (prevConsumer !== undefined) {\n        prevConsumer.nextConsumer = nextConsumer;\n    }\n    else {\n        producer.consumers = nextConsumer;\n        if (!consumerIsLive(producer)) {\n            let producerLink = producer.producers;\n            while (producerLink !== undefined) {\n                producerLink = producerRemoveLiveConsumerLink(producerLink);\n            }\n        }\n    }\n    return nextProducer;\n}\nfunction consumerIsLive(node) {\n    return node.consumerIsAlwaysLive || node.consumers !== undefined;\n}\nfunction runPostProducerCreatedFn(node) {\n    postProducerCreatedFn?.(node);\n}\nfunction setPostProducerCreatedFn(fn) {\n    const prev = postProducerCreatedFn;\n    postProducerCreatedFn = fn;\n    return prev;\n}\n// While a ReactiveNode is recomputing, it may not have destroyed previous links\n// This allows us to check if a given link will be destroyed by a reactivenode if it were to finish running immediately without accesing any more producers\nfunction isValidLink(checkLink, consumer) {\n    const producersTail = consumer.producersTail;\n    if (producersTail !== undefined) {\n        let link = consumer.producers;\n        do {\n            if (link === checkLink) {\n                return true;\n            }\n            if (link === producersTail) {\n                break;\n            }\n            link = link.nextProducer;\n        } while (link !== undefined);\n    }\n    return false;\n}\n\n/**\n * The default equality function used for `signal` and `computed`, which uses referential equality.\n */\nfunction defaultEquals(a, b) {\n    return Object.is(a, b);\n}\n\n/**\n * Create a computed signal which derives a reactive value from an expression.\n */\nfunction createComputed(computation, equal) {\n    const node = Object.create(COMPUTED_NODE);\n    node.computation = computation;\n    if (equal !== undefined) {\n        node.equal = equal;\n    }\n    const computed = () => {\n        // Check if the value needs updating before returning it.\n        producerUpdateValueVersion(node);\n        // Record that someone looked at this signal.\n        producerAccessed(node);\n        if (node.value === ERRORED) {\n            throw node.error;\n        }\n        return node.value;\n    };\n    computed[SIGNAL] = node;\n    if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n        const debugName = node.debugName ? ' (' + node.debugName + ')' : '';\n        computed.toString = () => `[Computed${debugName}: ${node.value}]`;\n    }\n    runPostProducerCreatedFn(node);\n    return computed;\n}\n/**\n * A dedicated symbol used before a computed value has been calculated for the first time.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst UNSET = /* @__PURE__ */ Symbol('UNSET');\n/**\n * A dedicated symbol used in place of a computed signal value to indicate that a given computation\n * is in progress. Used to detect cycles in computation chains.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst COMPUTING = /* @__PURE__ */ Symbol('COMPUTING');\n/**\n * A dedicated symbol used in place of a computed signal value to indicate that a given computation\n * failed. The thrown error is cached until the computation gets dirty again.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst ERRORED = /* @__PURE__ */ Symbol('ERRORED');\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nconst COMPUTED_NODE = /* @__PURE__ */ (() => {\n    return {\n        ...REACTIVE_NODE,\n        value: UNSET,\n        dirty: true,\n        error: null,\n        equal: defaultEquals,\n        kind: 'computed',\n        producerMustRecompute(node) {\n            // Force a recomputation if there's no current value, or if the current value is in the\n            // process of being calculated (which should throw an error).\n            return node.value === UNSET || node.value === COMPUTING;\n        },\n        producerRecomputeValue(node) {\n            if (node.value === COMPUTING) {\n                // Our computation somehow led to a cyclic read of itself.\n                throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode ? 'Detected cycle in computations.' : '');\n            }\n            const oldValue = node.value;\n            node.value = COMPUTING;\n            const prevConsumer = consumerBeforeComputation(node);\n            let newValue;\n            let wasEqual = false;\n            try {\n                newValue = node.computation();\n                // We want to mark this node as errored if calling `equal` throws; however, we don't want\n                // to track any reactive reads inside `equal`.\n                setActiveConsumer(null);\n                wasEqual =\n                    oldValue !== UNSET &&\n                        oldValue !== ERRORED &&\n                        newValue !== ERRORED &&\n                        node.equal(oldValue, newValue);\n            }\n            catch (err) {\n                newValue = ERRORED;\n                node.error = err;\n            }\n            finally {\n                consumerAfterComputation(node, prevConsumer);\n            }\n            if (wasEqual) {\n                // No change to `valueVersion` - old and new values are\n                // semantically equivalent.\n                node.value = oldValue;\n                return;\n            }\n            node.value = newValue;\n            node.version++;\n        },\n    };\n})();\n\nfunction defaultThrowError() {\n    throw new Error();\n}\nlet throwInvalidWriteToSignalErrorFn = defaultThrowError;\nfunction throwInvalidWriteToSignalError(node) {\n    throwInvalidWriteToSignalErrorFn(node);\n}\nfunction setThrowInvalidWriteToSignalError(fn) {\n    throwInvalidWriteToSignalErrorFn = fn;\n}\n\n/**\n * If set, called after `WritableSignal`s are updated.\n *\n * This hook can be used to achieve various effects, such as running effects synchronously as part\n * of setting a signal.\n */\nlet postSignalSetFn = null;\n/**\n * Creates a `Signal` getter, setter, and updater function.\n */\nfunction createSignal(initialValue, equal) {\n    const node = Object.create(SIGNAL_NODE);\n    node.value = initialValue;\n    if (equal !== undefined) {\n        node.equal = equal;\n    }\n    const getter = (() => signalGetFn(node));\n    getter[SIGNAL] = node;\n    if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n        const debugName = node.debugName ? ' (' + node.debugName + ')' : '';\n        getter.toString = () => `[Signal${debugName}: ${node.value}]`;\n    }\n    runPostProducerCreatedFn(node);\n    const set = (newValue) => signalSetFn(node, newValue);\n    const update = (updateFn) => signalUpdateFn(node, updateFn);\n    return [getter, set, update];\n}\nfunction setPostSignalSetFn(fn) {\n    const prev = postSignalSetFn;\n    postSignalSetFn = fn;\n    return prev;\n}\nfunction signalGetFn(node) {\n    producerAccessed(node);\n    return node.value;\n}\nfunction signalSetFn(node, newValue) {\n    if (!producerUpdatesAllowed()) {\n        throwInvalidWriteToSignalError(node);\n    }\n    if (!node.equal(node.value, newValue)) {\n        node.value = newValue;\n        signalValueChanged(node);\n    }\n}\nfunction signalUpdateFn(node, updater) {\n    if (!producerUpdatesAllowed()) {\n        throwInvalidWriteToSignalError(node);\n    }\n    signalSetFn(node, updater(node.value));\n}\nfunction runPostSignalSetFn(node) {\n    postSignalSetFn?.(node);\n}\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nconst SIGNAL_NODE = /* @__PURE__ */ (() => {\n    return {\n        ...REACTIVE_NODE,\n        equal: defaultEquals,\n        value: undefined,\n        kind: 'signal',\n    };\n})();\nfunction signalValueChanged(node) {\n    node.version++;\n    producerIncrementEpoch();\n    producerNotifyConsumers(node);\n    postSignalSetFn?.(node);\n}\n\nexport { COMPUTING, ERRORED, REACTIVE_NODE, SIGNAL, SIGNAL_NODE, UNSET, consumerAfterComputation, consumerBeforeComputation, consumerDestroy, consumerMarkDirty, consumerPollProducersForChange, createComputed, createSignal, defaultEquals, finalizeConsumerAfterComputation, getActiveConsumer, isInNotificationPhase, isReactive, producerAccessed, producerIncrementEpoch, producerMarkClean, producerNotifyConsumers, producerUpdateValueVersion, producerUpdatesAllowed, resetConsumerBeforeComputation, runPostProducerCreatedFn, runPostSignalSetFn, setActiveConsumer, setPostProducerCreatedFn, setPostSignalSetFn, setThrowInvalidWriteToSignalError, signalGetFn, signalSetFn, signalUpdateFn };\n"],"x_google_ignoreList":[0,1]}